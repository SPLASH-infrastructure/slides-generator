<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE event [<!ELEMENT zip_code (#PCDATA)><!ELEMENT url_link_display (#PCDATA)><!ELEMENT url (#PCDATA)><!ELEMENT tracks (track+)><!ELEMENT track (#PCDATA)><!ELEMENT title (#PCDATA)><!ELEMENT timeslot (slot_id?, event_id?, title, room, date, start_time, end_date?, end_time, description?, acm_doi?, persons?, tracks?, tags?)><!ELEMENT tags (tag+)><!ELEMENT tag (#PCDATA)><!ELEMENT suffix (#PCDATA)><!ELEMENT subevent_logo_url (#PCDATA)><!ELEMENT subevent_id (#PCDATA)><!ELEMENT subevent (subevent_id?, title, acronym?, subevent_type, description?, room, date, url?, url_link_display?, subevent_logo_url?, acm_doi?, persons?, tracks?, tags?, sponsor?, timeslot*)><!ELEMENT state (#PCDATA)><!ELEMENT start_time (#PCDATA)><!ELEMENT start_date (#PCDATA)><!ELEMENT sponsor (#PCDATA)><!ELEMENT sort_key (#PCDATA)><!ELEMENT slot_id (#PCDATA)><!ELEMENT subevent_type EMPTY><!ATTLIST subevent_type	type (case_study | demonstration | poster | regular | tutorial | workshop) #IMPLIED><!ELEMENT room (#PCDATA)><!ELEMENT role (#PCDATA)><!ELEMENT picture_url (#PCDATA)><!ELEMENT persons (person+)><!ELEMENT person (role, sort_key, first_name, middle_name?, last_name, suffix?, affiliation, acm_profile_id?, email?, bio?, homepage_url?, picture_url?, person_id?)><!ELEMENT middle_name (#PCDATA)><!ELEMENT location (facility_name, facility_map_url?, address, city, state?, country, zip_code?)><!ELEMENT last_name (#PCDATA)><!ELEMENT homepage_url (#PCDATA)><!ELEMENT first_name (#PCDATA)><!ELEMENT facility_name (#PCDATA)><!ELEMENT facility_map_url (#PCDATA)><!ELEMENT event_type EMPTY><!ATTLIST event_type	type (conference|workshop|symposium) #IMPLIED><!ELEMENT event (event_details, subevent*, timeslot*, timezone_id?)><!ELEMENT event_logo_url (#PCDATA)><!ELEMENT event_details (title, acronym, event_type, start_date, end_date, location, description, url?, url_link_display?, event_logo_url?, persons?)><!ELEMENT end_time (#PCDATA)><!ELEMENT end_date (#PCDATA)><!ELEMENT email (#PCDATA)><!ELEMENT description (#PCDATA)><!ELEMENT date (#PCDATA)><!ELEMENT country (#PCDATA)><!ELEMENT city (#PCDATA)><!ELEMENT bio (#PCDATA)><!ELEMENT affiliation (#PCDATA)><!ELEMENT address (#PCDATA)><!ELEMENT acronym (#PCDATA)><!ELEMENT acm_profile_id (#PCDATA)><!ELEMENT acm_doi (#PCDATA)>]>
<event>
  <event_details>
    <title>SPLASH 2020</title>
    <acronym>SPLASH 2020</acronym>
    <event_type type="conference"/>
    <start_date>2020/11/15</start_date>
    <end_date>2020/11/21</end_date>
    <location>
      <facility_name>Online</facility_name>
      <address>undefined</address>
      <city>Online Conference</city>
      <country>undefined</country>
    </location>
    <description>Welcome to SPLASH 2020, the ACM SIGPLAN conference on Systems, Programming, Languages, and Applications: Software for Humanity. SPLASH embraces all aspects of software construction and delivery, to make it the premier conference on the applications of programming languages—at the intersection of programming languages and software engineering. SPLASH takes place Sunday November 15th to Friday 20th. 
NEW: Watch a quick 6-minute instructional video on How to Attend SPLASH 2020 here: https://www.youtube.com/watch?v=bFiiuIEBG5I 
VIRTUAL SPLASH has three main streams: 
 
 SPLASH-I for OOPSLA and ECOOP research papers; 
 SPLASH-II for REBASE industry-oriented talks; 
 SPLASH-III for the major co-located events: GPCE/SLE on Sunday/Monday; Onward! Papers and Essays on Tuesday; SAS/DLS on Wednesday/Thursday; and OOPSLA research papers on Friday. 
 
MIRRORING In what we think is world first, SPLASH will do 12 hour mirroring, each conference days will be exactly 12 hours long with every single talk scheduled to repeat with a 12 hour delay. Therefore: whatever YOUR time zone happens to be, you can attend SPLASH during any convenient 12 hour block. For example: Alex from New Zealand plans to attend between 8am and 8pm NZ Standard Time; Jan from Czechia plans to attend between 8am and 8pm Central European Time, while Hridesh from Iowa plans to attend between 9am and 9pm Central Daylight Time! 
Workshops will take place outside the main three streams in virtual rooms SPLASH IV-VI. Please consult this table for details and login to SPLASH Clowdr to enter these rooms:  
 
  
   
    
    
   VMIL11/17 
    
    
    
   
  
  
   
    
    
   NSAD11/17 
    
    
    Tutorials11/20  
   
   
    
    
   LIVE11/7 
    
    
    SPLASH-E 11/20  
   
   
    
   HILT11/16 
   HILT11/17 
    
   TAPAS11/19 
    DocSymp 11/20  
   
   
   LPOP11/15 
   REBLS11/16 
    AGERE11/17 
   HATRA11/18 
   HATRA11/19 
   PLATEAU11/20 
   
  
 


 
SPLASH has multiple keynotes and invited industrial talks. These talks are followed by Ask Me Anything questions where you can engage with our speakers.</description>
    <url>https://2020.splashcon.org</url>
    <url_link_display>SPLASH 2020</url_link_display>
    <persons>
      <person>
        <role>General Chair in Organizing Committee, Committee Member in Steering Committee</role>
        <sort_key>1</sort_key>
        <first_name>Hridesh</first_name>
        <last_name>Rajan</last_name>
        <affiliation>Iowa State University, USA</affiliation>
        <bio>Hridesh Rajan is a Professor and Chair of Computer Science at Iowa State University, where he has been since 2005. Professor Rajan earned his MS and Ph.D. from the University of Virginia in 2004 and 2005 respectively. Professor Rajan’s recent research and educational activities are aimed at decreasing the barrier to entry to data-driven sciences to broaden participation. His work on the Boa project is aimed at the invention and refinement of programming languages and cyberinfrastructures that democratize data-driven science &amp;amp; engineering, including software engineering. His work on the Midwest Big Data Summer School is experimenting with broadly accessible data science curricula. Professor Rajan was the founding general chair of the Midwest Big Data Summer School. Professor Rajan’s research interests also include programming language design and implementation, and software engineering. He leads two research projects: Panini, whose goals are to enable modular reasoning about concurrent programs, and Boa that was established in Summer 2012 as an end-to-end infrastructure for analyzing large-scale software repositories and other open data sets. Professor Rajan is the director of the Laboratory for Software Design at Iowa State University, director of graduate admissions and recruitment for the Department of Computer Science. He serves as the department chair of the Department of Computer Science and served as the Professor-In-Charge of the Data Science education programs at Iowa State University from 2017-2019, and chair of the information technology committee for the university from 2015-2019. Professor Rajan served on the steering committee of the Midwest Big Data Hub, a consortium of universities in the Midwest region of the United States focused on promoting data science activities. Professor Rajan is a recipient of the National Science Foundation CAREER award in 2009, LAS Award for Early Achievement in Research in 2010, a Big-12 Fellowship in 2012. He is a 2018-19 Fulbright U.S. Scholar, a distinguished member of the ACM, and a member of IEEE, and AAAS. He is also the inaugural holder of the Kingland Professorship in the Department of Computer Science.</bio>
        <homepage_url>https://hridesh.github.io</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/hrideshrajan/f57a0842-20af-4fd4-b79f-5d673c2c485c/small.jpg</picture_url>
        <person_id>hrideshrajan</person_id>
      </person>
      <person>
        <role>Chair in Steering Committee</role>
        <sort_key>2</sort_key>
        <first_name>Eelco</first_name>
        <last_name>Visser</last_name>
        <affiliation>Delft University of Technology, Netherlands</affiliation>
        <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science at Delft University of Technology. He received a master’s and doctorate in computer science from the University of Amsterdam in 1993 and 1997, respectively. Previously he served as postdoc at the Oregon Graduate Institute, as Assistant Professor at Utrecht University, and as Associate Professor at TU Delft. 
His research interests include programming languages, software language engineering, domain-specific programming languages, program transformation, syntax definition, and parsing. With his students he has designed and implemented the Spoofax language workbench, as well as many domain-specific languages, including DSLs for syntax definition (SDF2, SDF3), program transformation (Stratego), static semantics (NaBL, Statix), dynamic semantics (DynSem), software deployment (Nix), web application development (WebDSL), and mobile phone applications (mobl). In the language designer’s workbench project he is pursuing high-level declarative language definition that serves for language implementation and verification.</bio>
        <homepage_url>http://eelcovisser.org</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
        <person_id>eelcovisser</person_id>
      </person>
      <person>
        <role>OOPSLA Review Committee Chair in Organizing Committee, Committee Member in Steering Committee</role>
        <sort_key>3</sort_key>
        <first_name>David</first_name>
        <last_name>Grove</last_name>
        <affiliation>IBM Research</affiliation>
        <bio>I am a Distinguished Research Staff Member at the IBM T.J. Watson Research Center. I joined IBM Research in 1998 after completing my PhD at the University of Washington. I am a software systems researcher, working primarily on problems in programming language implementation and scalable runtime systems. 
I have contributed to a number of technical topics in programming language design and implementation including the analysis and optimization of object-oriented languages, virtual machine design and implementation, scalable runtime systems, Just-In-Time compilation, online feedback-directed optimization, and garbage collection.</bio>
        <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-groved</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/davidgrove/5524049e-7d0a-4799-ad8c-93e1e76a77ec/small.jpg</picture_url>
        <person_id>davidgrove</person_id>
      </person>
      <person>
        <role>Virtualization Co-Chair in Organizing Committee</role>
        <sort_key>4</sort_key>
        <first_name>Steve</first_name>
        <last_name>Blackburn</last_name>
        <affiliation>Australian National University</affiliation>
        <bio>My research interests are centered on the challenge of making software run faster and more power-efficiently on modern hardware. My primary interests include: microarchitectural support for managed languages, fast and efficient garbage collection, and the design and implementation of virtual machines. As a backdrop to this I have a longstanding interest in role of sound methodology and infrastructure in successful research innovation.</bio>
        <homepage_url>http://users.cecs.anu.edu.au/~steveb/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/steveblackburn/1deee732-405d-4403-a974-a418751399c2/small.jpg</picture_url>
        <person_id>steveblackburn</person_id>
      </person>
      <person>
        <role>Virtualization Co-Chair in Organizing Committee</role>
        <sort_key>5</sort_key>
        <first_name>Alex</first_name>
        <last_name>Potanin</last_name>
        <affiliation>Victoria University of Wellington</affiliation>
        <bio>I am an Associate Professor in the School of Engineering and Computer Science at Victoria University of Wellington, New Zealand. 
I am originally from Moscow, Russia with a background in Mathematics. I have completed my PhD in programming languages in 2006 and took up a job as a Lecturer in Software Engineering at Victoria University of Wellington. During my studies, I took short breaks to work as a Visiting Researcher at Purdue University, and Software Engineer at two Wellington start-ups. I spent 2013 on sabbatical at Carnegie Mellon University in Pittsburgh, PA, USA. I spent winter 2019/2020 on sabbatical at Kyoto University in Japan.</bio>
        <homepage_url>http://homepages.ecs.vuw.ac.nz/~alex/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/alexpotanin/614f887b-90a3-4626-b67d-fa63309b44c8/small.jpg</picture_url>
        <person_id>alexpotanin</person_id>
      </person>
      <person>
        <role>Virtualization Co-Chair in Organizing Committee, Committee Member in Steering Committee</role>
        <sort_key>6</sort_key>
        <first_name>Jan</first_name>
        <last_name>Vitek</last_name>
        <affiliation>Northeastern University, USA / Czech Technical University, Czechia</affiliation>
        <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
        <homepage_url>http://janvitek.org</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
        <person_id>janvitek</person_id>
      </person>
      <person>
        <role>Onward! Papers Chair in Organizing Committee, Committee Member in Steering Committee</role>
        <sort_key>7</sort_key>
        <first_name>Stephen</first_name>
        <last_name>Kell</last_name>
        <affiliation>University of Kent</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.kent.ac.uk/people/staff/srk21</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/stephenkell/53088184-3e8c-4a2c-b34f-b2a290cff411/small.jpg</picture_url>
        <person_id>stephenkell</person_id>
      </person>
      <person>
        <role>Onward! Essays Chair in Organizing Committee</role>
        <sort_key>8</sort_key>
        <first_name>Didier</first_name>
        <last_name>Verna</last_name>
        <affiliation>EPITA / LRDE</affiliation>
        <bio>Didier Verna has a Ph.D. and an habilitation in Computer Science, and is currently working as a professor for EPITA, a private Computer Science university located in Paris. He gives or has given lectures on Operating Systems, Computer Graphics, Object-Oriented, Functional Programming and Typesetting. His main research interests are multi-paradigm approaches to genericity and performance. 
Didier Verna is the president of the European Lisp Symposium steering committee and serves or has served as a program committee member in various conferences (International Lisp Conference, European Lisp Symposium, Dynamic Languages Symposium, ACM Symposium on Applied Computing, Onward!, Context-Oriented Programming workshop etc. ). 
Didier Verna is also quite involved in free software: he was one of the core maintainers of XEmacs for more than 15 years, a contributor to Gnus and BBDB, and an occasional contributor to other Free Software projects (the GNU Autotools most notably; he was one of the technical reviewers for the “Goat Book”). He is the author of several LaTeX packages and Common Lisp libraries. 
All of this is in fact half-true: two days a week, Didier Verna drops his scientific hat and wears the semi-professional Jazz musician one instead (he has released 3 albums with his quartet). He also is a certified Aikido teacher, and gives coaching sessions on the theme “Aikido and Conflict Management” for large companies.</bio>
        <homepage_url>https://www.lrde.epita.fr/~didier</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/didierverna/854d6aef-85b1-4d6e-a0e3-fa0dc86e3927/small.jpg</picture_url>
        <person_id>didierverna</person_id>
      </person>
      <person>
        <role>Local Arrangements Chair in Organizing Committee</role>
        <sort_key>9</sort_key>
        <first_name>Ravi</first_name>
        <last_name>Chugh</last_name>
        <affiliation>University of Chicago</affiliation>
        <bio>I am an Assistant Professor at the University of Chicago. I enjoy developing and deploying programming language technology — type systems, synthesis algorithms, and other program analysis techniques — for applications in software engineering and human-computer interaction.</bio>
        <homepage_url>http://people.cs.uchicago.edu/~rchugh</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/ravichugh/ea931b20-b1e1-4e07-b209-ba0b568e315d/small.jpg</picture_url>
        <person_id>ravichugh</person_id>
      </person>
      <person>
        <role>Rebase Co-chair in Organizing Committee</role>
        <sort_key>10</sort_key>
        <first_name>Satish</first_name>
        <last_name>Chandra</last_name>
        <affiliation>Facebook, USA</affiliation>
        <bio>Satish Chandra obtained a PhD from the University of Wisconsin-Madison in 1997, and a B.Tech from the Indian Institute of Technology-Kanpur in 1991, both in computer science. From 1997 to 2002, he was a member of technical staff at Bell Laboratories, where his research focused on program analysis, domain-specific languages, and data-communication protocols. From 2002 to 2013, he was a research staff member at IBM Research, where his research focused on bug finding and verification, software synthesis, and test automation. His work on bug finding shipped in IBM’s Java static analysis product, and his work on test automation was adopted in IBM’s testing services offering. From 2013 to 2016, he worked at Samsung Research America, where he led the advanced programming tools research team. His work on memory profiling of web apps was included in Samsung’s Tizen IDE. In 2016, he started working at Facebook. He is an ACM Distinguished Scientist.</bio>
        <homepage_url>https://sites.google.com/site/schandraacmorg/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/satishchandra/6f67adc9-cd3d-4d0b-ad13-5bb13fd21834/small.jpg</picture_url>
        <person_id>satishchandra</person_id>
      </person>
      <person>
        <role>Rebase Co-chair in Organizing Committee</role>
        <sort_key>11</sort_key>
        <first_name>Yu David</first_name>
        <last_name>Liu</last_name>
        <affiliation>State University of New York (SUNY) Binghamton</affiliation>
        <bio>I am a Professor at State University of New York (SUNY) at Binghamton. I am interested in programming languages, computer systems, and software engineering. My current research focuses are energy-aware programming languages, data-intensive software, programming unmanned aerial vehicles, and type systems. I received my Ph.D. in Computer Science from the Johns Hopkins University, in 2007.</bio>
        <homepage_url>http://www.cs.binghamton.edu/~davidl</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/yudavidliu/1da5367f-6c86-4df7-859d-ca63bc2a178b/small.jpg</picture_url>
        <person_id>yudavidliu</person_id>
      </person>
      <person>
        <role>PLMW Co-Chair in Organizing Committee</role>
        <sort_key>12</sort_key>
        <first_name>Karim</first_name>
        <last_name>Ali</last_name>
        <affiliation>University of Alberta</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://karimali.ca</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/karimali/460ecc0b-764d-462b-a93e-66a3270d72ef/small.jpg</picture_url>
        <person_id>karimali</person_id>
      </person>
      <person>
        <role>PLMW Co-Chair in Organizing Committee</role>
        <sort_key>13</sort_key>
        <first_name>Jonathan</first_name>
        <last_name>Bell</last_name>
        <affiliation>Northeastern University, USA</affiliation>
        <bio>Jon is an Assistant Professor directing research in Software Engineering and Software Systems at Northeastern University. His research makes it easier for developers to create reliable and secure software by improving software testing and program analysis. Jon’s work on accelerating software testing has been recognized with an ACM SIGSOFT Distinguished Paper Award (ICSE ’14 – Unit Test Virtualization with VMVM), and was the basis for an industrial collaboration with Electric Cloud. His program analysis research has resulted in several widely adopted runtime systems for the JVM, including the Phosphor taint tracking system (OOPSLA ’14) and CROCHET checkpoint/rollback tool (ECOOP ’18). His research has been funded by the NSA and the NSF, and he is the recipient of the NSF CAREER award. At George Mason, Jon taught courses in distributed systems, web development, and program analysis. His teaching at GMU has been recognized with a departmental award. Jon serves on a variety of program committees and was recently co-chair of the PLDI 2020 Artifact Evaluation Committee. As part of his efforts to broaden the participation of underrepresented groups in computing, Jon co-organizes the PL/SE mentoring workshop at SPLASH (in 2017, 2018, 2019 and 2020).</bio>
        <homepage_url>http://jonbell.net/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/jonathanbell/1ef3641d-0ed6-4021-aab6-b13b53962e3d/small.jpg</picture_url>
        <person_id>jonathanbell</person_id>
      </person>
      <person>
        <role>PLMW Co-Chair in Organizing Committee</role>
        <sort_key>14</sort_key>
        <first_name>Malavika</first_name>
        <last_name>Samak</last_name>
        <affiliation>CSAIL, MIT</affiliation>
        <bio>I am a Postdoctoral Associate working at CSAIL, MIT. I received my PhD from the Department of Computer Science and Automation, IISc Bangalore and was supported by a Google India PhD fellowship. For my doctoral dissertation, I designed and implemented techniques to address the problem of automatically synthesizing clients for detecting concurrency bugs in multithreaded libraries. My research interests are in software engineering and programming languages.</bio>
        <homepage_url>https://sites.google.com/site/malavikasamak/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/malavikasamak/ce059484-133f-4009-8f2d-de4df3abb83f/small.jpg</picture_url>
        <person_id>malavikasamak</person_id>
      </person>
      <person>
        <role>Workshops Co-Chair in Organizing Committee</role>
        <sort_key>15</sort_key>
        <first_name>Mehdi</first_name>
        <last_name>Bagherzadeh</last_name>
        <affiliation>Oakland University, USA</affiliation>
        <bio>Assistant Professor, Department of Computer Science and Engineering</bio>
        <homepage_url>https://mbagherz.bitbucket.io/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/mehdibagherzadeh/95dc6f53-51a0-4bf1-b822-7bbe8c4d223a/small.jpg</picture_url>
        <person_id>mehdibagherzadeh</person_id>
      </person>
      <person>
        <role>Workshops Co-Chair in Organizing Committee</role>
        <sort_key>16</sort_key>
        <first_name>Neville</first_name>
        <last_name>Grech</last_name>
        <affiliation>University of Malta</affiliation>
        <bio>I am a Lecturer at the University of Malta. My expertise is focused on program analysis, applied to security and other high-level applications. My research work has been recently highlighted by ACM SIGPLAN and Communications of the ACM. I am also interested in the areas of energy efficient systems, smart contracts, semantics and generative programming. My research tools include decompilers and security analyzers for the Ethereum platform (Gigahorse) and Java pointer and taint analysis frameworks (Doop, P/Taint and HeapDL). Previously, I was Reach High Fellow at the University of Athens, a Senior Research Associate at the University of Bristol, and have worked in industry as a Data Scientist and Software Engineer. I hold a PhD from the University of Southampton.</bio>
        <homepage_url>http://www.nevillegrech.com</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/nevillegrech/e0405613-3240-4ef2-a51f-cb7536870dc5/small.jpg</picture_url>
        <person_id>nevillegrech</person_id>
      </person>
      <person>
        <role>Workshops Co-Chair in Organizing Committee</role>
        <sort_key>17</sort_key>
        <first_name>Ali</first_name>
        <last_name>Jannesari</last_name>
        <affiliation>Iowa State University</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://www.eecs.berkeley.edu/~jannesari/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/alijannesari/bc7c4a53-b541-49d8-a2c3-04e4a5f18047/small.jpg</picture_url>
        <person_id>alijannesari</person_id>
      </person>
      <person>
        <role>Student Research Competition Co-Chair in Organizing Committee</role>
        <sort_key>18</sort_key>
        <first_name>Sasa</first_name>
        <last_name>Misailovic</last_name>
        <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://misailo.cs.illinois.edu/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/sasamisailovic/6e3299c7-e0f5-4e78-a5f3-7ea49e488545/small.jpg</picture_url>
        <person_id>sasamisailovic</person_id>
      </person>
      <person>
        <role>Student Research Competition Co-Chair in Organizing Committee</role>
        <sort_key>19</sort_key>
        <first_name>Julia</first_name>
        <last_name>Rubin</last_name>
        <affiliation>University of British Columbia, Canada</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.ece.ubc.ca/~mjulia/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/juliarubin/5846079d-0c90-4d9a-8f16-eef07002e37d/small.jpg</picture_url>
        <person_id>juliarubin</person_id>
      </person>
      <person>
        <role>Publicity Chair in Organizing Committee</role>
        <sort_key>20</sort_key>
        <first_name>Hitesh</first_name>
        <last_name>Sajnani</last_name>
        <affiliation>Microsoft </affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.ics.uci.edu/~hsajnani/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/hiteshsajnani/01055225-912e-4ea5-865b-e5e0e01767c2/small.jpg</picture_url>
        <person_id>hiteshsajnani</person_id>
      </person>
      <person>
        <role>Web Chair in Organizing Committee</role>
        <sort_key>21</sort_key>
        <first_name>Rangeet</first_name>
        <last_name>Pan</last_name>
        <affiliation>Iowa State University, USA</affiliation>
        <bio>Rangeet Pan is a Ph.D. student at Iowa State University. His research interests include program analysis, machine learning, and software engineering. He has published works at ESEC/FSE and ICSE.</bio>
        <homepage_url>https://rangeetpanisu.web.app/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/rangeetpan/3f0551cd-7e73-4053-bb36-66f8d05daae5/small.jpg</picture_url>
        <person_id>rangeetpan</person_id>
      </person>
      <person>
        <role>Student Volunteer Co-Chair in Organizing Committee</role>
        <sort_key>22</sort_key>
        <first_name>Robert</first_name>
        <last_name>Dyer</last_name>
        <affiliation>University of Nebraska - Lincoln</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://go.unl.edu/rdyer</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/robertdyer/774d6fd8-9a08-4c37-9113-f0bc0c5fb833/small.jpg</picture_url>
        <person_id>robertdyer</person_id>
      </person>
      <person>
        <role>Student Volunteer Co-Chair in Organizing Committee</role>
        <sort_key>23</sort_key>
        <first_name>Samantha Syeda</first_name>
        <last_name>Khairunnesa</last_name>
        <affiliation>Iowa State University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://web.cs.iastate.edu/~sammy/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/samanthasyedakhairunnesa/23aa8334-ebf0-4967-b8ab-6d4cbf1509c5/small.jpg</picture_url>
        <person_id>samanthasyedakhairunnesa</person_id>
      </person>
      <person>
        <role>Sponsorship Chair in Organizing Committee</role>
        <sort_key>24</sort_key>
        <first_name>Ganesha</first_name>
        <last_name>Upadhyaya</last_name>
        <affiliation>Harmony.one</affiliation>
        <bio>I am currently a Research Engineer at Harmony.one, Mountain View, CA. I work on blockchain network, protocol, and smart contract verification. Previously, I was a Senior Staff Researcher at Futurewei Technologies (Huawei R&amp;amp;D), Champaign, IL, where I worked on researching and developing compiler, runtime, and frameworks for Huawei’s mobile, cloud, and IoT solutions. In addition, impactful software engineering research has always been my passion.</bio>
        <homepage_url>http://web.cs.iastate.edu/~ganeshau/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/ganeshaupadhyaya/e4cda76a-77e7-4064-a67e-a85da0616702/small.jpg</picture_url>
        <person_id>ganeshaupadhyaya</person_id>
      </person>
      <person>
        <role>Poster Co-Chair in Organizing Committee</role>
        <sort_key>25</sort_key>
        <first_name>Christos</first_name>
        <last_name>Dimoulas</last_name>
        <affiliation>PLT @ Northwestern University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://users.eecs.northwestern.edu/~chrdimo/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/christosdimoulas1/b0a0a408-c992-49cf-99f4-39e30fe9ce1d/small.jpg</picture_url>
        <person_id>christosdimoulas1</person_id>
      </person>
      <person>
        <role>Poster Co-Chair in Organizing Committee</role>
        <sort_key>26</sort_key>
        <first_name>Murali</first_name>
        <last_name>Krishna Ramanathan</last_name>
        <affiliation>Uber Technologies Inc.</affiliation>
        <bio>Murali Krishna Ramanathan is a Programming Systems Research Scientist at Uber Technologies Inc. Previously, he was affiliated with IISc, Bangalore and Coverity Inc. He has designed and implemented several novel program analysis tools for detecting software bugs. He received his PhD in Computer Science from Purdue University.</bio>
        <homepage_url>https://sites.google.com/view/mkramanathan/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/muralikrishnaramanathan/52304999-046a-4d35-a2ed-9eb9ca2db709/small.jpg</picture_url>
        <person_id>muralikrishnaramanathan</person_id>
      </person>
      <person>
        <role>Publications Chair in Organizing Committee</role>
        <sort_key>27</sort_key>
        <first_name>Saba</first_name>
        <last_name>Alimadadi</last_name>
        <affiliation>Simon Fraser University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://ece.ubc.ca/~saba/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/sabaalimadadi/fb15cf5f-b2f9-4ff5-84d1-1b5aa9be2378/small.jpg</picture_url>
        <person_id>sabaalimadadi</person_id>
      </person>
      <person>
        <role>SPLASH-E Co-Chair in Organizing Committee</role>
        <sort_key>28</sort_key>
        <first_name>Elisa</first_name>
        <last_name>Baniassad</last_name>
        <affiliation>University of British Columbia</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.ubc.ca/~ebani</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/elisabaniassad/ebb453ca-88ce-4678-823e-82b113c14751/small.jpg</picture_url>
        <person_id>elisabaniassad</person_id>
      </person>
      <person>
        <role>SPLASH-E Co-Chair in Organizing Committee</role>
        <sort_key>29</sort_key>
        <first_name>Charlie</first_name>
        <last_name>Curtsinger</last_name>
        <affiliation>Grinnell College</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://ccurtsinger.net</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/charliecurtsinger/e779a4c9-ade3-4073-b660-866046d6c953/small.jpg</picture_url>
        <person_id>charliecurtsinger</person_id>
      </person>
      <person>
        <role>Artifact Evaluation Chair in Organizing Committee</role>
        <sort_key>30</sort_key>
        <first_name>Colin</first_name>
        <last_name>Gordon</last_name>
        <affiliation>Drexel University</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://cs.drexel.edu/~csgordon/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/colingordon/d990db47-1ece-4016-bce5-b764428bd0ee/small.jpg</picture_url>
        <person_id>colingordon</person_id>
      </person>
      <person>
        <role>Artifact Evaluation Chair in Organizing Committee</role>
        <sort_key>31</sort_key>
        <first_name>Anders</first_name>
        <last_name>Møller</last_name>
        <affiliation>Aarhus University, Denmark</affiliation>
        <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
        <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
        <person_id>andersmoller</person_id>
      </person>
      <person>
        <role>Accessibility Chair in Organizing Committee</role>
        <sort_key>32</sort_key>
        <first_name>Henrique</first_name>
        <last_name>Rebelo</last_name>
        <affiliation>Universidade Federal de Pernambuco</affiliation>
        <bio>My chief [and long-term] research interest is at improving the productivity of programmers by enabling them to write programs that, as much as possible, look like their design [and design constraints]. I believe that programs that clearly capture the design structure and interfaces they implement are more configurable, fun to develop and easier to maintain. 
In pursuit of this goal, my research has been focused in programming language design and implementation, including software engineering, tools and related issues. 
I have worked massively in the area of design by contract (DbC) and aspect-oriented programming (AOP). In the former, I have contributed extensively to the implementation of the JML specification language and its [RAC] compiler. In the latter, more recently, I’m excited to have started the next generation of aspect-oriented programming, as outlined in my SBLP 2017 talk. In this context, I’m leading the development of aspect-oriented programming reloaded project, which includes the AspectJML programming language and its Online IDE. AspectJML is [now] a general-purpose aspect-oriented extension to Java. It supports programming in Java, JML, AspectJ, AspectJML, or a mixin of all that. Hence, some of my current research in the Software Productivity Group is AOP[Reloaded]/AspectJML related.</bio>
        <homepage_url>http://www.cin.ufpe.br/~hemr</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/henriquerebelo/a08e4c59-858e-41a6-aba3-e751248dd721/small.jpg</picture_url>
        <person_id>henriquerebelo</person_id>
      </person>
      <person>
        <role>Accessibility Chair in Organizing Committee</role>
        <sort_key>33</sort_key>
        <first_name>Sumon</first_name>
        <last_name>Biswas</last_name>
        <affiliation>Iowa State University, USA</affiliation>
        <bio>Sumon Biswas is a Ph.D. student of Computer&amp;nbsp;Science department at Iowa State University and Research Assistant at Laboratory of Software Design at ISU under the supervision of Hridesh Rajan. His research interests are in the blend of Data Science, Software Engineering, and Program Analysis. He has worked on large scale data science program analysis using the Boa framework. He worked on building Python language support for Boa to analyze machine learning programs.&amp;nbsp;Currently, he is&amp;nbsp;working in the&amp;nbsp;D4 (Dependable Data-Driven Discovery) project and focusing on increasing the dependability of data-driven software. Specifically, he is conducting research on improving the fairness of machine learning models.</bio>
        <homepage_url>http://www.cs.iastate.edu/~sumon/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/sumonbiswas/1f6429a0-dded-4481-9f4f-ba26909d837d/small.jpg</picture_url>
        <person_id>sumonbiswas</person_id>
      </person>
      <person>
        <role>AV Co-Chair in Organizing Committee</role>
        <sort_key>34</sort_key>
        <first_name>Benjamin</first_name>
        <last_name>Chung</last_name>
        <affiliation>Northeastern University, USA</affiliation>
        <bio>undefined</bio>
        <picture_url>https://2020.splashcon.org/getProfileImage/benjaminchung/30978af0-bcee-4c1e-9dd1-f2588ea14f38/small.jpg</picture_url>
        <person_id>benjaminchung</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>35</sort_key>
        <first_name>Jonathan</first_name>
        <last_name>Aldrich</last_name>
        <affiliation>Carnegie Mellon University, USA</affiliation>
        <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
        <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
        <person_id>jonathanaldrich</person_id>
      </person>
      <person>
        <role>Doctoral Symposium Co-Chair in Organizing Committee</role>
        <sort_key>36</sort_key>
        <first_name>Yvonne</first_name>
        <last_name>Coady</last_name>
        <affiliation>University of Victoria</affiliation>
        <bio>undefined</bio>
        <picture_url>https://2020.splashcon.org/getProfileImage/yvonnecoady/7b532c8e-0c31-445d-b943-ad956a6f5722/small.jpg</picture_url>
        <person_id>yvonnecoady</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>37</sort_key>
        <first_name>Elisa</first_name>
        <last_name>Gonzalez Boix</last_name>
        <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://soft.vub.ac.be/~egonzale</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/elisagonzalezboix/8e8a61c4-366e-49b5-a861-7dfbc98ee129/small.jpg</picture_url>
        <person_id>elisagonzalezboix</person_id>
      </person>
      <person>
        <role>Doctoral Symposium Co-Chair in Organizing Committee</role>
        <sort_key>38</sort_key>
        <first_name>Matthias</first_name>
        <last_name>Hauswirth</last_name>
        <affiliation>Università della Svizzera italiana</affiliation>
        <bio>I am an Associate-Professor at the USI (Università della Svizzera italiana) in Lugano, Switzerland. 
At USI I am heading Luce, the Lugano Computing Education research lab (http://luce.inf.usi.ch/) where we study how people learn to program and how to improve that learning process. I am a member of the program committee of the Swiss national program to train existing high school teachers to teach the new mandatory informatics course (https://www3.unifr.ch/gyminf/) and I am co-directing a similar state-wide program in Ticino. 
As part of my lab’s work on conceptual change in learning to program, we contribute to the growing repository of programming misconceptions at (https://progmiscon.org). Amongst other things, that repository maps misconceptions to features of specific programming languages, with links to the corresponding sections of the official language specifications.</bio>
        <homepage_url>http://www.inf.usi.ch/faculty/hauswirth/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/matthiashauswirth/2f29d37f-4c84-49d3-a27d-7e3909177c4c/small.jpg</picture_url>
        <person_id>matthiashauswirth</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>39</sort_key>
        <first_name>Hidehiko</first_name>
        <last_name>Masuhara</last_name>
        <affiliation>Tokyo Institute of Technology</affiliation>
        <bio>Hidehiko Masuhara is a Professor of Mathematical and Computing Science, Tokyo Institute of Technology since April 2013. He received his B.S., M.S., and Ph.D. in Computer Science from Department of Information Science, University of Tokyo in 1992, 1994, and 1999, respectively, and served as an assistant professor, lecturer, and associate professor at Graphics and Computer Science, Graduate School of Arts and Sciences, University of Tokyo from 1995 until 2013.</bio>
        <homepage_url>http://prg.is.titech.ac.jp/people/masuhara/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/hidehikomasuhara/3ea94269-6fb5-4c6d-8d6f-0435717377d6/small.jpg</picture_url>
        <person_id>hidehikomasuhara</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>40</sort_key>
        <first_name>Gail</first_name>
        <last_name>Murphy</last_name>
        <affiliation>University of British Columbia</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://blogs.ubc.ca/gailcmurphy/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/gailmurphy/73d0b02f-de45-4e07-83cc-8b24f293ff8a/small.jpg</picture_url>
        <person_id>gailmurphy</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>41</sort_key>
        <first_name>Jens</first_name>
        <last_name>Palsberg</last_name>
        <affiliation>University of California, Los Angeles</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.ucla.edu/~palsberg</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/jenspalsberg/9e470c6a-532d-472c-9fea-253b7fa22c7c/small.jpg</picture_url>
        <person_id>jenspalsberg</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>42</sort_key>
        <first_name>Benjamin C.</first_name>
        <last_name>Pierce</last_name>
        <affiliation>University of Pennsylvania, USA</affiliation>
        <bio>Benjamin Pierce is Henry Salvatori Professor of Computer and Information Science at the University of Pennsylvania and a Fellow of the ACM. His research interests include programming languages, type systems, language-based security, computer-assisted formal verification, differential privacy, and synchronization technologies. He is the author of the widely used graduate textbooks Types and Programming Languages and Software Foundations. He has served as co-Editor in Chief of the Journal of Functional Programming, as Managing Editor for Logical Methods in Computer Science, and as editorial board member of Mathematical Structures in Computer Science, Formal Aspects of Computing, and ACM Transactions on Programming Languages and Systems. He is also the lead designer of the popular Unison file synchronizer and co-developer of the Clowdr virtual conference platform.</bio>
        <homepage_url>http://www.cis.upenn.edu/~bcpierce/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/benjamincpierce/f2ee6f41-5bf7-4a0d-9b8d-71de6a666b1b/small.jpg</picture_url>
        <person_id>benjamincpierce</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>43</sort_key>
        <first_name>Yannis</first_name>
        <last_name>Smaragdakis</last_name>
        <affiliation>University of Athens, Greece</affiliation>
        <bio>Research Interests: programming languages and software engineering 
 
 Program analysis (static analysis, test generation, invariant inference, symbolic execution) 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality) 
</bio>
        <homepage_url>http://smaragd.org/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
        <person_id>yannissmaragdakis</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>44</sort_key>
        <first_name>Manu</first_name>
        <last_name>Sridharan</last_name>
        <affiliation>University of California at Riverside, USA</affiliation>
        <bio>I’m an associate professor at the University of California, Riverside. Previously I worked at IBM Research, Samsung Research, and Uber. My research focuses on developing tools and techniques to make large-scale software more reliable, performant, secure, and maintainable. For more details, see my homepage.</bio>
        <homepage_url>http://manu.sridharan.net</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/manusridharan/00859147-2155-45a9-9a48-7565ce5356ac/small.jpg</picture_url>
        <person_id>manusridharan</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>45</sort_key>
        <first_name>Emina</first_name>
        <last_name>Torlak</last_name>
        <affiliation>University of Washington</affiliation>
        <bio>Emina Torlak is an Associate Professor at the University of Washington, working at the intersection of programming languages, formal methods, and software engineering. She received her Bachelors (2003), Masters (2004), and Ph.D. (2009) degrees from MIT, and subsequently worked at IBM Research, LogicBlox, and as a research scientist at U.C. Berkeley. Her research focuses on developing automated tools and programming models for computer-aided design, verification, and synthesis of software. She is the creator of the Kodkod constraint solver, which has been used in over 70 academic and industrial tools for software engineering. Emina has applied her expertise to a broad range of problems, from verification of memory-consistency models to generation of test data for decision support applications. Her current work on the Rosette solver-aided language integrates constraint solvers into programming languages to support computer-aided verification, debugging, and synthesis of code, making programming a collaboration between humans and machines.</bio>
        <homepage_url>https://homes.cs.washington.edu/~emina/index.html</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/eminatorlak/b48dd8a1-4bf6-4d29-b6e3-fb0e9ea9ce8e/small.jpg</picture_url>
        <person_id>eminatorlak</person_id>
      </person>
    </persons>
  </event_details>
  <subevent>
    <subevent_id>a6998af5-11a7-43f3-8563-b76578ca92a1</subevent_id>
    <title>Scala: Scala Symposium</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-V</room>
    <date>2020/11/18</date>
    <url>https://2020.ecoop.org/home/scala-2020</url>
    <url_link_display>11th ACM SIGPLAN Scala Symposium</url_link_display>
    <tracks>
      <track>11th ACM SIGPLAN Scala Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>cceb84ac-dce1-43c1-9adf-89ec4aafbd86</slot_id>
      <title>Session: Scala - Scala Symposium</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/18</date>
      <start_time>09:00</start_time>
      <end_time>14:20</end_time>
      <tracks>
        <track>11th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3051db7d-1408-406f-9b83-1bc00d1869f9</slot_id>
      <event_id>c11b8672-426f-428e-b382-db557c4569c3</event_id>
      <title>Closing Scala 2020</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/18</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>13:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Conference Chair</role>
          <sort_key>1</sort_key>
          <first_name>Nada</first_name>
          <last_name>Amin</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://namin.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nadaamin/b083e70b-31f9-4a88-89ba-ae54f8ec9315/small.jpg</picture_url>
          <person_id>nadaamin</person_id>
        </person>
        <person>
          <role>General Chair</role>
          <sort_key>2</sort_key>
          <first_name>Guido</first_name>
          <last_name>Salvaneschi</last_name>
          <affiliation>University of St. Gallen, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.guidosalvaneschi.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guidosalvaneschi/6f1373d5-57c6-4d68-b6c3-c0a679ee24ed/small.jpg</picture_url>
          <person_id>guidosalvaneschi</person_id>
        </person>
        <person>
          <role>Publicity Chair</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Richter</last_name>
          <affiliation>Technische Universität Darmstadt</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidrichter/767d3510-ec6f-42b3-a172-f94a883d1af5/small.jpg</picture_url>
          <person_id>davidrichter</person_id>
        </person>
      </persons>
      <tracks>
        <track>11th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>352eb5bb-2254-4f6d-b67e-a84faf7732c8</slot_id>
      <event_id>f4874e56-74be-453f-8f2f-2bd0dd8a547f</event_id>
      <title>Welcome to Scala 2020</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/18</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>10:05</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Conference Chair</role>
          <sort_key>1</sort_key>
          <first_name>Nada</first_name>
          <last_name>Amin</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://namin.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nadaamin/b083e70b-31f9-4a88-89ba-ae54f8ec9315/small.jpg</picture_url>
          <person_id>nadaamin</person_id>
        </person>
        <person>
          <role>General Chair</role>
          <sort_key>2</sort_key>
          <first_name>Guido</first_name>
          <last_name>Salvaneschi</last_name>
          <affiliation>University of St. Gallen, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.guidosalvaneschi.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guidosalvaneschi/6f1373d5-57c6-4d68-b6c3-c0a679ee24ed/small.jpg</picture_url>
          <person_id>guidosalvaneschi</person_id>
        </person>
        <person>
          <role>Publicity Chair</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Richter</last_name>
          <affiliation>Technische Universität Darmstadt</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidrichter/767d3510-ec6f-42b3-a172-f94a883d1af5/small.jpg</picture_url>
          <person_id>davidrichter</person_id>
        </person>
      </persons>
      <tracks>
        <track>11th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>46c03259-81cc-4048-b1c5-227f2f61f83b</slot_id>
      <event_id>1ef9cb03-a21e-4a33-9a5a-f0ee48606516</event_id>
      <title>Towards a Sound Approximating Compiler for Numerical Kernels (Keynote)</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/18</date>
      <start_time>10:05</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>10:40</end_time>
      <description>Computing resources are fundamentally limited and sometimes an exact solution may not even exist. Thus, when implementing real-world systems, approximations are inevitable, as are the errors they introduce. The magnitude of errors is problem-dependent but higher accuracy generally comes at a cost in terms of memory, energy or runtime, effectively creating an accuracy-efficiency tradeoff. To take advantage of this tradeoff, we need to ensure that the computed results are sufficiently accurate, otherwise we risk disastrously incorrect results or system failures. 
In this talk, we present the current state of the tool Daisy which approximates numerical kernels in an automated and trustworthy fashion. Daisy allows a programmer to write exact high-level code and generates an efficient implementation satisfying a given accuracy specification. We discuss Daisy’s verification techniques for bounding the effects of numerical errors, and the approximations Daisy can synthesize fully automatically. 
 
Eva Darulova received a PhD from Ecole Polytechnique Federale de Lausanne (EPFL) and joined the Max Planck Institute for Software Systems (MPI-SWS) as tenure-track faculty in 2015. Her current research focus is on making programming with numerical uncertainties and approximations easier, safer, and the programs themselves more efficient.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eva</first_name>
          <last_name>Darulova</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mpi-sws.org/~eva/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/evadarulova/0d98744b-ec94-4a27-b1c0-0d728d54bdb7/small.jpg</picture_url>
          <person_id>evadarulova</person_id>
        </person>
      </persons>
      <tracks>
        <track>11th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>52a847ab-69fe-4e5b-b88b-72552b50d465</slot_id>
      <event_id>94f4b467-6923-49ea-a4ed-8013f52a3c28</event_id>
      <title>Toward a Simpler Syntactic Soundness for DOT (Student Talk)</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/18</date>
      <start_time>12:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>13:00</end_time>
      <description>One of the most distinguishing features of the Scala Programming Language is that it features path-dependent types. DOT calculi are a family of formalized programming languages that support path-dependent types. Proving type safety for a programming language with path-dependent types has proven difficult and after a long search Amin et al. presented a type safety proof of the WadlerFest DOT calculus. A more modular and extensible type safety proof for this calculus was later presented by Rapoport et al. This proof has been extended further to show various extensions of the WadlerFest DOT calculus are also sound. 
While the proof of Rapoport et al. is simpler and modular than previous proofs, we believe there are more opportunities for simplification. In this talk, we will discuss additional simplifications that are possible for the DOT calculus. The Coq proofs associated with the material of this talk can be found at https://github.com/themaplelab/dot-public.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ifaz</first_name>
          <last_name>Kabir</last_name>
          <affiliation>University of Alberta, Canada</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/ifazkabir/991cbcab-f46c-4c5e-8b8f-c365d1b11d6b/small.jpg</picture_url>
          <person_id>ifazkabir</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Karim</first_name>
          <last_name>Ali</last_name>
          <affiliation>University of Alberta</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://karimali.ca</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/karimali/460ecc0b-764d-462b-a93e-66a3270d72ef/small.jpg</picture_url>
          <person_id>karimali</person_id>
        </person>
      </persons>
      <tracks>
        <track>11th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5dea9e31-b0f4-4577-b674-c2a0f4fc9a42</slot_id>
      <event_id>7c75547f-00fe-457c-bb25-8609fefe812e</event_id>
      <title>ONNX-Scala: Typeful, Functional Deep Learning / Dotty Meets an Open AI Standard (Open-Source Talk)</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/18</date>
      <start_time>10:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>11:00</end_time>
      <description>Topics: Machine Learning, Interoperability 
The talk opens by providing a sketch of machine learning and how it relates to functional programming. We subsequently introduce ONNX and ONNX-Scala, looking at design goals and features, discussing backends, the generated fine-grained API, and model code generation. Along the way we compare an ONNX model visualization with the representation of the model in ONNX-Scala. This is followed by a brief discussion of the type-safe/functional features offered by ONNX-Scala and the Dotty features they are built on. Finally, we close on some remarks on future directions, particularly the use of Dotty metaprogramming and other new features.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Merritt</last_name>
          <affiliation>Independent</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cc.gatech.edu/~amerritt/</homepage_url>
          <person_id>alexandermerritt</person_id>
        </person>
      </persons>
      <tracks>
        <track>11th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>64428249-bcb2-4feb-a1ab-ec626b7fcb85</slot_id>
      <event_id>a12713fb-3d5e-4eab-b935-0d16512313cf</event_id>
      <title>Kaizen: A Scalable Concolic Fuzzing Tool for Scala (Extended Abstract)</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/18</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>11:20</end_time>
      <description>Scala is an open-source programming language created by Martin Odersky in 2001 and released under the BSD or Berkeley Software Distribution license. The language consolidates object-oriented and functional programming in one high-level and robust language. Scala also maintains static types that help to reduce tricky errors in real-world software systems. 
In this paper, we introduce the first Scala-specific security analysis too that works based on a concolic based fuzzing for evaluating large-scale codes written in Scala, we call our tool Kaizen. To evaluated our approach, we have analyzed 1,000 real-world projects and core libraries written in Scala existing on GitHub. As a result, our testing system could report 101 vulnerabilities some of those were unknown before. Furthermore, the outcome of our performance analysis on ScalaBench illustrates 49% runtime overhead that proves the efficiently of Kaizen in comparison with related tools in the JVM ecosystem.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohammadreza</first_name>
          <last_name>Ashouri</last_name>
          <affiliation>University of Potsdam, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/mohammadrezaashouri/aad5ab13-ae03-4c04-9161-a998bef05d6b/small.jpg</picture_url>
          <person_id>mohammadrezaashouri</person_id>
        </person>
      </persons>
      <tracks>
        <track>11th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9189681c-d7eb-43e3-bf9c-0f6e041198ba</slot_id>
      <event_id>11156f21-49b5-48cb-b0ca-549d00781de9</event_id>
      <title>ScalaPy: Seamless Python Interoperability for Cross-Platform Scala Programs</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/18</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>12:20</end_time>
      <description>In recent years, Python has become the language of choice for data scientists with its many high-quality scientific libraries and Scala has become the go-to language for big data systems. In this paper, we bridge these languages with ScalaPy, a system for interoperability between Scala and Python. With ScalaPy, developers can use Python libraries in Scala by treating Python values as Scala objects and exposing Scala values to Python. ScalaPy supports both Scala on the JVM and Scala Native, enabling its usage from data experiments in interactive notebook environments to performance-critical production systems. In this paper, we explore the challenges involved with mixing the semantics and implementations of these two disparate languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shadaj</first_name>
          <last_name>Laddad</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://shadaj.me</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shadajladdad/d64c98bb-f1a7-4627-8ce4-f30e39b4d77d/small.jpg</picture_url>
          <person_id>shadajladdad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Koushik</first_name>
          <last_name>Sen</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>Koushik Sen is a professor in the Department of Electrical Engineering and Computer Sciences at the University of California, Berkeley. His research interest lies in Software Engineering, Programming Languages, and Formal methods. He is interested in developing software tools and methodologies that improve programmer productivity and software quality. He holds a B.Tech from Indian Institute of Technology, Kanpur, and M.S. and Ph.D. in CS from University of Illinois at Urbana-Champaign.</bio>
          <homepage_url>https://people.eecs.berkeley.edu/~ksen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/koushiksen/9f417f8a-40b9-40a7-866c-9c44cd81859a/small.jpg</picture_url>
          <person_id>koushiksen</person_id>
        </person>
      </persons>
      <tracks>
        <track>11th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>932e0be6-0061-4e67-ba7b-52c9918fca8e</slot_id>
      <event_id>9d5fdf08-0288-446d-ac8e-73d01c4444fe</event_id>
      <title>Asterisk: Secure Programming Language for Smart Contracts (Student Talk)</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/18</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>12:00</end_time>
      <description>In this paper, we introduce Asterisk as a new statically-typed programming language that is built on top of the Scala compiler. This new programming language is particularly designed for building safe and reliable Ethereum smart contracts. Because the Ethereum platform supports the execution of decentralized programs (i.e., smart contracts), Asterisk can have broad applications in new domains of technology such as financial system, health care, and 5G networks. Moreover, Ethereum operates the second-largest cryptocurrency after Bitcoin, typically for holding and transferring digital assets on the blockchain platform. Consequently, the role of smart contract compilers is even more important in generating portable, secure, and predictable code under real-world circumstances in the blockchain network. Accordingly, Asterisk aims to empower the Ethereum community to deploy robust code for business-critical and high-value use cases. Asterisk’s compilation architecture leverages Scala, and therefore, the generated smart contracts by Asterisk are cross-platform in the sense that a compiled contract runs on all platforms for which there exists a Java Virtual Machine (JVM). The compiler structure also supports formal verification to guarantee the reliability and safety of the bytecode produced by Asterisk at runtime.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohammadreza</first_name>
          <last_name>Ashouri</last_name>
          <affiliation>University of Potsdam, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/mohammadrezaashouri/aad5ab13-ae03-4c04-9161-a998bef05d6b/small.jpg</picture_url>
          <person_id>mohammadrezaashouri</person_id>
        </person>
      </persons>
      <tracks>
        <track>11th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b94e7a8a-f9b3-4d85-8b4c-2782f74c753e</slot_id>
      <event_id>b34c0b84-607e-476e-b042-ec67a218324b</event_id>
      <title>Semantics-Preserving Inlining for Metaprogramming</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/18</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>12:40</end_time>
      <description>Inlining is used in many different ways in programming languages: some languages use it as a compiler-directive solely for optimization, some use it as a metaprogramming feature, and others lay their design in-between. 
Can we disentangle inlining from the other metaprogramming features? Yes, and this is the approach followed in Scala 3 to support a powerful set of metaprogramming constructs. In a multi-paradigm language like Scala, the concern for generality of inlining poses several interesting questions. In this paper, we explore these questions by explaining the rationale behind the design of Scala-3’s inlining capability and how it relates to its metaprogramming architecture.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Stucki</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://github.com/nicolasstucki</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nicolasstucki/4dfca9be-ecc5-4acb-a0bf-078dfb4abbf0/small.jpg</picture_url>
          <person_id>nicolasstucki</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aggelos</first_name>
          <last_name>Biboudis</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>Software engineer and computer science addict; researcher at heart, excited about extensibility of software, code generation and performance 
 
 Working on frameworks and tools for Data, Analytics &amp;amp; AI @Swisscom 
 Ex-researcher on Scala 3 @ LAMP/@EPFL 
 PhD from @dit_uoa 
 
@biboudis</bio>
          <homepage_url>http://biboudis.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aggelosbiboudis/89ee406d-41be-466b-a4e8-bf4c6aef486d/small.jpg</picture_url>
          <person_id>aggelosbiboudis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sébastien</first_name>
          <last_name>Doeraene</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>Sébastien Doeraene is a compiler/runtime systems hacker and a Scala enthusiast. Best known as the author of Scala.js, he is now executive director of the Scala Center. He holds a PhD from EPFL, having worked under the supervision of Prof. Martin Odersky, and a master’s degree in computer science engineering from Université catholique de Louvain in Belgium. When he is not busy coding, he sings in choirs and a cappella groups such as the Ensemble Vocal Évohé, or composes for said choirs.</bio>
          <homepage_url>https://lampwww.epfl.ch/~doeraene/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sebastiendoeraene/a6fd635a-6c1a-4896-a79f-234ccfaa2d7e/small.jpg</picture_url>
          <person_id>sebastiendoeraene</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Martin</first_name>
          <last_name>Odersky</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>Martin Odersky is a professor at EPFL in Lausanne, Switzerland. He has been working on programming languages for most of his career. He first studied structured and object-oriented programming as a PhD student of Niklaus Wirth, then fell in love with functional programming while working as a post doc at IBM and Yale. When Java came out, he started to add functional programming constructs to the new platform. This led to Pizza and GJ and eventually to Java 5 with generics. During that time he also developed javac, the current reference compiler for Java. 
Over the last 10 years, Martin worked on unifying object-oriented and functional programming in the Scala language. Scala quickly escaped from the research lab and became a popular open source tool and industrial language. He now oversees development of Scala as head of the programming group at EPFL and as academic director of the Scala center.</bio>
          <homepage_url>http://lampwww.epfl.ch/~odersky/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/martinodersky/fc1dd696-d0d4-47cb-9d9a-bba012d98f9e/small.jpg</picture_url>
          <person_id>martinodersky</person_id>
        </person>
      </persons>
      <tracks>
        <track>11th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>dbe209ed-4aa9-4604-b39b-93b6ecdf9ff4</subevent_id>
    <title>AGERE: Presentations</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-V</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/home/agere-2020</url>
    <url_link_display>AGERE 2020</url_link_display>
    <tracks>
      <track>AGERE 2020</track>
    </tracks>
    <timeslot>
      <slot_id>90edbf2d-baac-41de-9811-a5a760b9f367</slot_id>
      <title>Session: AGERE - Presentations</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/17</date>
      <start_time>05:00</start_time>
      <end_time>07:00</end_time>
      <tracks>
        <track>AGERE 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>13379d52-dfb8-48dd-9963-365d5672d526</slot_id>
      <event_id>6431756f-c3e7-4f64-b5f8-e88f5162cab5</event_id>
      <title>Revisiting the Network Stack in CAF</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/17</date>
      <start_time>05:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>06:10</end_time>
      <description>Applications increasingly demand distribution across the global Internet. The Actor model of computation has been wisely designed to abstract communication between actors and hence remains transparent w.r.t. distribution. Performance, security, and deployment considerations, however, make it difficult to define a specific communication transport that should be hardcoded into an actor framework. It is rather desirable to design appropriate transport abstractions, which allow for flexible choices and configurations of transport functions on the Internet. 
In this paper, we report about our ongoing work of redesigning, implementing, and evaluating a network stack that abstracts transport for the C++ Actor Framework (CAF). The stack allows for the exchanging of transport protocols and adds configuration options as well as compositions of protocols. First comparisons of TCP versus UDP with configurable reliability options are provided, as well as an early evaluation of its performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jakob</first_name>
          <last_name>Otto</last_name>
          <affiliation>HAW Hamburg</affiliation>
          <bio>undefined</bio>
          <person_id>jakobotto</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Raphael</first_name>
          <last_name>Hiesgen</last_name>
          <affiliation>HAW Hamburg</affiliation>
          <bio>phd student at HAW Hamburg</bio>
          <homepage_url>https://inet.haw-hamburg.de/members/raphael-hiesgen</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/raphaelhiesgen/a4f7eb66-26ad-4ace-8247-25afe7775f9b/small.jpg</picture_url>
          <person_id>raphaelhiesgen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dominik</first_name>
          <last_name>Charousset</last_name>
          <affiliation>HAW Hamburg</affiliation>
          <bio>undefined</bio>
          <person_id>dominikcharousset</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Thomas C.</first_name>
          <last_name>Schmidt</last_name>
          <affiliation>HAW Hamburg</affiliation>
          <bio>undefined</bio>
          <person_id>thomascschmidt</person_id>
        </person>
      </persons>
      <tracks>
        <track>AGERE 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2074aa32-5e24-4188-a334-c14fd2610109</slot_id>
      <event_id>34149c29-0cc2-446e-b44a-ebf62f052198</event_id>
      <title>Run, Agent, Run; Architecture and Benchmark of Actor-based Agents</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/17</date>
      <start_time>06:10</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>06:40</end_time>
      <description>The paper introduces an Agent-Oriented Programming (AOP) framework based on the Belief-Desire-Intention (BDI) model of agency. The novelty of this framework is in relying on the Actor model, instantiating each intentional agent as an autonomous micro-system run by actors. The working hypothesis behind this choice is that defining the agents via actors results in a more fine-grained modular architecture and that the execution of agent-oriented programs is enhanced (in scalability as well as in performance) by relying on robust implementations of Actor models such as Akka. The framework is benchmarked and analyzed quantitatively and qualitatively against three other AOP frameworks: Jason, ASTRA and Sarl.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mostafa Mohajeri</first_name>
          <last_name>Parizi</last_name>
          <affiliation>University of Amsterdam</affiliation>
          <bio>undefined</bio>
          <person_id>mostafamohajeriparizi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Giovanni</first_name>
          <last_name>Sileno</last_name>
          <affiliation>University of Amsterdam</affiliation>
          <bio>undefined</bio>
          <person_id>giovannisileno</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tom</first_name>
          <last_name>van Engers</last_name>
          <affiliation>Leibniz Institute, University of Amsterdam / TNO</affiliation>
          <bio>undefined</bio>
          <person_id>tomvanengers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sander</first_name>
          <last_name>Klous</last_name>
          <affiliation>University of Amsterdam</affiliation>
          <bio>undefined</bio>
          <person_id>sanderklous</person_id>
        </person>
      </persons>
      <tracks>
        <track>AGERE 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>553843b2-e51a-496d-a6ae-14d31d50f76a</slot_id>
      <event_id>162219e4-7f66-4def-93cf-347dd89e04fb</event_id>
      <title>AGERE: Closing</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/17</date>
      <start_time>06:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>06:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Elias</first_name>
          <last_name>Castegren</last_name>
          <affiliation>KTH Royal Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://eliasc.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eliascastegren/377a67c9-8fc9-4e1e-8925-558021e0d5c8/small.jpg</picture_url>
          <person_id>eliascastegren</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Joeri</first_name>
          <last_name>De Koster</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/joeridekoster/2f5765d5-6ed1-4a75-acf1-99a86a994912/small.jpg</picture_url>
          <person_id>joeridekoster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Thomas C.</first_name>
          <last_name>Schmidt</last_name>
          <affiliation>HAW Hamburg</affiliation>
          <bio>undefined</bio>
          <person_id>thomascschmidt</person_id>
        </person>
      </persons>
      <tracks>
        <track>AGERE 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6f1af665-44fd-4117-9778-1827256c99f1</slot_id>
      <event_id>48770916-13af-40b7-b697-709192e1e37a</event_id>
      <title>High-Throughput Stream Processing with Actors</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/17</date>
      <start_time>05:10</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>05:40</end_time>
      <description>The steady growth of data volume produced as continuous streams makes paramount the development of software capable of providing timely results to the users. The Actor Model (AM) offers a high-level of abstraction suited for developing scalable message-passing applications. It allows the application developer to focus on the application logic moving the burden of implementing fast and reliable inter-Actors message-exchange to the implementation framework. 
In this paper, by using the CAF framework as reference AM implementation, we focus on evaluating the model in high data rate streaming applications targeting scale-up servers. Our approach leverages Parallel Pattern (PP) abstractions to model streaming computations and introduces optimizations that otherwise could be challenging to implement without violating the AM’s semantics. The experimental analysis demonstrates that the new implementation skeletons we propose for our PPs can bring significant performance boosts (more than to 2x) in high data rate streaming applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Luca</first_name>
          <last_name>Rinaldi</last_name>
          <affiliation>University of Pisa</affiliation>
          <bio>undefined</bio>
          <person_id>lucarinaldi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Massimo</first_name>
          <last_name>Torquati</last_name>
          <affiliation>Computer Science Department - University of Pisa</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.di.unipi.it/~torquati</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/massimotorquati/edca658f-1e1e-4fd9-8689-a18e7dddb541/small.jpg</picture_url>
          <person_id>massimotorquati</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gabriele</first_name>
          <last_name>Mencagli</last_name>
          <affiliation>University of Pisa, Italy</affiliation>
          <bio>undefined</bio>
          <person_id>gabrielemencagli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Marco</first_name>
          <last_name>Danelutto</last_name>
          <affiliation>University of Pisa, Italy</affiliation>
          <bio>undefined</bio>
          <person_id>marcodanelutto</person_id>
        </person>
      </persons>
      <tracks>
        <track>AGERE 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7b56be3e-13a0-4099-90fd-039c4102a86e</slot_id>
      <event_id>53a1d349-c188-431b-b959-48ffc94f2c18</event_id>
      <title>AGERE: Opening</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/17</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>05:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Elias</first_name>
          <last_name>Castegren</last_name>
          <affiliation>KTH Royal Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://eliasc.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eliascastegren/377a67c9-8fc9-4e1e-8925-558021e0d5c8/small.jpg</picture_url>
          <person_id>eliascastegren</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Joeri</first_name>
          <last_name>De Koster</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/joeridekoster/2f5765d5-6ed1-4a75-acf1-99a86a994912/small.jpg</picture_url>
          <person_id>joeridekoster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Thomas C.</first_name>
          <last_name>Schmidt</last_name>
          <affiliation>HAW Hamburg</affiliation>
          <bio>undefined</bio>
          <person_id>thomascschmidt</person_id>
        </person>
      </persons>
      <tracks>
        <track>AGERE 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e2f1a7ee-178d-4983-8ba5-a27faf08e0bd</subevent_id>
    <title>SPLASH PLMW: Breakfast in Seattle (PLMW AMA)</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-PLMW</url>
    <url_link_display>PL Mentoring Workshop (PLMW)</url_link_display>
    <tracks>
      <track>PL Mentoring Workshop (PLMW)</track>
    </tracks>
    <timeslot>
      <slot_id>9b75d59c-eda3-4cd7-a155-d4ace3cfcfba</slot_id>
      <title>Session: SPLASH PLMW - Breakfast in Seattle (PLMW AMA)</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>10:20</start_time>
      <end_time>11:00</end_time>
      <tracks>
        <track>PL Mentoring Workshop (PLMW)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8f989f96-eb67-4548-bdc5-e89873244f71</slot_id>
      <event_id>8b95f21f-5136-4d54-bda4-beccb3419c21</event_id>
      <title>Ask Me Anything: Amal Ahmed</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>11:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Amal</first_name>
          <last_name>Ahmed</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/amal/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/amalahmed/301fd92b-d4ae-4998-8f6b-82cf081da653/small.jpg</picture_url>
          <person_id>amalahmed</person_id>
        </person>
      </persons>
      <tracks>
        <track>PL Mentoring Workshop (PLMW)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a230b722-cd7c-4562-95b5-983ebd19a315</subevent_id>
    <title>SPLASH Opening: Opening Session</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-opening</url>
    <url_link_display>Opening</url_link_display>
    <tracks>
      <track>Opening</track>
    </tracks>
    <timeslot>
      <slot_id>3b848cda-7fa8-4d77-8660-6f54fbd15346</slot_id>
      <title>Session: SPLASH Opening - Opening Session</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>19:00</start_time>
      <end_time>19:20</end_time>
      <tracks>
        <track>Opening</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>18639678-bac3-4f14-a1a2-51544f55e4c8</slot_id>
      <event_id>e341c0d1-a77b-4aa1-ae9b-83ec123e28da</event_id>
      <title>Opening Session</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>19:20</end_time>
      <description>Welcome to SPLASH 2020!</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hridesh</first_name>
          <last_name>Rajan</last_name>
          <affiliation>Iowa State University, USA</affiliation>
          <bio>Hridesh Rajan is a Professor and Chair of Computer Science at Iowa State University, where he has been since 2005. Professor Rajan earned his MS and Ph.D. from the University of Virginia in 2004 and 2005 respectively. Professor Rajan’s recent research and educational activities are aimed at decreasing the barrier to entry to data-driven sciences to broaden participation. His work on the Boa project is aimed at the invention and refinement of programming languages and cyberinfrastructures that democratize data-driven science &amp;amp; engineering, including software engineering. His work on the Midwest Big Data Summer School is experimenting with broadly accessible data science curricula. Professor Rajan was the founding general chair of the Midwest Big Data Summer School. Professor Rajan’s research interests also include programming language design and implementation, and software engineering. He leads two research projects: Panini, whose goals are to enable modular reasoning about concurrent programs, and Boa that was established in Summer 2012 as an end-to-end infrastructure for analyzing large-scale software repositories and other open data sets. Professor Rajan is the director of the Laboratory for Software Design at Iowa State University, director of graduate admissions and recruitment for the Department of Computer Science. He serves as the department chair of the Department of Computer Science and served as the Professor-In-Charge of the Data Science education programs at Iowa State University from 2017-2019, and chair of the information technology committee for the university from 2015-2019. Professor Rajan served on the steering committee of the Midwest Big Data Hub, a consortium of universities in the Midwest region of the United States focused on promoting data science activities. Professor Rajan is a recipient of the National Science Foundation CAREER award in 2009, LAS Award for Early Achievement in Research in 2010, a Big-12 Fellowship in 2012. He is a 2018-19 Fulbright U.S. Scholar, a distinguished member of the ACM, and a member of IEEE, and AAAS. He is also the inaugural holder of the Kingland Professorship in the Department of Computer Science.</bio>
          <homepage_url>https://hridesh.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hrideshrajan/f57a0842-20af-4fd4-b79f-5d673c2c485c/small.jpg</picture_url>
          <person_id>hrideshrajan</person_id>
        </person>
        <person>
          <role>OOPSLA Review Committee Chair</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Grove</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>I am a Distinguished Research Staff Member at the IBM T.J. Watson Research Center. I joined IBM Research in 1998 after completing my PhD at the University of Washington. I am a software systems researcher, working primarily on problems in programming language implementation and scalable runtime systems. 
I have contributed to a number of technical topics in programming language design and implementation including the analysis and optimization of object-oriented languages, virtual machine design and implementation, scalable runtime systems, Just-In-Time compilation, online feedback-directed optimization, and garbage collection.</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-groved</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidgrove/5524049e-7d0a-4799-ad8c-93e1e76a77ec/small.jpg</picture_url>
          <person_id>davidgrove</person_id>
        </person>
        <person>
          <role>ECOOP General Chair</role>
          <sort_key>3</sort_key>
          <first_name>Christian</first_name>
          <last_name>Hammer</last_name>
          <affiliation>University of Potsdam</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.uni-potsdam.de/se/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/christianhammer/7569da38-ffbb-4f7c-b613-c7d6aade9ffe/small.jpg</picture_url>
          <person_id>christianhammer</person_id>
        </person>
        <person>
          <role>ECOOP PC Chair</role>
          <sort_key>4</sort_key>
          <first_name>Robert</first_name>
          <last_name>Hirschfeld</last_name>
          <affiliation>Hasso-Plattner-Institut (HPI), Germany</affiliation>
          <bio>Robert Hirschfeld is a Professor of Computer Science at the Hasso Plattner Institute at the University of Potsdam, Germany. There he founded and leads the Software Architecture Group which is concerned with fundamental elements and structures of software. Methods and tools are developed for improving the comprehension and design of complex and interesting systems. 
Robert is interested in programming experiences and small system kernels. With his group he is working on dynamic programming languages, development tools, and runtime environments to make interactive programming more approachable. His preferred environment for exploring ideas is Squeak/Smalltalk. 
He served as a visiting professor at the Tokyo Institute of Technology (東京工業大学) and The University of Tokyo (東京大学), Japan. 
Robert was a senior researcher with DoCoMo Euro-Labs, the European research facility of NTT DoCoMo Japan, where he worked on infrastructure components for next generation mobile communication systems with a focus on dynamic service adaptation and context-oriented programming. 
Prior to joining DoCoMo Euro-Labs, he was a principal engineer at Windward Solutions in Sunnyvale, California, where he designed and implemented distributed object systems, consulted in the area of object database technologies, and developed innovative software products and applications. 
Robert received a Ph.D. in Computer Science from the Ilmenau University of Technology, Germany.</bio>
          <homepage_url>http://www.hirschfeld.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/roberthirschfeld/994ef4df-a890-4f16-bc1b-73b117dab33c/small.jpg</picture_url>
          <person_id>roberthirschfeld</person_id>
        </person>
        <person>
          <role>ECOOP 2021 General Chair</role>
          <sort_key>5</sort_key>
          <first_name>Anders</first_name>
          <last_name>Møller</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
          <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
          <person_id>andersmoller</person_id>
        </person>
      </persons>
      <tracks>
        <track>Opening</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d78113ab-97dd-41c1-83b0-8677be8860aa</subevent_id>
    <title>SPLASH Closing: Dinner in Delhi</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-closing</url>
    <url_link_display>Closing</url_link_display>
    <tracks>
      <track>Closing</track>
    </tracks>
    <timeslot>
      <slot_id>930a0b81-bb59-4105-b54f-1a37d3eb3268</slot_id>
      <title>Session: SPLASH Closing - Dinner in Delhi</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>06:20</start_time>
      <end_time>07:00</end_time>
      <tracks>
        <track>Closing</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4bc13b93-9dd7-46b8-be83-4405227d3e22</slot_id>
      <event_id>92603177-a865-4385-bf31-8163713f6a01</event_id>
      <title>Closing Session</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>06:20</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>07:00</end_time>
      <description>Thank you for attending SPLASH 2020!</description>
      <persons>
        <person>
          <role>General Chair</role>
          <sort_key>1</sort_key>
          <first_name>Hridesh</first_name>
          <last_name>Rajan</last_name>
          <affiliation>Iowa State University, USA</affiliation>
          <bio>Hridesh Rajan is a Professor and Chair of Computer Science at Iowa State University, where he has been since 2005. Professor Rajan earned his MS and Ph.D. from the University of Virginia in 2004 and 2005 respectively. Professor Rajan’s recent research and educational activities are aimed at decreasing the barrier to entry to data-driven sciences to broaden participation. His work on the Boa project is aimed at the invention and refinement of programming languages and cyberinfrastructures that democratize data-driven science &amp;amp; engineering, including software engineering. His work on the Midwest Big Data Summer School is experimenting with broadly accessible data science curricula. Professor Rajan was the founding general chair of the Midwest Big Data Summer School. Professor Rajan’s research interests also include programming language design and implementation, and software engineering. He leads two research projects: Panini, whose goals are to enable modular reasoning about concurrent programs, and Boa that was established in Summer 2012 as an end-to-end infrastructure for analyzing large-scale software repositories and other open data sets. Professor Rajan is the director of the Laboratory for Software Design at Iowa State University, director of graduate admissions and recruitment for the Department of Computer Science. He serves as the department chair of the Department of Computer Science and served as the Professor-In-Charge of the Data Science education programs at Iowa State University from 2017-2019, and chair of the information technology committee for the university from 2015-2019. Professor Rajan served on the steering committee of the Midwest Big Data Hub, a consortium of universities in the Midwest region of the United States focused on promoting data science activities. Professor Rajan is a recipient of the National Science Foundation CAREER award in 2009, LAS Award for Early Achievement in Research in 2010, a Big-12 Fellowship in 2012. He is a 2018-19 Fulbright U.S. Scholar, a distinguished member of the ACM, and a member of IEEE, and AAAS. He is also the inaugural holder of the Kingland Professorship in the Department of Computer Science.</bio>
          <homepage_url>https://hridesh.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hrideshrajan/f57a0842-20af-4fd4-b79f-5d673c2c485c/small.jpg</picture_url>
          <person_id>hrideshrajan</person_id>
        </person>
      </persons>
      <tracks>
        <track>Closing</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>52106b2a-4ab0-4edb-bd8e-fb7fa00874c2</subevent_id>
    <title>SPLASH Awards: Cocktails in New York</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-awards</url>
    <url_link_display>Awards</url_link_display>
    <tracks>
      <track>Awards</track>
    </tracks>
    <timeslot>
      <slot_id>623d4907-f0dd-4269-89ca-2599df741a21</slot_id>
      <title>Session: SPLASH Awards - Cocktails in New York</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>20:20</start_time>
      <end_time>21:00</end_time>
      <tracks>
        <track>Awards</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bf6c01df-5131-4de1-b096-18b058028feb</slot_id>
      <event_id>c0fd419e-0940-4fad-8e84-7f72a9339b79</event_id>
      <title>Awards Session</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>21:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Grove</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>I am a Distinguished Research Staff Member at the IBM T.J. Watson Research Center. I joined IBM Research in 1998 after completing my PhD at the University of Washington. I am a software systems researcher, working primarily on problems in programming language implementation and scalable runtime systems. 
I have contributed to a number of technical topics in programming language design and implementation including the analysis and optimization of object-oriented languages, virtual machine design and implementation, scalable runtime systems, Just-In-Time compilation, online feedback-directed optimization, and garbage collection.</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-groved</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidgrove/5524049e-7d0a-4799-ad8c-93e1e76a77ec/small.jpg</picture_url>
          <person_id>davidgrove</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Jens</first_name>
          <last_name>Palsberg</last_name>
          <affiliation>University of California, Los Angeles</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ucla.edu/~palsberg</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jenspalsberg/9e470c6a-532d-472c-9fea-253b7fa22c7c/small.jpg</picture_url>
          <person_id>jenspalsberg</person_id>
        </person>
      </persons>
      <tracks>
        <track>Awards</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2397a30c-a029-4cc6-b73c-358b37c0894f</subevent_id>
    <title>HILT: HILT workshop Tuesday sessions</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/home/hilt-2020</url>
    <url_link_display>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</url_link_display>
    <tracks>
      <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
    </tracks>
    <timeslot>
      <slot_id>677fff0c-e592-48ca-81f3-6f42a6fba062</slot_id>
      <title>Session: HILT - HILT workshop Tuesday sessions</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/17</date>
      <start_time>09:00</start_time>
      <end_time>13:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Bocchino</last_name>
          <affiliation>NASA/Caltech Jet Propulsion Laboratory</affiliation>
          <bio>I grew up in Haverford, Pennsylvania, and attended The Haverford School. From 1990–94 I attended Harvard College, graduating with an AB in mathematics. From 1994–97 I attended Harvard Law School, graduating with a JD and practicing law for several years in Boston. From 2003–10 I worked towards my Ph.D. in computer science at the University of Illinois at Urbana-Champaign with Vikram Adve as my advisor.</bio>
          <person_id>robertbocchino</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Tucker</first_name>
          <last_name>Taft</last_name>
          <affiliation>AdaCore, United States</affiliation>
          <bio> 
 Harvard College 1971-1975, AB Summa Cum Laude Chemistry 
 Harvard Radcliffe Student Computing Center 1975-1979, Systems Programmer 
 Intermetrics/AverStar/AverCom 1980-2002, Chief Scientist 
 SofCheck 2002-2011, Founder and CTO 
 AdaCore 2011-present, VP, Director of Language Research, Model-Based Toolset Product Architect 
</bio>
          <homepage_url>http://www.adacore.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tuckertaft/a31e3438-c202-49b1-95e4-3da5adac47be/small.jpg</picture_url>
          <person_id>tuckertaft</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>3</sort_key>
          <first_name>Richard</first_name>
          <last_name>Wai</last_name>
          <affiliation>ANNEXI-STRAYLINE</affiliation>
          <bio>Richard Wai is the Founder and Managing Director of ANNEXI-STRAYLINE, a start-up focused on the practical application of proven High Integrity technologies to mainstream software, particularly in large-scale cloud (SaaS) and IoT applications. Richard is an evangelist for the safety and maintainability provided by the Ada language, and is a member of the ISO Ada Rapporteur Group, tasked with the ongoing development of the Ada language. 
Richard began programming at an early age, with a particular interest in building practical, user-friendly software for non-technical users. Richard spent time studying higher-level design processes, and is working to bring the craftsmanship and diligence common in other creative and technical professions to the software industry, with the goal of promoting a disciplined, mature, and maintainability-oriented approach to mainstream software engineering. Richard holds an Honors Bachelor of Architecture with Distinction from the University of Toronto.</bio>
          <homepage_url>https://annexi-strayline.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/richardwai/97548551-5c3a-47aa-99e5-62ea5edfaf76/small.jpg</picture_url>
          <person_id>richardwai</person_id>
        </person>
      </persons>
      <tracks>
        <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>02d05e60-151e-46d9-92e6-1e378aace3d8</slot_id>
      <event_id>0933e4a7-fa6b-43c7-8093-18590e0f0ecf</event_id>
      <title>Tuesday Panel: Language support for parallel and distributed computing</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/17</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:00</end_time>
      <description>Language constructs that support parallel computing are relatively well recognized at this point, with features such as parallel loops (optionally with reduction operators), divide-and-conquer parallelism, and general parallel blocks. But what language features would make distributed computing safer and more productive? Is it helpful to be able to specify on what node a computation should take place, and on what node data should reside, or is that overspecification? We don’t normally expect a user of a parallel programming language to specify what core is used for a given iteration of a loop, nor which data should be moved into which core’s cache. Generally the compiler and the run-time manage the allocation of cores, and the hardware worries about the cache. But in a distributed world, communication costs can easily outweigh computation costs in a poorly designed application. This panel will discuss various language features, some of which already exist to support parallel computing, and how they could be enhanced or generalized to support distributed computing safely and efficiently. 
Our panel members are familiar with many of these issues: 
 
  Kyle Chard, University of Chicago and Argonne National Laboratory: “The past decade has seen a major transformation in the nature of programming as the need to make efficient use of parallel hardware is now inescapable. As the parallel programming community both grows and becomes yet more diverse there is a crucial need for high level language features that enable productivity, portability, safety, and usability. To strike a balance between usability and performance we need to focus on ways to raise the level of abstraction, making parallelism more accessible to developers in their working environments, and automating complex runtime decisions where possible, even if this comes at the expense of performance and/or functionality.”  
  James Munns, founder Ferrous Systems: “I can speak broadly around Rust’s capability to make certain aspects easier, such as serialization, state handling, error management, etc. Good distributed computing relies on safe and effective concurrent computing, so Rust’s features such as the Rayon library for light-weight threading, as well as Rust’s more conventional heavy-weight threading support, provide a basis for moving into the distributed computing realm.”  
  Richard Wai, founder Annexi-Strayline: “The rapidly changing and diverse space of distributed computing imposes complex challenges, particularly to language-defined specification of behavior. We should consider what safety threats arise from high communication costs. The real safety threat may be in the management and coordination of a large distributed codebase, where changes in one partition could potentially propagate serious defects out into the larger system, with unpredictable outcomes. There also seems to be a movement towards expanding the NUMA concept (or COMA) to distributed systems through rDMA fabrics and other similar architectures. This could mean a future where heterogenous systems share a cache-coherent global address space. We should consider how languages might scale to such system architectures, particularly in the parallel processing domain. How might a parallel loop behave over a cache-coherent fabric - particularly if the elements of the iterated data are disbursed?”  
  Tucker Taft (moderator), VP and Director of Language Research, AdaCore: “My career has been focused on the design of programming languages that can enhance the effectiveness and productivity of developers building large, high-performance, safe, secure, correct, and often real-time software-intensive systems. In the mean time, the hardware world has moved from relatively simple, single-processor, single-machine systems, through multi-core and many-core machines, on to heterogeneous and distributed networks of multi-core nodes with GPUs and FPGAs, cooperating to solve otherwise intractable problems. Programming languages have lagged behind this evolution, meaning that today’s programmer is generally confronted with all of this complexity. In some sense we have lost our high-level languages for developing software for these new systems, and are effectively back to doing machine-level programming, where now we worry about individual messages and data placement, much like the old assembly languages where we worried about individual machine instructions and machine registers. The question is can we regain a high-level model for doing distributed computing, but still achieve the performance achievable by “machine-level” distributed computing?”  
</description>
      <persons>
        <person>
          <role>Panel Moderator</role>
          <sort_key>1</sort_key>
          <first_name>Tucker</first_name>
          <last_name>Taft</last_name>
          <affiliation>AdaCore, United States</affiliation>
          <bio> 
 Harvard College 1971-1975, AB Summa Cum Laude Chemistry 
 Harvard Radcliffe Student Computing Center 1975-1979, Systems Programmer 
 Intermetrics/AverStar/AverCom 1980-2002, Chief Scientist 
 SofCheck 2002-2011, Founder and CTO 
 AdaCore 2011-present, VP, Director of Language Research, Model-Based Toolset Product Architect 
</bio>
          <homepage_url>http://www.adacore.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tuckertaft/a31e3438-c202-49b1-95e4-3da5adac47be/small.jpg</picture_url>
          <person_id>tuckertaft</person_id>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>2</sort_key>
          <first_name>Kyle</first_name>
          <last_name>Chard</last_name>
          <affiliation>University of Chicago</affiliation>
          <bio>undefined</bio>
          <person_id>kylechard</person_id>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>3</sort_key>
          <first_name>James</first_name>
          <last_name>Munns</last_name>
          <affiliation>Ferrous Systems</affiliation>
          <bio>James is an embedded systems engineer, with a history of working on software for a wide range of systems, including safety critical avionics, and rapidly prototyped IoT systems. James is a founding member of the Rust Embedded Working Group, as well as a founder of Ferrous Systems, a consultancy focused on systems development in Rust, with a specialty in embedded systems development. 
James is working hard to bring Rust to new places in the embedded domain, including efforts to qualify the Rust language for use in safety critical systems through the Sealed Rust initiative, and building easy to use open source tooling in the Knurling-rs project.</bio>
          <homepage_url>https://ferrous-systems.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jamesmunns/e1388ee6-bdb8-4713-af26-e40b3a96f104/small.jpg</picture_url>
          <person_id>jamesmunns</person_id>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>4</sort_key>
          <first_name>Richard</first_name>
          <last_name>Wai</last_name>
          <affiliation>ANNEXI-STRAYLINE</affiliation>
          <bio>Richard Wai is the Founder and Managing Director of ANNEXI-STRAYLINE, a start-up focused on the practical application of proven High Integrity technologies to mainstream software, particularly in large-scale cloud (SaaS) and IoT applications. Richard is an evangelist for the safety and maintainability provided by the Ada language, and is a member of the ISO Ada Rapporteur Group, tasked with the ongoing development of the Ada language. 
Richard began programming at an early age, with a particular interest in building practical, user-friendly software for non-technical users. Richard spent time studying higher-level design processes, and is working to bring the craftsmanship and diligence common in other creative and technical professions to the software industry, with the goal of promoting a disciplined, mature, and maintainability-oriented approach to mainstream software engineering. Richard holds an Honors Bachelor of Architecture with Distinction from the University of Toronto.</bio>
          <homepage_url>https://annexi-strayline.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/richardwai/97548551-5c3a-47aa-99e5-62ea5edfaf76/small.jpg</picture_url>
          <person_id>richardwai</person_id>
        </person>
      </persons>
      <tracks>
        <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>33f5667c-fe16-43f6-a150-269b2ea5a951</slot_id>
      <event_id>ec480b31-c409-478e-8ce5-1ea614e1d376</event_id>
      <title>Tuesday later coffee break</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/17</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>11:10</end_time>
      <description>HILT Clowdr Break Room</description>
      <tracks>
        <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>474ed364-f811-4e34-9345-29dae6457499</slot_id>
      <event_id>1f6b0117-688a-4aa5-871d-ad23e1f0dd04</event_id>
      <title>Challenges and lessons learned introducing Fuse, an evolving open source technology, into an established legacy Ada and C++ program</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/17</date>
      <start_time>10:35</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>11:00</end_time>
      <description>Background: When the FAA (Federal Aviation Administration) launched the System Wide Information Management (SWIM) initiative, the FAA had the goal of using the same portable, open infrastructure across all systems in the NAS (National Airspace System). In ~2008 the FAA chose Progress Software’s Free/Open Source Software (FOSS) based bundle known and supported under the Fuse brand. The licenses used by programs including EnRoute Automation Modernization (ERAM) were obtained by the FAA through Progress to use their Java framework. The name of the Computer Software Configuration Item (CSCI) for this SWIM client within ERAM is ERAM SWIM Application Service (ESAS). 
Areas to be discussed: 
 
 Development Challenges 
   
   ERAM is an Ada/C++ near real-time system using a purpose built middleware with a DO278 Level C compliant process. 
   Tactical Staffing can be a challenge when you have a large team using a common language and subset of the project using a different language it is harder to move folks back and forth. 
   Best practice Coding Standards were already developed for the common project languages, adopting Java with the Fuse stack required augmenting the standards and toolsets. 
   Formal Documentation on ERAM conformed to a DID (Decentralized Identifiers) compliant specification in the Statement of Work, adopting good Java practices with tool-generated design docs required working with the customer on process changes in addition to folding the tools into our toolbox. 
    
 External Forces 
   
   The Fuse product itself was undergoing a high degree of maturation change while development was proceeding. 
   The rate of Fuse change contributed to reduction in future scope, had impacts when the system was updated to future Fuse versions. 
   JBoss Fuse major versions can change which system is supported, e.g. spring-&amp;gt;blueprint. 
    
 Maintenance Challenges in a long-life National Airspace System (NAS) Critical System 
   
   Since the original team was relatively small compared to the larger project staff, staff turnover of key positions had a greater impact on the remaining developers, and the use of common “popular industry tools” may have made it easier for some employees to find related work elsewhere. 
   As the project usage and Fuse ownership evolved, we worked updates into the system to lower the total cost of ownership to the customer. 
   Now that this area has been relatively stable for a long period and has had less “touch time” from developers, we are about to undergo a Tech Refresh and port platforms, and reconsider which (if any) of the system layers of the JBoss Fuse system will be utilized. 
   Like the Java community at large, new JBoss Fuse versions bring in new features that impact CPU and memory, even if you do not intend to use the new features. But staying current with the product is often required for security patches. 
    
 Test &amp;amp; Performance 
   
   Java Virtual Machine as a runtime engine is very different from a C++ or Ada program. Ensuring the same level of NAS reliability required updating our Testing methodology. 
   A Java Virtual Machine does garbage collection and Fuse adds a lot of extra processes to the runtime. Performance becomes harder to predict as Java Virtual Machine garbage collection is a “black box”. 
    
</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Brian</first_name>
          <last_name>Kleinke</last_name>
          <affiliation>Leidos</affiliation>
          <bio>undefined</bio>
          <person_id>briankleinke</person_id>
        </person>
      </persons>
      <tracks>
        <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5a54e04e-7e97-4d2d-8013-9762003137f1</slot_id>
      <event_id>8f8e47fe-7de5-443a-8f1d-43960d59c530</event_id>
      <title>XERIS/APEX: Hyperscaling with Ada</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/17</date>
      <start_time>10:10</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>10:35</end_time>
      <description>Using Ada to implement traditional, containerized microservices is trivial. However, doing so fails to fully harness Ada’s explicit design focus on the development of very large systems, among other strengths like concurrency and strong typing. 
XERIS/APEX ultimately seeks to implement a framework that integrates with the Ada runtime, to provide super efficient distributed computing and communication across a dynamic number of partitions and nodes, both on contemporary cloud platforms and across ad-hoc IoT networks. XERIS/APEX achieves this with a combination of a shared-memory communications layer, and an optional Ada-specific exokernel. 
There are two fundamental design considerations that constrict the communications framework. Firstly, it must be capable of supporting a full implementation of Ada’s Annex E E.5 “Partition Communication Subsystem”. Secondly, it should provide the simplest and safest possible direct interface for the implementation of custom high-performance user-defined distributed message passing models. 
The communications layer is optimized for rDMA fabrics but is largely transport agnostic. Tenancy of the larger network (the “tier horizon”) is dynamic and management is fully decentralized. On each machine (or NUMA region), the communication layer presents itself as a decentralized set of CAS queues in a shared memory region, which manage the ownership of a related set of “sectors” in the same shared memory region. Since all synchronization is via CAS queues, the system is fully lockless and does not require mediation by the kernel. Marshaling of data between regions is handled by a dedicated partition per region, which transparently uses whatever transport schemes are available for the larger tier horizon network.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Richard</first_name>
          <last_name>Wai</last_name>
          <affiliation>ANNEXI-STRAYLINE</affiliation>
          <bio>Richard Wai is the Founder and Managing Director of ANNEXI-STRAYLINE, a start-up focused on the practical application of proven High Integrity technologies to mainstream software, particularly in large-scale cloud (SaaS) and IoT applications. Richard is an evangelist for the safety and maintainability provided by the Ada language, and is a member of the ISO Ada Rapporteur Group, tasked with the ongoing development of the Ada language. 
Richard began programming at an early age, with a particular interest in building practical, user-friendly software for non-technical users. Richard spent time studying higher-level design processes, and is working to bring the craftsmanship and diligence common in other creative and technical professions to the software industry, with the goal of promoting a disciplined, mature, and maintainability-oriented approach to mainstream software engineering. Richard holds an Honors Bachelor of Architecture with Distinction from the University of Toronto.</bio>
          <homepage_url>https://annexi-strayline.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/richardwai/97548551-5c3a-47aa-99e5-62ea5edfaf76/small.jpg</picture_url>
          <person_id>richardwai</person_id>
        </person>
      </persons>
      <tracks>
        <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>667d6562-3a7d-47ba-b22b-321e7dd51449</slot_id>
      <event_id>d7ed94d8-fc6f-4462-bcf3-8a91fa45549a</event_id>
      <title>Tuesday Keynote: ZeroMQ - The world-saving superhero sockets of the networking world</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/17</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>10:00</end_time>
      <description>ZeroMQ (also known as ØMQ, 0MQ, or zmq) looks like an embeddable networking library but acts like a concurrency framework. It gives you sockets that carry atomic messages secure and reliable across various transports like in-process, inter-process, TCP, and multicast. You can connect sockets N-to-N with patterns like fan-out, pub-sub, task distribution, and request-reply. It’s fast enough to be the fabric for clustered products. Its asynchronous I/O model gives you scalable multicore applications, built as asynchronous message-processing tasks. It has a score of language APIs and runs on most operating systems. 
This keynote is going to make an introduction into the goals and basic concepts of ZeroMQ. Tell how the project came to be and explain the ways of community. Finally we’re going to showcase software built on top of ZeroMQ namely: czmq (High-level C binding), Zyre (Framework for proximity-based peer-to-peer application), Sphactor (Extended nodal actor framework based on zactor) and Dafka (Decentralized distributed streaming platform).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Arnaud</first_name>
          <last_name>Loonstra</last_name>
          <affiliation>Utrecht School of the Arts, Netherlands</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/arnaudloonstra/e346fcf7-4d00-4b15-aa3d-263b9e69e275/small.jpg</picture_url>
          <person_id>arnaudloonstra</person_id>
        </person>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>2</sort_key>
          <first_name>Kevin</first_name>
          <last_name>Sapper</last_name>
          <affiliation>codecentric AG</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/kevinsapper/dc359afa-5ded-499c-83da-7d76a8c1b7f4/small.jpg</picture_url>
          <person_id>kevinsapper</person_id>
        </person>
      </persons>
      <tracks>
        <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6ead5a47-ab84-4787-a853-4712419b2d5d</slot_id>
      <event_id>5bfbde56-10a7-4b7a-83ba-1268580dd964</event_id>
      <title>Building a Culture of Safe and Performant Systems with the Rust Programming Language</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/17</date>
      <start_time>11:35</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>12:00</end_time>
      <description>This talk focuses on how the Rust language has approached the design and implementation of safe and performant systems through two major focuses: building tools that enforce strong, fundamental guarantees; while also ensuring that the human aspect of systems design is fulfilled through robust teaching material for developers of all backgrounds, error messages that serve as a system of teaching rather than a system of reprimand, and guiding developers towards robust engineering practices by making reliable design choices straightforward (and making shortcuts ‘noisy’). 
Although the systems that are being built today are becoming more complex, from timing critical embedded systems to massively distributed cloud applications, systems are often constrained by how straightforward they are to understand by the engineers and scientists building them. Rust has succeeded by developing a language that focuses on consistent, understandable, and composable abstractions, that allow for reasoning about systems both at a macro and a micro level. While this benefits the humans building these systems, it also allows for powerful opportunities for static analysis and compile time optimizations. 
Rust has also set the standard for what it means to support the humans that are developing these systems. This approach starts from a culture of free, open source, and high quality teaching materials, from everything including the language, the compiler, the standard library, and even widely used third party libraries. The Rust compiler, while unforgiving in enforcing soundness and correctness in code constructs, counters this edge by providing literate error diagnostics, often recommending a correct fix, or a reference towards conceptual information required to understand WHY code is incorrect, instead of allowing the user to disable a correctness check. 
These core foundations, both technological as well as cultural, have set Rust on a path towards being a language of choice for systems programing for the next decades, and as a tool that empowers everyone, including those not from a traditional systems background, to building safe and performant systems at scale. 
My aim is that participants leave this workshop with a better understanding of the design choices, effort investments, and language concepts that have been applied by the Rust Programming Language, and how they can be applied to other projects, languages, or technologies.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>James</first_name>
          <last_name>Munns</last_name>
          <affiliation>Ferrous Systems</affiliation>
          <bio>James is an embedded systems engineer, with a history of working on software for a wide range of systems, including safety critical avionics, and rapidly prototyped IoT systems. James is a founding member of the Rust Embedded Working Group, as well as a founder of Ferrous Systems, a consultancy focused on systems development in Rust, with a specialty in embedded systems development. 
James is working hard to bring Rust to new places in the embedded domain, including efforts to qualify the Rust language for use in safety critical systems through the Sealed Rust initiative, and building easy to use open source tooling in the Knurling-rs project.</bio>
          <homepage_url>https://ferrous-systems.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jamesmunns/e1388ee6-bdb8-4713-af26-e40b3a96f104/small.jpg</picture_url>
          <person_id>jamesmunns</person_id>
        </person>
      </persons>
      <tracks>
        <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7ecd1b23-e601-4c89-a6dd-6686d323cde7</slot_id>
      <event_id>4424891a-7606-41f0-ae52-35f40c2e9af5</event_id>
      <title>Tuesday early coffee break</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/17</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>10:10</end_time>
      <description>HILT Clowdr Break Room</description>
      <tracks>
        <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8a96b3d0-245a-428f-a1cd-e811b45d3e07</slot_id>
      <event_id>2904f48f-1c31-4266-81f6-c2e0cb4acc67</event_id>
      <title>Productive Parallel Programming with Parsl</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/17</date>
      <start_time>11:10</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>11:35</end_time>
      <description>Parsl is a parallel programming library that aims to make it easy to specify parallelism in Python programs and to realize that parallelism on arbitrary parallel and distributed computing systems. Parsl relies on developers annotating Python functions—wrapping either Python or external applications—and linking together these functions via data exchanged between them. Parsl establishes a dynamic dependency graph and sends tasks for execution on connected resources when dependencies are resolved. Parsl’s runtime system enables different compute resources to be used, from laptops to supercomputers, without modification to the Parsl program.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kyle</first_name>
          <last_name>Chard</last_name>
          <affiliation>University of Chicago</affiliation>
          <bio>undefined</bio>
          <person_id>kylechard</person_id>
        </person>
      </persons>
      <tracks>
        <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5ed1c620-e47a-420b-8a1a-1e1367eba0fb</subevent_id>
    <title>SPLASH Closing: Cocktails in Rio</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-closing</url>
    <url_link_display>Closing</url_link_display>
    <tracks>
      <track>Closing</track>
    </tracks>
    <timeslot>
      <slot_id>b3da7777-e280-4636-99dd-627ff7be211a</slot_id>
      <title>Session: SPLASH Closing - Cocktails in Rio</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>18:20</start_time>
      <end_time>19:00</end_time>
      <tracks>
        <track>Closing</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cc83c20a-0218-4712-a36e-0475125bca5d</slot_id>
      <event_id>92603177-a865-4385-bf31-8163713f6a01</event_id>
      <title>Closing Session</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>18:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>19:00</end_time>
      <description>Thank you for attending SPLASH 2020!</description>
      <persons>
        <person>
          <role>General Chair</role>
          <sort_key>1</sort_key>
          <first_name>Hridesh</first_name>
          <last_name>Rajan</last_name>
          <affiliation>Iowa State University, USA</affiliation>
          <bio>Hridesh Rajan is a Professor and Chair of Computer Science at Iowa State University, where he has been since 2005. Professor Rajan earned his MS and Ph.D. from the University of Virginia in 2004 and 2005 respectively. Professor Rajan’s recent research and educational activities are aimed at decreasing the barrier to entry to data-driven sciences to broaden participation. His work on the Boa project is aimed at the invention and refinement of programming languages and cyberinfrastructures that democratize data-driven science &amp;amp; engineering, including software engineering. His work on the Midwest Big Data Summer School is experimenting with broadly accessible data science curricula. Professor Rajan was the founding general chair of the Midwest Big Data Summer School. Professor Rajan’s research interests also include programming language design and implementation, and software engineering. He leads two research projects: Panini, whose goals are to enable modular reasoning about concurrent programs, and Boa that was established in Summer 2012 as an end-to-end infrastructure for analyzing large-scale software repositories and other open data sets. Professor Rajan is the director of the Laboratory for Software Design at Iowa State University, director of graduate admissions and recruitment for the Department of Computer Science. He serves as the department chair of the Department of Computer Science and served as the Professor-In-Charge of the Data Science education programs at Iowa State University from 2017-2019, and chair of the information technology committee for the university from 2015-2019. Professor Rajan served on the steering committee of the Midwest Big Data Hub, a consortium of universities in the Midwest region of the United States focused on promoting data science activities. Professor Rajan is a recipient of the National Science Foundation CAREER award in 2009, LAS Award for Early Achievement in Research in 2010, a Big-12 Fellowship in 2012. He is a 2018-19 Fulbright U.S. Scholar, a distinguished member of the ACM, and a member of IEEE, and AAAS. He is also the inaugural holder of the Kingland Professorship in the Department of Computer Science.</bio>
          <homepage_url>https://hridesh.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hrideshrajan/f57a0842-20af-4fd4-b79f-5d673c2c485c/small.jpg</picture_url>
          <person_id>hrideshrajan</person_id>
        </person>
      </persons>
      <tracks>
        <track>Closing</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>28f21542-bfcb-4715-a6b5-1f9f298a71d9</subevent_id>
    <title>SPLASH PLMW: Breakfast in Paris (PLMW AMA)</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-PLMW</url>
    <url_link_display>PL Mentoring Workshop (PLMW)</url_link_display>
    <tracks>
      <track>PL Mentoring Workshop (PLMW)</track>
    </tracks>
    <timeslot>
      <slot_id>fd47df49-efcd-43a3-aaab-1d91daf74683</slot_id>
      <title>Session: SPLASH PLMW - Breakfast in Paris (PLMW AMA)</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>00:20</start_time>
      <end_time>01:00</end_time>
      <tracks>
        <track>PL Mentoring Workshop (PLMW)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ddc635b7-00a4-4656-b095-0e23a3539aaf</slot_id>
      <event_id>17cce97b-92ae-40a1-9368-bd7e69a0addf</event_id>
      <title>Ask Me Anything: Sriram Rajamani</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>01:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Sriram</first_name>
          <last_name>Rajamani</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Sriram Rajamani is Distinguished Scientist and Managing Director of Microsoft Research India. His research interests are in designing, building and analyzing computer systems in a principled manner. Over the years he has worked on various topics including Hardware and Software Verification, Type Systems, Language Design, Distributed Systems, Security and Privacy. His current research interest is in combining Program Synthesis and Machine Learning. Together with Tom Ball, he was awarded the CAV 2011 Award for “contributions to software model checking, specifically the development of the SLAM/SDV software model checker that successfully demonstrated computer-aided verification techniques on real programs.” Sriram was elected ACM Fellow in 2015 for contributions to software analysis and defect detection. Recently, Sriram has been elected Fellow of Indian National Academy of Engineering. Sriram has a PhD from UC Berkeley, MS from University of Virginia and BEng from College of Engineering, Guindy, all with specialization in Computer Science. Sriram was general chair for POPL 2015 in India, and was program Co-Chair for CAV 2005. He co-founded the Mysore Park Series, and the ISEC conference series in India. He serves on the CACM editorial board as co-chair for special regional sections, to bring computing innovations from around the world to CACM.</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/sriram/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sriramrajamani/85dbb2f3-41e7-493b-af72-d9a3338eea4e/small.jpg</picture_url>
          <person_id>sriramrajamani</person_id>
        </person>
      </persons>
      <tracks>
        <track>PL Mentoring Workshop (PLMW)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ecc5f801-3fb3-4129-8cfa-65f4bfcb2de0</subevent_id>
    <title>SPLASH Opening: Opening Session</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-opening</url>
    <url_link_display>Opening</url_link_display>
    <tracks>
      <track>Opening</track>
    </tracks>
    <timeslot>
      <slot_id>e0f57124-cf86-4a5e-b499-e1f5293a4dcb</slot_id>
      <title>Session: SPLASH Opening - Opening Session</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>07:00</start_time>
      <end_time>07:20</end_time>
      <tracks>
        <track>Opening</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>094be895-e53c-49f2-9aa0-4fc27aacf310</slot_id>
      <event_id>e341c0d1-a77b-4aa1-ae9b-83ec123e28da</event_id>
      <title>Opening Session</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>07:20</end_time>
      <description>Welcome to SPLASH 2020!</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hridesh</first_name>
          <last_name>Rajan</last_name>
          <affiliation>Iowa State University, USA</affiliation>
          <bio>Hridesh Rajan is a Professor and Chair of Computer Science at Iowa State University, where he has been since 2005. Professor Rajan earned his MS and Ph.D. from the University of Virginia in 2004 and 2005 respectively. Professor Rajan’s recent research and educational activities are aimed at decreasing the barrier to entry to data-driven sciences to broaden participation. His work on the Boa project is aimed at the invention and refinement of programming languages and cyberinfrastructures that democratize data-driven science &amp;amp; engineering, including software engineering. His work on the Midwest Big Data Summer School is experimenting with broadly accessible data science curricula. Professor Rajan was the founding general chair of the Midwest Big Data Summer School. Professor Rajan’s research interests also include programming language design and implementation, and software engineering. He leads two research projects: Panini, whose goals are to enable modular reasoning about concurrent programs, and Boa that was established in Summer 2012 as an end-to-end infrastructure for analyzing large-scale software repositories and other open data sets. Professor Rajan is the director of the Laboratory for Software Design at Iowa State University, director of graduate admissions and recruitment for the Department of Computer Science. He serves as the department chair of the Department of Computer Science and served as the Professor-In-Charge of the Data Science education programs at Iowa State University from 2017-2019, and chair of the information technology committee for the university from 2015-2019. Professor Rajan served on the steering committee of the Midwest Big Data Hub, a consortium of universities in the Midwest region of the United States focused on promoting data science activities. Professor Rajan is a recipient of the National Science Foundation CAREER award in 2009, LAS Award for Early Achievement in Research in 2010, a Big-12 Fellowship in 2012. He is a 2018-19 Fulbright U.S. Scholar, a distinguished member of the ACM, and a member of IEEE, and AAAS. He is also the inaugural holder of the Kingland Professorship in the Department of Computer Science.</bio>
          <homepage_url>https://hridesh.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hrideshrajan/f57a0842-20af-4fd4-b79f-5d673c2c485c/small.jpg</picture_url>
          <person_id>hrideshrajan</person_id>
        </person>
        <person>
          <role>OOPSLA Review Committee Chair</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Grove</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>I am a Distinguished Research Staff Member at the IBM T.J. Watson Research Center. I joined IBM Research in 1998 after completing my PhD at the University of Washington. I am a software systems researcher, working primarily on problems in programming language implementation and scalable runtime systems. 
I have contributed to a number of technical topics in programming language design and implementation including the analysis and optimization of object-oriented languages, virtual machine design and implementation, scalable runtime systems, Just-In-Time compilation, online feedback-directed optimization, and garbage collection.</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-groved</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidgrove/5524049e-7d0a-4799-ad8c-93e1e76a77ec/small.jpg</picture_url>
          <person_id>davidgrove</person_id>
        </person>
        <person>
          <role>ECOOP General Chair</role>
          <sort_key>3</sort_key>
          <first_name>Christian</first_name>
          <last_name>Hammer</last_name>
          <affiliation>University of Potsdam</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.uni-potsdam.de/se/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/christianhammer/7569da38-ffbb-4f7c-b613-c7d6aade9ffe/small.jpg</picture_url>
          <person_id>christianhammer</person_id>
        </person>
        <person>
          <role>ECOOP PC Chair</role>
          <sort_key>4</sort_key>
          <first_name>Robert</first_name>
          <last_name>Hirschfeld</last_name>
          <affiliation>Hasso-Plattner-Institut (HPI), Germany</affiliation>
          <bio>Robert Hirschfeld is a Professor of Computer Science at the Hasso Plattner Institute at the University of Potsdam, Germany. There he founded and leads the Software Architecture Group which is concerned with fundamental elements and structures of software. Methods and tools are developed for improving the comprehension and design of complex and interesting systems. 
Robert is interested in programming experiences and small system kernels. With his group he is working on dynamic programming languages, development tools, and runtime environments to make interactive programming more approachable. His preferred environment for exploring ideas is Squeak/Smalltalk. 
He served as a visiting professor at the Tokyo Institute of Technology (東京工業大学) and The University of Tokyo (東京大学), Japan. 
Robert was a senior researcher with DoCoMo Euro-Labs, the European research facility of NTT DoCoMo Japan, where he worked on infrastructure components for next generation mobile communication systems with a focus on dynamic service adaptation and context-oriented programming. 
Prior to joining DoCoMo Euro-Labs, he was a principal engineer at Windward Solutions in Sunnyvale, California, where he designed and implemented distributed object systems, consulted in the area of object database technologies, and developed innovative software products and applications. 
Robert received a Ph.D. in Computer Science from the Ilmenau University of Technology, Germany.</bio>
          <homepage_url>http://www.hirschfeld.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/roberthirschfeld/994ef4df-a890-4f16-bc1b-73b117dab33c/small.jpg</picture_url>
          <person_id>roberthirschfeld</person_id>
        </person>
        <person>
          <role>ECOOP 2021 General Chair</role>
          <sort_key>5</sort_key>
          <first_name>Anders</first_name>
          <last_name>Møller</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
          <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
          <person_id>andersmoller</person_id>
        </person>
      </persons>
      <tracks>
        <track>Opening</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4f01ad42-8c1d-4085-9af5-1e9c023e423f</subevent_id>
    <title>SPLASH Awards: Breakfast in Chicago</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-awards</url>
    <url_link_display>Awards</url_link_display>
    <tracks>
      <track>Awards</track>
    </tracks>
    <timeslot>
      <slot_id>9dd152e8-694a-4a4d-9f30-286d8606a6b6</slot_id>
      <title>Session: SPLASH Awards - Breakfast in Chicago</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>08:20</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>Awards</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2e95fb9c-7b37-433c-b8f4-4f324d5e9cdc</slot_id>
      <event_id>c0fd419e-0940-4fad-8e84-7f72a9339b79</event_id>
      <title>Awards Session</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>09:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Grove</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>I am a Distinguished Research Staff Member at the IBM T.J. Watson Research Center. I joined IBM Research in 1998 after completing my PhD at the University of Washington. I am a software systems researcher, working primarily on problems in programming language implementation and scalable runtime systems. 
I have contributed to a number of technical topics in programming language design and implementation including the analysis and optimization of object-oriented languages, virtual machine design and implementation, scalable runtime systems, Just-In-Time compilation, online feedback-directed optimization, and garbage collection.</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-groved</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidgrove/5524049e-7d0a-4799-ad8c-93e1e76a77ec/small.jpg</picture_url>
          <person_id>davidgrove</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Jens</first_name>
          <last_name>Palsberg</last_name>
          <affiliation>University of California, Los Angeles</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ucla.edu/~palsberg</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jenspalsberg/9e470c6a-532d-472c-9fea-253b7fa22c7c/small.jpg</picture_url>
          <person_id>jenspalsberg</person_id>
        </person>
      </persons>
      <tracks>
        <track>Awards</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9ac42f36-aade-4a6a-8c93-4865686779ce</subevent_id>
    <title>HILT: HILT workshop Monday sessions</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-V</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/home/hilt-2020</url>
    <url_link_display>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</url_link_display>
    <tracks>
      <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
    </tracks>
    <timeslot>
      <slot_id>fd6303d2-0f59-4698-acf8-41a3a8c69b08</slot_id>
      <title>Session: HILT - HILT workshop Monday sessions</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/16</date>
      <start_time>09:00</start_time>
      <end_time>13:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Luis Miguel</first_name>
          <last_name>Pinho</last_name>
          <affiliation>ISEP P.PORTO</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cister.isep.ipp.pt/people/luis_miguel_pinho/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/luismiguelpinho/070a3fcf-ac81-43e8-9cbc-52f6fc217074/small.jpg</picture_url>
          <person_id>luismiguelpinho</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Tucker</first_name>
          <last_name>Taft</last_name>
          <affiliation>AdaCore, United States</affiliation>
          <bio> 
 Harvard College 1971-1975, AB Summa Cum Laude Chemistry 
 Harvard Radcliffe Student Computing Center 1975-1979, Systems Programmer 
 Intermetrics/AverStar/AverCom 1980-2002, Chief Scientist 
 SofCheck 2002-2011, Founder and CTO 
 AdaCore 2011-present, VP, Director of Language Research, Model-Based Toolset Product Architect 
</bio>
          <homepage_url>http://www.adacore.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tuckertaft/a31e3438-c202-49b1-95e4-3da5adac47be/small.jpg</picture_url>
          <person_id>tuckertaft</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>3</sort_key>
          <first_name>Richard</first_name>
          <last_name>Wai</last_name>
          <affiliation>ANNEXI-STRAYLINE</affiliation>
          <bio>Richard Wai is the Founder and Managing Director of ANNEXI-STRAYLINE, a start-up focused on the practical application of proven High Integrity technologies to mainstream software, particularly in large-scale cloud (SaaS) and IoT applications. Richard is an evangelist for the safety and maintainability provided by the Ada language, and is a member of the ISO Ada Rapporteur Group, tasked with the ongoing development of the Ada language. 
Richard began programming at an early age, with a particular interest in building practical, user-friendly software for non-technical users. Richard spent time studying higher-level design processes, and is working to bring the craftsmanship and diligence common in other creative and technical professions to the software industry, with the goal of promoting a disciplined, mature, and maintainability-oriented approach to mainstream software engineering. Richard holds an Honors Bachelor of Architecture with Distinction from the University of Toronto.</bio>
          <homepage_url>https://annexi-strayline.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/richardwai/97548551-5c3a-47aa-99e5-62ea5edfaf76/small.jpg</picture_url>
          <person_id>richardwai</person_id>
        </person>
      </persons>
      <tracks>
        <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2c4d2067-a305-4299-b285-0695c7bc53da</slot_id>
      <event_id>e80d97bc-110a-488c-8de1-79ab61fe021e</event_id>
      <title>A Layered Mapping of Ada 202X to OpenMP</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/16</date>
      <start_time>10:15</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>10:45</end_time>
      <description>The OpenMP specification defines a set of compiler directives, library routines, and environment variables that together represent the OpenMP Application Programming Interface, and is currently defined for C, C++, and Fortran. The forthcoming version of Ada, currently dubbed Ada 202X, includes lightweight parallelism features, in particular parallel blocks and parallel loops. All versions of Ada, since its inception in 1983, have included “tasking,” which corresponds to what are traditionally considered “heavyweight” parallelism features, or simply “concurrency” features. Ada “tasks” typically map to what are called “kernel threads,” in that the operating system manages them and schedules them. However, one of the goals of lightweight parallelism is to reduce overhead by doing more of the management outside the kernel of the operating system, using a light-weight-thread (LWT) scheduler. The OpenMP library routines support both levels of threading, but for Ada 202X, the main interest is in making use of OpenMP for its lightweight thread scheduling capabilities. 
Given the above, for Ada 202X we are recommending a layered mapping to OpenMP (or other LWT scheduler), where upon seeing the syntax for a parallel construct, the compiler generates calls on a top layer which is independent of the particular LWT scheduler that will be controlling the light-weight threads. Below this layer would be an LWT-scheduler-independent API, which implements the API using a “plug-in” architecture. Specific LWT schedulers could be “plugged in” to this API implementation, and handle the various calls through the API. In the absence of any plugin, the API implementation would fall back to a purely sequential implementation. 
This talk will present this layered approach,which should allow Ada 202X users to take advantage of the OpenMP features of interest, and to accommodate evolution of the OpenMP standard as well as the ability to use other LWT schedulers which might come from, say, an RTOS vendor. We believe this layered approach might be a model for other languages that want to provide a binding to OpenMP capabilities, while not requiring heavy use of compiler directives as is done in current mappings to C and Fortran, which can hurt readability and do not tend to be as composable as syntax.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tucker</first_name>
          <last_name>Taft</last_name>
          <affiliation>AdaCore, United States</affiliation>
          <bio> 
 Harvard College 1971-1975, AB Summa Cum Laude Chemistry 
 Harvard Radcliffe Student Computing Center 1975-1979, Systems Programmer 
 Intermetrics/AverStar/AverCom 1980-2002, Chief Scientist 
 SofCheck 2002-2011, Founder and CTO 
 AdaCore 2011-present, VP, Director of Language Research, Model-Based Toolset Product Architect 
</bio>
          <homepage_url>http://www.adacore.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tuckertaft/a31e3438-c202-49b1-95e4-3da5adac47be/small.jpg</picture_url>
          <person_id>tuckertaft</person_id>
        </person>
      </persons>
      <tracks>
        <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3104daab-37bd-482a-8710-4d89aede370f</slot_id>
      <event_id>2c656f1e-59d0-4f2f-8aa0-25e5afc82011</event_id>
      <title>Monday Panel: OpenMP for High Integrity systems: Moving responsibility from users to vendors</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/16</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>13:00</end_time>
      <description>Introduction OpenMP is traditionally focused on boosting performance in HPC systems. However, other domains are showing an increasing interest on the use of OpenMP by virtue of key aspects introduced in recent versions of the specification: the tasking model, the accelerator model and other features like the requires, metadirective and declare variant directives, that allow forcing specific requirements and behaviors at execution time. One such domain is the safety-critical embedded domain, where several works have been presented towards the adoption of OpenMP. However, there is still a deep gap to be filled: as stated in the OpenMP specification “application developers are responsible for correctly using the OpenMP API to produce a conforming program”. This is not acceptable in high integrity systems, where aspects such as reliability and resiliency have to be ensured at different levels of criticality. For this reason, there is a need for moving the responsibility of producing correct OpenMP programs from users to vendors. This requires all specifications, and compiler and runtime implementations, to include the features needed to ensure safety, among other non-functional requirements. The panelists are technical leaders in the diverse domains involved in the topic of the panel: 
 
  Dirk Ziegenbein is a chief expert for engineering of cyber-physical systems at Bosch Corporate Research. Dirk has a deep background on modelling and design for embedded systems, and works developing methods and technologies for software systems engineering. He provides a key perspective on the needs of the industry regarding safety, and the challenges introduced by the inevitable use of parallel computing in automotive. In this sense, he reflects an interest on the modelling of the parallel system, rather than on the parallel programming model itself, so the particular inter-platform API (e.g., OpenCL, OpenMP, etc.) used to exploit parallelism is relevant, at this level, (1) to match the execution model designed at high-level, and (2) to preserve the non-functional requirements of the system.  
  Michael Klemm is the CEO of the OpenMP Architecture Review Board, organization in which he has been involved, among many others, in the development error handling features. His interests include compiler construction and design of programming languages, and his work is focused on High Performance and Throughput Computing. He provides a crucial point of view regarding the maturity of parallel APIs like OpenMP, and the fate of OpenMP to exploit safety-critical systems. Michael endorses the OpenMP community perspective, which targets mainly performance. This means that new features introduced in the specification (and ideally in the implementations) should not harm performance, and have to be compatible with the rest of the platform. He also provides a key knowledge on how new features targeting high-integrity systems could be included in OpenMP, and what is the willingness of current vendors to implement such kind of new features.  
  Tucker Taft is VP and Director of Language Research at AdaCore. Tucker has lead the design of Ada95 in the past, and has strong knowledge on compiler construction, static analysis and programming language design. His experience with high-integrity systems and languages contributes with a key perspective on how to effectively provide parallel APIs with the safety requirements of critical systems. Tucker represents a vendor point of view from the high-integrity domain angle, and so stands by vendors covering any aspects that are not necessarily a responsibility of the user. This idea can have an impact on the specification of APIs like OpenMP, as some features (e.g., data scoping, tasks dependencies, etc.) might not need to be controlled by the user any more, but by the compiler and the runtime instead. His expertise in language design, together with that of Dr. Klemm, set the scene for an interesting conversation about the future of parallel programming models and frameworks.  
  Eduardo Quiñones is the leader of the Predictable Parallel Computing group at the Barcelona Supercomputing Center. His research involves the next generation industry requirements for critical real-time systems spanning highly parallel heterogeneous architectures, parallel programming models and compiler design. He’s knowledge on both safety and performance sides makes Eduardo an excellent facilitator for all the parties involved in the development of high-integrity and high-performance systems. Given the obvious gap between design models and parallel programming models, his position is crucial to ensure the modifications in Cyber-Physical Systems and parallel programming models suit all parties. Additionally, his research activities provide an interesting opportunity to verify that the requirements are passed from design to implementation effectively before vendors have to implement new specifications.  
</description>
      <persons>
        <person>
          <role>Panel Moderator</role>
          <sort_key>1</sort_key>
          <first_name>Sara</first_name>
          <last_name>Royuela</last_name>
          <affiliation>Barcelona Supercomputing Center</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/sararoyuela/efef497b-1849-49d9-9a2d-eac049bd9cbe/small.jpg</picture_url>
          <person_id>sararoyuela</person_id>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Klemm</last_name>
          <affiliation>OpenMP ARB</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.openmp.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelklemm/c4015ceb-9d95-4416-8119-0b52f3427942/small.jpg</picture_url>
          <person_id>michaelklemm</person_id>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>3</sort_key>
          <first_name>Eduardo</first_name>
          <last_name>Quiñones</last_name>
          <affiliation>Barcelona Supercomputing Center (BSC)</affiliation>
          <bio>undefined</bio>
          <person_id>eduardoquinones</person_id>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>4</sort_key>
          <first_name>Tucker</first_name>
          <last_name>Taft</last_name>
          <affiliation>AdaCore, United States</affiliation>
          <bio> 
 Harvard College 1971-1975, AB Summa Cum Laude Chemistry 
 Harvard Radcliffe Student Computing Center 1975-1979, Systems Programmer 
 Intermetrics/AverStar/AverCom 1980-2002, Chief Scientist 
 SofCheck 2002-2011, Founder and CTO 
 AdaCore 2011-present, VP, Director of Language Research, Model-Based Toolset Product Architect 
</bio>
          <homepage_url>http://www.adacore.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tuckertaft/a31e3438-c202-49b1-95e4-3da5adac47be/small.jpg</picture_url>
          <person_id>tuckertaft</person_id>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>5</sort_key>
          <first_name>Dirk</first_name>
          <last_name>Ziegenbein</last_name>
          <affiliation>Robert Bosch GmbH</affiliation>
          <bio>undefined</bio>
          <person_id>dirkziegenbein</person_id>
        </person>
      </persons>
      <tracks>
        <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>473874fc-2b4d-40e0-b0f5-8d944fa5c8d1</slot_id>
      <event_id>741eaacd-9a71-4725-85b4-670c7d03bc04</event_id>
      <title>Parallel Multiple Double Precision to Solve Polynomial Systems</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/16</date>
      <start_time>10:45</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:15</end_time>
      <description>Hardware double precision is often insufficient to solve large scientific problems accurately. Computing with software defined extended precision can cause significant computational overhead. The application of parallel algorithms compensates for this overhead.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jan</first_name>
          <last_name>Verschelde</last_name>
          <affiliation>University of Illinois at Chicago</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.math.uic.edu/~jan</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janverschelde/d4b8f61c-aca0-4388-a3fd-147f7a5a7039/small.jpg</picture_url>
          <person_id>janverschelde</person_id>
        </person>
      </persons>
      <tracks>
        <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6f8bb7ba-1cc1-4eed-be73-4d85c27bc08e</slot_id>
      <event_id>bab96d5a-6b1f-4a01-ae60-be35808965f1</event_id>
      <title>Monday Keynote: What's new with the OpenMP API Version 5.1</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/16</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>10:00</end_time>
      <description>The OpenMP API is the parallel programming language for on-node parallelism using multi-threading and heterogeneous programming, e.g., for GPUs. In this talk, we will highlight the key additions that have been made for the OpenMP API specification 5.1 and how they improve key features of the previous OpenMP API specification versions 4.5 and 5.0.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Klemm</last_name>
          <affiliation>OpenMP ARB</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.openmp.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelklemm/c4015ceb-9d95-4416-8119-0b52f3427942/small.jpg</picture_url>
          <person_id>michaelklemm</person_id>
        </person>
      </persons>
      <tracks>
        <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8168a0cd-3ed5-407d-8a1e-1d903e825a08</slot_id>
      <event_id>16f49fb0-06e6-4bdb-9e9e-6a3e7ed41db2</event_id>
      <title>Monday early coffee break</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/16</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>10:15</end_time>
      <description>HILT Clowdr Break Room</description>
      <tracks>
        <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d6538222-b609-4872-a236-5c3ac4041038</slot_id>
      <event_id>66be6851-ed13-4db1-9daf-83c747691730</event_id>
      <title>Monday later coffee break</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/16</date>
      <start_time>11:15</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:30</end_time>
      <description>HILT Clowdr Break Room</description>
      <tracks>
        <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f9e6bd80-456e-4d69-a573-a637ce316dd8</slot_id>
      <event_id>a9ab0d65-7fe1-43dc-9823-96433f2f81d0</event_id>
      <title>Using the Tapir Compiler Intermediate Representation to Support Efficient Parallel Languages</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/16</date>
      <start_time>11:30</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>12:00</end_time>
      <description>This presentation gives an overview of Tapir, which embeds recursive fork-join parallelism, as supported by task-parallel programming platforms such as Cilk and OpenMP, into a mainstream compiler’s IR. Mainstream compilers typically treat parallel linguistic constructs as syntactic sugar for function calls into a parallel runtime. These calls prevent the compiler from performing optimizations on and across parallel control constructs. Remedying this situation has generally been thought to require an extensive reworking of compiler analyses and code transformations to handle parallel semantics. Tapir enables effective compiler optimization of recursive fork-join programs with only minor changes to existing compiler analyses and code transformations. 
Tapir leverages the “serial-projection property,” which is commonly satisfied by recursive fork-join programs, to handle the semantics of these programs without an extensive rework of the compiler. Tapir uses the serial-projection property to order logically parallel fine-grained tasks in the program’s control-flow graph. This ordered representation of parallel tasks allows the compiler to optimize parallel codes effectively with only minor modifications. For example, to implement Tapir/LLVM, a prototype of Tapir in the LLVM compiler, we added or modified less than 300030003000 lines of the half-million-line core middle-end functionality in LLVM version~6. 
These changes suffice to enable LLVM’s existing compiler optimizations for serial code — including loop-invariant-code motion, common-subexpression elimination, and tail-recursion elimination — to work with parallel control constructs such as parallel loops and Cilk’s cilk_spawn keyword. By making use of existing LLVM optimizations and new parallel optimizations, Tapir/LLVM can optimize recursive fork-join programs more effectively than traditional compilation methods. On a suite of 353535 Cilk application benchmarks, Tapir/LLVM produces more efficient executables for 303030 benchmarks, with faster 181818-core running times for 262626 of them, compared to a nearly identical compiler that compiles parallel linguistic constructs the traditional way. In addition, by integrating Tapir/LLVM into the Accelerated Linear Algebra (XLA) compiler in Google’s TensorFlow machine-learning framework, Tapir/LLVM enables more effective compiler optimization of a variety of neural networks written in TensorFlow, improving the parallel performance of these networks by a geometric-mean multiplicative factor of 30%–-100% across a variety of CPU hardware architectures. 
This presentation will overview how Tapir supports compiler optimization of recursive fork-join programs. The talk will examine Tapir and how it enables compiler optimization of parallel programs using existing compiler optimizations for serial code and new parallel optimizations, such as loop scheduling and loop stripmining, that restructure the parallel control flow of the program. The talk will describe how Tapir enables efficient and effective debugging of compiler optimizations for parallel programs. The talk will discuss some theoretical foundations for compiler optimizations based on Tapir.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>TB</first_name>
          <last_name>Schardl</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>undefined</bio>
          <person_id>tbschardl</person_id>
        </person>
      </persons>
      <tracks>
        <track>HILT 2020 Workshop on Safe Languages and Technologies for Structured and Efficient Parallel and Distributed/Cloud Computing.</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>37aa4d5f-b391-4a54-8516-78288c6660db</subevent_id>
    <title>SPLASH CARES: CARES</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-cares</url>
    <url_link_display>CARES</url_link_display>
    <tracks>
      <track>CARES</track>
    </tracks>
    <timeslot>
      <slot_id>7b3eb383-55b7-4219-87a8-86a8aa84a883</slot_id>
      <title>Session: SPLASH CARES - CARES</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>07:40</start_time>
      <end_time>08:20</end_time>
      <tracks>
        <track>CARES</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a1306d10-f5a6-4121-af88-6362911d880c</slot_id>
      <event_id>0cbcc236-94a2-4e98-ba56-8caba12a4fe1</event_id>
      <title>CARES Session</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>07:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>08:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>CARES</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>aa856e66-ab45-467f-985f-db44466251f8</subevent_id>
    <title>SPLASH CARES: CARES</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-cares</url>
    <url_link_display>CARES</url_link_display>
    <tracks>
      <track>CARES</track>
    </tracks>
    <timeslot>
      <slot_id>6aec9d7b-4b7f-4422-81e5-f81f46ef83b5</slot_id>
      <title>Session: SPLASH CARES - CARES</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>17:40</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>CARES</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8315a7ff-4907-48d1-885b-6f465dace393</slot_id>
      <event_id>16711022-670f-4545-8452-b2a55fb6a9bd</event_id>
      <title>CARES Session</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>17:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>18:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>CARES</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>757937d4-1231-4747-ba43-971cdd7bac10</subevent_id>
    <title>LIVE: Keynote &amp; Short Talks</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-VI</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/home/live-2020</url>
    <url_link_display>LIVE 2020</url_link_display>
    <tracks>
      <track>LIVE 2020</track>
    </tracks>
    <timeslot>
      <slot_id>26f3400c-48b2-4f94-95bf-81628809079a</slot_id>
      <title>Session: LIVE - Keynote &amp; Short Talks</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/17</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>LIVE 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>44d5f279-0dcf-4acd-982c-825ac1f5b77a</slot_id>
      <event_id>6a4ef11e-0cb4-45d1-bd7c-3a2af4613d0f</event_id>
      <title>Toward a Multi-Language and Multi-Environment Framework for Live Programming</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/17</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>10:10</end_time>
      <description>While applications of live programming are expanding to more practical and professional domains, most live programming environments (LPEs) are still developed for a single target language with an original code editor. We propose an implementation framework for developing LPEs so that we can minimize efforts on implementing an LPE for a different target language and for an existing code editor/IDE. Our idea is to use a meta-JIT language implementation framework (e.g., Graal/Truffle and RPython) and the Language Server Protocol (LSP) to separate core live programming implementations from language specific and editor/IDE specific implementations. This paper takes the Kanon live programming environment as a concrete example, and discusses how we can design the framework to accommodate the features of Kanon. Although the framework design is still underway, the paper presents a sketch of the framework APIs for separating language specific functions, and clarifies the requirements to LSP.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hidehiko</first_name>
          <last_name>Masuhara</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>Hidehiko Masuhara is a Professor of Mathematical and Computing Science, Tokyo Institute of Technology since April 2013. He received his B.S., M.S., and Ph.D. in Computer Science from Department of Information Science, University of Tokyo in 1992, 1994, and 1999, respectively, and served as an assistant professor, lecturer, and associate professor at Graphics and Computer Science, Graduate School of Arts and Sciences, University of Tokyo from 1995 until 2013.</bio>
          <homepage_url>http://prg.is.titech.ac.jp/people/masuhara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hidehikomasuhara/3ea94269-6fb5-4c6d-8d6f-0435717377d6/small.jpg</picture_url>
          <person_id>hidehikomasuhara</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shusuke</first_name>
          <last_name>Takahashi</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>shusuketakahashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yusuke</first_name>
          <last_name>Izawa</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://3tty0n.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yusukeizawa/2d1131a1-4abb-4ade-9761-e3d2648bd9f5/small.jpg</picture_url>
          <person_id>yusukeizawa</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Youyou</first_name>
          <last_name>Cong</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://prg.is.titech.ac.jp/people/cong/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/youyoucong/55f54fd9-cac5-44ae-93c1-921409269efc/small.jpg</picture_url>
          <person_id>youyoucong</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>834f2fc8-527e-410f-9b06-d93e9c033fe3</slot_id>
      <event_id>5ab87729-cc8b-42ec-b097-c49039acc202</event_id>
      <title>Liveliness, Reactivity, and Interactivity in the Future of Notebook Programming</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/17</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>10:00</end_time>
      <description>Notebook Programming, typified by platforms like Jupyter Notebooks, Observable, or Google Colab, is a popular—and still rapidly evolving—programming paradigm today with the dream of a fast interactive programming workflow at its core. In this talk we’ll take a look at a spectrum of ideas from different systems on what future notebooks should and could be. I’ll share some of our own recent work, mage, which extends the possibilities of live programming in notebooks from parameter tuning widgets to direct manipulation of full complex GUI tools that produce code in-situ.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Mary Beth</first_name>
          <last_name>Kery</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/marybethkery/ff58abfe-4522-49ed-a179-654f4ec7a6c9/small.jpg</picture_url>
          <person_id>marybethkery</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ca4bac9b-6f45-4084-b169-631228f0970b</slot_id>
      <event_id>0a56b175-b72f-45fb-a568-1c0e4a8d197a</event_id>
      <title>Toward Providing Live Feedback in Web Automation IDEs</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/17</date>
      <start_time>10:10</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>10:20</end_time>
      <description>Web automation can help users save time and energy by automatically performing tedious web tasks for them. However, macro scripts can be difficult for users to understand and edit, whether they are a colleague viewing the macro for the first time, or the macro creator trying to edit their macro months after it was first created. A major barrier to understanding macro scripts is that they lack user interface (UI) context. Users cannot look at a macro script and understand exactly what UI elements are being interacted with and what effect commands have on the UI. To explore how we might expand macro representations to include visual context, we built VizMac, a tool that lets users record their actions on a web page to generate a macro script and see their recording as an animation. Users can inspect the animation to see the UI state before and after a given line of code is run, and can see the UI elements corresponding to UI selectors in the code visually highlighted. These features help provide an understanding of the code that has been generated. Through a user study we saw that participants appreciated the animation features, but often still struggled to identify the source of errors when they occurred. We believe providing live feedback of the script’s outcome will help users identify the source of errors more efficiently and effectively, and we present several design goals and challenges.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rebecca</first_name>
          <last_name>Krosnick</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-personal.umich.edu/~rkros/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rebeccakrosnick/7a7844b0-4e3e-4741-8e18-e2ec53e9b5de/small.jpg</picture_url>
          <person_id>rebeccakrosnick</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Oney</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://from.so</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stephenoney/50337dd4-e50f-4ae1-bd53-e240734c4619/small.jpg</picture_url>
          <person_id>stephenoney</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>790bcc4c-c015-42e6-aeee-5c0a0f8bee56</subevent_id>
    <title>NSAD: Invited Talk</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/home/nsad-2020</url>
    <url_link_display>NSAD 2020</url_link_display>
    <tracks>
      <track>NSAD 2020</track>
    </tracks>
    <timeslot>
      <slot_id>0518720b-5aab-4f52-a9ea-1430b6fa011b</slot_id>
      <title>Session: NSAD - Invited Talk</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/17</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Khalil</first_name>
          <last_name>Ghorbal</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>I am currently a researcher at Inria (Rennes, France), in the Hycomes group. My research interests orbit the following topics: 
 
 Algebraic methods for generating invariant sets 
 Certified numerical computations 
 Quantifier elimination in finite and real closed fields 
 Combinatorial optimization 
 
I was previously a postdoc at Carnegie Mellon University (Pittsburgh, PA, USA), School of Computer Science, Logical Systems Lab and before that at NEC Labs America, System Analysis and Verification Group (Princeton, NJ, USA).</bio>
          <homepage_url>http://khalilghorbal.info</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/khalilghorbal/a714313f-dcce-4d9c-bfdb-5fa9aba21096/small.jpg</picture_url>
          <person_id>khalilghorbal</person_id>
        </person>
      </persons>
      <tracks>
        <track>NSAD 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>88722093-b9ea-46c8-a2d7-9c66822aefad</slot_id>
      <event_id>3ae5d40c-d2bb-48af-8935-cb521916f41f</event_id>
      <title>Invited Talk: Abstract Domains in SMT Solving for Real Algebra</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/17</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>02:20</end_time>
      <description>Existentially quantified real-algebraic formulas are Boolean combinations of constraints that compare polynomials with real-valued variables to zero. As shown by Tarski in the late 40s, real algebra allows quantifier elimination. This result implies that checking the truth of real algebraic formulas is a decidable problem, but unfortunately it is computationally hard. SMT solving attacks this problem with practically effective heuristics, separating the analysis of the Boolean structure of the formula and the consistency of the involved theory constraints. 
Thus the SMT search is done by the cooperation of a SAT solver, analysing the Boolean skeleton, and a theory solver, checking the consistency of sets of theory atoms. For real-algebraic theory solvers, besides incomplete decision procedures like linearisation, interval constraint propagation, subtropical satisfiability or virtual substitution, the only complete decision procedure in use is the cylindrical algebraic decomposition (CAD) method discovered by Collins in the mid 70s which has been integrated in SMT solving. 
The CAD method decomposes the state space into a finite set of disjoint regions named cells, which are arranged cylindrically in a stack-like fashion, and which have the property that all input polynomials are sign-invariant inside each of the cells. Therefore, it is sufficient to test an arbitrary point from each cell in order to determine the truth of the formula. The cells, whose shapes depend on the input polynomials and some other components used in the CAD method, build a central abstract domain for CAD. 
In this invited talk we shortly introduce SMT solving and discuss relevant abstract domains for the theory of real algebra. We will put a special focus on the CAD and its cells, and illustrate how a modified abstract domain view can improve the quality of quantifier elimination.</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Erika</first_name>
          <last_name>Abraham</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio> 
  2013-today: Full professor, RWTH Aachen University, Germany. Head of the research group Theory of Hybrid Systems. Research topics: SMT solving, formal methods for probabilistic and hybrid systems.  
  2008-2013: Junior professor, RWTH Aachen University, Germany. Head of the junior research group Theory of Hybrid Systems. Research topics: SMT solving, formal methods for probabilistic and hybrid systems.  
  2007-2008: Postdoctoral researcher, Jülich Research Centre, Germany. Research topics: parallel and high-performance computing, performance analysis.  
  2005-2007: Postdoctoral researcher, Albert-Ludwigs-University Freiburg, Germany. Research topics: Verification of hybrid systems, bounded model checking, SAT and SMT solving.  
  1999-2005: Ph.D. student, Christian-Albrechts-University Kiel, Germany. Research topics: Deductive proof systems for multithreaded object-oriented languages.  
</bio>
          <homepage_url>http://ths.rwth-aachen.de/people/erika-abraham/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/erikaabraham/24df4f80-87f3-44d7-8a64-b57a03770233/small.jpg</picture_url>
          <person_id>erikaabraham</person_id>
        </person>
      </persons>
      <tracks>
        <track>NSAD 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>afc35c23-c634-4977-831d-a0cc7eb24448</subevent_id>
    <title>LIVE: Full Talks II</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-VI</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/home/live-2020</url>
    <url_link_display>LIVE 2020</url_link_display>
    <tracks>
      <track>LIVE 2020</track>
    </tracks>
    <timeslot>
      <slot_id>a1ea50f7-a7de-48b7-b1db-1c62170df7e0</slot_id>
      <title>Session: LIVE - Full Talks II</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/17</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <tracks>
        <track>LIVE 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>17ed3564-a835-4cd8-8323-5510074ed7e2</slot_id>
      <event_id>1bbd487d-79ef-497e-9ee6-6287013cf660</event_id>
      <title>Sketchable Interaction - End-User Customization via Interactive Regions</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/17</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:20</end_time>
      <description>Sketchable Interaction (SI) is a concept for a generic graphical environment that facilitates end-user customization of user interfaces and visual programming. Within an SI context, all graphical objects, including canvas, icons, and the mouse pointer, are interactive regions with arbitrary shapes. Users can draw further interactive regions with their mouse cursor, fingers or stylus, creating a sketch of a user interface. All interactive regions may contain effects which are applied to other regions once those overlap or touch. These effects can modify data, graphical representation, or both, of other regions. For example, a “Delete” region will delete all documents that are dragged onto it. Additionally, regions have properties such as position, scale, or color which can be linked to arbitrary properties of other region effects. For example, while dragging a region, the position of that region is temporarily linked to the position of the cursor’s region. These two principles allow users to iteratively construct user interfaces for a variety of different tasks, such as document management, data processing, or window management. Sketchable Interaction can also function as a visual programming language via special conveyor belt regions which transport other regions (e.g. documents) along their path. While in transit, these regions can pass through other regions which apply their effects to the document. Conveyor belts can also be used as conditional branches, allowing for simple application logic to be implemented via SI concepts. A C++ runtime handles collision and linking. All interactive regions and their behaviors are implemented via Python plugins. 
We have completed a robust implementation of the runtime and are currently exploring novel application supported by combinations of simple tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jürgen</first_name>
          <last_name>Hahn</last_name>
          <affiliation>University of Regensburg</affiliation>
          <bio>undefined</bio>
          <person_id>jurgenhahn</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Raphael</first_name>
          <last_name>Wimmer</last_name>
          <affiliation>University of Regensburg</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://hci.ur.de/people/raphael_wimmer</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/raphaelwimmer/37f180ac-99d7-44b9-82ad-f75885dac742/small.jpg</picture_url>
          <person_id>raphaelwimmer</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3a296272-c3bb-472e-8606-42aef01e7016</slot_id>
      <event_id>43de802a-b0c4-4a6a-9826-77a0347bbd6a</event_id>
      <title>Data Theater: A Live Programming Environment for Prototyping Data-Driven Explorable Explanations</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/17</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:40</end_time>
      <description>Explorable explanations (a.k.a. ‘explorables’) enable readers to learn concepts in domains such as math, physics, and the social sciences by interacting with live visualizations. Despite their popularity, there is currently a high barrier to creating explorables since one must be adept at UI and visualization programming. To learn about these challenges, we interviewed 6 educators who were interested in explorables but lacked the skills to create them from scratch. These interviews gave us design insights to lower some of these implementation barriers. We used these insights to create a live programming system called Data Theater that enables programmers to prototype explorables by writing their simulation logic in Python and mapping Python values to visualization elements using a declarative JSON grammar. To demonstrate the capabilities of Data Theater, we used it to recreate two of Bret Victor’s original physics simulation explorables and found that our approach can lower the barriers to prototyping explorables.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sam</first_name>
          <last_name>Lau</last_name>
          <affiliation>University of California San Diego</affiliation>
          <bio>I am Sam Lau, a Ph.D. student advised by Philip Guo in the Cognitive Science department at UC San Diego. I study human-computer interaction (HCI), where I prototype new software for programming, statistics, and data science instructors to prepare their lessons.</bio>
          <homepage_url>https://www.samlau.me/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/samlau/e756bf1b-7a1b-4d2e-8463-367411f4624f/small.jpg</picture_url>
          <person_id>samlau</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Philip</first_name>
          <last_name>Guo</last_name>
          <affiliation>University of California San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pgbovine.net</homepage_url>
          <person_id>philipguo1</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a7b92f02-f326-4aff-bf44-4784214c6fb4</slot_id>
      <event_id>cd2db9c3-0885-45ad-ae62-315ec4951063</event_id>
      <title>Wrap-up Discussion and Feedback</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/17</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>14:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>LIVE 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f13aae83-4601-4bf1-a7f6-f7dcc6773c98</slot_id>
      <event_id>1bd277ce-0336-4d87-a0ea-f1daae9ee4f9</event_id>
      <title>ManipML: Towards Bimodal Tangible Functional Programming</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/17</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>14:00</end_time>
      <description>Can live programming be augmented with direct manipulation on the live program values? The programmer might either text edit their code or use their mouse to manipulate live program values to modify their program. While such bimodal programming environments have been demonstrated for graphical domains, how to offer such a system for more generic programming remains an open question. 
To explore this question, we take inspiration from Conal Elliot’s tangible functional programming system Eros, in which the user manipulates function values on a canvas to create new values by composition. While not bimodal, Eros demonstrated that functional programming might enable a non-linear editing style in which programs are constructed out of order rather than top-down. 
To take initial steps towards non-linear tangible editing in a bimodal interface, we present ManipML, a text and direct manipulation interface for building simple OCaml programs. Running alongside a traditional text editor, ManipML displays a manipulable skeleton of the program structure, along with runtime values from an example execution. Drag-and-drop interactions enable insertion and replacement of code. We demonstrate ManipML’s workflow by constructing a function to perform natural number addition.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Brian</first_name>
          <last_name>Hempel</last_name>
          <affiliation>University of Chicago</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.uchicago.edu/~brianhempel/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brianhempel/8609eedc-999e-4fbb-a36c-5394ab85f36f/small.jpg</picture_url>
          <person_id>brianhempel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ravi</first_name>
          <last_name>Chugh</last_name>
          <affiliation>University of Chicago</affiliation>
          <bio>I am an Assistant Professor at the University of Chicago. I enjoy developing and deploying programming language technology — type systems, synthesis algorithms, and other program analysis techniques — for applications in software engineering and human-computer interaction.</bio>
          <homepage_url>http://people.cs.uchicago.edu/~rchugh</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ravichugh/ea931b20-b1e1-4e07-b209-ba0b568e315d/small.jpg</picture_url>
          <person_id>ravichugh</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4f2fb810-6e5d-43b9-a8a1-aff897973948</subevent_id>
    <title>LIVE: Full Talks I</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-VI</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/home/live-2020</url>
    <url_link_display>LIVE 2020</url_link_display>
    <tracks>
      <track>LIVE 2020</track>
    </tracks>
    <timeslot>
      <slot_id>09c4201c-cb9f-4806-9ad0-5c481914c49b</slot_id>
      <title>Session: LIVE - Full Talks I</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/17</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>LIVE 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>04b03c56-7ade-4260-a60f-7a480116e687</slot_id>
      <event_id>1a588cbf-09f7-4a09-bedf-0b3015a4f5df</event_id>
      <title>Functional Block Programming and Debugging</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/17</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>12:00</end_time>
      <description>Recent years have seen the inclusion of introductory programming courses as early as in elementary schools, as an answer to the onminpresence of computer technology. While some curriculums rely on traditional text-based languages, such as Java or Python, others advocate for more accessible visual programming environments, such as Scratch or Microsoft MakeCode. Most of these tools adopt an imperative paradigm in which programs are expressed using pre-defined instruction blocks. This setup is particularily well suited to interactive debugging environments, using the common stepping model to control execution. However, as they focus on control rather than data, they often lack appropriate mechanisms to manipulate non-trivial data structures. 
In an effort to provide an alternative approach, we are developing FunBlocks, a hybrid programming environment based on algebraic data types and term rewriting. Rewriting systems emphasis on data rather than control, enabling students and novices to create a better understanding of data structures, while letting them define elaborate transformation strategies without the need to get familiar with the ad-hoc semantics of pre-defined control-flow statements. Instead, terms describe the program’s state syntactically, while rewriting rules describe its semantics. Furthermore, terms and rewriting rules also provide a simple way to adopt the traditional watch expressions and step-by-step execution, respectively, whereas such techniques are often difficult to apply on declarative programs. This paper gives an overview of the design principles of FunBlocks, with a particular focus on its visual editor and debugger.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dimitri</first_name>
          <last_name>Racordon</last_name>
          <affiliation>University of Geneva, Switzerland</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/dimitriracordon/23c16a97-1d4c-47e1-9270-89755cace04c/small.jpg</picture_url>
          <person_id>dimitriracordon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Emmanouela</first_name>
          <last_name>Stachtiari</last_name>
          <affiliation>University of Geneva</affiliation>
          <bio>undefined</bio>
          <person_id>emmanouelastachtiari</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Damien</first_name>
          <last_name>Morard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/damienmorard/a132a10c-930c-4c34-bc8b-e2cd758cde59/small.jpg</picture_url>
          <person_id>damienmorard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Didier</first_name>
          <last_name>Buchs</last_name>
          <affiliation>University of Geneva, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>didierbuchs</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5fd17916-80c1-4bca-9971-1b0d4eb01b6d</slot_id>
      <event_id>505f0d9a-6f10-4fbb-9860-fb23295f8bfa</event_id>
      <title>NBSafety: Fine-Grained Lineage for Safer Jupyter Notebooks</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/17</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>11:20</end_time>
      <description>Computational notebooks have emerged as the platform of choice for data science and analytical workflows, enabling rapid iteration and exploration. By keeping intermediate program state in memory and segmenting units of execution into so-called “cells”, notebooks allow users to execute their workflows interactively and enjoy particularly tight feedback. However, as cells are added, removed, reordered, and rerun, this hidden intermediate state accumulates in a way that is not necessarily correlated with the notebook’s visible code, making execution behavior difficult to reason about, and leading to errors and lack of reproducibility. We present NBSafety, a custom Jupyter kernel that uses runtime tracing and static analysis to automatically manage lineage associated with cell execution and global notebook state. NBSafety detects and prevents errors that users make during unaided notebook interactions, all while preserving the flexibility of existing notebook semantics. We evaluate NBSafety’s ability to prevent erroneous interactions by replaying and analyzing NBSafety real notebook sessions. Of these, NBSafety identified 117 sessions with potential safety errors, and in the remaining 549 sessions, the cells that NBSafety identified as resolving safety issues were more than 7x more likely to be selected by users for re-execution compared to a random baseline, even though the users were not using NBSafety and were therefore not influenced by its suggestions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Macke</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>stephenmacke1</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b4371290-d420-497e-ac54-385ff76e2ab8</slot_id>
      <event_id>d3fa2b6b-c1d8-46d5-bcd9-d07472f5292b</event_id>
      <title>Exploring Human-in-the-loop Program Synthesis with Live Coding</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/17</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>12:20</end_time>
      <description>Live Coding is a budding performative practice whereby artists write code that generates media (audio, visuals, etc.) live on stage. In live coding, the process of writing code is itself the final product, rather than a fixed implementation of a tool, as typically seen in software development. We propose that this unique performance style, with a heavy emphasis on the evolution of code, is an ideal space to explore program synthesis. In this paper, we present a synthesis-aided live coding interface for drum sequencer patterns. Our live coding environment allows performers to live coding in Javascript, uses a programming-by-example model for synthesis. The synthesis toolchain uses SyGuS and a set of templates specific to live coding music. We describe the tool and its implementation, and highlight key areas of future exploration.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mark</first_name>
          <last_name>Santolucito</last_name>
          <affiliation>Barnard College, Columbia University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.marksantolucito.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/marksantolucito/51821284-64c1-46e0-b979-96e8324079bf/small.jpg</picture_url>
          <person_id>marksantolucito</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cf60e363-1dd2-4cdd-928e-15152388c037</slot_id>
      <event_id>245d0cfb-e52a-493a-a98d-6b9c148d2181</event_id>
      <title>Mito: Edit a spreadsheet. Generate production ready Python.</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/17</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>11:40</end_time>
      <description>Mito is an editable spreadsheet inside a Jupyter notebook. With Mito, you can call your data frame as a spreadsheet, which you can edit in a point and click way, utilizing all the functions you have come to know in Excel. Every edit is then converted into production ready Python. This allows the users to create repeatable spreadsheet workflows, something that Excel struggles with. There are two large user segments for this tool. The first is the Python user who wants to do more analysis in a point and click way and still generate repeatable code. The second is the spreadsheet user who wants to learn Python. They can edit the Mito spreadsheet and see the resultant Python that is generated, teaching them the correct syntax. The ultimate vision is to bring spreadsheet and Python workflows together in one tool, allowing business analysts and data scientists alike to work together.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jacob</first_name>
          <last_name>Diamond-Reivich</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>jacobdiamondreivich</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>760301b3-d775-4558-8a5f-ee56cef5db76</subevent_id>
    <title>SPLASH CARES: CARES</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-cares</url>
    <url_link_display>CARES</url_link_display>
    <tracks>
      <track>CARES</track>
    </tracks>
    <timeslot>
      <slot_id>f2b5bde1-a6b3-44fa-9040-7f3f97a3eab6</slot_id>
      <title>Session: SPLASH CARES - CARES</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>19:40</start_time>
      <end_time>20:20</end_time>
      <tracks>
        <track>CARES</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>035df7fa-5556-4af1-ba71-116422fbe628</slot_id>
      <event_id>0cbcc236-94a2-4e98-ba56-8caba12a4fe1</event_id>
      <title>CARES Session</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>19:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>20:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>CARES</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a465de0d-9871-4cb0-b3df-107838162c74</subevent_id>
    <title>NSAD: Papers</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/home/nsad-2020</url>
    <url_link_display>NSAD 2020</url_link_display>
    <tracks>
      <track>NSAD 2020</track>
    </tracks>
    <timeslot>
      <slot_id>6764e119-a7f3-40b3-9e55-ec75d61e3adb</slot_id>
      <title>Session: NSAD - Papers</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/17</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Liqian</first_name>
          <last_name>Chen</last_name>
          <affiliation>National University of Defense Technology, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://lqchen.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/liqianchen/59d3ba12-c8e5-4891-a6e4-ef49b25fcc64/small.jpg</picture_url>
          <person_id>liqianchen</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Khalil</first_name>
          <last_name>Ghorbal</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>I am currently a researcher at Inria (Rennes, France), in the Hycomes group. My research interests orbit the following topics: 
 
 Algebraic methods for generating invariant sets 
 Certified numerical computations 
 Quantifier elimination in finite and real closed fields 
 Combinatorial optimization 
 
I was previously a postdoc at Carnegie Mellon University (Pittsburgh, PA, USA), School of Computer Science, Logical Systems Lab and before that at NEC Labs America, System Analysis and Verification Group (Princeton, NJ, USA).</bio>
          <homepage_url>http://khalilghorbal.info</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/khalilghorbal/a714313f-dcce-4d9c-bfdb-5fa9aba21096/small.jpg</picture_url>
          <person_id>khalilghorbal</person_id>
        </person>
      </persons>
      <tracks>
        <track>NSAD 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>06d9deb2-4670-4351-acff-a8ff42215639</slot_id>
      <event_id>01977982-7903-48db-97a5-022995b6f82d</event_id>
      <title>Rigorous Linear Programming Techniques for Numerical Abstract Domains</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/17</date>
      <start_time>04:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>04:20</end_time>
      <description>Linear programming is a key technique for several numerical abstract domains, such as Template Constraint Matrix, constraint-only polyhedra, etc. However, most state-of-the-art linear programming solvers use floating-point arithmetic in their implementations, which can only give an approximate result that may be unsound (e.g., resulting in a larger value than the exact result for a minimization objective function). On the other hand, the solvers based on exact arithmetic are slow and have poor scalability. To this end, this paper aims at leveraging rigorous linear programming techniques which are built on the top of floating-point linear programming for soundly implementing numerical abstract domains. Particularly, in this paper, we present a new technique of rigorous linear programming which is based on Fourier-Mozkin elimination as a supplement to existing rigorous linear programming techniques. On the basis, we implement a tool, RlpSolver, combining Fourier-Mozkin elimination based and existing rigorous linear programming techniques together to lift effectiveness of rigorous linear programming in the scene of designing numerical abstract domains. Experimental results show that the new technique is complementary with existing rigorous linear programming techniques and their combination produces better results than a separate technique.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tengbin</first_name>
          <last_name>Wang</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>tengbinwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Liqian</first_name>
          <last_name>Chen</last_name>
          <affiliation>National University of Defense Technology, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://lqchen.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/liqianchen/59d3ba12-c8e5-4891-a6e4-ef49b25fcc64/small.jpg</picture_url>
          <person_id>liqianchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ji</first_name>
          <last_name>Wang</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>jiwang</person_id>
        </person>
      </persons>
      <tracks>
        <track>NSAD 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>446da261-90bc-4dfb-be6f-b542a2a65150</slot_id>
      <event_id>0a4f168b-29ff-465b-9156-d8b716621b22</event_id>
      <title>Abstract Domains for Constraint Programming with Differential Equations</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/17</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>03:20</end_time>
      <description>Cyber-physical systems (CPSs), as cruise control systems, involve life-critical or mission critical functions that must be validated. Formal verification techniques can bring high assurance level but have to be extended to embrace all the components of CPSs. Physical part models of CPSs are usually defined from ordinary differential equations (ODEs) and reachability methods can be used to compute safe over-approximation of the solution set of ODEs. However, additional constraints, as obstacle avoidance have also to be considered to validate CPSs. To meet this need, we propose in this paper a framework, based on abstract domains, for solving constraint satisfaction problems where the objects manipulated are described by ODEs. We use a form of disjunctive completion for which we provide a split operator and an efficient constraint filtering mechanism that takes advantage of the continuity aspect of ODEs. We illustrate the benefits of our method on a real-world application of trajectory validation of a swarm of drones, for which the main property we aim to prove is the absence of collisions between drone trajectories. Our work has been concretized in the form of a cooperation between the DynIbex library, used for the abstraction of ODEs, and the AbSolute constraint solver, used for the constraint resolution. Experiments show promising results.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ghiles</first_name>
          <last_name>Ziat</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>ghilesziat</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Mullier</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>oliviermullier</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Julien Alexandre</first_name>
          <last_name>dit Sandretto</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>julienalexandreditsandretto</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Christophe</first_name>
          <last_name>Garion</last_name>
          <affiliation>ISAE-SUPAERO</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://personnel.isae-supaero.fr/christophe-garion?lang=en</homepage_url>
          <person_id>christophegarion</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Alexandre</first_name>
          <last_name>Chapoutot</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>alexandrechapoutot</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Xavier</first_name>
          <last_name>Thirioux</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>xavierthirioux</person_id>
        </person>
      </persons>
      <tracks>
        <track>NSAD 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7d6357f9-bad6-41ff-af94-a665af3c27f2</slot_id>
      <event_id>d4fd22e9-2e8f-4717-b651-8a6f37b5a6e4</event_id>
      <title>Numeric Domains Meet Algebraic Data Types</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/17</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>03:40</end_time>
      <description>We report on the design and formalization of a novel abstract domain, called numeric path relations (NPRs), that combines numeric relational domains with algebraic data types. This domain expresses relations between algebraic values that can contain scalar data. The construction of the domain is parameterized by the choice of a relational domain on scalar values. The construction employs projection paths on algebraic values, and in particular projections on variant cases, whose sound treatment is subtle due to mutual exclusiveness.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Santiago</first_name>
          <last_name>Bautista</last_name>
          <affiliation>Univ Rennes, ENS Rennes, Inria, IRISA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/santiagobautista/e558a0ab-28b1-425c-94b5-94b4c57cb71c/small.jpg</picture_url>
          <person_id>santiagobautista</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thomas P.</first_name>
          <last_name>Jensen</last_name>
          <affiliation>INRIA Rennes</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.irisa.fr/celtique/jensen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/thomaspjensen/88563f7d-114a-474a-aa4d-4eb39db60f73/small.jpg</picture_url>
          <person_id>thomaspjensen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benoît</first_name>
          <last_name>Montagu</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.irisa.fr/Benoit.Montagu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/benoitmontagu1/8883f081-9226-4066-b5fc-43520583f70a/small.jpg</picture_url>
          <person_id>benoitmontagu1</person_id>
        </person>
      </persons>
      <tracks>
        <track>NSAD 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8a49a299-d25b-4eb3-81f7-9e80511ec5a2</slot_id>
      <event_id>3e396d3d-3807-4f5a-ad5a-28940ddc5ccd</event_id>
      <title>Proving array properties using data abstraction</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/17</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>04:00</end_time>
      <description>This paper presents a framework to abstract data structures within Horn clauses that allows abstractions to be easily expressed, compared, composed and implemented. These abstractions introduce new quantifiers that we eliminate with quantifier elimination techniques. 
We study the case of arrays and our experimental evaluation show promising results on classical array programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julien</first_name>
          <last_name>Braine</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>julienbraine</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Laure</first_name>
          <last_name>Gonnord</last_name>
          <affiliation>University of Lyon &amp; LIP, France</affiliation>
          <bio>Laure Gonnord received her PhD degree in computer science from the University Joseph Fourier (Grenoble, France), in 2007. She currently holds an assistant professor position at University Lyon I/UCBL, France. She got her Habilitation in 2017. 
Her main research interests lie in the design of static analyses, with emphasis on the automatic synthesis of numerical and memory invariants and application in compilation (scheduling) and termination proofs. She belongs to the CASH team of the LIP laboratory (ENS de Lyon, France).</bio>
          <homepage_url>http://laure.gonnord.org/pro</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lauregonnord/6b741986-7933-4cba-9205-8e5e8451d8fa/small.jpg</picture_url>
          <person_id>lauregonnord</person_id>
        </person>
      </persons>
      <tracks>
        <track>NSAD 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>44ffcac7-273d-4f4b-9563-99b5d059967f</subevent_id>
    <title>SPLASH -E: Welcome and Keynote</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-SPLASH-E</url>
    <url_link_display>SPLASH-E</url_link_display>
    <tracks>
      <track>SPLASH-E</track>
    </tracks>
    <timeslot>
      <slot_id>1845491e-df7c-45c2-b295-a9c38f56e9c7</slot_id>
      <title>Session: SPLASH -E - Welcome and Keynote</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/20</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Elisa</first_name>
          <last_name>Baniassad</last_name>
          <affiliation>University of British Columbia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ubc.ca/~ebani</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elisabaniassad/ebb453ca-88ce-4678-823e-82b113c14751/small.jpg</picture_url>
          <person_id>elisabaniassad</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Charlie</first_name>
          <last_name>Curtsinger</last_name>
          <affiliation>Grinnell College</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ccurtsinger.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/charliecurtsinger/e779a4c9-ade3-4073-b660-866046d6c953/small.jpg</picture_url>
          <person_id>charliecurtsinger</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>100e9f54-687b-40dc-a9d6-f11b7c2d3be2</slot_id>
      <event_id>e5dbbe7c-94c9-4396-b463-e89f593bdba7</event_id>
      <title>Welcome</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/20</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>09:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Charlie</first_name>
          <last_name>Curtsinger</last_name>
          <affiliation>Grinnell College</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ccurtsinger.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/charliecurtsinger/e779a4c9-ade3-4073-b660-866046d6c953/small.jpg</picture_url>
          <person_id>charliecurtsinger</person_id>
        </person>
        <person>
          <role>Co-chair</role>
          <sort_key>2</sort_key>
          <first_name>Elisa</first_name>
          <last_name>Baniassad</last_name>
          <affiliation>University of British Columbia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ubc.ca/~ebani</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elisabaniassad/ebb453ca-88ce-4678-823e-82b113c14751/small.jpg</picture_url>
          <person_id>elisabaniassad</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e385e87c-4212-406a-8509-400a620d5a09</slot_id>
      <event_id>133245a4-7259-4ac7-a2fd-06917ebd77f0</event_id>
      <title>SPLASH-E Keynote</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/20</date>
      <start_time>09:10</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>10:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nicki</first_name>
          <last_name>Washington</last_name>
          <affiliation>Duke University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://nickiwashington.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nickiwashington/4c80d84b-7e4a-43d8-af0d-600237a60b6b/small.jpg</picture_url>
          <person_id>nickiwashington</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>999fdb4e-af41-43a7-9c20-6c1d9e7b3b4c</subevent_id>
    <title>SPLASH Onward! Papers: T-3-Onward</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
      <track>Onward! Essays</track>
    </tracks>
    <timeslot>
      <slot_id>76251e2e-e500-47ff-9ba5-1834f76fe27f</slot_id>
      <title>Session: SPLASH Onward! Papers - T-3-Onward</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2efe4521-aba0-47f1-978a-b4f2955701be</slot_id>
      <event_id>c7a92e3e-e35f-4c15-9cd3-ea11f7016ac0</event_id>
      <title>Putting the Semantics into Semantic Versioning</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>12:00</end_time>
      <description>The long-standing aspiration for software reuse has made astonishing strides in the past few years. Many modern software development ecosystems now come with rich sets of publicly-available components contributed by the community. Downstream developers can leverage these upstream components, boosting their productivity. 
However, components evolve at their own pace. This imposes obligations on and yields benefits for downstream developers, especially since changes can be breaking, requiring additional downstream work to adapt to. Upgrading too late leaves downstream vulnerable to security issues and missing out on useful improvements; upgrading too early results in excess work. Semantic versioning has been proposed as an elegant mechanism to communicate levels of compatibility, enabling downstream developers to automate dependency upgrades. However, there is evidence suggesting that this approach faces problems, and is only slowly being adopted. 
While it is questionable whether a version number can adequately characterize version compatibility in general, we argue that developers would greatly benefit from tools such as semantic version calculators to help them upgrade safely. The time is now for the research community to develop such tools: large component ecosystems exist and are accessible, component interactions have become observable through automated builds, and recent research advances in program analysis have made the development of relevant tools feasible. In particular, verified contracts (both traditional and lightweight) are a promising input to semantic versioning calculators, which can suggest whether an upgrade is likely to be safe.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jens</first_name>
          <last_name>Dietrich</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>I am an Associate Professor in the School of Engineering and Advanced Technology (SEAT) at the Turitea (Palmerston North) Campus of Massey University. I have a Master in Mathematics and a PhD in Computer Science from the University of Leipzig. I have worked for a couple of years in industry as consultant in Germany, Namibia, Switzerland and the UK, and returned in 2003 to academia. My research interests are in the areas of software componentry, evolution and static analysis.</bio>
          <homepage_url>https://ecs.wgtn.ac.nz/Main/JensDietrich</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jensdietrich/ab54c290-4f44-4d77-9842-cdc18922d7b4/small.jpg</picture_url>
          <person_id>jensdietrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Lam</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://patricklam.ca</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/patricklam/d94f6246-8d4e-4896-a263-379eb20a9b24/small.jpg</picture_url>
          <person_id>patricklam</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Pearce</last_name>
          <affiliation>Victoria University of Wellington, New Zealand</affiliation>
          <bio>David (@whileydave) graduated with a PhD from Imperial College London in 2005, and took up a lecturer position at Victoria University of Wellington, NZ. David’s PhD thesis was on efficient algorithms for pointer analysis of C, and his techniques have since been incorporated into GCC. His interests are in programming languages, compilers and static analysis. 
Since 2009, he has been developing the Whiley Programming Language (whiley.org) which is designed specifically to simplify program verification. Prior to that, David developed the Java Compiler Kit (JKit), which is an open source Java Compiler aimed at simplifying static analysis. 
David has previously interned at Bell Labs, New Jersey, where he worked on compilers for FPGAs; and also at IBM Hursely, UK, where he worked with the AspectJ development team on profiling systems.</bio>
          <homepage_url>http://homepages.ecs.vuw.ac.nz/~djp/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidpearce/22bf61c2-1912-4f75-a0a6-fc77ea16dd34/small.jpg</picture_url>
          <person_id>davidpearce</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>809ef1b3-44de-4c15-8ea6-4146d587913d</slot_id>
      <event_id>538dbb83-bda8-4f57-a308-5f47c726d7b8</event_id>
      <title>How (Not) To Write Java Pointer Analyses After 2020</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>11:20</end_time>
      <description>Despite being a very old discipline, pointer analysis still attracts several research papers every year in premier programming language venues. While a major goal of contemporary pointer analysis research is to improve its efficiency without sacrificing precision, we also see works that introduce novel ways of solving the problem itself. What does this mean? Research in this area is not going to die soon. 
I too have been writing pointer analyses of various kinds, specially for object-oriented languages such as Java. While some standard ways of writing such analyses are clear, I have realized that there are an umpteen number of nooks and pitfalls that make the task difficult and error prone. In particular, there are several misconceptions and undocumented practices, being aware of which would save significant research time. On the other hand, there are lessons from my own research that might go a long way in writing correct, precise and efficient pointer analyses, faster. This paper summarizes some such learnings, with a hope to help readers beat the state-of-the-art in (Java) pointer analysis, as they move into their research careers beyond 2020.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manas</first_name>
          <last_name>Thakur</last_name>
          <affiliation>IIT Mandi</affiliation>
          <bio>Assistant Professor at Indian Institute of Technology Mandi, India.</bio>
          <homepage_url>https://manas.gitlab.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manasthakur/c8d83ff4-14f0-46ad-beb5-2e2a35b13ebf/small.jpg</picture_url>
          <person_id>manasthakur</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bf7b3639-5b9d-41ff-a7d8-5cab4ea5a91f</slot_id>
      <event_id>734f329a-291e-4cc1-aee1-a79175158f11</event_id>
      <title>The Wonderful Wizard of LoC: Paying Attention to the Man Behind the Curtain of Line-of-Code Metrics</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>11:40</end_time>
      <description>Lines-of-code metrics are commonly reported in PL, SE, and Systems papers. This convention has several different, often contradictory, goals, including demonstrating the “hardness” of a problem, and demonstrating the “easiness” of a problem. In many cases, the reporting of loc metrics is done not with a clearly communicated intention, but instead in an automatic, checkbox-ticking, manner. 
In this paper we investigate the uses of code metrics in PL, SE, and System papers. We consider the different goals that reporting metrics aims to achieve, several various domains wherein metrics are relevant, and various alternative metrics and their pros and cons for the different goals and domains. We argue that communicating claims about research software is usually best achieved not by reporting quantitative metrics, but by reporting the qualitative experience of researchers, and propose guidelines for the cases when quantitative metrics are appropriate. 
We end with a case study of the one area in which lines of code are not the default measurement—code produced by papers’ solutions—and identify how measurements offered are used to support an explicit claim about the algorithm. Inspired by this positive example, we call for other cogent measures to be developed to support other claims authors wish to make.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kalev</first_name>
          <last_name>Alpernas</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.tau.ac.il/~kalevalp/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/kalevalpernas/05430004-6682-4918-b6b0-8b3398cb9428/small.jpg</picture_url>
          <person_id>kalevalpernas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yotam</first_name>
          <last_name>Feldman</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/research/yotam.feldman/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yotamfeldman/ed864714-e66c-4ec1-a171-8c2ac69d62a1/small.jpg</picture_url>
          <person_id>yotamfeldman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ea928827-ea52-43b4-831b-fb0dfa3318a7</slot_id>
      <event_id>49dcbe04-cb78-487b-8021-c2b2cca6e30e</event_id>
      <title>Demystifying Dependence</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>12:20</end_time>
      <description>Programmers are told “depend on interfaces, not implementations.” But, given a program, is it possible even to assess objectively whether such advice has been followed? 
Programmers frequently talk in ways like this about dependence, but the very term, like many used in software engineering, has hitherto eluded precise definition. In this work, we resolve a variety of confusions about dependence, and present a formal definition unifying multiple varieties of software dependence, grounded in Halpern and Pearl’s theory of actual causation. This definition is parameterized by the formal system characterizing the property of interest, and by constraints on “reasonable changes” to the program. By picking different choices of formal system, one can specialize our definition to characterize dynamic dependence (slicing), static dependence (correctness), and dependence of performance properties. Overall, our work provides a path to making conversations about software dependence fully objective, and might serve as a basis for future work automatically checking forms of dependence which were previously too abstract or high-level to be candidates for tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>James</first_name>
          <last_name>Koppel</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>www.jameskoppel.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jameskoppel/285bb202-88a1-4b77-bf13-bd39911247ef/small.jpg</picture_url>
          <person_id>jameskoppel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Jackson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/dnj/</homepage_url>
          <person_id>danieljackson</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5eb6a36d-e8c2-4d9b-bf81-042bbdf4db58</subevent_id>
    <title>SPLASH Onward! Essays: T-4-Onward</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-Onward-Essays</url>
    <url_link_display>Onward! Essays</url_link_display>
    <tracks>
      <track>Onward! Essays</track>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot>
      <slot_id>447b6f18-b1d0-4ce3-904f-d4a6ca2c785e</slot_id>
      <title>Session: SPLASH Onward! Essays - T-4-Onward</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>13:00</start_time>
      <end_time>14:00</end_time>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3232081f-0e24-444a-a99e-00a1e33730fe</slot_id>
      <event_id>185d56d8-71e8-445f-8ca3-ecfe421bd8c0</event_id>
      <title>Intrepydd: Performance, Productivity and Portability for Data Science Application Kernels</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:40</end_time>
      <description>Major simultaneous disruptions are now under way in both hardware and software. In hardware, ``extreme heterogeneity'' has become critical to sustaining cost and performance improvements after Moore’s Law, but poses productivity and portability challenges for developers. In software, the rise of large-scale data science is driven by developers who come from diverse backgrounds and, moreover, who demand the rapid prototyping and interactive-notebook capabilities of high-productivity languages like Python. 
We introduce the Intrepydd programming system, which enables data scientists to write application {\em kernels} with high performance, productivity, and portability on current and future hardware. Intrepydd is based on Python, though the approach can be applied to other base languages as well. To deliver high performance, the Intrepydd toolchain uses ahead-of-time (AOT) compilation and high-level compiler optimizations of Intrepydd kernels. Intrepydd achieves portability by its ability to compile kernels in different modes for execution on different hardware platforms, and for invocation from Python or C++ main programs. 
An empirical evaluation shows significant performance improvements relative to Python, and the suitability of Intrepydd for mapping on to post-Moore accelerators and architectures with relative ease. In summary, we believe that Intrepydd represents a new direction of ``Discipline-Aware Languages'' (DiALs), which brings us closer to the holy grail of obtaining productivity and portability with higher performance than current Python-like languages, and with more generality than current domain-specific languages and libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tong</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>My research tries to improve the correctness and performance of softwares by making better compiler and runtime systems.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/tongzhou/9d2400c2-f3c2-465c-bc3f-7627bbae5555/small.jpg</picture_url>
          <person_id>tongzhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jun</first_name>
          <last_name>Shirako</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>junshirako1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anirudh</first_name>
          <last_name>Jain</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>anirudhjain</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sriseshan</first_name>
          <last_name>Srikanth</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>sriseshansrikanth</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Conte</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>thomasconte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Richard</first_name>
          <last_name>Vuduc</last_name>
          <affiliation>Georgia Tech</affiliation>
          <bio>See website</bio>
          <homepage_url>https://vuduc.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/richardvuduc/18a7667a-ab20-4ff4-b4ea-8f1f95f6abff/small.jpg</picture_url>
          <person_id>richardvuduc</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Vivek</first_name>
          <last_name>Sarkar</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>Vivek Sarkar is Chair of the School of Computer Science and the Stephen Fleming Chair for Telecommunications in the College of Computing at Georgia Institute of Technology. He conducts research in multiple aspects of programmability and productivity in parallel computing, including programming languages, compilers, runtime systems, and debuggers for parallel, heterogeneous, and high-performance computer systems. 
Sarkar started his career in IBM Research after obtaining his Ph.D. from Stanford University, supervised by John Hennessy. His research projects at IBM include the PTRAN automatic parallelization system led by Fran Allen, the ASTI optimizer for IBM’s XL Fortran product compilers, the open-source Jikes Research Virtual Machine for the Java language, and the X10 programming language developed in the DARPA HPCS program. He was a member of the IBM Academy of Technology during 1995-2007. After moving to academia, Sarkar has mentored over 30 Ph.D. students and postdoctoral researchers in the Habanero Extreme Scale Software Research Laboratory, first at Rice University since 2007, and now at Georgia Tech since 2017. Researchers in his lab have developed the Habanero-C/C++ and Habanero-Java programming systems for parallel, heterogeneous, and distributed platforms. While at Rice, Sarkar was the E.D. Butcher Chair in Engineering, served as Chair of the Department of Computer Science, created a new sophomore-level course on the fundamentals of parallel programming, as well as a three-course Coursera specialization on parallel, concurrent, and distributed programming. 
Sarkar is an ACM Fellow and an IEEE Fellow. He has been serving as a member of the US Department of Energy’s Advanced Scientific Computing Advisory Committee (ASCAC) since 2009, and on CRA’s Board of Directors since 2015. He is also the recipient of the 2020 ACM-IEEE CS Ken Kennedy Award.</bio>
          <homepage_url>http://vsarkar.cc.gatech.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/viveksarkar1/a34d5fee-4238-404c-a8b1-6de976f74890/small.jpg</picture_url>
          <person_id>viveksarkar1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>951bf7e8-ea42-4188-9ce2-41cfefbe58a7</slot_id>
      <event_id>2f305d32-0104-451e-9df8-c32c270e49fd</event_id>
      <title>A principled approach to REPL interpreters</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>14:00</end_time>
      <description>Read-eval-print-loops (REPLs) allow programmers to test out snippets of code, explore APIs, or even incrementally construct code, and get immediate feedback on their actions. However, even though many languages provide a REPL, the relation between the language as is and what is accepted at the REPL prompt is not always well-defined. Furthermore, implementing a REPL for new languages, such as DSLs, may incur significant language engineering cost. 
In this paper we survey the domain of REPLs and investigate the (formal) principles underlying REPLs. We identify and define the class of sequential languages, which admit a sound REPL implementation based on a definitional interpreter, and present design guidelines for extending existing language implementations to support REPL-style interfaces (including computational notebooks). The obtained REPLs can then be generically turned into an exploring interpreter, to allow exploration of the user’s interaction. 
The approach is illustrated using three case studies, based on MiniJava, QL (a DSL for questionnaires), and eFLINT (a DSL for normative rules). We expect sequential languages, and the consequent design principles, to be stepping stones towards a better understanding of the essence of REPLs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>L. Thomas</first_name>
          <last_name>van Binsbergen</last_name>
          <affiliation>Centrum Wiskunde &amp; Informatica</affiliation>
          <bio>Thomas van Binsbergen is designing and implementing domain-specific languages for the formal specification of norms from a variety of sources such as laws, regulations, policies, contracts and codes of conduct. The resulting formalizations are used in policy-enhanced, distributed software architectures for data sharing. By ensuring compliance with the formalized norms, such systems reduce the risk of violating regulations and add value by increasing the trust in sharing activities. 
The SSPDDP project is a collaboration between the knowledge institutes UvA, CWI and VU and the industrial partners ABN AMRO, ING and KLM to develop secure and scalable techniques for policy-enforced data sharing. The project investigates fundamental research questions to develop future-proof, cryptographic solutions to secure and trustworthy data sharing, automatic policy enforcement in distributed systems and bringing the aforementioned data sharing methods to scale. Besides being academically relevant, the outcomes of these investigations suggest a principled, sound and pragmatic mode of operation that can add value to the industry partners in several ways. 
In the past, Van Binsbergen has developed modular techniques for describing the semantics of programming languages as part of the PLanCompS project with Peter Mosses and parser combinators for generalised top-down parsing with Adrian Johnstone and Elizabeth Scott. The results are described in his PhD thesis titled “Executable Formal Specification of Programming Languages with Reusable Components” (http://ltvanbinsbergen.nl/thesis/thesis.pdf). 
Keywords: modular language definition, domain-specific languages, formal specification, modelling languages, policy-enhanced data-sharing, generalised top-down parsing, declarative programming, purely functional programming, I-MSOS, FunCons, attribute grammars, computer science education</bio>
          <homepage_url>http://ltvanbinsbergen.nl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lthomasvanbinsbergen/b276e9a4-2229-45a7-ae0f-e25fb729b0e6/small.jpg</picture_url>
          <person_id>lthomasvanbinsbergen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mauricio</first_name>
          <last_name>Verano Merino</last_name>
          <affiliation>Technische Universiteit Eindhoven</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://maveme.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mauricioveranomerino/e4a3ec56-b66f-4885-9989-c4a230e08446/small.jpg</picture_url>
          <person_id>mauricioveranomerino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pierre</first_name>
          <last_name>Jeanjean</last_name>
          <affiliation>Inria, Univ Rennes, CNRS, IRISA</affiliation>
          <bio>undefined</bio>
          <person_id>pierrejeanjean</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tijs</first_name>
          <last_name>van der Storm</last_name>
          <affiliation>CWI &amp; University of Groningen, Netherlands</affiliation>
          <bio>Tijs van der Storm is senior researcher in the Software Analysis and Transformation (SWAT) group at Centrum Wiskunde &amp;amp; Informatica (CWI) in Amsterdam, and full professor in Software Engineering at the University of Groningen in Groningen. His research focuses on improving programmer experience through new and better software languages and developing the tools and techniques to engineer them in a modular and interactive fashion.</bio>
          <homepage_url>http://www.cwi.nl/~storm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tijsvanderstorm/1c2fdfb2-3ce0-4e75-91af-35d9a48f56c5/small.jpg</picture_url>
          <person_id>tijsvanderstorm</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Barais</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>olivierbarais1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>af3dad57-a64e-486c-a822-c55ea57d23e1</slot_id>
      <event_id>de7f53dd-f844-4b70-b3c5-5ce2c614266b</event_id>
      <title>Notes on Notebooks: Is Jupyter the Bringer of Jollity?</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:20</end_time>
      <description>As the interactive computational notebook becomes a more prominent code development medium, we examine advantages and disadvantages of this particular source code format. We formally specify the structure of a coding notebook layout. We describe complexities in notebook programming; some of these are incidental whereas others may be inherent complexities. We outline how we envisage research and development might proceed to advance the cause of notebook programming.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Singer</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~jsinger</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeremysinger/14db1542-37ba-4e0e-b338-e3a952991f1a/small.jpg</picture_url>
          <person_id>jeremysinger</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>826f0c2f-a247-44cc-b223-b407a4f70172</subevent_id>
    <title>SPLASH Onward! Papers: T-3-Onward</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
      <track>Onward! Essays</track>
    </tracks>
    <timeslot>
      <slot_id>bf9c6f0b-e49d-4cd8-a336-e6199fe17af4</slot_id>
      <title>Session: SPLASH Onward! Papers - T-3-Onward</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1cf875f1-2f8c-4433-87e6-12e82682c447</slot_id>
      <event_id>49dcbe04-cb78-487b-8021-c2b2cca6e30e</event_id>
      <title>Demystifying Dependence</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>00:20</end_time>
      <description>Programmers are told “depend on interfaces, not implementations.” But, given a program, is it possible even to assess objectively whether such advice has been followed? 
Programmers frequently talk in ways like this about dependence, but the very term, like many used in software engineering, has hitherto eluded precise definition. In this work, we resolve a variety of confusions about dependence, and present a formal definition unifying multiple varieties of software dependence, grounded in Halpern and Pearl’s theory of actual causation. This definition is parameterized by the formal system characterizing the property of interest, and by constraints on “reasonable changes” to the program. By picking different choices of formal system, one can specialize our definition to characterize dynamic dependence (slicing), static dependence (correctness), and dependence of performance properties. Overall, our work provides a path to making conversations about software dependence fully objective, and might serve as a basis for future work automatically checking forms of dependence which were previously too abstract or high-level to be candidates for tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>James</first_name>
          <last_name>Koppel</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>www.jameskoppel.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jameskoppel/285bb202-88a1-4b77-bf13-bd39911247ef/small.jpg</picture_url>
          <person_id>jameskoppel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Jackson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/dnj/</homepage_url>
          <person_id>danieljackson</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7cca4f99-750a-4e30-a8b8-a27293445775</slot_id>
      <event_id>538dbb83-bda8-4f57-a308-5f47c726d7b8</event_id>
      <title>How (Not) To Write Java Pointer Analyses After 2020</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>23:20</end_time>
      <description>Despite being a very old discipline, pointer analysis still attracts several research papers every year in premier programming language venues. While a major goal of contemporary pointer analysis research is to improve its efficiency without sacrificing precision, we also see works that introduce novel ways of solving the problem itself. What does this mean? Research in this area is not going to die soon. 
I too have been writing pointer analyses of various kinds, specially for object-oriented languages such as Java. While some standard ways of writing such analyses are clear, I have realized that there are an umpteen number of nooks and pitfalls that make the task difficult and error prone. In particular, there are several misconceptions and undocumented practices, being aware of which would save significant research time. On the other hand, there are lessons from my own research that might go a long way in writing correct, precise and efficient pointer analyses, faster. This paper summarizes some such learnings, with a hope to help readers beat the state-of-the-art in (Java) pointer analysis, as they move into their research careers beyond 2020.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manas</first_name>
          <last_name>Thakur</last_name>
          <affiliation>IIT Mandi</affiliation>
          <bio>Assistant Professor at Indian Institute of Technology Mandi, India.</bio>
          <homepage_url>https://manas.gitlab.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manasthakur/c8d83ff4-14f0-46ad-beb5-2e2a35b13ebf/small.jpg</picture_url>
          <person_id>manasthakur</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c5b3e868-576f-405f-bb04-d817a3561853</slot_id>
      <event_id>734f329a-291e-4cc1-aee1-a79175158f11</event_id>
      <title>The Wonderful Wizard of LoC: Paying Attention to the Man Behind the Curtain of Line-of-Code Metrics</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>23:40</end_time>
      <description>Lines-of-code metrics are commonly reported in PL, SE, and Systems papers. This convention has several different, often contradictory, goals, including demonstrating the “hardness” of a problem, and demonstrating the “easiness” of a problem. In many cases, the reporting of loc metrics is done not with a clearly communicated intention, but instead in an automatic, checkbox-ticking, manner. 
In this paper we investigate the uses of code metrics in PL, SE, and System papers. We consider the different goals that reporting metrics aims to achieve, several various domains wherein metrics are relevant, and various alternative metrics and their pros and cons for the different goals and domains. We argue that communicating claims about research software is usually best achieved not by reporting quantitative metrics, but by reporting the qualitative experience of researchers, and propose guidelines for the cases when quantitative metrics are appropriate. 
We end with a case study of the one area in which lines of code are not the default measurement—code produced by papers’ solutions—and identify how measurements offered are used to support an explicit claim about the algorithm. Inspired by this positive example, we call for other cogent measures to be developed to support other claims authors wish to make.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kalev</first_name>
          <last_name>Alpernas</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.tau.ac.il/~kalevalp/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/kalevalpernas/05430004-6682-4918-b6b0-8b3398cb9428/small.jpg</picture_url>
          <person_id>kalevalpernas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yotam</first_name>
          <last_name>Feldman</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/research/yotam.feldman/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yotamfeldman/ed864714-e66c-4ec1-a171-8c2ac69d62a1/small.jpg</picture_url>
          <person_id>yotamfeldman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ddc26d91-ac58-461f-b4ab-617613ea11a6</slot_id>
      <event_id>c7a92e3e-e35f-4c15-9cd3-ea11f7016ac0</event_id>
      <title>Putting the Semantics into Semantic Versioning</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>00:00</end_time>
      <description>The long-standing aspiration for software reuse has made astonishing strides in the past few years. Many modern software development ecosystems now come with rich sets of publicly-available components contributed by the community. Downstream developers can leverage these upstream components, boosting their productivity. 
However, components evolve at their own pace. This imposes obligations on and yields benefits for downstream developers, especially since changes can be breaking, requiring additional downstream work to adapt to. Upgrading too late leaves downstream vulnerable to security issues and missing out on useful improvements; upgrading too early results in excess work. Semantic versioning has been proposed as an elegant mechanism to communicate levels of compatibility, enabling downstream developers to automate dependency upgrades. However, there is evidence suggesting that this approach faces problems, and is only slowly being adopted. 
While it is questionable whether a version number can adequately characterize version compatibility in general, we argue that developers would greatly benefit from tools such as semantic version calculators to help them upgrade safely. The time is now for the research community to develop such tools: large component ecosystems exist and are accessible, component interactions have become observable through automated builds, and recent research advances in program analysis have made the development of relevant tools feasible. In particular, verified contracts (both traditional and lightweight) are a promising input to semantic versioning calculators, which can suggest whether an upgrade is likely to be safe.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jens</first_name>
          <last_name>Dietrich</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>I am an Associate Professor in the School of Engineering and Advanced Technology (SEAT) at the Turitea (Palmerston North) Campus of Massey University. I have a Master in Mathematics and a PhD in Computer Science from the University of Leipzig. I have worked for a couple of years in industry as consultant in Germany, Namibia, Switzerland and the UK, and returned in 2003 to academia. My research interests are in the areas of software componentry, evolution and static analysis.</bio>
          <homepage_url>https://ecs.wgtn.ac.nz/Main/JensDietrich</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jensdietrich/ab54c290-4f44-4d77-9842-cdc18922d7b4/small.jpg</picture_url>
          <person_id>jensdietrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Lam</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://patricklam.ca</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/patricklam/d94f6246-8d4e-4896-a263-379eb20a9b24/small.jpg</picture_url>
          <person_id>patricklam</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Pearce</last_name>
          <affiliation>Victoria University of Wellington, New Zealand</affiliation>
          <bio>David (@whileydave) graduated with a PhD from Imperial College London in 2005, and took up a lecturer position at Victoria University of Wellington, NZ. David’s PhD thesis was on efficient algorithms for pointer analysis of C, and his techniques have since been incorporated into GCC. His interests are in programming languages, compilers and static analysis. 
Since 2009, he has been developing the Whiley Programming Language (whiley.org) which is designed specifically to simplify program verification. Prior to that, David developed the Java Compiler Kit (JKit), which is an open source Java Compiler aimed at simplifying static analysis. 
David has previously interned at Bell Labs, New Jersey, where he worked on compilers for FPGAs; and also at IBM Hursely, UK, where he worked with the AspectJ development team on profiling systems.</bio>
          <homepage_url>http://homepages.ecs.vuw.ac.nz/~djp/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidpearce/22bf61c2-1912-4f75-a0a6-fc77ea16dd34/small.jpg</picture_url>
          <person_id>davidpearce</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f207ecc9-7191-4c50-8b4b-6b45bd0b70da</subevent_id>
    <title>SPLASH Onward! Essays: T-5-Onward</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-Onward-Essays</url>
    <url_link_display>Onward! Essays</url_link_display>
    <tracks>
      <track>Onward! Essays</track>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot>
      <slot_id>1840cc92-5aa9-4766-98b2-4f4fba40b1be</slot_id>
      <title>Session: SPLASH Onward! Essays - T-5-Onward</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>03:00</start_time>
      <end_time>04:00</end_time>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3aad3423-4d23-431e-a0dc-e4b365c98b17</slot_id>
      <event_id>bd1659e4-ca0c-498d-a2c0-478c6c8c8f1d</event_id>
      <title>Natural Language Theory Meets Programming Language Theory: An Interdisciplinary Framework for Programming Language Evaluation</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>03:20</end_time>
      <description>Programming languages researchers make a variety of different kinds of claims about the design of languages and related tools and calculi. Each type of claim requires different kinds of reasons and evidence to justify. Claims regarding the aesthetics or elegance of a design, or its effects on people, are especially tricky to justify because they are less strictly defined and are subject to change depending on the exact audience. In this essay, we take an interdisciplinary approach to this problem by drawing on the fields of argument theory and rhetorical analysis to argue that programming languages researchers can provide reasons for their claims about effects on people by providing descriptions of specific features of their systems that support their claim. In order to demonstrate this framework, we show several examples of how this is already being practiced in some programming languages research, and conclude by calling for authors to provide descriptive evidence to bolster such claims and to frame and strengthen other evaluation methods such as user studies.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stefan K.</first_name>
          <last_name>Muller</last_name>
          <affiliation>Illinois Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~smuller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stefankmuller/db0c31ad-55ec-4010-948d-d405e6483cde/small.jpg</picture_url>
          <person_id>stefankmuller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hannah</first_name>
          <last_name>Ringler</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>hannahringler</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4ebab62c-13da-43bf-b7d6-ea0749d72575</slot_id>
      <event_id>c542014b-18d7-4287-87c7-d9a630060cef</event_id>
      <title>Analogy-Making as a Core Primitive in the Software Engineering Toolbox</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>04:00</end_time>
      <description>An analogy is an identification of structural similarities and correspondences between two objects. Computational models of analogy making have been studied extensively in the field of cognitive science to better understand high-level human cognition. For instance, Melanie Mitchell and Douglas Hofstadter sought to better understand high-level perception by developing the Copycat algorithm for completing analogies between letter sequences. In this paper, we argue that analogy making should be seen as a core primitive in software engineering. We motivate this argument by showing how complex software engineering problems such as program understanding and source-code transformation learning can be reduced to an instance of the analogy-making problem. We demonstrate this idea using Sifter, a new analogy-making algorithm suitable for software engineering applications that adapts and extends ideas from Copycat. In particular, Sifter reduces analogy-making to searching for a sequence of update rule applications. Sifter uses a novel representation for mathematical structures capable of effectively representing the wide variety of information embedded in software. We conclude by listing major areas of future work for Sifter and analogy-making in software engineering.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Sotoudeh</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://masot.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthewsotoudeh/32b819f5-05ef-4b0a-8a19-d59eed661278/small.jpg</picture_url>
          <person_id>matthewsotoudeh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aditya V.</first_name>
          <last_name>Thakur</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://thakur.cs.ucdavis.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adityavthakur/89eb0287-7273-4261-b8a5-47ccfc8799b0/small.jpg</picture_url>
          <person_id>adityavthakur</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f64b5bf0-1bae-4bc7-919f-c8b02be99fbc</slot_id>
      <event_id>c93c5c4d-1a3f-4cef-b393-3e7e6bd8b067</event_id>
      <title>Software design as story telling -- Reflecting on the work of Italo Calvino</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>03:40</end_time>
      <description>What do software writers have in common with other professional writers? What can we software developers learn from professional writers? This paper proposes a reflection on such topics using as a reference the book “Six Memos for the Next Millennium”, a posthumous work by the Italian novelist, editor, and literary critic Italo Calvino. A comparison is drawn between such work and the current principles ruling how software should be written and developed, and a claim is made that this is an area worth further exploration.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paolo</first_name>
          <last_name>Ciancarini</last_name>
          <affiliation>University of Bologna</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.unibo.it/~cianca/</homepage_url>
          <person_id>paolociancarini</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sergey</first_name>
          <last_name>Masyagin</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>sergeymasyagin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Giancarlo</first_name>
          <last_name>Succi</last_name>
          <affiliation>Innopolis University</affiliation>
          <bio>undefined</bio>
          <person_id>giancarlosucci</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ea675c2c-44c3-468b-b855-41694d4ab956</subevent_id>
    <title>SPLASH -E: Papers</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-SPLASH-E</url>
    <url_link_display>SPLASH-E</url_link_display>
    <tracks>
      <track>SPLASH-E</track>
    </tracks>
    <timeslot>
      <slot_id>214fd039-8faf-44a5-a3bd-c437a4bbcc15</slot_id>
      <title>Session: SPLASH -E - Papers</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/20</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a36fa2d5-3be3-43d0-8a16-abb9d7a3f85e</slot_id>
      <event_id>8ded4668-6e6c-4acc-ad27-cdbebe99705f</event_id>
      <title>CSS Instruction Enhanced by Objective Typography</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/20</date>
      <start_time>11:30</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>11:50</end_time>
      <description>This course experience report details an approach for teaching Cascading Style Sheets (CSS) constrained by the rules of objective typography. The approach condenses CSS to a human-scaled but representative subset of fewer than a dozen properties, which students then apply to a fundamental problem of visual communication: setting text that is accessible and readable across the range of screens on web-enabled devices. Students discover how to determine rule-governed values and ratios according to typographic principles, which are in turn applied and modified in a predictable, mathematically harmonious way across an entire website via its style sheet. Students learn how to verify visual results under particular viewing conditions before refactoring their work to accessibly engineer the web for diverse groups of human users. Experiential evidence suggests that these techniques transfer to other aspects of CSS, but formal study is needed.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Karl</first_name>
          <last_name>Stolley</last_name>
          <affiliation>Illinois Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://stolley.co/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/karlstolley/fe6b0ce7-90d6-4b6d-9cef-5802870d524e/small.jpg</picture_url>
          <person_id>karlstolley</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ec5f9e99-1b60-48c3-a08f-bc62b8eaf673</slot_id>
      <event_id>10d0bad4-f2e5-47e2-a577-8c8ee9ac155a</event_id>
      <title>Nudging Student Learning Strategies Using Formative Feedback in Automatically Graded Assessments</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/20</date>
      <start_time>11:50</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>12:20</end_time>
      <description>Automated assessment tools are widely used as a means for providing formative feedback to undergraduate students in computer science courses while helping those courses simultaneously scale to meet student demand. While formative feedback is a laudable goal, we have observed many students trying to debug their solutions into existence using only the feedback given, while losing context of the learning goals intended by the course staff. In this paper we detail case studies of two undergraduate courses indicating that limiting feedback to only giving nudges or hints about where students should focus their efforts in future attempts, can improve how they internalize and act on automatically provided feedback. By carefully reasoning about errors uncovered by our automated assessment approaches, we have been able to create feedback for students that helps them to revisit the learning outcomes for the assignment or course. This approach has been applied to both multiple-choice feedback in online quiz taking systems and automated assessment of student programming tasks for over 1,000 students from second and third-year software engineering courses. We have found that not only has student performance not suffered, but that the students reflect positively about how they investigate automated assessment failures.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lucas</first_name>
          <last_name>Zamprogno</last_name>
          <affiliation>University of British Columbia</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/lucaszamprogno/b42f32eb-3275-46ee-8b3e-01dadf00e2ad/small.jpg</picture_url>
          <person_id>lucaszamprogno</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Reid</first_name>
          <last_name>Holmes</last_name>
          <affiliation>University of British Columbia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.ubc.ca/~rtholmes</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/reidholmes/62072024-51a4-412c-9a05-af7a560429f1/small.jpg</picture_url>
          <person_id>reidholmes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Elisa</first_name>
          <last_name>Baniassad</last_name>
          <affiliation>University of British Columbia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ubc.ca/~ebani</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elisabaniassad/ebb453ca-88ce-4678-823e-82b113c14751/small.jpg</picture_url>
          <person_id>elisabaniassad</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>febb011f-9073-420e-bcb1-978787d380d7</slot_id>
      <event_id>01c022da-76bb-453c-9c14-cc3ffa849d01</event_id>
      <title>The PL-Detective Revisited</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/20</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>11:30</end_time>
      <description>The semantics of programming languages comprise many concepts that are alternatives to each other, such as by-reference and by-value parameter passing. To help teach these concepts, Diwan et al. introduced the programming language Mystery, with fixed syntax but configurable semantics, and described how this language enables new approaches to teaching programming languages concepts. In this paper, we reproduce the studies by Diwan et al. in a [European Country] setting, describe extensions to the original system, and a new technique for evaluating the utility of student experiments. We largely confirm the earlier findings and show how our evaluation technique helps us in our understanding of student experiments.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Reichenbach</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/christophreichenbach/04687677-a813-459e-8929-d1e4a32627c6/small.jpg</picture_url>
          <person_id>christophreichenbach</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>656d623f-d252-4a6e-9935-127c1c0a3a22</subevent_id>
    <title>SPLASH Onward! Papers: T-2-Onward</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
      <track>Onward! Essays</track>
    </tracks>
    <timeslot>
      <slot_id>7f0dd32e-839a-42b5-bc95-81efa9ab9abf</slot_id>
      <title>Session: SPLASH Onward! Papers - T-2-Onward</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>21:00</start_time>
      <end_time>22:20</end_time>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1ac2fe82-b842-434f-a4c2-67f8fbeae8cd</slot_id>
      <event_id>61a0b3ff-079e-4f32-b965-6212b38b01cc</event_id>
      <title>Discussion of Aviation Software Oversight Improvement</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>21:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>22:00</end_time>
      <description>The certification of US aviation software is described and critiqued. Flight critical software certification and regulation need external academic review and intervention. Industry is driven to generate profits over prioritizing concerns for public safety and has failed at developing adequately proven methods of certifying that flight critical software is safe to deploy. 
Disclaimer: The opinions expressed in this work are the views of the author and do not reflect the official policy or position of any agency of the U.S. government.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marc</first_name>
          <last_name>Ronell</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>marcronell</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>65d0abdc-ac53-4a5d-a4d5-70740108fd5b</slot_id>
      <event_id>f5df0dfc-f912-43a8-ab3d-e57ff4e3846c</event_id>
      <title>A Case Study in Language-Based Security: Building an I/O Library for Wyvern</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>22:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>22:20</end_time>
      <description>As the impact of vulnerabilities increases in practice, it is imperative for programming languages to include security as a first-class design consideration. While a number of security-related language features have been proposed to address this need, in many cases, we do not know enough about whether it is practical and useful to build software systems in languages with these features. 
In this paper, we begin to investigate this question, using a case study methodology. The setting of our case study is Wyvern, a recently designed language we selected because it incorporates three advanced security-related features: capability safety for enforcing the principle of least privilege, an effect system for tracking the secure use of resources, and a language extension feature that mitigates command injection. In our case study, we built a small standard I/O library, seeking to use the new language features to create a library that is less vulnerable to misuse and can serve as a building block for more secure programs, compared to conventional I/O library designs. Our study suggests that these features are indeed practicable and useful, and thus potentially promising for inclusion in other future language designs. It also sheds light on the value and cost of these features and suggests directions for future research on security-focused language design.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jennifer</first_name>
          <last_name>Fish</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>jenniferfish</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Darya</first_name>
          <last_name>Melicher</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://scholar.google.com/citations?user=KoIZBqwAAAAJ</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/daryamelicher/dd1aba2a-1ed3-43a6-ae6e-b9905a5a8bc2/small.jpg</picture_url>
          <person_id>daryamelicher</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>71ecd6c4-e3af-40a2-a2ae-32bf17e964d5</slot_id>
      <event_id>6cc1e9be-46b1-4962-9d3d-2920b847aea7</event_id>
      <title>Example-Based Live Programming for Everyone: Building Language-agnostic Tools for Live Programming with LSP and GraalVM</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>21:20</end_time>
      <description>Our community has explored various approaches to improve the programming experience. Although many of them, such as Example-based Live Programming (ELP), have shown to be effective, they are still not widespread in conventional programming environments. A reason for that is the effort required to provide sophisticated tools that rely on run-time information. To target multiple language ecosystems, it is often necessary to implement the same concepts, but for different languages and runtimes. Two emerging technologies present an opportunity to reduce this effort significantly: the Language Server Protocol (LSP) and language implementation frameworks such as GraalVM’s Truffle. In this paper, we show how an ELP system can be built in a language-agnostic way by leveraging these two technologies. Based on our approach, we implemented the Babylonian Programming system, an ELP system that has previously only been implemented for exploratory ecosystems. Our system, on the other hand, brings ELP for all languages supported by the GraalVM to Visual Studio Code (VS Code). Moreover, we outline what a language-agnostic infrastructure needs to provide and how the LSP could be extended to support ELP also independently from programming environments. Further, we demonstrate how our approach enables the use of ELP in the context of polyglot programming. We illustrate the consequences of our approach by discussing its advantages and limitations and by comparing the features of our system to other ELP systems. Moreover, we give an outlook of how tools that rely on run-time information could be built in the future. This in turn might motivate future tool builders and researchers to consider implementing more tools in a language-agnostic way from the start to make them available to a broader audience.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fabio</first_name>
          <last_name>Niephaus</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://fniephaus.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/fabioniephaus/44d2c4cc-3f4f-42d2-8496-ca7e59905dd3/small.jpg</picture_url>
          <person_id>fabioniephaus</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Rein</last_name>
          <affiliation>Hasso Plattner Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.patrickrein.de</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/patrickrein/0538cdc6-52aa-408d-9042-80e24d2f8260/small.jpg</picture_url>
          <person_id>patrickrein</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jakob</first_name>
          <last_name>Edding</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>jakobedding</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jonas</first_name>
          <last_name>Hering</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>jonashering</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Bastian</first_name>
          <last_name>König</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>bastiankonig</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Kolya</first_name>
          <last_name>Opahle</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>kolyaopahle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Nico</first_name>
          <last_name>Scordialo</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>nicoscordialo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Robert</first_name>
          <last_name>Hirschfeld</last_name>
          <affiliation>Hasso-Plattner-Institut (HPI), Germany</affiliation>
          <bio>Robert Hirschfeld is a Professor of Computer Science at the Hasso Plattner Institute at the University of Potsdam, Germany. There he founded and leads the Software Architecture Group which is concerned with fundamental elements and structures of software. Methods and tools are developed for improving the comprehension and design of complex and interesting systems. 
Robert is interested in programming experiences and small system kernels. With his group he is working on dynamic programming languages, development tools, and runtime environments to make interactive programming more approachable. His preferred environment for exploring ideas is Squeak/Smalltalk. 
He served as a visiting professor at the Tokyo Institute of Technology (東京工業大学) and The University of Tokyo (東京大学), Japan. 
Robert was a senior researcher with DoCoMo Euro-Labs, the European research facility of NTT DoCoMo Japan, where he worked on infrastructure components for next generation mobile communication systems with a focus on dynamic service adaptation and context-oriented programming. 
Prior to joining DoCoMo Euro-Labs, he was a principal engineer at Windward Solutions in Sunnyvale, California, where he designed and implemented distributed object systems, consulted in the area of object database technologies, and developed innovative software products and applications. 
Robert received a Ph.D. in Computer Science from the Ilmenau University of Technology, Germany.</bio>
          <homepage_url>http://www.hirschfeld.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/roberthirschfeld/994ef4df-a890-4f16-bc1b-73b117dab33c/small.jpg</picture_url>
          <person_id>roberthirschfeld</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a2e23d50-867d-44bb-914a-c709be7ed08b</slot_id>
      <event_id>71f0486c-4cb8-4129-bf78-31b62f01a30a</event_id>
      <title>End-User Software Customization by Direct Manipulation of Tabular Data</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>21:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>21:40</end_time>
      <description>Customizing software should be as easy as using it. But most customization methods require a dramatic shift from using a GUI to writing customization scripts in a programming language. 
We introduce data-driven customization, a new way for end users to extend software by direct manipulation without doing traditional programming. We augment existing user interfaces with a table view showing the structured data inside the application. When users edit the table, their changes are reflected in the original UI. This simple model accommodates a spreadsheet formula language and custom data editing widgets, providing enough power to implement a variety of useful extensions. 
We illustrate the approach with Wildcard, a browser extension that implements data-driven customization on the web using web scraping. Through concrete examples, we show that this paradigm can support useful extensions to many real websites, and we share reflections from our experiences using the tool. 
Finally, we share our broader vision for data-driven customization: a future where end users have greater access to the data inside their applications, and better tools for flexibly making use of that data in the context of everyday software usage.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Geoffrey</first_name>
          <last_name>Litt</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>geoffreylitt1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Jackson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/dnj/</homepage_url>
          <person_id>danieljackson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Millis</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>tylermillis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jessica</first_name>
          <last_name>Quaye</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>jessicaquaye</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>754af2bd-aa31-46ca-81b4-9a3eecc5dbe2</subevent_id>
    <title>SPLASH Onward! Essays: T-5-Onward</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-Onward-Essays</url>
    <url_link_display>Onward! Essays</url_link_display>
    <tracks>
      <track>Onward! Essays</track>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot>
      <slot_id>c84b5d6a-de77-43cc-b22b-daf4a293d9b9</slot_id>
      <title>Session: SPLASH Onward! Essays - T-5-Onward</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>15:00</start_time>
      <end_time>16:00</end_time>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8ee8b3b5-2a92-4df8-a405-f4727d7c8233</slot_id>
      <event_id>c93c5c4d-1a3f-4cef-b393-3e7e6bd8b067</event_id>
      <title>Software design as story telling -- Reflecting on the work of Italo Calvino</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>15:40</end_time>
      <description>What do software writers have in common with other professional writers? What can we software developers learn from professional writers? This paper proposes a reflection on such topics using as a reference the book “Six Memos for the Next Millennium”, a posthumous work by the Italian novelist, editor, and literary critic Italo Calvino. A comparison is drawn between such work and the current principles ruling how software should be written and developed, and a claim is made that this is an area worth further exploration.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paolo</first_name>
          <last_name>Ciancarini</last_name>
          <affiliation>University of Bologna</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.unibo.it/~cianca/</homepage_url>
          <person_id>paolociancarini</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sergey</first_name>
          <last_name>Masyagin</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>sergeymasyagin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Giancarlo</first_name>
          <last_name>Succi</last_name>
          <affiliation>Innopolis University</affiliation>
          <bio>undefined</bio>
          <person_id>giancarlosucci</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bf390b0c-6836-472a-a895-0648f3974d90</slot_id>
      <event_id>bd1659e4-ca0c-498d-a2c0-478c6c8c8f1d</event_id>
      <title>Natural Language Theory Meets Programming Language Theory: An Interdisciplinary Framework for Programming Language Evaluation</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>15:20</end_time>
      <description>Programming languages researchers make a variety of different kinds of claims about the design of languages and related tools and calculi. Each type of claim requires different kinds of reasons and evidence to justify. Claims regarding the aesthetics or elegance of a design, or its effects on people, are especially tricky to justify because they are less strictly defined and are subject to change depending on the exact audience. In this essay, we take an interdisciplinary approach to this problem by drawing on the fields of argument theory and rhetorical analysis to argue that programming languages researchers can provide reasons for their claims about effects on people by providing descriptions of specific features of their systems that support their claim. In order to demonstrate this framework, we show several examples of how this is already being practiced in some programming languages research, and conclude by calling for authors to provide descriptive evidence to bolster such claims and to frame and strengthen other evaluation methods such as user studies.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stefan K.</first_name>
          <last_name>Muller</last_name>
          <affiliation>Illinois Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~smuller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stefankmuller/db0c31ad-55ec-4010-948d-d405e6483cde/small.jpg</picture_url>
          <person_id>stefankmuller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hannah</first_name>
          <last_name>Ringler</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>hannahringler</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c8e99fb3-34b3-40c4-a283-3970090dc95e</slot_id>
      <event_id>c542014b-18d7-4287-87c7-d9a630060cef</event_id>
      <title>Analogy-Making as a Core Primitive in the Software Engineering Toolbox</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>16:00</end_time>
      <description>An analogy is an identification of structural similarities and correspondences between two objects. Computational models of analogy making have been studied extensively in the field of cognitive science to better understand high-level human cognition. For instance, Melanie Mitchell and Douglas Hofstadter sought to better understand high-level perception by developing the Copycat algorithm for completing analogies between letter sequences. In this paper, we argue that analogy making should be seen as a core primitive in software engineering. We motivate this argument by showing how complex software engineering problems such as program understanding and source-code transformation learning can be reduced to an instance of the analogy-making problem. We demonstrate this idea using Sifter, a new analogy-making algorithm suitable for software engineering applications that adapts and extends ideas from Copycat. In particular, Sifter reduces analogy-making to searching for a sequence of update rule applications. Sifter uses a novel representation for mathematical structures capable of effectively representing the wide variety of information embedded in software. We conclude by listing major areas of future work for Sifter and analogy-making in software engineering.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Sotoudeh</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://masot.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthewsotoudeh/32b819f5-05ef-4b0a-8a19-d59eed661278/small.jpg</picture_url>
          <person_id>matthewsotoudeh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aditya V.</first_name>
          <last_name>Thakur</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://thakur.cs.ucdavis.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adityavthakur/89eb0287-7273-4261-b8a5-47ccfc8799b0/small.jpg</picture_url>
          <person_id>adityavthakur</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>cdd02ae6-fb4f-489f-bf3f-2650787231ee</subevent_id>
    <title>PLATEAU: Role of Visualization</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-V</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/home/plateau-2020</url>
    <url_link_display>PLATEAU 2020</url_link_display>
    <tracks>
      <track>PLATEAU 2020</track>
    </tracks>
    <timeslot>
      <slot_id>57817560-d1ab-443b-9d81-c14dcb9007a1</slot_id>
      <title>Session: PLATEAU - Role of Visualization</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/20</date>
      <start_time>13:30</start_time>
      <end_time>14:40</end_time>
      <tracks>
        <track>PLATEAU 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0979b060-a60b-47a1-ab9a-0b2406d6ab0f</slot_id>
      <event_id>5742d62b-4d30-4b3f-a547-b9e3b332224b</event_id>
      <title>The Essence of Program Semantics Visualizers: A Three-Axis Model</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/20</date>
      <start_time>13:30</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>14:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Josh</first_name>
          <last_name>Pollock</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://joshmpollock.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joshpollock/03037e72-2932-4ed1-8666-41a19597e24a/small.jpg</picture_url>
          <person_id>joshpollock</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Grace</first_name>
          <last_name>Oh</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>graceoh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eunice</first_name>
          <last_name>Jun</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>eunicejun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Philip</first_name>
          <last_name>Guo</last_name>
          <affiliation>University of California San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pgbovine.net</homepage_url>
          <person_id>philipguo1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Tatlock</last_name>
          <affiliation>University of Washington, Seattle</affiliation>
          <bio>Associate Professor at the University of Washington</bio>
          <homepage_url>https://ztatlock.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zacharytatlock/87af1196-2d8d-4bd5-a692-018d3939a00f/small.jpg</picture_url>
          <person_id>zacharytatlock</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLATEAU 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>100ffe01-85ad-4a02-81ad-dc11b49c9dea</slot_id>
      <event_id>8bd4d37f-90a0-4d74-ba19-8b17f05ef6a5</event_id>
      <title>How to make program understanding tools more programmer-friendly?</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/20</date>
      <start_time>14:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>14:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shraddha</first_name>
          <last_name>Barke</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>shraddhabarke</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLATEAU 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>67afe3b1-1b3f-41b8-aa98-1045d1b66de6</slot_id>
      <event_id>9044b999-9e70-41a4-9f12-34a61de0a815</event_id>
      <title>Documentation Generation as Information Visualization</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/20</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>14:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Will</first_name>
          <last_name>Crichton</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://willcrichton.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/willcrichton/03949743-0d45-4f73-9496-b6ab65dc7f5c/small.jpg</picture_url>
          <person_id>willcrichton</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLATEAU 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>dac28683-2f77-4af6-ae7a-10fb4981b791</subevent_id>
    <title>SPLASH -E: Lightning Talks and Discussion</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-SPLASH-E</url>
    <url_link_display>SPLASH-E</url_link_display>
    <tracks>
      <track>SPLASH-E</track>
    </tracks>
    <timeslot>
      <slot_id>66d7f1bb-9bc6-4f11-b503-0e536e111574</slot_id>
      <title>Session: SPLASH -E - Lightning Talks and Discussion</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/20</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>67c1bc95-3294-484c-9036-525131de9cea</subevent_id>
    <title>SPLASH Onward! Essays: T-4-Onward</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-Onward-Essays</url>
    <url_link_display>Onward! Essays</url_link_display>
    <tracks>
      <track>Onward! Essays</track>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot>
      <slot_id>bc56fe49-591e-4e9e-98d9-59f038d491ed</slot_id>
      <title>Session: SPLASH Onward! Essays - T-4-Onward</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>01:00</start_time>
      <end_time>02:00</end_time>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>00372e53-0551-49e0-af32-774fa48df6b3</slot_id>
      <event_id>185d56d8-71e8-445f-8ca3-ecfe421bd8c0</event_id>
      <title>Intrepydd: Performance, Productivity and Portability for Data Science Application Kernels</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:40</end_time>
      <description>Major simultaneous disruptions are now under way in both hardware and software. In hardware, ``extreme heterogeneity'' has become critical to sustaining cost and performance improvements after Moore’s Law, but poses productivity and portability challenges for developers. In software, the rise of large-scale data science is driven by developers who come from diverse backgrounds and, moreover, who demand the rapid prototyping and interactive-notebook capabilities of high-productivity languages like Python. 
We introduce the Intrepydd programming system, which enables data scientists to write application {\em kernels} with high performance, productivity, and portability on current and future hardware. Intrepydd is based on Python, though the approach can be applied to other base languages as well. To deliver high performance, the Intrepydd toolchain uses ahead-of-time (AOT) compilation and high-level compiler optimizations of Intrepydd kernels. Intrepydd achieves portability by its ability to compile kernels in different modes for execution on different hardware platforms, and for invocation from Python or C++ main programs. 
An empirical evaluation shows significant performance improvements relative to Python, and the suitability of Intrepydd for mapping on to post-Moore accelerators and architectures with relative ease. In summary, we believe that Intrepydd represents a new direction of ``Discipline-Aware Languages'' (DiALs), which brings us closer to the holy grail of obtaining productivity and portability with higher performance than current Python-like languages, and with more generality than current domain-specific languages and libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tong</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>My research tries to improve the correctness and performance of softwares by making better compiler and runtime systems.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/tongzhou/9d2400c2-f3c2-465c-bc3f-7627bbae5555/small.jpg</picture_url>
          <person_id>tongzhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jun</first_name>
          <last_name>Shirako</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>junshirako1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anirudh</first_name>
          <last_name>Jain</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>anirudhjain</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sriseshan</first_name>
          <last_name>Srikanth</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>sriseshansrikanth</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Conte</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>thomasconte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Richard</first_name>
          <last_name>Vuduc</last_name>
          <affiliation>Georgia Tech</affiliation>
          <bio>See website</bio>
          <homepage_url>https://vuduc.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/richardvuduc/18a7667a-ab20-4ff4-b4ea-8f1f95f6abff/small.jpg</picture_url>
          <person_id>richardvuduc</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Vivek</first_name>
          <last_name>Sarkar</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>Vivek Sarkar is Chair of the School of Computer Science and the Stephen Fleming Chair for Telecommunications in the College of Computing at Georgia Institute of Technology. He conducts research in multiple aspects of programmability and productivity in parallel computing, including programming languages, compilers, runtime systems, and debuggers for parallel, heterogeneous, and high-performance computer systems. 
Sarkar started his career in IBM Research after obtaining his Ph.D. from Stanford University, supervised by John Hennessy. His research projects at IBM include the PTRAN automatic parallelization system led by Fran Allen, the ASTI optimizer for IBM’s XL Fortran product compilers, the open-source Jikes Research Virtual Machine for the Java language, and the X10 programming language developed in the DARPA HPCS program. He was a member of the IBM Academy of Technology during 1995-2007. After moving to academia, Sarkar has mentored over 30 Ph.D. students and postdoctoral researchers in the Habanero Extreme Scale Software Research Laboratory, first at Rice University since 2007, and now at Georgia Tech since 2017. Researchers in his lab have developed the Habanero-C/C++ and Habanero-Java programming systems for parallel, heterogeneous, and distributed platforms. While at Rice, Sarkar was the E.D. Butcher Chair in Engineering, served as Chair of the Department of Computer Science, created a new sophomore-level course on the fundamentals of parallel programming, as well as a three-course Coursera specialization on parallel, concurrent, and distributed programming. 
Sarkar is an ACM Fellow and an IEEE Fellow. He has been serving as a member of the US Department of Energy’s Advanced Scientific Computing Advisory Committee (ASCAC) since 2009, and on CRA’s Board of Directors since 2015. He is also the recipient of the 2020 ACM-IEEE CS Ken Kennedy Award.</bio>
          <homepage_url>http://vsarkar.cc.gatech.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/viveksarkar1/a34d5fee-4238-404c-a8b1-6de976f74890/small.jpg</picture_url>
          <person_id>viveksarkar1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2e5f96d2-0379-43f9-bf66-7dd4e161653e</slot_id>
      <event_id>de7f53dd-f844-4b70-b3c5-5ce2c614266b</event_id>
      <title>Notes on Notebooks: Is Jupyter the Bringer of Jollity?</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:20</end_time>
      <description>As the interactive computational notebook becomes a more prominent code development medium, we examine advantages and disadvantages of this particular source code format. We formally specify the structure of a coding notebook layout. We describe complexities in notebook programming; some of these are incidental whereas others may be inherent complexities. We outline how we envisage research and development might proceed to advance the cause of notebook programming.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Singer</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~jsinger</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeremysinger/14db1542-37ba-4e0e-b338-e3a952991f1a/small.jpg</picture_url>
          <person_id>jeremysinger</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4f56dca4-18c1-409a-a08e-fa841557f754</slot_id>
      <event_id>2f305d32-0104-451e-9df8-c32c270e49fd</event_id>
      <title>A principled approach to REPL interpreters</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>02:00</end_time>
      <description>Read-eval-print-loops (REPLs) allow programmers to test out snippets of code, explore APIs, or even incrementally construct code, and get immediate feedback on their actions. However, even though many languages provide a REPL, the relation between the language as is and what is accepted at the REPL prompt is not always well-defined. Furthermore, implementing a REPL for new languages, such as DSLs, may incur significant language engineering cost. 
In this paper we survey the domain of REPLs and investigate the (formal) principles underlying REPLs. We identify and define the class of sequential languages, which admit a sound REPL implementation based on a definitional interpreter, and present design guidelines for extending existing language implementations to support REPL-style interfaces (including computational notebooks). The obtained REPLs can then be generically turned into an exploring interpreter, to allow exploration of the user’s interaction. 
The approach is illustrated using three case studies, based on MiniJava, QL (a DSL for questionnaires), and eFLINT (a DSL for normative rules). We expect sequential languages, and the consequent design principles, to be stepping stones towards a better understanding of the essence of REPLs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>L. Thomas</first_name>
          <last_name>van Binsbergen</last_name>
          <affiliation>Centrum Wiskunde &amp; Informatica</affiliation>
          <bio>Thomas van Binsbergen is designing and implementing domain-specific languages for the formal specification of norms from a variety of sources such as laws, regulations, policies, contracts and codes of conduct. The resulting formalizations are used in policy-enhanced, distributed software architectures for data sharing. By ensuring compliance with the formalized norms, such systems reduce the risk of violating regulations and add value by increasing the trust in sharing activities. 
The SSPDDP project is a collaboration between the knowledge institutes UvA, CWI and VU and the industrial partners ABN AMRO, ING and KLM to develop secure and scalable techniques for policy-enforced data sharing. The project investigates fundamental research questions to develop future-proof, cryptographic solutions to secure and trustworthy data sharing, automatic policy enforcement in distributed systems and bringing the aforementioned data sharing methods to scale. Besides being academically relevant, the outcomes of these investigations suggest a principled, sound and pragmatic mode of operation that can add value to the industry partners in several ways. 
In the past, Van Binsbergen has developed modular techniques for describing the semantics of programming languages as part of the PLanCompS project with Peter Mosses and parser combinators for generalised top-down parsing with Adrian Johnstone and Elizabeth Scott. The results are described in his PhD thesis titled “Executable Formal Specification of Programming Languages with Reusable Components” (http://ltvanbinsbergen.nl/thesis/thesis.pdf). 
Keywords: modular language definition, domain-specific languages, formal specification, modelling languages, policy-enhanced data-sharing, generalised top-down parsing, declarative programming, purely functional programming, I-MSOS, FunCons, attribute grammars, computer science education</bio>
          <homepage_url>http://ltvanbinsbergen.nl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lthomasvanbinsbergen/b276e9a4-2229-45a7-ae0f-e25fb729b0e6/small.jpg</picture_url>
          <person_id>lthomasvanbinsbergen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mauricio</first_name>
          <last_name>Verano Merino</last_name>
          <affiliation>Technische Universiteit Eindhoven</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://maveme.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mauricioveranomerino/e4a3ec56-b66f-4885-9989-c4a230e08446/small.jpg</picture_url>
          <person_id>mauricioveranomerino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pierre</first_name>
          <last_name>Jeanjean</last_name>
          <affiliation>Inria, Univ Rennes, CNRS, IRISA</affiliation>
          <bio>undefined</bio>
          <person_id>pierrejeanjean</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tijs</first_name>
          <last_name>van der Storm</last_name>
          <affiliation>CWI &amp; University of Groningen, Netherlands</affiliation>
          <bio>Tijs van der Storm is senior researcher in the Software Analysis and Transformation (SWAT) group at Centrum Wiskunde &amp;amp; Informatica (CWI) in Amsterdam, and full professor in Software Engineering at the University of Groningen in Groningen. His research focuses on improving programmer experience through new and better software languages and developing the tools and techniques to engineer them in a modular and interactive fashion.</bio>
          <homepage_url>http://www.cwi.nl/~storm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tijsvanderstorm/1c2fdfb2-3ce0-4e75-91af-35d9a48f56c5/small.jpg</picture_url>
          <person_id>tijsvanderstorm</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Barais</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>olivierbarais1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>053aaf36-b1d8-41a6-9234-fe95a3124c1f</subevent_id>
    <title>PLATEAU: Domain-Specific Languages and Tools	</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-V</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/home/plateau-2020</url>
    <url_link_display>PLATEAU 2020</url_link_display>
    <tracks>
      <track>PLATEAU 2020</track>
    </tracks>
    <timeslot>
      <slot_id>dfb69f50-2791-4ce3-9795-be399a5109dc</slot_id>
      <title>Session: PLATEAU - Domain-Specific Languages and Tools	</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/20</date>
      <start_time>12:00</start_time>
      <end_time>13:20</end_time>
      <tracks>
        <track>PLATEAU 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5853abf4-a510-4162-a3e2-4e952641fb61</slot_id>
      <event_id>0bfccc38-4a2e-4ea8-bdae-b3749f06c298</event_id>
      <title>Welcome!</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/20</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Co-chair</role>
          <sort_key>1</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Sunshine</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jssunshi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joshuasunshine/474067e5-86e8-476c-9622-5c89be145f4b/small.jpg</picture_url>
          <person_id>joshuasunshine</person_id>
        </person>
        <person>
          <role>Co-chair</role>
          <sort_key>2</sort_key>
          <first_name>Elena</first_name>
          <last_name>Glassman</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>Elena Glassman is a the Stanley A. Marks and William H. Marks Assistant Professor at the Radcliffe Institute and a professor of computer science at the Harvard Paulson School of Engineering and Applied Sciences specializing in human-computer interaction. She designs, builds and evaluates systems for comprehending and interacting with intelligent systems and population-level structure in large code and data corpora. Prior to joining Harvard as an assistant professor, Glassman earned BS, MEng and PhD degrees from MIT EECS and served as a postdoctoral scholar at the University of California, Berkeley EECS department and Berkeley Institute for Design.</bio>
          <homepage_url>http://glassmanlab.seas.harvard.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elenaglassman/4951972c-4212-4bfb-9e7a-bdaefbf84466/small.jpg</picture_url>
          <person_id>elenaglassman</person_id>
        </person>
        <person>
          <role>Co-chair</role>
          <sort_key>3</sort_key>
          <first_name>Sarah E.</first_name>
          <last_name>Chasins</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.eecs.berkeley.edu/~schasins/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sarahchasins/11334835-84ec-45c0-8ba1-2b87910eb7f7/small.jpg</picture_url>
          <person_id>sarahchasins</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLATEAU 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>58a42fe4-3296-4a74-ba9c-83a8fbb7f3ec</slot_id>
      <event_id>0d804ea2-8442-41c6-9e0f-81b8d5e82463</event_id>
      <title>The IoT Codex: A Book of Paper Engineering Techniques for Authoring and Composing Embedded Computing Applications</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/20</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>13:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kristin</first_name>
          <last_name>Williams</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>kristinwilliams</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLATEAU 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ab71b217-f5ad-4c9e-b39d-ca156033e6c4</slot_id>
      <event_id>41232bd1-63c1-48c7-808d-a428d60b3cbd</event_id>
      <title>Static Analysis for Safer Notebook Interactions</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/20</date>
      <start_time>12:10</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>12:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Macke</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>stephenmacke</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hongpu</first_name>
          <last_name>Gong</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>hongpugong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Doris</first_name>
          <last_name>Lee</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>dorislee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Head</last_name>
          <affiliation>UC Berkeley</affiliation>
          <bio>Andrew studies computer science as a PhD candidate at UC Berkeley. He dreams of a future where rediscovery is a thing of the past, because people readily share the lessons they learn in their everyday life. He has built and studied software development tools with software engineering research teams at Google and Microsoft Research. His work appears at top academic conferences in software engineering and human-computer interaction including CHI and ICSE.</bio>
          <homepage_url>http://andrewhead.info</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andrewhead/43940666-a935-4e63-abdc-50a2f1d01c86/small.jpg</picture_url>
          <person_id>andrewhead</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Doris</first_name>
          <last_name>Xin</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>dorisxin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Aditya</first_name>
          <last_name>Parameswaran</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>adityaparameswaran</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLATEAU 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ccfe1e9d-37a5-485e-b25a-e0219562c099</slot_id>
      <event_id>71955868-7f3a-49ec-a276-d4b9ab6784f4</event_id>
      <title>Lightening the Cognitive Load of Shell Programming</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/20</date>
      <start_time>12:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>13:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ishaan</first_name>
          <last_name>Gandhi</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>ishaangandhi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anshula</first_name>
          <last_name>Gandhi</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>anshulagandhi</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLATEAU 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d2e88b59-4a10-4cdc-b081-2ffd9655c4f6</subevent_id>
    <title>SPLASH Onward! Papers: T-2-Onward</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
      <track>Onward! Essays</track>
    </tracks>
    <timeslot>
      <slot_id>22f6c68e-4ff2-4a08-b80e-cc8da6a9a274</slot_id>
      <title>Session: SPLASH Onward! Papers - T-2-Onward</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0a8381ee-b72f-4944-a709-78625ade2338</slot_id>
      <event_id>71f0486c-4cb8-4129-bf78-31b62f01a30a</event_id>
      <title>End-User Software Customization by Direct Manipulation of Tabular Data</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>09:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>09:40</end_time>
      <description>Customizing software should be as easy as using it. But most customization methods require a dramatic shift from using a GUI to writing customization scripts in a programming language. 
We introduce data-driven customization, a new way for end users to extend software by direct manipulation without doing traditional programming. We augment existing user interfaces with a table view showing the structured data inside the application. When users edit the table, their changes are reflected in the original UI. This simple model accommodates a spreadsheet formula language and custom data editing widgets, providing enough power to implement a variety of useful extensions. 
We illustrate the approach with Wildcard, a browser extension that implements data-driven customization on the web using web scraping. Through concrete examples, we show that this paradigm can support useful extensions to many real websites, and we share reflections from our experiences using the tool. 
Finally, we share our broader vision for data-driven customization: a future where end users have greater access to the data inside their applications, and better tools for flexibly making use of that data in the context of everyday software usage.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Geoffrey</first_name>
          <last_name>Litt</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>geoffreylitt1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Jackson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/dnj/</homepage_url>
          <person_id>danieljackson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Millis</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>tylermillis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jessica</first_name>
          <last_name>Quaye</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>jessicaquaye</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1abe9e3b-34f7-4814-8248-b58d0f57ec45</slot_id>
      <event_id>6cc1e9be-46b1-4962-9d3d-2920b847aea7</event_id>
      <title>Example-Based Live Programming for Everyone: Building Language-agnostic Tools for Live Programming with LSP and GraalVM</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>09:20</end_time>
      <description>Our community has explored various approaches to improve the programming experience. Although many of them, such as Example-based Live Programming (ELP), have shown to be effective, they are still not widespread in conventional programming environments. A reason for that is the effort required to provide sophisticated tools that rely on run-time information. To target multiple language ecosystems, it is often necessary to implement the same concepts, but for different languages and runtimes. Two emerging technologies present an opportunity to reduce this effort significantly: the Language Server Protocol (LSP) and language implementation frameworks such as GraalVM’s Truffle. In this paper, we show how an ELP system can be built in a language-agnostic way by leveraging these two technologies. Based on our approach, we implemented the Babylonian Programming system, an ELP system that has previously only been implemented for exploratory ecosystems. Our system, on the other hand, brings ELP for all languages supported by the GraalVM to Visual Studio Code (VS Code). Moreover, we outline what a language-agnostic infrastructure needs to provide and how the LSP could be extended to support ELP also independently from programming environments. Further, we demonstrate how our approach enables the use of ELP in the context of polyglot programming. We illustrate the consequences of our approach by discussing its advantages and limitations and by comparing the features of our system to other ELP systems. Moreover, we give an outlook of how tools that rely on run-time information could be built in the future. This in turn might motivate future tool builders and researchers to consider implementing more tools in a language-agnostic way from the start to make them available to a broader audience.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fabio</first_name>
          <last_name>Niephaus</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://fniephaus.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/fabioniephaus/44d2c4cc-3f4f-42d2-8496-ca7e59905dd3/small.jpg</picture_url>
          <person_id>fabioniephaus</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Rein</last_name>
          <affiliation>Hasso Plattner Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.patrickrein.de</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/patrickrein/0538cdc6-52aa-408d-9042-80e24d2f8260/small.jpg</picture_url>
          <person_id>patrickrein</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jakob</first_name>
          <last_name>Edding</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>jakobedding</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jonas</first_name>
          <last_name>Hering</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>jonashering</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Bastian</first_name>
          <last_name>König</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>bastiankonig</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Kolya</first_name>
          <last_name>Opahle</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>kolyaopahle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Nico</first_name>
          <last_name>Scordialo</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>nicoscordialo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Robert</first_name>
          <last_name>Hirschfeld</last_name>
          <affiliation>Hasso-Plattner-Institut (HPI), Germany</affiliation>
          <bio>Robert Hirschfeld is a Professor of Computer Science at the Hasso Plattner Institute at the University of Potsdam, Germany. There he founded and leads the Software Architecture Group which is concerned with fundamental elements and structures of software. Methods and tools are developed for improving the comprehension and design of complex and interesting systems. 
Robert is interested in programming experiences and small system kernels. With his group he is working on dynamic programming languages, development tools, and runtime environments to make interactive programming more approachable. His preferred environment for exploring ideas is Squeak/Smalltalk. 
He served as a visiting professor at the Tokyo Institute of Technology (東京工業大学) and The University of Tokyo (東京大学), Japan. 
Robert was a senior researcher with DoCoMo Euro-Labs, the European research facility of NTT DoCoMo Japan, where he worked on infrastructure components for next generation mobile communication systems with a focus on dynamic service adaptation and context-oriented programming. 
Prior to joining DoCoMo Euro-Labs, he was a principal engineer at Windward Solutions in Sunnyvale, California, where he designed and implemented distributed object systems, consulted in the area of object database technologies, and developed innovative software products and applications. 
Robert received a Ph.D. in Computer Science from the Ilmenau University of Technology, Germany.</bio>
          <homepage_url>http://www.hirschfeld.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/roberthirschfeld/994ef4df-a890-4f16-bc1b-73b117dab33c/small.jpg</picture_url>
          <person_id>roberthirschfeld</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1df791d7-3361-4555-b145-469145d3cd4e</slot_id>
      <event_id>61a0b3ff-079e-4f32-b965-6212b38b01cc</event_id>
      <title>Discussion of Aviation Software Oversight Improvement</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>10:00</end_time>
      <description>The certification of US aviation software is described and critiqued. Flight critical software certification and regulation need external academic review and intervention. Industry is driven to generate profits over prioritizing concerns for public safety and has failed at developing adequately proven methods of certifying that flight critical software is safe to deploy. 
Disclaimer: The opinions expressed in this work are the views of the author and do not reflect the official policy or position of any agency of the U.S. government.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marc</first_name>
          <last_name>Ronell</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>marcronell</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>49ff881c-c9cf-48f1-b80d-e960c1d4293f</slot_id>
      <event_id>f5df0dfc-f912-43a8-ab3d-e57ff4e3846c</event_id>
      <title>A Case Study in Language-Based Security: Building an I/O Library for Wyvern</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>10:20</end_time>
      <description>As the impact of vulnerabilities increases in practice, it is imperative for programming languages to include security as a first-class design consideration. While a number of security-related language features have been proposed to address this need, in many cases, we do not know enough about whether it is practical and useful to build software systems in languages with these features. 
In this paper, we begin to investigate this question, using a case study methodology. The setting of our case study is Wyvern, a recently designed language we selected because it incorporates three advanced security-related features: capability safety for enforcing the principle of least privilege, an effect system for tracking the secure use of resources, and a language extension feature that mitigates command injection. In our case study, we built a small standard I/O library, seeking to use the new language features to create a library that is less vulnerable to misuse and can serve as a building block for more secure programs, compared to conventional I/O library designs. Our study suggests that these features are indeed practicable and useful, and thus potentially promising for inclusion in other future language designs. It also sheds light on the value and cost of these features and suggests directions for future research on security-focused language design.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jennifer</first_name>
          <last_name>Fish</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>jenniferfish</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Darya</first_name>
          <last_name>Melicher</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://scholar.google.com/citations?user=KoIZBqwAAAAJ</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/daryamelicher/dd1aba2a-1ed3-43a6-ae6e-b9905a5a8bc2/small.jpg</picture_url>
          <person_id>daryamelicher</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>31370849-9eba-4f86-ad71-aebda7f4e46d</subevent_id>
    <title>SPLASH -E: Panel</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-SPLASH-E</url>
    <url_link_display>SPLASH-E</url_link_display>
    <tracks>
      <track>SPLASH-E</track>
    </tracks>
    <timeslot>
      <slot_id>2e50aa3c-8987-4e73-a2b6-bd1aed9d0e5e</slot_id>
      <title>Session: SPLASH -E - Panel</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/20</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>40feb7b0-a357-4bea-99d5-718427877a5c</slot_id>
      <event_id>f4b78b53-dc15-4dfe-aa1e-f67b22f3e263</event_id>
      <title>Panel Discussion</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/20</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>14:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3ede0efe-3df1-4701-8487-c6646865172f</subevent_id>
    <title>LPOP: 14:25-- Logic and Language Expressiveness</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/home/lpop-2020</url>
    <url_link_display>Logic and Practice of Programming (LPOP) 2020</url_link_display>
    <tracks>
      <track>Logic and Practice of Programming (LPOP) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>620525f2-e33c-414c-9e07-4c1f856948f6</slot_id>
      <title>Session: LPOP - 14:25-- Logic and Language Expressiveness</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Peter</first_name>
          <last_name>Van Roy</last_name>
          <affiliation>Université catholique de Louvain</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.info.ucl.ac.be/~pvr/pldc.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/petervanroy/d483fce0-cfeb-405b-b540-a48b942e9315/small.jpg</picture_url>
          <person_id>petervanroy</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3cd7a50b-b780-41d5-a849-49cffe1dec87</slot_id>
      <event_id>ab65d889-3a41-4312-b2ee-9fa0ceb1f960</event_id>
      <title>Logical English</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>15:05</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>15:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Kowalski</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/robertkowalski/77be6e32-f9d1-4dec-9696-a25c3429e505/small.jpg</picture_url>
          <person_id>robertkowalski</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cc041470-1f3c-4d8e-8b6d-bfcb33a9d0c1</slot_id>
      <event_id>79664896-2100-4fa7-8fa9-e9895aa22be1</event_id>
      <title>Invited Talk: From CLP(R) to MiniZinc: There and Back Again</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>14:25</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>15:05</end_time>
      <description>Constraint logic programming (CLP) was a revolution in declarative programming showing how we could answer very interesting and complex questions by a combination of programmed search and constraint solving. But constraint programming (CP) moved away from its logic programming roots to concentrate on modelling, simply specifying a system of constraints, in the process losing the ability to do complex meta-search. MiniZinc is one of the leading constraint programming modelling languages. It was originally designed to tackle complex CP problems, typically small systems of complex constraints. But its uses have changed, often it is used to solve very large systems of simple constraints. This meant that many of the original assumptions in the design of MiniZinc are invalid. In this talk we will examine a new architecture for MiniZinc, which uses constraint solving for model optimization, and includes incremental solving and backtracking. In some sense the new architecture makes MiniZinc a CLP system, bringing us back to the roots of the field. 
This is joint work with Guido Tack, Graeme Gange, and Jip Dekker.</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Peter</first_name>
          <last_name>Stuckey</last_name>
          <affiliation>University of Melbourne</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/peterstuckey/f24f0191-cf04-4f91-beb7-49f07cbc987c/small.jpg</picture_url>
          <person_id>peterstuckey</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e378964c-e76b-4e6a-b741-587d994e8944</slot_id>
      <event_id>b5b4b8c0-16b9-4e72-89ca-2f5d01468a9b</event_id>
      <title>Flamingo, a Compiler and Runtime for Reactive ALM Systems</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>15:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Hines</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/danielhines/460234f5-b5cb-4ea2-9c87-b6c1b2c98edc/small.jpg</picture_url>
          <person_id>danielhines</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ff9621f9-8b48-4132-add1-08bcd8fbf8f2</slot_id>
      <event_id>e61837ab-b308-451c-befa-d24a099f8882</event_id>
      <title>Panel: Since Logic Languages Are So Good, Why Aren’t They Pervasive?</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>15:30</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>16:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Panelist</role>
          <sort_key>1</sort_key>
          <first_name>Peter</first_name>
          <last_name>Stuckey</last_name>
          <affiliation>University of Melbourne</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/peterstuckey/f24f0191-cf04-4f91-beb7-49f07cbc987c/small.jpg</picture_url>
          <person_id>peterstuckey</person_id>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>2</sort_key>
          <first_name>Robert</first_name>
          <last_name>Kowalski</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/robertkowalski/77be6e32-f9d1-4dec-9696-a25c3429e505/small.jpg</picture_url>
          <person_id>robertkowalski</person_id>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>3</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Hines</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/danielhines/460234f5-b5cb-4ea2-9c87-b6c1b2c98edc/small.jpg</picture_url>
          <person_id>danielhines</person_id>
        </person>
        <person>
          <role>Chair</role>
          <sort_key>4</sort_key>
          <first_name>David</first_name>
          <last_name>Warren</last_name>
          <affiliation>Stony Brook University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidwarren/b04656c2-bfa4-4548-86ae-d465920ced13/small.jpg</picture_url>
          <person_id>davidwarren</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5482c6bd-0f31-4077-8c1a-2cb8cd28954f</subevent_id>
    <title>SPLASH Doctoral Symposium: Slot 5</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-VI</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-Doctoral-Symposium</url>
    <url_link_display>Doctoral Symposium</url_link_display>
    <tracks>
      <track>Doctoral Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>0c9ce40b-72b9-4251-a896-a21c37e13939</slot_id>
      <title>Session: SPLASH Doctoral Symposium - Slot 5</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/20</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Yvonne</first_name>
          <last_name>Coady</last_name>
          <affiliation>University of Victoria</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/yvonnecoady/7b532c8e-0c31-445d-b943-ad956a6f5722/small.jpg</picture_url>
          <person_id>yvonnecoady</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6d0e4556-e68f-4bfa-bbdc-408eaca28bb6</slot_id>
      <event_id>46ed0ac9-6479-4e86-98e1-96946c81e54e</event_id>
      <title>Closing</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/20</date>
      <start_time>16:15</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>16:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Co-chair</role>
          <sort_key>1</sort_key>
          <first_name>Nafise</first_name>
          <last_name>Eskandani Masoule</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.stg.tu-darmstadt.de/staff/nafise_eskandani</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nafiseeskandanimasoule/6eac9bf0-bfcf-4440-ba06-24fa9145cb4e/small.jpg</picture_url>
          <person_id>nafiseeskandanimasoule</person_id>
        </person>
        <person>
          <role>Co-chair</role>
          <sort_key>2</sort_key>
          <first_name>Yvonne</first_name>
          <last_name>Coady</last_name>
          <affiliation>University of Victoria</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/yvonnecoady/7b532c8e-0c31-445d-b943-ad956a6f5722/small.jpg</picture_url>
          <person_id>yvonnecoady</person_id>
        </person>
        <person>
          <role>Co-chair</role>
          <sort_key>3</sort_key>
          <first_name>Philipp</first_name>
          <last_name>Dominik Schubert</last_name>
          <affiliation>Heinz Nixdorf Institut, Paderborn University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://it-schubert.com/philipp/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippdominikschubert/3e920a42-6541-44bd-90ee-89428b6f2438/small.jpg</picture_url>
          <person_id>philippdominikschubert</person_id>
        </person>
        <person>
          <role>Co-chair</role>
          <sort_key>4</sort_key>
          <first_name>Chengsong</first_name>
          <last_name>Tan</last_name>
          <affiliation>King's College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kclpure.kcl.ac.uk/portal/en/persons/chengsong-tan(a63b381b-04bc-4cd7-beea-beb3e96cb153).html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/chengsongtan/d642cd16-c06d-41c2-abd0-f3fe54175174/small.jpg</picture_url>
          <person_id>chengsongtan</person_id>
        </person>
        <person>
          <role>Co-chair</role>
          <sort_key>5</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Hauswirth</last_name>
          <affiliation>Università della Svizzera italiana</affiliation>
          <bio>I am an Associate-Professor at the USI (Università della Svizzera italiana) in Lugano, Switzerland. 
At USI I am heading Luce, the Lugano Computing Education research lab (http://luce.inf.usi.ch/) where we study how people learn to program and how to improve that learning process. I am a member of the program committee of the Swiss national program to train existing high school teachers to teach the new mandatory informatics course (https://www3.unifr.ch/gyminf/) and I am co-directing a similar state-wide program in Ticino. 
As part of my lab’s work on conceptual change in learning to program, we contribute to the growing repository of programming misconceptions at (https://progmiscon.org). Amongst other things, that repository maps misconceptions to features of specific programming languages, with links to the corresponding sections of the official language specifications.</bio>
          <homepage_url>http://www.inf.usi.ch/faculty/hauswirth/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthiashauswirth/2f29d37f-4c84-49d3-a27d-7e3909177c4c/small.jpg</picture_url>
          <person_id>matthiashauswirth</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>87017c2c-62c5-4758-8ab9-fa49ae2f86fa</slot_id>
      <event_id>fbeea91c-d16d-473a-85f5-768ee28c964c</event_id>
      <title>Round up by the academic panel</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/20</date>
      <start_time>16:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>16:15</end_time>
      <description>undefined</description>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8c76c7b2-f9cd-4e6c-ad0c-c302f1fdde72</slot_id>
      <event_id>a8b15d43-8a0f-4bc2-88c7-0cbe27f6ebfb</event_id>
      <title>Metamorphic Testing of Android Graphics Drivers [Invited Talk]</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/20</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>16:00</end_time>
      <description>Graphics drivers are hard to build and hard to test, yet their correct operation is critical: a mobile device that is functioning perfectly well with the exception of its display is not very useful! In this talk I will describe our experience building and using GraphicsFuzz, an automated testing tool for graphics drivers based on metamorphic testing. 
GraphicsFuzz originated as a research project at Imperial College London, which led to the GraphicsFuzz spin-out company that was acquired by Google in 2018. GraphicsFuzz is now a central line of defence in ensuring the quality of graphics drivers for the Android platform. GraphicsFuzz focuses on finding bugs in shader compilers. GraphicsFuzz automatically finds cases where a shader compiler has generated wrong code by: 
 
  starting with an original, high-value shader (e.g. captured from a game);  
  applying semantics-preserving transformations to this original shader to produce a family of equivalent shaders that should render identical or very similar images to the original shader when executed on the same GPU;  
  calling out compiler bugs by identifying significant mismatch between images;  
  homing in on the root causes of bugs by automatically reducing a transformed shader for which a mismatch occurs until the difference between the original and transformed shaders is as small as possible whilst still preserving the mismatch.  
 
As well as providing technical details of how the approach works and showcasing some example bugs found by the technique, I will discuss some of the main open problems and opportunities related to applying metamorphic testing automatically at scale, including how to cope with potential false alarms related to round-off error associated with floating-point computation, how to automatically triage and de-duplicate bug reports, and how to test the metamorphic testing tool itself.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alastair</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d2a04d96-903e-4f10-8430-b35ce5c351cc</subevent_id>
    <title>SPLASH Student Research Competition: Student Research Competition Posters Mirror</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-VII</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-SRC</url>
    <url_link_display>Student Research Competition</url_link_display>
    <tracks>
      <track>Student Research Competition</track>
    </tracks>
    <timeslot>
      <slot_id>195e7cfe-fbc7-4be5-a4b1-28f762498db5</slot_id>
      <title>Session: SPLASH Student Research Competition - Student Research Competition Posters Mirror</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/18</date>
      <start_time>00:20</start_time>
      <end_time>01:00</end_time>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0bd561b4-6549-4364-9804-cee117e535cf</slot_id>
      <event_id>4c9e9502-89a1-4941-9c83-fd714440fc57</event_id>
      <title>Design and Implementation of a Gradual Verifier</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/18</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mona</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Columbia University</affiliation>
          <bio>undefined</bio>
          <person_id>monazhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jacob</first_name>
          <last_name>Gorenburg</last_name>
          <affiliation>Haverford College</affiliation>
          <bio>undefined</bio>
          <person_id>jacobgorenburg</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3b7f2558-9d04-4c88-af77-043840569062</slot_id>
      <event_id>0f6fcad1-23d8-4864-857d-7188b4966ae1</event_id>
      <title>Consolidation: A Technique for Improving Permissiveness of Human-Machine Interfaces</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/18</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sang Heon</first_name>
          <last_name>Choi</last_name>
          <affiliation>Rose-Hulman Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>sangheonchoi</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>42e2420e-b0d1-4f3f-a6cf-a611af5b8d6d</slot_id>
      <event_id>714badf7-132c-4165-b890-705017d4f0e6</event_id>
      <title>Psamathe: A DSL for Safe Blockchain Assets</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/18</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Reed</first_name>
          <last_name>Oei</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>reedoei</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>52a8e5ae-d621-4ea5-bbbf-d5cb8e00c44b</slot_id>
      <event_id>c3e71786-1ffe-4570-a0c1-09e4be63f341</event_id>
      <title>SASIL: A Domain-Specific Language for Simulating Declarative Specifications of Scheduling Systems</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/18</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gahwon</first_name>
          <last_name>Lee</last_name>
          <affiliation>The University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>gahwonlee</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>851ed701-cc5f-4e09-a80e-25181fb06ab2</slot_id>
      <event_id>cfe79dbb-7209-48a3-b872-744fb7c417c1</event_id>
      <title>A Software Library Model for the Internet of Things</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/18</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ian</first_name>
          <last_name>C. McCormack</last_name>
          <affiliation>University of Wisconsin-Eau Claire</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/iancmccormack/96c410ff-9d83-48f8-bada-c8608133ca54/small.jpg</picture_url>
          <person_id>iancmccormack</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>97e025b3-7193-4baa-b1df-a7afae40031e</slot_id>
      <event_id>8981bf9f-a801-4d61-932d-611f64632d8e</event_id>
      <title>Machine Learning to Ease Understanding of Data Driven Compiler Optimizations</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/18</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Raphael</first_name>
          <last_name>Mosaner</last_name>
          <affiliation>Johannes Kepler University Linz</affiliation>
          <bio>undefined</bio>
          <person_id>raphaelmosaner</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c2d31e8e-956a-4388-a65d-cfb8a3dc09c3</slot_id>
      <event_id>481d6316-609f-4adf-8106-627a1c2e93ae</event_id>
      <title>Detecting Performance Patterns with Deep Learning</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/18</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sophia</first_name>
          <last_name>Kolak</last_name>
          <affiliation>Columbia University/Carnegie Mellon University</affiliation>
          <bio>Fourth year undergraduate in the Computer Science Department at Columbia University, interested in software engineering and machine learning research, currently seeking PhD positions.</bio>
          <homepage_url>https://sophiakolak.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sophiakolak/58616602-83ed-4445-a6f3-3574d3b04eea/small.jpg</picture_url>
          <person_id>sophiakolak</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fb003c22-1189-499b-8c65-f996cb736be7</slot_id>
      <event_id>f67006f2-b607-45d0-966a-275112b59372</event_id>
      <title>SOAR: Synthesis for Open-Source API Refactoring</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/18</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aidan</first_name>
          <last_name>Z.H. Yang</last_name>
          <affiliation>Queen's University / Carnegie Mellon University</affiliation>
          <bio>I am an undergraduate engineering student at Queen’s University, Canada. Applying to PhD positions for Fall 2021.</bio>
          <homepage_url>https://aidanby.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aidanzhyang/808566b3-7761-4650-ac90-521f00deda99/small.jpg</picture_url>
          <person_id>aidanzhyang</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ff660c23-b630-4ac3-a357-ff0c00d462b3</slot_id>
      <event_id>b39f39ab-9675-47b8-83a3-2ccad5841fc1</event_id>
      <title>Evaluating Importance of Edge Types when Using Graph Neural Network for Predicting Return Types of Python Functions</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/18</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vitaly</first_name>
          <last_name>Romanov</last_name>
          <affiliation>Innopolis University</affiliation>
          <bio>undefined</bio>
          <person_id>vitalyromanov</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>24ba8b41-820b-4cd3-b39b-420e1579dfd7</subevent_id>
    <title>VMIL: Invited Talk: Evolution of the Dart PL </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-V</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/home/vmil-2020</url>
    <url_link_display>VMIL 2020</url_link_display>
    <tracks>
      <track>VMIL 2020</track>
    </tracks>
    <timeslot>
      <slot_id>659d6a8b-bf03-41a0-8c9a-2e4cc6e289f1</slot_id>
      <title>Session: VMIL - Invited Talk: Evolution of the Dart PL </title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/17</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>VMIL 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3c06a4cd-32c5-43dc-8346-8df6f612d1f5</slot_id>
      <event_id>f104fac5-1217-4e4f-a85f-934929a63ac9</event_id>
      <title>10 years of Dart</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/17</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>10:20</end_time>
      <description>Dart might be the only contemporary programming language that changed its core principles so radically between two major versions. 10 years ago, in 2010, it was born as a dynamically typed programming language with optional static types - ideas of Strongtalk wrapped into familiar C-like syntax. A language destined to be executed in a native VM with an adaptive JIT compiler. Yet over the years Dart has evolved into a language with a sound static type system, and is being deployed in contexts that require ahead-of-time compilation and prohibit JITing. Now, it is even trying to get rid of the “billion-dollar mistake” - null - and incrementally transition to non-nullable by default reference types. This talk focuses on the architecture of Dart Virtual Machine and how it followed the evolution of the Dart language, adapting to the new semantics and new execution environments, where users wanted to bring Dart to.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Vyacheslav</first_name>
          <last_name>Egorov</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mrale.ph</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vyacheslavegorov/7a515db5-6434-4059-85e7-ea703c754044/small.jpg</picture_url>
          <person_id>vyacheslavegorov</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4b979e3a-9a30-4eeb-8598-479ef9129f0a</subevent_id>
    <title>LPOP:  12:00-- Logic in Artificial Intelligence and Machine Learning</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/home/lpop-2020</url>
    <url_link_display>Logic and Practice of Programming (LPOP) 2020</url_link_display>
    <tracks>
      <track>Logic and Practice of Programming (LPOP) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>848f8427-ddc3-4db5-9897-59f2cd2976e3</slot_id>
      <title>Session: LPOP -  12:00-- Logic in Artificial Intelligence and Machine Learning</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Peter</first_name>
          <last_name>Van Roy</last_name>
          <affiliation>Université catholique de Louvain</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.info.ucl.ac.be/~pvr/pldc.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/petervanroy/d483fce0-cfeb-405b-b540-a48b942e9315/small.jpg</picture_url>
          <person_id>petervanroy</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>01025df5-1774-41fa-bf77-c3285500b149</slot_id>
      <event_id>26e7f84f-e4be-4d63-b272-15209e7dabfe</event_id>
      <title>Invited Talk: Logic, Probability, Knowledge, and Learning</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>12:40</end_time>
      <description>One purpose of learning is to accumulate knowledge, which then becomes an input to enable further learning. I will examine this idea first in the context of logic and then in the context of probability. The idea becomes particularly powerful with probabilistic formalisms that draw on the expressive power of first-order logic, although there is still a long way to go before the potential of cumulative learning is fulfilled.</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Stuart</first_name>
          <last_name>Russell</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>Stuart Russell is a Professor of Computer Science at the University of California at Berkeley, holder of the Smith-Zadeh Chair in Engineering, and Director of the Center for Human-Compatible AI. He is a recipient of the IJCAI Computers and Thought Award and from 2012 to 2014 held the Chaire Blaise Pascal in Paris. He is an Honorary Fellow of Wadham College, Oxford, an Andrew Carnegie Fellow, and a Fellow of the American Association for Artificial Intelligence, the Association for Computing Machinery, and the American Association for the Advancement of Science. His book “Artificial Intelligence: A Modern Approach” (with Peter Norvig) is the standard text in AI, used in 1500 universities in 135 countries. His research covers a wide range of topics in artificial intelligence, with an emphasis on the long-term future of artificial intelligence and its relation to humanity. He has developed a new global seismic monitoring system for the nuclear-test-ban treaty and is currently working to ban lethal autonomous weapons.</bio>
          <homepage_url>https://www.cs.berkeley.edu/~russell/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stuartrussell/aaf4480c-53ae-4f24-85f3-46bf497b4796/small.jpg</picture_url>
          <person_id>stuartrussell</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>13d9b2dd-53fd-4205-adcc-e5266c9b9494</slot_id>
      <event_id>e9db27b7-d08a-4d88-b19c-24856062ae27</event_id>
      <title>Break: Ask Me Anything</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>12:55</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>13:05</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Gopal</first_name>
          <last_name>Gupta</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>gopalgupta</person_id>
        </person>
        <person>
          <role>Chair</role>
          <sort_key>2</sort_key>
          <first_name>Joost</first_name>
          <last_name>Vennekens</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/joostvennekens/ab838f39-bb0e-455f-9f55-2c443b06ae6a/small.jpg</picture_url>
          <person_id>joostvennekens</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f18442ac-a20c-4202-8b51-65f481573953</slot_id>
      <event_id>3e75d79f-3283-4d5b-a036-25483718898d</event_id>
      <title>Training Neural Networks to Do Logic, with Logic</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>12:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>12:55</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paul</first_name>
          <last_name>Tarau</last_name>
          <affiliation>University of North Texas</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unt.edu/~tarau/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/paultarau/79013cf3-bf98-4bbd-aaec-7f4bdc977f08/small.jpg</picture_url>
          <person_id>paultarau</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3c1622bf-3597-4545-b754-41ef3f554c20</subevent_id>
    <title>LPOP: 10:00-- Logic in Program Specification and Analysis</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/home/lpop-2020</url>
    <url_link_display>Logic and Practice of Programming (LPOP) 2020</url_link_display>
    <tracks>
      <track>Logic and Practice of Programming (LPOP) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>d6c7fe55-f978-4545-ad09-11da37c82dc0</slot_id>
      <title>Session: LPOP - 10:00-- Logic in Program Specification and Analysis</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Y. Annie</first_name>
          <last_name>Liu</last_name>
          <affiliation>Stony Brook University</affiliation>
          <bio>Y. Annie Liu is Professor of Computer Science at Stony Brook University. Her primary research is in languages and algorithms, especially on systematic methods for design and optimization. The methods are centered around incrementalization—the discrete counterpart of differentiation in calculus. Besides research and service, she also enjoys teaching. She has taught in a wide range of Computer Science areas, and presented over 100 conference and invited talks worldwide. She received her BS from Peking University, MEng from Tsinghua University, and PhD from Cornell University, all in Computer Science. 
Annie Liu’s Design and Analysis Research Laboratory has projects in modeling and specification, analysis and verification, design and optimization, code generation, and testing. These projects are for optimizing compilers, interactive environments, real-time and embedded systems, database systems, semantic Web, distributed systems, big data analysis, security, and more. Her awards include a State University of New York Chancellor’s Award for Excellence in Scholarship and Creative Activities.</bio>
          <homepage_url>http://www.cs.stonybrook.edu/~liu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yannieliu/d4044868-1dde-4caf-8536-3d1df77f2d1d/small.jpg</picture_url>
          <person_id>yannieliu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>19ca38e1-64d7-4230-982a-d5ed415cba06</slot_id>
      <event_id>52d57544-f1d8-4a06-a857-71f22fc7f3b0</event_id>
      <title>Break: Ask Me Anything</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>11:50</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>12:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Leuschel</last_name>
          <affiliation>University of Düsseldorf</affiliation>
          <bio>undefined</bio>
          <person_id>michaelleuschel</person_id>
        </person>
        <person>
          <role>Chair</role>
          <sort_key>2</sort_key>
          <first_name>Jorge</first_name>
          <last_name>Lobo</last_name>
          <affiliation>ICREA and Universitat Pompeu Fabra</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/jorgelobo/bd3d1e29-e99e-498a-87a8-60007e3133d4/small.jpg</picture_url>
          <person_id>jorgelobo</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>61d2a8d0-67d5-40ad-9ab9-6d82b3c857fe</slot_id>
      <event_id>7497f9d7-7d6c-4293-9863-db8f335f39c5</event_id>
      <title>Panel: Logic in Program Specification: Where Has It Failed? How Can We Fix It? </title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>11:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Panelist</role>
          <sort_key>1</sort_key>
          <first_name>Leslie</first_name>
          <last_name>Lamport</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/leslielamport/89cf550a-01cf-4ed7-a09e-f1e357872838/small.jpg</picture_url>
          <person_id>leslielamport</person_id>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>2</sort_key>
          <first_name>Richard</first_name>
          <last_name>Waldinger</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/richardwaldinger/914e729c-41b3-4573-a85b-eab7d89f0d1b/small.jpg</picture_url>
          <person_id>richardwaldinger</person_id>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>3</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Cousot</last_name>
          <affiliation>New York University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/patrickcousot/42f5b16b-b574-4d75-a3b1-902508060f2a/small.jpg</picture_url>
          <person_id>patrickcousot</person_id>
        </person>
        <person>
          <role>Chair</role>
          <sort_key>4</sort_key>
          <first_name>David</first_name>
          <last_name>Warren</last_name>
          <affiliation>Stony Brook University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidwarren/b04656c2-bfa4-4548-86ae-d465920ced13/small.jpg</picture_url>
          <person_id>davidwarren</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>80cbf669-a528-4263-bf2a-9544d95bc221</slot_id>
      <event_id>017b3270-a58b-4ed5-a87e-13c91d52f49b</event_id>
      <title>Deductive Synthesis of the Unification Algorithm: The Automation of Introspection</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>10:50</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>11:05</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Richard</first_name>
          <last_name>Waldinger</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/richardwaldinger/914e729c-41b3-4573-a85b-eab7d89f0d1b/small.jpg</picture_url>
          <person_id>richardwaldinger</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b50e6bde-8754-47a6-a7de-3d7ccf50eae8</slot_id>
      <event_id>41045725-fdb0-4438-9f1c-700df02b4b0d</event_id>
      <title>Invited Talk: If You're Not Writing a Program, Don't Use a Programming Language</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>10:10</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>10:50</end_time>
      <description>Algorithms are not programs. They can and should be written with math rather than programming languages or pseudo-languages. This applies to many more algorithms than the ones taught in algorithm courses. 
Note: This will be a Q &amp;amp; A session for the following talk https://youtu.be/wQiWwQcMKuw The talk itself is 50 minutes; the video includes Q&amp;amp;A and is longer. Participants are asked to watch the video before the talk.</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Leslie</first_name>
          <last_name>Lamport</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/leslielamport/89cf550a-01cf-4ed7-a09e-f1e357872838/small.jpg</picture_url>
          <person_id>leslielamport</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>baa4d0e7-6eb6-4408-8876-c6c4fec203ed</slot_id>
      <event_id>6569c0f4-5832-4e24-a6f3-8203500c6164</event_id>
      <title>Logic in Program Analysis and Verification</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>11:05</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>11:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Cousot</last_name>
          <affiliation>New York University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/patrickcousot/42f5b16b-b574-4d75-a3b1-902508060f2a/small.jpg</picture_url>
          <person_id>patrickcousot</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bfd90c22-915a-4c3b-b1bf-8000728b37fa</slot_id>
      <event_id>fd1846cc-905f-4880-8986-5a4328c7ab3b</event_id>
      <title>Opening and Introduction</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>10:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Chair</role>
          <sort_key>1</sort_key>
          <first_name>Peter</first_name>
          <last_name>Van Roy</last_name>
          <affiliation>Université catholique de Louvain</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.info.ucl.ac.be/~pvr/pldc.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/petervanroy/d483fce0-cfeb-405b-b540-a48b942e9315/small.jpg</picture_url>
          <person_id>petervanroy</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8eb9db46-f46f-461b-beba-5cd98110a814</subevent_id>
    <title>SPLASH Student Research Competition: Breakfast in Wellington</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-SRC</url>
    <url_link_display>Student Research Competition</url_link_display>
    <tracks>
      <track>Student Research Competition</track>
    </tracks>
    <timeslot>
      <slot_id>20312296-86c7-483e-96a2-1fbbd4598565</slot_id>
      <title>Session: SPLASH Student Research Competition - Breakfast in Wellington</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>12:20</start_time>
      <end_time>13:00</end_time>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>061b2e19-ffbb-4b02-82ba-926f2a5abf0b</slot_id>
      <event_id>a9e3d4ea-adaf-4e67-a431-fcf11578554b</event_id>
      <title>Student Research Competition</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d9ccca0d-386b-4efe-911e-b31ece8b6c0c</subevent_id>
    <title>VMIL: Invited Talk + Paper</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-V</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/home/vmil-2020</url>
    <url_link_display>VMIL 2020</url_link_display>
    <tracks>
      <track>VMIL 2020</track>
    </tracks>
    <timeslot>
      <slot_id>2fae049a-d9e0-40d0-ad27-c67f3970272b</slot_id>
      <title>Session: VMIL - Invited Talk + Paper</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/17</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>VMIL 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0fbeb190-1dcf-407b-9754-2f6620fb3c11</slot_id>
      <event_id>76c9b092-6ec6-41c8-9aaf-d29258d48069</event_id>
      <title>Understanding Graal IR</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/17</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>11:40</end_time>
      <description>The Graal compiler uses a graphical sea-of-nodes IR that can be difficult to understand and work with when trying to improve performance of complicated programs. When used with an automatic partial evaluator, such as Truffle, and with a high-level language with complex semantics such as Ruby, the resulting IR graphs become even harder to work with. At Shopify we’re working on new tools to understand complex Graal IR graphs generated from the TruffleRuby and Sulong interpreters, as used to run a large, complex, production application. We’ll show what these tools enable us to do and what innovative ideas we can bring to understand the relevant parts of the graph without getting swamped in the expanse of it.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Chris</first_name>
          <last_name>Seaton</last_name>
          <affiliation>Shopify</affiliation>
          <bio>Chris is a Researcher at Shopify, where he works on the Ruby programming Language, and a Visitor at the University of Manchester. 
He was formerly a Research Manager at the Oracle Labs Virtual Machine Research Group, where he led the TruffleRuby implementation of Ruby, and worked on other language and virtual machine projects. Before this he completed a PhD at Manchester where he researched programming languages and irregular parallelism, and an MEng at the University of Bristol on languages with mutable syntax and semantics. 
In his spare time he’s Second in Command of the Cheshire Yeomanry squadron of the Queen’s Own Yeomanry, Cheshire’s historic reserve light cavalry squadron.</bio>
          <homepage_url>https://chrisseaton.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/chrisseaton/ace700bb-530d-472f-9683-f0f036db05ea/small.jpg</picture_url>
          <person_id>chrisseaton</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>60d58dc1-a54a-4ee1-a58f-bd105be0b7c3</slot_id>
      <event_id>54b0fd11-d2a9-4e0e-a6c2-8038e842765f</event_id>
      <title>Programming Microcontrollers through High-Level Abstractions</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/17</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>12:20</end_time>
      <description>This paper is intended at showing how programming embedded systems can increase in safety and compositionality with the use of high-level abstractions. Firstly, we provide an hardware abstraction layer through a virtual machine approach that enables the use of a high-level programming language. We describe our dedicated OCaml virtual machine that enable the development of richer programs for microcontrollers using advanced programming paradigms. Secondly, we introduce an original use of OCaml parameterized modules for describing the electronic circuit connected to the microcontroller, as well as the communication between this device and its environment. Thirdly, the extensibility of OCaml offers a way to easily describe the concurrent aspects of a program by implementing a synchronous dataflow extension to the language. We apply the presented abstractions to both entertainment applications and embedded software examples, showing how they increase expressivity and safety of our programs, while keeping their memory footprint low enough to be runnable on devices with very scarce resources.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Steven</first_name>
          <last_name>Varoumas</last_name>
          <affiliation>Sorbonne University  — LIP6</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://stevenvar.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stevenvaroumas/2d832ce1-3bac-45df-bc43-c33d6b7be488/small.jpg</picture_url>
          <person_id>stevenvaroumas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Basile</first_name>
          <last_name>Pesin</last_name>
          <affiliation>Inria Paris</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://vertmo.github.io/</homepage_url>
          <person_id>basilepesin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benoît</first_name>
          <last_name>Vaugon</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>benoitvaugon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Emmanuel</first_name>
          <last_name>Chailloux</last_name>
          <affiliation>UPMC, France</affiliation>
          <bio>undefined</bio>
          <person_id>emmanuelchailloux</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1b699c4b-24b3-4479-882e-0ef7d9109d58</subevent_id>
    <title>VMIL: Invited Talk - Racket  </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-V</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/home/vmil-2020</url>
    <url_link_display>VMIL 2020</url_link_display>
    <tracks>
      <track>VMIL 2020</track>
    </tracks>
    <timeslot>
      <slot_id>a4d687d0-9675-45d4-95f6-eebb96e03410</slot_id>
      <title>Session: VMIL - Invited Talk - Racket  </title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/17</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <tracks>
        <track>VMIL 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9537c55e-2ae1-4832-ae5c-b99a938132f9</slot_id>
      <event_id>44d37f15-d3ae-4f30-a938-8e2d2ed11458</event_id>
      <title>Racket’s Intermediate Language for Control</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/17</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>16:20</end_time>
      <description>As a language that is intended for building languages in a composable way, Racket provides an especially rich set of constructs for control, including delimited continuations and efficient reflection on continuations. This talk will explain Racket’s constructs for control and describe how the implementation is built in layers.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Flatt</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>Matthew Flatt is a professor in the School of Computing at the University of Utah, where he works on extensible programming languages, runtime systems, and applications of functional programming. He is one of the developers of the Racket programming language. He received his PhD from Rice University in 1999.</bio>
          <homepage_url>http://www.cs.utah.edu/~mflatt/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthewflatt/b4995a2a-f1be-406b-ac9b-fcd5984c1c31/small.jpg</picture_url>
          <person_id>matthewflatt</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9d8ee2ff-2037-4909-ad1b-cdcdc8b94151</subevent_id>
    <title>SPLASH Doctoral Symposium: Slot 2</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-VI</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-Doctoral-Symposium</url>
    <url_link_display>Doctoral Symposium</url_link_display>
    <tracks>
      <track>Doctoral Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>08ca6f5a-e7d9-4c6e-9dae-5355c8470fba</slot_id>
      <title>Session: SPLASH Doctoral Symposium - Slot 2</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/20</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Hauswirth</last_name>
          <affiliation>Università della Svizzera italiana</affiliation>
          <bio>I am an Associate-Professor at the USI (Università della Svizzera italiana) in Lugano, Switzerland. 
At USI I am heading Luce, the Lugano Computing Education research lab (http://luce.inf.usi.ch/) where we study how people learn to program and how to improve that learning process. I am a member of the program committee of the Swiss national program to train existing high school teachers to teach the new mandatory informatics course (https://www3.unifr.ch/gyminf/) and I am co-directing a similar state-wide program in Ticino. 
As part of my lab’s work on conceptual change in learning to program, we contribute to the growing repository of programming misconceptions at (https://progmiscon.org). Amongst other things, that repository maps misconceptions to features of specific programming languages, with links to the corresponding sections of the official language specifications.</bio>
          <homepage_url>http://www.inf.usi.ch/faculty/hauswirth/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthiashauswirth/2f29d37f-4c84-49d3-a27d-7e3909177c4c/small.jpg</picture_url>
          <person_id>matthiashauswirth</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6a9f93d9-dbbd-4701-86fe-aaea32f61a0e</slot_id>
      <event_id>e5b86488-357f-4cf1-9346-18a0b426bdc5</event_id>
      <title>Gradual Value-Dependent Information Flow Control [SPLASH DS]</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/20</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>09:35</end_time>
      <description>Data confidentiality is critical but cumbersome to ensure. To help in the task, we propose a gradual, value-dependent approach to information flow control targeting a small imperative language similar to existing low-level languages. With a hybrid approach, we seek to lessen the flaws of standalone static and dynamic analyses and heighten their advantages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eduardo</first_name>
          <last_name>Geraldo</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>eduardogeraldo</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b2726178-9ba2-47fe-8593-833dabc91b5c</slot_id>
      <event_id>e2a864c2-d5b5-4d4f-b313-ef02236b403e</event_id>
      <title>Machine Learning to Ease Understanding of Data Driven Compiler Optimizations [SPLASH DS]</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/20</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>10:15</end_time>
      <description>Optimizing compilers use—often hand-crafted—heuristics to control optimizations such as inlining or loop unrolling. These heuristics are based on data such as size and structure of the parts to be optimized. A compilation, however, produces much more (platform specific) data that one could use as a basis for an optimization decision. We thus propose the use of machine learning (ML) to derive better optimization decisions from this wealth of data and to tackle the shortcomings of hand-crafted heuristics. Ultimately, we want to shed light on the quality and performance of optimizations by using empirical data with automated feedback and updates in a production compiler.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Raphael</first_name>
          <last_name>Mosaner</last_name>
          <affiliation>Johannes Kepler University Linz</affiliation>
          <bio>undefined</bio>
          <person_id>raphaelmosaner</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5416d105-4792-48c3-8101-0a0f05c9691e</subevent_id>
    <title>SPLASH Student Research Competition: Student Research Competition Posters</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-VII</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-SRC</url>
    <url_link_display>Student Research Competition</url_link_display>
    <tracks>
      <track>Student Research Competition</track>
    </tracks>
    <timeslot>
      <slot_id>d698b4bf-12ec-459c-9a45-546a4dcab1d8</slot_id>
      <title>Session: SPLASH Student Research Competition - Student Research Competition Posters</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/17</date>
      <start_time>12:20</start_time>
      <end_time>13:00</end_time>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>02595614-616e-4647-a4cb-9b02654bf915</slot_id>
      <event_id>4c9e9502-89a1-4941-9c83-fd714440fc57</event_id>
      <title>Design and Implementation of a Gradual Verifier</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/17</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mona</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Columbia University</affiliation>
          <bio>undefined</bio>
          <person_id>monazhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jacob</first_name>
          <last_name>Gorenburg</last_name>
          <affiliation>Haverford College</affiliation>
          <bio>undefined</bio>
          <person_id>jacobgorenburg</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>12b61fb4-2b4e-4d83-9d1b-c67ec846994c</slot_id>
      <event_id>cfe79dbb-7209-48a3-b872-744fb7c417c1</event_id>
      <title>A Software Library Model for the Internet of Things</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/17</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ian</first_name>
          <last_name>C. McCormack</last_name>
          <affiliation>University of Wisconsin-Eau Claire</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/iancmccormack/96c410ff-9d83-48f8-bada-c8608133ca54/small.jpg</picture_url>
          <person_id>iancmccormack</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4667c3b9-4093-40ea-8b9d-28557a64c79a</slot_id>
      <event_id>8981bf9f-a801-4d61-932d-611f64632d8e</event_id>
      <title>Machine Learning to Ease Understanding of Data Driven Compiler Optimizations</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/17</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Raphael</first_name>
          <last_name>Mosaner</last_name>
          <affiliation>Johannes Kepler University Linz</affiliation>
          <bio>undefined</bio>
          <person_id>raphaelmosaner</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>624eddc1-b158-49db-970b-6f19abad44f9</slot_id>
      <event_id>0f6fcad1-23d8-4864-857d-7188b4966ae1</event_id>
      <title>Consolidation: A Technique for Improving Permissiveness of Human-Machine Interfaces</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/17</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sang Heon</first_name>
          <last_name>Choi</last_name>
          <affiliation>Rose-Hulman Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>sangheonchoi</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a3b5b809-2b59-47e7-819f-17f20ecd8490</slot_id>
      <event_id>c3e71786-1ffe-4570-a0c1-09e4be63f341</event_id>
      <title>SASIL: A Domain-Specific Language for Simulating Declarative Specifications of Scheduling Systems</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/17</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gahwon</first_name>
          <last_name>Lee</last_name>
          <affiliation>The University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>gahwonlee</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a9a8710f-7da5-4421-a43d-c785869a3278</slot_id>
      <event_id>714badf7-132c-4165-b890-705017d4f0e6</event_id>
      <title>Psamathe: A DSL for Safe Blockchain Assets</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/17</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Reed</first_name>
          <last_name>Oei</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>reedoei</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f05554f0-a037-4db8-aa2b-18f9479283a6</slot_id>
      <event_id>b39f39ab-9675-47b8-83a3-2ccad5841fc1</event_id>
      <title>Evaluating Importance of Edge Types when Using Graph Neural Network for Predicting Return Types of Python Functions</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/17</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vitaly</first_name>
          <last_name>Romanov</last_name>
          <affiliation>Innopolis University</affiliation>
          <bio>undefined</bio>
          <person_id>vitalyromanov</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f8bdc9e4-6e3a-48f4-bc05-65b98db0322f</slot_id>
      <event_id>481d6316-609f-4adf-8106-627a1c2e93ae</event_id>
      <title>Detecting Performance Patterns with Deep Learning</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/17</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sophia</first_name>
          <last_name>Kolak</last_name>
          <affiliation>Columbia University/Carnegie Mellon University</affiliation>
          <bio>Fourth year undergraduate in the Computer Science Department at Columbia University, interested in software engineering and machine learning research, currently seeking PhD positions.</bio>
          <homepage_url>https://sophiakolak.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sophiakolak/58616602-83ed-4445-a6f3-3574d3b04eea/small.jpg</picture_url>
          <person_id>sophiakolak</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ff3c066d-4b56-45de-ab0e-623250409219</slot_id>
      <event_id>f67006f2-b607-45d0-966a-275112b59372</event_id>
      <title>SOAR: Synthesis for Open-Source API Refactoring</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/17</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aidan</first_name>
          <last_name>Z.H. Yang</last_name>
          <affiliation>Queen's University / Carnegie Mellon University</affiliation>
          <bio>I am an undergraduate engineering student at Queen’s University, Canada. Applying to PhD positions for Fall 2021.</bio>
          <homepage_url>https://aidanby.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aidanzhyang/808566b3-7761-4650-ac90-521f00deda99/small.jpg</picture_url>
          <person_id>aidanzhyang</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>43949be6-e7ee-430c-815d-3ca6dcfdd2e3</subevent_id>
    <title>SPLASH Doctoral Symposium: Slot 1</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-VI</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-Doctoral-Symposium</url>
    <url_link_display>Doctoral Symposium</url_link_display>
    <tracks>
      <track>Doctoral Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>5f925065-a8ec-4bef-a7e2-25deaf570eef</slot_id>
      <title>Session: SPLASH Doctoral Symposium - Slot 1</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/20</date>
      <start_time>07:00</start_time>
      <end_time>08:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Philipp</first_name>
          <last_name>Dominik Schubert</last_name>
          <affiliation>Heinz Nixdorf Institut, Paderborn University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://it-schubert.com/philipp/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippdominikschubert/3e920a42-6541-44bd-90ee-89428b6f2438/small.jpg</picture_url>
          <person_id>philippdominikschubert</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>512ba413-c4b5-4fcf-bca5-b06e5fef3f51</slot_id>
      <event_id>1316045b-84e0-46f8-a499-e0e529398eb5</event_id>
      <title>A Property-Based Testing Framework for Machine Learning Programs [ECOOP DS]</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/20</date>
      <start_time>07:45</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>08:20</end_time>
      <description>Today, Machine Learning (ML) models are increasingly being applied in decision-making systems. The application areas of ML now range from autonomous driving, social, economical to even law. Hence, there exists an urgent need to ensure the quality of such ML models. Consequently, researchers have started to develop methods checking various sorts of requirements. However, most of the existing validation techniques either focus on a particular type of ML model (e.g. Deep Neural Network) or validating a specific property (e.g. fairness, robustness). A unified method for checking any ML model for a user specified property is largely lacking. In this work, we propose to develop a property-based testing framework for machine learning. Our approach works by generating test inputs on a white-box model via a well-known verification technique, and this white-box model is automatically inferred from the black-box model under test. On the white-box model, the space of test inputs are systematically explored by a directed computation of test cases. We term our approach as verification-based testing. So far, we have applied our technique to check the monotonicity property of ML models and find it to be more effective and efficient compared to an existing property-based testing technique.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Arnab</first_name>
          <last_name>Sharma</last_name>
          <affiliation>University of Paderborn</affiliation>
          <bio>undefined</bio>
          <person_id>arnabsharma</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a1988254-34ef-4eaf-8893-b5864abf710a</slot_id>
      <event_id>aac60186-1f45-4cfc-b827-f51316e43468</event_id>
      <title>Improving User Experience of Static Analysis Tools [ECOOP DS]</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/20</date>
      <start_time>07:10</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>07:45</end_time>
      <description>Static analysis tools help detect bugs and security issues in program code and thereby support the development of high-quality programs. However, software developers often omit using them due to usability issues. Research has shown that workflow integration and specialized user interfaces (UIs) are important to improve usability. This proposed research project contributes new concepts for specialized UIs incorporating developer input for displaying relevant analysis results or even recommending next bugs to fix.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Schlichtig</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>michaelschlichtig</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b32e32de-333c-4c9d-992f-9a49ae8abe91</slot_id>
      <event_id>eac7384d-8264-4121-b529-f10b06941d35</event_id>
      <title>Introduction and Welcome from the Organizers</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/20</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>07:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Co-chair</role>
          <sort_key>1</sort_key>
          <first_name>Philipp</first_name>
          <last_name>Dominik Schubert</last_name>
          <affiliation>Heinz Nixdorf Institut, Paderborn University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://it-schubert.com/philipp/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippdominikschubert/3e920a42-6541-44bd-90ee-89428b6f2438/small.jpg</picture_url>
          <person_id>philippdominikschubert</person_id>
        </person>
        <person>
          <role>Co-chair</role>
          <sort_key>2</sort_key>
          <first_name>Yvonne</first_name>
          <last_name>Coady</last_name>
          <affiliation>University of Victoria</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/yvonnecoady/7b532c8e-0c31-445d-b943-ad956a6f5722/small.jpg</picture_url>
          <person_id>yvonnecoady</person_id>
        </person>
        <person>
          <role>Co-chair</role>
          <sort_key>3</sort_key>
          <first_name>Chengsong</first_name>
          <last_name>Tan</last_name>
          <affiliation>King's College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kclpure.kcl.ac.uk/portal/en/persons/chengsong-tan(a63b381b-04bc-4cd7-beea-beb3e96cb153).html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/chengsongtan/d642cd16-c06d-41c2-abd0-f3fe54175174/small.jpg</picture_url>
          <person_id>chengsongtan</person_id>
        </person>
        <person>
          <role>Co-chair</role>
          <sort_key>4</sort_key>
          <first_name>Nafise</first_name>
          <last_name>Eskandani Masoule</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.stg.tu-darmstadt.de/staff/nafise_eskandani</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nafiseeskandanimasoule/6eac9bf0-bfcf-4440-ba06-24fa9145cb4e/small.jpg</picture_url>
          <person_id>nafiseeskandanimasoule</person_id>
        </person>
        <person>
          <role>Co-chair</role>
          <sort_key>5</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Hauswirth</last_name>
          <affiliation>Università della Svizzera italiana</affiliation>
          <bio>I am an Associate-Professor at the USI (Università della Svizzera italiana) in Lugano, Switzerland. 
At USI I am heading Luce, the Lugano Computing Education research lab (http://luce.inf.usi.ch/) where we study how people learn to program and how to improve that learning process. I am a member of the program committee of the Swiss national program to train existing high school teachers to teach the new mandatory informatics course (https://www3.unifr.ch/gyminf/) and I am co-directing a similar state-wide program in Ticino. 
As part of my lab’s work on conceptual change in learning to program, we contribute to the growing repository of programming misconceptions at (https://progmiscon.org). Amongst other things, that repository maps misconceptions to features of specific programming languages, with links to the corresponding sections of the official language specifications.</bio>
          <homepage_url>http://www.inf.usi.ch/faculty/hauswirth/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthiashauswirth/2f29d37f-4c84-49d3-a27d-7e3909177c4c/small.jpg</picture_url>
          <person_id>matthiashauswirth</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d88de06c-6473-4faf-9b1e-5dfac5272ea4</subevent_id>
    <title>SPLASH Doctoral Symposium: Slot 3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-VI</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-Doctoral-Symposium</url>
    <url_link_display>Doctoral Symposium</url_link_display>
    <tracks>
      <track>Doctoral Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>0a7ba034-0a56-4e8f-a6c5-3d4d1c5498d0</slot_id>
      <title>Session: SPLASH Doctoral Symposium - Slot 3</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/20</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Nafise</first_name>
          <last_name>Eskandani Masoule</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.stg.tu-darmstadt.de/staff/nafise_eskandani</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nafiseeskandanimasoule/6eac9bf0-bfcf-4440-ba06-24fa9145cb4e/small.jpg</picture_url>
          <person_id>nafiseeskandanimasoule</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c5fe3325-40a1-4927-86a7-fbb41244b490</slot_id>
      <event_id>c40928e8-d11e-40aa-bc43-644c4ec3456f</event_id>
      <title>Thesis design and engineering tradeoffs [Invited Talk]</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/20</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Doug</first_name>
          <last_name>Lea</last_name>
          <affiliation>State University of New York (SUNY) Oswego</affiliation>
          <bio>Doug Lea is a professor of Computer Science at the State University of New York at Oswego. He is an author of books, articles, reports, and standardization efforts on object oriented software development including those on specification, design and implementation techniques, distributed, concurrent, and parallel object systems, and software reusability; and has served as chair, organizer, or program committee member for many conferences and workshops in these areas. He is the primary author of several widely used software packages and components.</bio>
          <homepage_url>http://gee.cs.oswego.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/douglea/3419ce80-c31d-4958-b043-53f6d89a34cd/small.jpg</picture_url>
          <person_id>douglea</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ee463f1c-fa02-4b1f-8cfe-652497366655</slot_id>
      <event_id>5b9293b3-fba4-43c9-bbc3-b7b41ce6409f</event_id>
      <title>Model-Driven Development of Mobile Applications [ECOOP DS]</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/20</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>11:35</end_time>
      <description>Mobile applications are one of the main features of mobile devices that have increased the prevalence of mobile use. In turn, such prevalence has increased the demand for high quality, interactive, and intelligent mobile applications. Achieving these requirements on multiple platforms, in critical domains, and with short time-to-market causes high challenges to developers and companies, which can be addressed by Model-Driven Development (MDD). The MDD approach plays a substantial role in increasing software productivity and enhancing solution quality by synthesising mobile applications from high-level specifications, and by automatically generating implementations on different platforms rather than relying on manually coding different platform versions. Effective application solutions strongly depend on the appropriate choice of architecture design and back-end services, and expertise in these choices can be encoded into an MDD process. Although some current research attempts to adopt MDD for mobile applications, the studies are still limited and have room for improvement. The published work tends to focus on either generating user interfaces or on simple data-centric applications. Therefore, this research aims to support the solution quality of complex cross-platform mobile applications by developing an advanced MDD framework that is compatible with native mobile applications, supports complex algorithms, as well as advanced services such as machine learning and cloud-based mobile back-ends. The inputs required for this framework are textual models for the user interface, data, and process of the app, and the outputs are complete functional mobile applications for Android and iOS.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lyan</first_name>
          <last_name>Alwakeel</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>lyanalwakeel</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ca67b85b-7f34-484e-8af2-cc53f0a12247</subevent_id>
    <title>SPLASH Student Research Competition: Breakfast in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-SRC</url>
    <url_link_display>Student Research Competition</url_link_display>
    <tracks>
      <track>Student Research Competition</track>
    </tracks>
    <timeslot>
      <slot_id>b1bb8cbb-d1b2-4e72-874a-a2a75d34bfc4</slot_id>
      <title>Session: SPLASH Student Research Competition - Breakfast in Paris</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>00:20</start_time>
      <end_time>01:00</end_time>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>27e9c703-c098-40fe-9407-36203f6c5c2d</slot_id>
      <event_id>a9e3d4ea-adaf-4e67-a431-fcf11578554b</event_id>
      <title>Student Research Competition</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3bb1a84a-0d2e-4a26-90d1-44808e766d75</subevent_id>
    <title>SPLASH Doctoral Symposium: Slot 4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-VI</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-Doctoral-Symposium</url>
    <url_link_display>Doctoral Symposium</url_link_display>
    <tracks>
      <track>Doctoral Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>af3f1b96-1c65-467c-9060-4bff8d4fe186</slot_id>
      <title>Session: SPLASH Doctoral Symposium - Slot 4</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/20</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Chengsong</first_name>
          <last_name>Tan</last_name>
          <affiliation>King's College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kclpure.kcl.ac.uk/portal/en/persons/chengsong-tan(a63b381b-04bc-4cd7-beea-beb3e96cb153).html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/chengsongtan/d642cd16-c06d-41c2-abd0-f3fe54175174/small.jpg</picture_url>
          <person_id>chengsongtan</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5a878f34-86bb-47de-938c-b319c0e9455b</slot_id>
      <event_id>50bb1250-faa7-4de4-9161-9c08006a80c5</event_id>
      <title>Self-Marketing as a Researcher [Invited Talk]</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/20</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>13:50</end_time>
      <description>In the world of science, your thought is what matters. Your ideas that you work on, which you investigate, question, validate, and maybe even prove. This is your research and this is what you publish about. In an ideal world, this would be enough for you to receive the recognition you deserve and be invited to more prestigious positions. However, it is only the necessary requirement in the process. Much of our society — and the scientific community is no exception but in fact a poster example — has become an economy of attention… of visibility. It is not only necessary to do great work, it is also necessary to “beat the drums” so other people feel compelled to devote some of their attention to your work. In my talk, I will show you that this may be actually true using some examples from my limited experiments involving observations only from my point of view (so n=1 and your mileage may differ) and myself. Furthermore, we will discuss what you can do to attract attention and receive the visibility you deserve for your work. For this, I will add examples of brilliant and not-so-brilliant science communication done be me and other people. This means we will also talk about the abyss of trumpism-filled tweeting and the points where you should actually leave communication to the professionals. In the end you will probably have a large to-do list for the time after the conference.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ben</first_name>
          <last_name>Hermann</last_name>
          <affiliation>Technical University Dortmund</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.thewhitespace.de</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/benhermann1/8d5d764e-6408-48bb-9ead-c1c016c62297/small.jpg</picture_url>
          <person_id>benhermann1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>df3ebcbc-8089-48d7-bffb-7bbba47fbaa1</subevent_id>
    <title>SPLASH Student Research Competition: Breakfast in Seattle</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-SRC</url>
    <url_link_display>Student Research Competition</url_link_display>
    <tracks>
      <track>Student Research Competition</track>
    </tracks>
    <timeslot>
      <slot_id>274c9c36-2ef6-40f0-8fd4-b49545b39c66</slot_id>
      <title>Session: SPLASH Student Research Competition - Breakfast in Seattle</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/19</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e5d9b4a3-7ed8-4f83-b1ea-91bf709ca38b</slot_id>
      <event_id>f61bee32-c3d8-4485-b7f7-38b8d4e32e47</event_id>
      <title>Student Research Competition</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/19</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>12:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6857f725-997e-4227-9b8b-b1164e8fad3f</subevent_id>
    <title>VMIL: Invited Talk - JitBuilder 2.0</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-V</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/home/vmil-2020</url>
    <url_link_display>VMIL 2020</url_link_display>
    <tracks>
      <track>VMIL 2020</track>
    </tracks>
    <timeslot>
      <slot_id>e300920b-0522-4ac1-a655-68e5aeb17d02</slot_id>
      <title>Session: VMIL - Invited Talk - JitBuilder 2.0</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/17</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Juan</first_name>
          <last_name>Fumero</last_name>
          <affiliation>University of Manchester, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jjfumero.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juanfumero/e76896d1-7e40-4e77-859f-dc51392013a2/small.jpg</picture_url>
          <person_id>juanfumero</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cf47c657-cf11-448d-bdeb-b242b9dbe57a</slot_id>
      <event_id>f340d21c-fc15-43d0-bf44-0f16078df9f4</event_id>
      <title>In Pursuit of Easy(er) JITs</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/17</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>14:20</end_time>
      <description>In the early days of the Eclipse OMR project, we created the unimaginatively named JitBuilder API aiming to make it easier to build a JIT compiler. JitBuilder has been used to create prototype JIT compilers in a few thousand lines of C++ for WebAssembly, Lua, Smalltalk, Javascript, the Rosie Pattern Language, BF, Kaleidoscope, and Base9, as well as a number of other less language-centric dynamic code generators (including an alternative code generator for LLVM IR). Although it brings key facilities for privatizing virtual machine state and translating bytecode handlers, the JitBuilder API did not completely meet the “easy” goal particularly in the areas of extensibility and debuggability, and did not offer strong DSL optimization possibilities. In this talk, I’ll explain and summarize the key features of the JitBuilder API before introducing some recent exploratory work to create the next version: JitBuilder2. This new fully-fledged (if currently incomplete) compiler IL shares some directions with MLIR, but has some unique challenges and features, all designed around the pursuit of “easy” JIT compiler construction. Through the talk, I’ll show off some of these features (that’s right, I’ll demo a compiler IL!) and highlight some of the interesting directions I think we could take it from here.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Mark</first_name>
          <last_name>Stoodley</last_name>
          <affiliation>IBM Canada</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/markstoodley/4d48f041-7d47-4ff0-a45c-bf650fd741cb/small.jpg</picture_url>
          <person_id>markstoodley</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>625dd95f-cee9-451f-b517-ef50c35e6588</subevent_id>
    <title>LPOP: 13:05-- Logic and Implementation Tractability</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/home/lpop-2020</url>
    <url_link_display>Logic and Practice of Programming (LPOP) 2020</url_link_display>
    <tracks>
      <track>Logic and Practice of Programming (LPOP) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>e3d76eb6-e02d-4858-a259-cd7a24890f55</slot_id>
      <title>Session: LPOP - 13:05-- Logic and Implementation Tractability</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Y. Annie</first_name>
          <last_name>Liu</last_name>
          <affiliation>Stony Brook University</affiliation>
          <bio>Y. Annie Liu is Professor of Computer Science at Stony Brook University. Her primary research is in languages and algorithms, especially on systematic methods for design and optimization. The methods are centered around incrementalization—the discrete counterpart of differentiation in calculus. Besides research and service, she also enjoys teaching. She has taught in a wide range of Computer Science areas, and presented over 100 conference and invited talks worldwide. She received her BS from Peking University, MEng from Tsinghua University, and PhD from Cornell University, all in Computer Science. 
Annie Liu’s Design and Analysis Research Laboratory has projects in modeling and specification, analysis and verification, design and optimization, code generation, and testing. These projects are for optimizing compilers, interactive environments, real-time and embedded systems, database systems, semantic Web, distributed systems, big data analysis, security, and more. Her awards include a State University of New York Chancellor’s Award for Excellence in Scholarship and Creative Activities.</bio>
          <homepage_url>http://www.cs.stonybrook.edu/~liu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yannieliu/d4044868-1dde-4caf-8536-3d1df77f2d1d/small.jpg</picture_url>
          <person_id>yannieliu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7c2c8332-e366-44e6-97f1-10dce742d68c</slot_id>
      <event_id>5f4f86f5-3a9e-4266-880a-03600eaa264b</event_id>
      <title>Panel: Logic in Artificial Intelligence: Don’t Machine Learning and Neural Networks Do It All?</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>13:45</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>14:15</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Panelist</role>
          <sort_key>1</sort_key>
          <first_name>Stuart</first_name>
          <last_name>Russell</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>Stuart Russell is a Professor of Computer Science at the University of California at Berkeley, holder of the Smith-Zadeh Chair in Engineering, and Director of the Center for Human-Compatible AI. He is a recipient of the IJCAI Computers and Thought Award and from 2012 to 2014 held the Chaire Blaise Pascal in Paris. He is an Honorary Fellow of Wadham College, Oxford, an Andrew Carnegie Fellow, and a Fellow of the American Association for Artificial Intelligence, the Association for Computing Machinery, and the American Association for the Advancement of Science. His book “Artificial Intelligence: A Modern Approach” (with Peter Norvig) is the standard text in AI, used in 1500 universities in 135 countries. His research covers a wide range of topics in artificial intelligence, with an emphasis on the long-term future of artificial intelligence and its relation to humanity. He has developed a new global seismic monitoring system for the nuclear-test-ban treaty and is currently working to ban lethal autonomous weapons.</bio>
          <homepage_url>https://www.cs.berkeley.edu/~russell/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stuartrussell/aaf4480c-53ae-4f24-85f3-46bf497b4796/small.jpg</picture_url>
          <person_id>stuartrussell</person_id>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>2</sort_key>
          <first_name>Paul</first_name>
          <last_name>Tarau</last_name>
          <affiliation>University of North Texas</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unt.edu/~tarau/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/paultarau/79013cf3-bf98-4bbd-aaec-7f4bdc977f08/small.jpg</picture_url>
          <person_id>paultarau</person_id>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>3</sort_key>
          <first_name>Adnan</first_name>
          <last_name>Darwiche</last_name>
          <affiliation>UCLA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.cs.ucla.edu/~darwiche/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adnandarwiche/6ddddf6d-4589-4c4d-a483-bd2921e7be2d/small.jpg</picture_url>
          <person_id>adnandarwiche</person_id>
        </person>
        <person>
          <role>Chair</role>
          <sort_key>4</sort_key>
          <first_name>David</first_name>
          <last_name>Warren</last_name>
          <affiliation>Stony Brook University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidwarren/b04656c2-bfa4-4548-86ae-d465920ced13/small.jpg</picture_url>
          <person_id>davidwarren</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>99cc1a70-9868-4b4e-987b-8783541a1ac8</slot_id>
      <event_id>175c02c4-366f-4365-9dbc-9a9ddeacec3d</event_id>
      <title>Invited Talk: Tractable Boolean Circuits: Applications and Compilation Algorithms</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>13:05</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>13:45</end_time>
      <description>Tractable Boolean circuits have been playing an increasingly important role in AI and beyond, being also the basis for tractable probabilistic circuits. This includes (1) providing a systematic approach for tackling problems beyond NP, (2) allowing one to learn from certain combinations of knowledge and data, and (3) reasoning about the behavior of some machine learning systems. In this talk, I will review the basics and applications of tractable Boolean circuits, while also discussing the compilation of Boolean formula into tractable circuits: a critical process which can benefit from additional efforts by the broad computer science community.</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Adnan</first_name>
          <last_name>Darwiche</last_name>
          <affiliation>UCLA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.cs.ucla.edu/~darwiche/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adnandarwiche/6ddddf6d-4589-4c4d-a483-bd2921e7be2d/small.jpg</picture_url>
          <person_id>adnandarwiche</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c33e4b48-5adf-4a88-9659-ce4941a59d75</slot_id>
      <event_id>52ca8b99-e213-4550-bad4-64faa980bfa4</event_id>
      <title>Break: Ask Me Anything</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/15</date>
      <start_time>14:15</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>14:25</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Hermenegildo</last_name>
          <affiliation>IMDEA Software Institute and T.U. of Madrid</affiliation>
          <bio>Manuel Hermenegildo is Distinguished Professor at (and was the Founding Director of) the IMDEA Software Institute. He is also full Prof. of Computer Science at the Tech. U. of Madrid, UPM. Previously he held an Endowed Chair in Information Science and Technology at the U. of New Mexico. He was also project leader at the MCC research center and Adjunct Associate Prof. at the CS Department of the U. of Texas, both in Austin, Texas. See his home page for more information. 
Research interests: Energy-Aware Computing, Resource / non-functional property analysis, verification, and control; Global Program Analysis, Optimization, Verification, Debugging; Abstract Interpretation; Partial Evaluation; Parallelism and Parallelizing Compilers; Constraint/Logic/Functional Programming Theory and Implementation, Abstract Machines; Automatic Documentation Tools, Execution Visualization; Sequential and Parallel Computer Architecture.</bio>
          <homepage_url>http://cliplab.org/herme</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelhermengildo/9ad5b1a1-5b09-4700-a372-66f4683bb674/small.jpg</picture_url>
          <person_id>manuelhermengildo</person_id>
        </person>
        <person>
          <role>Chair</role>
          <sort_key>2</sort_key>
          <first_name>Martin</first_name>
          <last_name>Gebser</last_name>
          <affiliation>University of Klagenfurt, Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ainf.aau.at/prosys</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/martingebser/c8c2f893-df02-4647-a5e2-491aad17cfd3/small.jpg</picture_url>
          <person_id>martingebser</person_id>
        </person>
      </persons>
      <tracks>
        <track>Logic and Practice of Programming (LPOP) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>77b42226-8d75-4483-b7b2-c98cb75755db</subevent_id>
    <title>REBLS: Welcome to REBLS &amp; Keynote</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/home/rebls-2020</url>
    <url_link_display>REBLS 2020</url_link_display>
    <tracks>
      <track>REBLS 2020</track>
    </tracks>
    <timeslot>
      <slot_id>f9d117cd-c8ad-4c9f-9533-08d2c66dcf82</slot_id>
      <title>Session: REBLS - Welcome to REBLS &amp; Keynote</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/16</date>
      <start_time>07:00</start_time>
      <end_time>08:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Perez</last_name>
          <affiliation>NIA / NASA Formal Methods</affiliation>
          <bio>Researcher @ NIA / NASA Formal Methods | Founder @ Haskell Game Company Keera Studios | Haskell game and mobile app developer.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/ivanperez/c45c544e-ba8b-4bed-8026-1a1bd7ea42a0/small.jpg</picture_url>
          <person_id>ivanperez</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e69a6810-6f59-4642-bbd2-18e5a56121fc</slot_id>
      <event_id>3249376f-d843-408f-9326-5c67df834f62</event_id>
      <title>Keynote: SCADE 6</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/16</date>
      <start_time>07:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>08:20</end_time>
      <description>SCADE is a development environment for safety critical embedded software used for more than twenty years in various application domains like avionics, nuclear plants, transportation, automotive. Its code generator is qualified for several industrial standards (DO-178C, IEC 61508, EN 50128, IEC 60880 and ISO 26262) to be used in the development of the most safety critical systems. 
Scade is historically based on the synchronous language Lustre designed in Grenoble in the VERIMAG laboratory by its two mains authors Paul Caspi and Nicolas Halbwachs. In its early days, SCADE was mainly seen as a graphical notation for this academic language. 
In 2008, a major new version was released, based on the language Scade 6 that extended the dataflow point of view offered by Lustre to integrate new constructs inspired by Esterel and SyncCharts in order to allow more control oriented design style. This language is formally specified following the work of Marc Pouzet on the design of Lucid Synchrone, in particular on the static correction of programs. The formalized aspects cover mainly the static semantics i.e. the type systems that define what a correct program is; this correction is based on four type systems: Types (in the most classical sense), Clocks, Initialization analysis and Causality analyses. 
As a formal language, Scade is also well suited to apply formal verification on the applications developed with it. Programs are guaranteed to run in finite memory which allows to use state of the art model checking techniques. 
The talk will go through this history, giving some insights on the new Scade 6 constructs, its differences with Lustre and on the development of its qualified code generator. 
The formal verification of Scade 6 programs will also be illustrated. 
About the speaker 
Jean-Louis Colaço is R&amp;amp;D Distinguished Engineer at ANSYS and works on SCADE Core technologies (language, compiler, and other semantic based tools). He received his Engineering and master’s degree in 1994 and his Ph.D. in Computer Science from the National Polytechnic Institute of Toulouse in 1997. He started working on Scade language in 1999 and his one of the main designers of Scade 6 language. From 2007 to 2008 he worked in the innovation group at Siemens-VDO as a project manager in the powertrain department. From 2008 to 2013 he was at Prover-Technology working on certified formal verification doing both tool development and consulting on application of model checking to railways systems.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Jean-Louis</first_name>
          <last_name>Colaço</last_name>
          <affiliation>ANSYS</affiliation>
          <bio>Jean-Louis Colaço is R&amp;amp;D Distinguished Engineer at ANSYS and works on ANSYS® SCADE Suite® Core technologies (language, compiler, and other semantic based tools). 
He received his Engineering and master’s degree in 1994 and his Ph.D. in Computer Science from the National Polytechnic Institute of Toulouse in 1997. 
He started working on Scade language and compilation in 1999 and his one of the main designers of Scade 6 language. 
From 2007 to 2008 he worked in the innovation group at Siemens-VDO as a project manager in the powertrain department. 
From 2008 to 2013 he was at Prover-Technology working on certified formal verification doing both tool development and consulting on application of model checking to railways systems.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeanlouiscolaco/95455a18-bf6c-4632-a0b8-a8fd984243dc/small.jpg</picture_url>
          <person_id>jeanlouiscolaco</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f0dff02f-85d8-483c-bc90-f5525c2dc08c</slot_id>
      <event_id>03c9b5fd-4436-4727-a974-7ebd8093cfc2</event_id>
      <title>Welcome to REBLS</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/16</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>07:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Chair</role>
          <sort_key>1</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Perez</last_name>
          <affiliation>NIA / NASA Formal Methods</affiliation>
          <bio>Researcher @ NIA / NASA Formal Methods | Founder @ Haskell Game Company Keera Studios | Haskell game and mobile app developer.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/ivanperez/c45c544e-ba8b-4bed-8026-1a1bd7ea42a0/small.jpg</picture_url>
          <person_id>ivanperez</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b745c7af-cb33-45ec-b30b-8f9f08beb8f5</subevent_id>
    <title>SLE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/17</date>
    <url>https://conf.researchr.org/home/sle-2020</url>
    <url_link_display>SLE (Software Language Engineering) 2020</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>e496920b-83f0-4ce8-ac14-54791928a8e2</slot_id>
      <title>Session: SLE - </title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>03:00</start_time>
      <end_time>03:40</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Ralf</first_name>
          <last_name>Lämmel</last_name>
          <affiliation>Facebook London</affiliation>
          <bio>http://www.softlang.org/rlaemmel:bio</bio>
          <homepage_url>http://softlang.wikidot.com/rlaemmel:home</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ralflammel/bc00aec2-e243-40e0-be65-bf9e5e21b0be/small.jpg</picture_url>
          <person_id>ralflammel</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>97ccf6b1-5407-475a-a859-6fae61c10e61</slot_id>
      <event_id>1e1d3614-e96a-428d-afe4-b54c8c8e1473</event_id>
      <title>A Semantic Framework for PEGs</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>03:20</end_time>
      <description>Parsing Expression Grammars (PEGs) are a recognition-based formalism which allows to describe the syntactical and the lexical elements of a language. The main difference between Context-Free Grammars (CFGs) and PEGs relies on the interpretation of the choice operator: while the CFGs' unordered choice $e \mid e'$ is interpreted as the union of the languages recognized by $e$ and $e'$, the PEGs' prioritized choice $e / e'$ discards $e'$ if $e$ succeeds. Such subtle, but important difference, changes the language recognized and yields more efficient parsing algorithms. This paper proposes a rewriting logic semantics for PEGs. We start with a rewrite theory giving meaning to the usual constructs in PEGs. Later, we show that cuts, a mechanism for controlling backtracks in PEGs, finds also a natural representation in our framework. We generalize such mechanism, allowing for both local and global cuts with a precise, unified and formal semantics. Hence, our work strives at better understanding and controlling backtracks in parsers for PEGs. The semantics we propose is executable and, besides being a parser with modest efficiency, it can be used as a playground to test different optimization ideas. More importantly, it is a mathematical tool that can be used for different analyses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sergio</first_name>
          <last_name>Queiroz de Medeiros</last_name>
          <affiliation>Universidade Federal do Rio Grande do Norte</affiliation>
          <bio>undefined</bio>
          <person_id>sergioqueirozdemedeiros</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Carlos</first_name>
          <last_name>Olarte</last_name>
          <affiliation>Federal University of Rio Grande do Norte, Brazil</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.google.com/site/carlosolarte/</homepage_url>
          <person_id>carlosolarte</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ee383e5f-8da7-4c15-ab5d-154033e08279</slot_id>
      <event_id>404708eb-bcbb-481f-b5ef-b48d662575be</event_id>
      <title>Untangling Mechanized Proofs</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>03:40</end_time>
      <description>Proof assistants like Coq, Lean, or HOL4 rely heavily on stateful meta-programs called \emph{scripts} to assemble proofs. Unlike pen-and-paper proofs, proof scripts only describe the steps to take (induct on $x$, apply a theorem, …), not the \emph{states} that these steps lead to; as a result, plain proof scripts are essentially incomprehensible without the assistance of an interactive user interface able to run the script and show the corresponding proof states. 
Until now, the standard process to communicate a proof without forcing readers to execute its script was to manually copy-paste intermediate proof states into the script, as source code comments — a tedious and error-prone exercise. Additional prose (such as for a book or tutorial) was likewise embedded in comments, preserving executability at the cost of a mediocre text-editing experience. 
This paper describes a new approach to the development and dissemination of literate proof scripts, with a focus on the Coq proof assistant. Specifically, we describe two contributions: a compiler that interleaves Coq's output with the original proof script to produce interactive webpages that are complete, self-contained presentations of Coq proofs; and a new literate programming toolkit that allows authors to switch seamlessly between prose- and code-oriented views of the same sources, by translating back and forth between reStructuredText documents and literate Coq source files. In combination, these tools offer a new way to write, communicate, and preserve proofs, combining the flexibility of procedural proof scripts and the intelligibility of declarative proofs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Clément</first_name>
          <last_name>Pit-Claudel</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>I’m a PhD candidate at MIT, working in Adam Chlipala’s lab. My research focuses on proof assistants, extensible compilers, and programming languages; my broader interests include hardware design languages, optimization, databases, and type theory. I work on end-to-end verified compilation pipelines from high-level specifications to assembly language, verified compilers and fast simulation for rule-based hardware design languages with EHRs, and Coq tooling. And I’m applying for faculty positions this year!</bio>
          <homepage_url>http://pit-claudel.fr/clement/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/clementpitclaudel/4a4c3ccf-6680-4f0b-a87f-056c4d081fc2/small.jpg</picture_url>
          <person_id>clementpitclaudel</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>034c8431-850f-4d8f-bd2b-a702454f9fd0</subevent_id>
    <title>SLE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/16</date>
    <url>https://conf.researchr.org/home/sle-2020</url>
    <url_link_display>SLE (Software Language Engineering) 2020</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>9d65fce7-f05a-4f64-bf5c-c3b131211d45</slot_id>
      <title>Session: SLE - </title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Paddy</first_name>
          <last_name>Krishnan</last_name>
          <affiliation>Oracle Labs, Australia</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/paddykrishnan/36e9562d-4d3c-47a8-a27b-cdae9ff14c32/small.jpg</picture_url>
          <person_id>paddykrishnan</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0ed16ebb-9aca-4027-8a45-361f336679cc</slot_id>
      <event_id>96904519-a65b-454a-beea-44c4b59c05c4</event_id>
      <title>Example-Driven Software Language Engineering</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:40</end_time>
      <description>Language workbenches—tools to define software languages together with their IDEs—are designed to simplify language engineering and implementation: they free language engineers from many meticulous tasks, but oftentimes have a very steep learning curve even for experienced software professionals. With the assumption that meta-definitions are one of the key factors that hinder language engineering, we introduce an example-driven approach to language definition. We describe in this paper our vision of a web-based tool aimed at beginner language engineers, and list possible requirements for such a tool. A language is defined by giving examples of code written in it using illustrative syntax definition. These examples are then annotated to specify different concerns of language definition—abstract syntax, typing rules, validation rules, formatting rules, and dynamic semantics.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mikhail</first_name>
          <last_name>Barash</last_name>
          <affiliation>University of Bergen, Norway</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://dsl-course.org/mikbar/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mikhailbarash/d876d731-3779-4e11-8aee-de2bcef5e938/small.jpg</picture_url>
          <person_id>mikhailbarash</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>306af139-9ebc-4b69-b9a7-4ad06e4f4f2b</slot_id>
      <event_id>606ec49c-4792-4253-89ec-4010e21d70de</event_id>
      <title>A Precedence-Driven Approach for Concurrent Model Synchronization Scenarios using Triple Graph Grammars</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:20</end_time>
      <description>Concurrent model synchronization is the task of restoring consistency between two correlated models after they have been changed concurrently and independently. To determine whether such concurrent model changes conflict with each other and to resolve these conflicts taking domain- or user-specific preferences into account is highly challenging. In this paper, we present a framework for concurrent model synchronization algorithms based on Triple Graph Grammars (TGGs). TGGs specify the consistency of correlated models using grammar rules; these rules can be used to derive different consistency restoration operations. Using TGGs, we infer a causal dependency relation for model elements that enables us to detect conflicts non-invasively. Different kinds of conflicts are detected first and resolved by the subsequent conflict resolution process. Users configure the overall synchronization process by orchestrating the application of consistency restoration fragments according to several conflict resolution strategies to achieve individual synchronization goals. As proof of concept, we have implemented this framework in the model transformation tool eMoflon. Our initial evaluation shows that the runtime of our presented approach scales with the size of model changes and conflicts, rather than model size.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lars</first_name>
          <last_name>Fritsche</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>larsfritsche1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jens</first_name>
          <last_name>Kosiol</last_name>
          <affiliation>University of Marburg, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>jenskosiol1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Adrian</first_name>
          <last_name>Möller</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>adrianmoller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Andy</first_name>
          <last_name>Schürr</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/andyschurr/b3c83371-9583-4f5a-b3ca-1240bf1f9bda/small.jpg</picture_url>
          <person_id>andyschurr</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Gabriele</first_name>
          <last_name>Taentzer</last_name>
          <affiliation>University of Marburg, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.uni-marburg.de/fb12/swt/gabi-taentzer</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gabrieletaentzer/c2ef5fee-d409-4762-87a4-ad92dda7413b/small.jpg</picture_url>
          <person_id>gabrieletaentzer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>48548dc2-5b97-494d-8455-9a407a09343d</slot_id>
      <event_id>0579642d-68a8-476d-85c0-4a8d1667dd31</event_id>
      <title>Behavior Trees in Action: A Study of Robotics Applications</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>00:00</end_time>
      <description>Autonomous robots combine a variety of skills to form increasingly complex behaviors called missions. While the skills are often programmed at a relatively low level of abstraction, their coordination is architecturally separated and often expressed in higher-level languages or frameworks. Recently, the language of Behavior Trees gained attention among roboticists for this reason. Originally designed for computer games to model autonomous actors, Behavior Trees offer an extensible tree-based representation of missions. However, even though, several implementations of the language are in use, little is known about its usage and scope in the real world. How do behavior trees relate to traditional languages for describing behavior? How are behavior tree concepts used in applications? What are the benefits of using them? 
We present a study of the key language concepts in Behavior Trees and their use in real-world robotic applications. We identify behavior tree languages and compare their semantics to the most well-known behavior modeling languages: state and activity diagrams. We mine open source repositories for robotics applications that use the language and analyze this usage. We find that Behavior Trees are a pragmatic language, not fully specified, allowing projects to extend it even for just one model. Behavior trees clearly resemble the models-at-runtime paradigm. We contribute a dataset of real-world behavior models, hoping to inspire the community to use and further develop this language, associated tools, and analysis techniques.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Razan</first_name>
          <last_name>Ghzouli</last_name>
          <affiliation>Chalmers University of Technology &amp; University of Gothenburg</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://orcid.org/0000-0002-5428-8113</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/razanghzouli/4a1d42cd-e90e-427e-8686-f823139700f3/small.jpg</picture_url>
          <person_id>razanghzouli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thorsten</first_name>
          <last_name>Berger</last_name>
          <affiliation>Chalmers University of Technology, Sweden / University of Gothenburg, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.chalmers.se/~bergert</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/thorstenberger/d2f325bb-820f-49b8-985d-e62ac888dedd/small.jpg</picture_url>
          <person_id>thorstenberger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Einar</first_name>
          <last_name>Broch Johnsen</last_name>
          <affiliation>University of Oslo</affiliation>
          <bio>undefined</bio>
          <person_id>einarbrochjohnsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Swaib</first_name>
          <last_name>Dragule</last_name>
          <affiliation>Chalmers | University of Gothenburg</affiliation>
          <bio>undefined</bio>
          <person_id>swaibdragule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Andrzej</first_name>
          <last_name>Wąsowski</last_name>
          <affiliation>IT University of Copenhagen, Denmark</affiliation>
          <bio>MSc Eng from Warsaw University of Technology (2000) PhD from IT University of Copenhagen (2005) 
Interested in developing repeatable software engineering methods, supported by innovative tools and technology, to solve domain specific problems (safety critical systems, industry automation, robotics, legacy systems, and personal data protection).</bio>
          <homepage_url>http://www.itu.dk/people/wasowski</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andrzejwasowski/36304e96-b840-4d13-933d-7f422b4a3ddc/small.jpg</picture_url>
          <person_id>andrzejwasowski</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f7a8fee3-9466-46ae-bd37-5bbdaf96d23d</slot_id>
      <event_id>8418bc21-ddd2-4ae2-aef7-57450c6d8922</event_id>
      <title>A Search-Based and Fault-Tolerant Approach to Concurrent Model Synchronisation</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>00:20</end_time>
      <description>In collaboration scenarios, we often encounter situations in which semantically interrelated models are changed concurrently. Concurrent model synchronization denotes the task of keeping these models consistent by propagating changes between them. This is challenging as changes can contradict each other and thus be in conflict. A problem with current synchronisation approaches is that they are often nondeterministic, i.e., the order in which changes are propagated is essential for the result. Furthermore, a common limitation is that the involved models must have been in a consistent state at some point, and that the applied changes are at least valid for the domain in which they were made. We propose a hybrid approach based on Triple Graph Grammars (TGGs) and Integer Linear Programming (ILP) to overcome these issues: TGGs are a grammar-based means that supplies us with a superset of possible synchronization solutions, forming a search space from which an optimum solution incorporating user-defined preferences can be chosen by ILP. Therefore, the proposed method combines configurability by comprising expert knowledge via TGGs with the flexible input handling of search-based techniques: By accepting arbitrary graph structures as input models, the approach is tolerant towards errors induced during the modelling process, i.e., it can cope with input models which do not conform to their metamodel or which cannot be generated by the TGG at hand. The approach is implemented in the model transformation tool eMoflon and evaluated regarding scalability for growing model sizes and an increasing number of changes.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nils</first_name>
          <last_name>Weidmann</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>nilsweidmann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lars</first_name>
          <last_name>Fritsche</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>larsfritsche1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anthony</first_name>
          <last_name>Anjorin</last_name>
          <affiliation>Paderborn University, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/anthonyanjorin1/158aeedd-1bac-498b-9521-79557507e112/small.jpg</picture_url>
          <person_id>anthonyanjorin1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>815bb438-d010-40e1-8e42-6e54188c44fd</subevent_id>
    <title>HATRA: Research Agenda Planning</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-VI</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/home/hatra-2020</url>
    <url_link_display>Human Aspects of Types and Reasoning Assistants</url_link_display>
    <tracks>
      <track>Human Aspects of Types and Reasoning Assistants</track>
    </tracks>
    <timeslot>
      <slot_id>83c0123d-c9dd-4c99-b53b-6429faa9633a</slot_id>
      <title>Session: HATRA - Research Agenda Planning</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/19</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3c74b66d-2784-454d-89dc-23ece8992433</slot_id>
      <event_id>48be832b-b484-4c5c-80d7-d03d99dffd56</event_id>
      <title>Research Agenda Planning</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/19</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>16:20</end_time>
      <description>As an output of this workshop, we would like to construct a research agenda for the HATRA community. We hope that this will help motivate and inspire future work in this area, as well as help researches focus on the most important, useful questions.</description>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e130c44f-2cce-4ddc-9ba3-bd79a7a8515b</subevent_id>
    <title>HATRA: Types</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/home/hatra-2020</url>
    <url_link_display>Human Aspects of Types and Reasoning Assistants</url_link_display>
    <tracks>
      <track>Human Aspects of Types and Reasoning Assistants</track>
    </tracks>
    <timeslot>
      <slot_id>59e67db1-cecb-4335-9efa-8067e3bfb8b1</slot_id>
      <title>Session: HATRA - Types</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/18</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6a1c3e46-4676-48a1-9b1d-c5a634d98f23</slot_id>
      <event_id>2d5d9980-7c40-405b-bd43-e1dbe74295f9</event_id>
      <title>The Usability of Ownership</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/18</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>13:20</end_time>
      <description>Ownership is the flagship feature of Rust, known to be a learning challenge for any new user. A core usability challenge of ownership in practice is the gap between its definition and its implementation within Rust’s borrow checker. As a sound and incomplete static analysis, Rust users must carefully interpret type errors to distinguish genuinely unsound behavior from limitations of the analyzer. I explore the challenges at each step in this process of interpretation, and suggest a variety of educational and automated interventions that could improve the usability of ownership.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Will</first_name>
          <last_name>Crichton</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://willcrichton.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/willcrichton/03949743-0d45-4f73-9496-b6ab65dc7f5c/small.jpg</picture_url>
          <person_id>willcrichton</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7f909358-5e99-4fd3-a9c4-76a6ee50b35e</slot_id>
      <event_id>10bca0b2-9290-46b9-b1d6-7ef327abcd13</event_id>
      <title>RustViz: Interactively Visualizing Ownership and Borrowing</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/18</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>13:40</end_time>
      <description>Rust is a systems programming language that guarantees memory safety without the need for a garbage collector by statically tracking ownership and borrowing events. The associated rules are subtle and unique among industry programming languages, which can make learning Rust more challenging. Motivated by the challenges that Rust learners face, we are developing RustViz, a tool that allows teachers to generate an interactive timeline depicting ownership and borrow events for each variable in a Rust code example. These visualizations are intended to help Rust learners develop an understanding of ownership and borrowing by example. This paper introduces RustViz by example, shows how teachers can use it to generate visualizations, describes learning goals, and proposes a study designed to evaluate RustViz based on these learning goals.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gongming (Gabriel)</first_name>
          <last_name>Luo</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <person_id>gongminggabrielluo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vishnu</first_name>
          <last_name>Reddy</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <person_id>vishnureddy</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marcelo</first_name>
          <last_name>Almeida</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <person_id>marceloalmeida</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yingying</first_name>
          <last_name>Zhu</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <person_id>yingyingzhu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ke</first_name>
          <last_name>Du</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <person_id>kedu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Cyrus</first_name>
          <last_name>Omar</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>https://fplab.mplse.org/</bio>
          <homepage_url>https://web.eecs.umich.edu/~comar</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cyrusomar/6f85cfe7-5130-42cf-9976-450725051201/small.jpg</picture_url>
          <person_id>cyrusomar</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>acd0e6d4-e214-41fa-a0bf-3b57511ea1e4</slot_id>
      <event_id>b618747e-7889-4e45-acf4-74f69aa20a79</event_id>
      <title>Guiding user annotations for units-of-measure verification</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/18</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>14:00</end_time>
      <description>This extended abstract reports on previous work of the CamFort project in which we developed an external units-of-measure type system for Fortran code, targeted at scientists. Our approach can guide the programmer in adding specifications (type annotations) to existing code, with the aim of easing adoption on legacy code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dominic</first_name>
          <last_name>Orchard</last_name>
          <affiliation>University of Kent, UK</affiliation>
          <bio>Dr Dominic Orchard is a Lecturer in the School of Computing at the University of Kent, UK and he is a fellow of the SSI. His research interests are programming language design and semantics, mathematically structured programming, effect and coeffect systems, embedded domain-specific languages (esp. for parallelisation), and applying programming language research to computational science.</bio>
          <homepage_url>http://dorchard.co.uk</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/dominicorchard/f448aa26-a342-457c-91a6-3f9525a759a3/small.jpg</picture_url>
          <person_id>dominicorchard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mistral</first_name>
          <last_name>Contrastin</last_name>
          <affiliation>Facebook London</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://dodisturb.me</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mistralcontrastin/e41de656-5770-47da-a642-5f1f934a6b9c/small.jpg</picture_url>
          <person_id>mistralcontrastin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Danish</last_name>
          <affiliation>University of Cambridge, UK</affiliation>
          <bio>undefined</bio>
          <person_id>matthewdanish</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Rice</last_name>
          <affiliation>University of Cambridge, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cl.cam.ac.uk/~acr31</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andrewrice/d82f99ff-a659-43c8-8d8f-f244f91cb9a8/small.jpg</picture_url>
          <person_id>andrewrice</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>80176d78-ece3-453c-b35f-b53ae478c4cf</subevent_id>
    <title>HATRA: Novices and Application Domains</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-VI</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/home/hatra-2020</url>
    <url_link_display>Human Aspects of Types and Reasoning Assistants</url_link_display>
    <tracks>
      <track>Human Aspects of Types and Reasoning Assistants</track>
    </tracks>
    <timeslot>
      <slot_id>3063d3de-3792-4251-81bc-52fd1a795502</slot_id>
      <title>Session: HATRA - Novices and Application Domains</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/19</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>18467653-096a-42f3-8be8-7f8418585fa4</slot_id>
      <event_id>fea140a9-0261-4987-80ff-ee8666551db8</event_id>
      <title>Hazel Tutor: Guiding Novices Through Type-Driven Development Strategies</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/19</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>14:20</end_time>
      <description>Hazel Tutor is a work-in-progress editor service for the Hazel programming environment designed to interactively help novices learn type-driven development strategies as they construct, edit, and debug code. The system provides both feedback and, when requested, suggestions on the basis of type information available at the cursor. Hazel is able to supply the Hazel Tutor with the necessary information at all times, including when there are \emph{holes} in the program. When the cursor is on an empty hole, the system organizes the suggestions based on the type-driven development strategy that we aim to teach students. We are beginning to work on presenting debugging strategies when on an error hole. We outline our hypotheses, specific research questions of interest, and planned future studies.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hannah</first_name>
          <last_name>Potter</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <person_id>hannahpotter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Cyrus</first_name>
          <last_name>Omar</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>https://fplab.mplse.org/</bio>
          <homepage_url>https://web.eecs.umich.edu/~comar</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cyrusomar/6f85cfe7-5130-42cf-9976-450725051201/small.jpg</picture_url>
          <person_id>cyrusomar</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>61984c0b-34fb-409d-95d1-fa92a9572674</slot_id>
      <event_id>3ab487b3-2220-4ec4-8fe4-8441b78edaf0</event_id>
      <title>Reference-Driven Synthesis for Programming Tutors</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/19</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>13:20</end_time>
      <description>When giving automated feedback to a student working on a beginner’s exercise, many programming tutors run into a completeness problem. On the one hand, we want a student to experiment freely. On the other hand, we want a student to write her program in such a way that we can provide constructive feedback. We propose to investigate how we can overcome this problem by using program synthesis, which we use to generate correct solutions that closely match a student program, and give feedback based on the results.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Niek</first_name>
          <last_name>Mulleners</last_name>
          <affiliation>Utrecht University</affiliation>
          <bio>undefined</bio>
          <person_id>niekmulleners</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Johan</first_name>
          <last_name>Jeuring</last_name>
          <affiliation>Open University of the Netherlands, Netherlands</affiliation>
          <bio>undefined</bio>
          <person_id>johanjeuring1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9dc59374-8530-4089-9965-e69d4306775c</slot_id>
      <event_id>9603250d-9342-4e9b-9a0f-eb57f647d720</event_id>
      <title>Opportunities and Challenges for Circuit Board Level Hardware Description Languages</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/19</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>14:00</end_time>
      <description>Board-level hardware description languages (HDLs) are one approach to increasing automation and raising the level of abstraction for designing electronics. These systems borrow programming languages concepts like generators and type systems, but also must be designed with human factors in mind to serve existing hardware engineers. In this work, we look at one recent prototype system, and discuss open questions from fundamental models through usable interfaces.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Richard</first_name>
          <last_name>Lin</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>undefined</bio>
          <person_id>richardlin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bjoern</first_name>
          <last_name>Hartmann</last_name>
          <affiliation>UC Berkeley</affiliation>
          <bio>undefined</bio>
          <person_id>bjoernhartmann</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ad8231a0-ee9c-4624-9ebc-b9aff298c5d7</slot_id>
      <event_id>45904726-426a-410e-86aa-8f5e86331f85</event_id>
      <title>Towards Solver-Aided Creativity</title>
      <room>Online | SPLASH-VI</room>
      <date>2020/11/19</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>13:40</end_time>
      <description>A number of creative tasks involve a process of defining, exploring, and refining search spaces. For example, procedural content generation comprises a set of creative technical practices for generating digital artifacts, such as video game levels, with the goal of a diverse, novel, and high-quality range of output to create variation in game-player experiences. Story authorship, game development, digital art creation, and more follow similar patterns. However, current digital tools that could assist with this process are mainly limited to audiences who already have a high degree of skill and confidence with programming in general-purpose languages. Furthermore, even with proficiency in these tools, they are limited in the control they offer for exploring and systematically assessing the possibility space defined by author rules. In this proposal, I argue for building on the success of solver-aided languages of tools by addressing these needs of creative practitioners.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chris</first_name>
          <last_name>Martens</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>Ph.D. Carnegie Mellon University, 2015 
Postdoc UC Santa Cruz, 2015-2016 
Assistant Professor, NC State University, 2016-present</bio>
          <homepage_url>http://go.ncsu.edu/cmartens</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/chrismartens/962dad73-d5f2-486d-a080-7722ef25ed3f/small.jpg</picture_url>
          <person_id>chrismartens</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b8e0bfbd-d0b9-4eb9-88ba-5ecfc10649c2</subevent_id>
    <title>SLE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/16</date>
    <url>https://conf.researchr.org/home/sle-2020</url>
    <url_link_display>SLE (Software Language Engineering) 2020</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>2199a116-6bde-44cc-a995-9a1d3a820cf6</slot_id>
      <title>Session: SLE - </title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>15:00</start_time>
      <end_time>15:40</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Paddy</first_name>
          <last_name>Krishnan</last_name>
          <affiliation>Oracle Labs, Australia</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/paddykrishnan/36e9562d-4d3c-47a8-a27b-cdae9ff14c32/small.jpg</picture_url>
          <person_id>paddykrishnan</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>68c255ec-e48d-43e5-96e9-23bf9be2b4ba</slot_id>
      <event_id>1e1d3614-e96a-428d-afe4-b54c8c8e1473</event_id>
      <title>A Semantic Framework for PEGs</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>15:20</end_time>
      <description>Parsing Expression Grammars (PEGs) are a recognition-based formalism which allows to describe the syntactical and the lexical elements of a language. The main difference between Context-Free Grammars (CFGs) and PEGs relies on the interpretation of the choice operator: while the CFGs' unordered choice $e \mid e'$ is interpreted as the union of the languages recognized by $e$ and $e'$, the PEGs' prioritized choice $e / e'$ discards $e'$ if $e$ succeeds. Such subtle, but important difference, changes the language recognized and yields more efficient parsing algorithms. This paper proposes a rewriting logic semantics for PEGs. We start with a rewrite theory giving meaning to the usual constructs in PEGs. Later, we show that cuts, a mechanism for controlling backtracks in PEGs, finds also a natural representation in our framework. We generalize such mechanism, allowing for both local and global cuts with a precise, unified and formal semantics. Hence, our work strives at better understanding and controlling backtracks in parsers for PEGs. The semantics we propose is executable and, besides being a parser with modest efficiency, it can be used as a playground to test different optimization ideas. More importantly, it is a mathematical tool that can be used for different analyses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sergio</first_name>
          <last_name>Queiroz de Medeiros</last_name>
          <affiliation>Universidade Federal do Rio Grande do Norte</affiliation>
          <bio>undefined</bio>
          <person_id>sergioqueirozdemedeiros</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Carlos</first_name>
          <last_name>Olarte</last_name>
          <affiliation>Federal University of Rio Grande do Norte, Brazil</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.google.com/site/carlosolarte/</homepage_url>
          <person_id>carlosolarte</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>82d4554d-892c-4a74-a804-8d16c1be9cd3</slot_id>
      <event_id>404708eb-bcbb-481f-b5ef-b48d662575be</event_id>
      <title>Untangling Mechanized Proofs</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>15:40</end_time>
      <description>Proof assistants like Coq, Lean, or HOL4 rely heavily on stateful meta-programs called \emph{scripts} to assemble proofs. Unlike pen-and-paper proofs, proof scripts only describe the steps to take (induct on $x$, apply a theorem, …), not the \emph{states} that these steps lead to; as a result, plain proof scripts are essentially incomprehensible without the assistance of an interactive user interface able to run the script and show the corresponding proof states. 
Until now, the standard process to communicate a proof without forcing readers to execute its script was to manually copy-paste intermediate proof states into the script, as source code comments — a tedious and error-prone exercise. Additional prose (such as for a book or tutorial) was likewise embedded in comments, preserving executability at the cost of a mediocre text-editing experience. 
This paper describes a new approach to the development and dissemination of literate proof scripts, with a focus on the Coq proof assistant. Specifically, we describe two contributions: a compiler that interleaves Coq's output with the original proof script to produce interactive webpages that are complete, self-contained presentations of Coq proofs; and a new literate programming toolkit that allows authors to switch seamlessly between prose- and code-oriented views of the same sources, by translating back and forth between reStructuredText documents and literate Coq source files. In combination, these tools offer a new way to write, communicate, and preserve proofs, combining the flexibility of procedural proof scripts and the intelligibility of declarative proofs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Clément</first_name>
          <last_name>Pit-Claudel</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>I’m a PhD candidate at MIT, working in Adam Chlipala’s lab. My research focuses on proof assistants, extensible compilers, and programming languages; my broader interests include hardware design languages, optimization, databases, and type theory. I work on end-to-end verified compilation pipelines from high-level specifications to assembly language, verified compilers and fast simulation for rule-based hardware design languages with EHRs, and Coq tooling. And I’m applying for faculty positions this year!</bio>
          <homepage_url>http://pit-claudel.fr/clement/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/clementpitclaudel/4a4c3ccf-6680-4f0b-a87f-056c4d081fc2/small.jpg</picture_url>
          <person_id>clementpitclaudel</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>17377b23-05ed-4f99-9bc8-8939f18a240b</subevent_id>
    <title>REBLS: Session 2</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/home/rebls-2020</url>
    <url_link_display>REBLS 2020</url_link_display>
    <tracks>
      <track>REBLS 2020</track>
    </tracks>
    <timeslot>
      <slot_id>1ff77aed-0311-4a2a-b5d2-adf544182abd</slot_id>
      <title>Session: REBLS - Session 2</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/16</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>REBLS 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2a3ba612-ea07-4586-8a89-72046a62c9fc</slot_id>
      <event_id>d14ecb44-4f2f-4795-bb37-06ea3e0c87f5</event_id>
      <title>The essence of live coding: Change the program, keep the state!</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/16</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>12:20</end_time>
      <description>One rarely encounters programming languages and frameworks that provide general-purpose and type-safe hot code swap. It is demonstrated here that this is entirely possible in Haskell, by faithfully following the motto of live coding: “Change the program, keep the state.” 
With generic programming, one easily arrives at an automatic state migration function. The approach can be generalised to an arrowized Functional Reactive Programming framework that is parametrized by its side effects. It allows for building up complete live programs from reusable, modular components, and to separate data flow cleanly from control flow. Useful utilities for debugging and quickchecking are presented.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Bärenz</last_name>
          <affiliation>sonnen eServices GmbH</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.manuelbaerenz.de/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelbarenz/96dd561c-d7d2-4756-b737-c8b5745361ba/small.jpg</picture_url>
          <person_id>manuelbarenz</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>802723a6-caf0-4f36-9ac1-86a91f55607a</slot_id>
      <event_id>cfc3f989-b646-41e5-947c-a1991af6134a</event_id>
      <title>Asynchronous Monad for Reactive IoT Programming</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/16</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:40</end_time>
      <description>Many industrial IoT applications process sensor data over distributed networks to monitor devices in real-time. Since the sensor telemetries are transmitted over networks as events, imperative and event-driven programs are often used to handle IoT data. However, the inverted control flow and shared global states of these imperative programs make them difficult to interface with synchronized computation on IoT data. This problem is further complicated for high-frequency data such as electric signals, which may require dynamic adjustment to data sampling rate to operate under the constraints of network and system. 
In this paper, we propose a push-pull reactive programming model for IoT application to address this challenge. This model uses push-streams for asynchronous computation such as data capturing and user controls, and uses pull streams for synchronized computation such as data analysis. This model is simpler than push-based models by avoiding the complexity of glitch prevention through re-sampling in pull-streams. It is also more flexible than pull-based models by allowing dynamic adjustment of the sampling rate to maintain real-time speed of the IoT computation. The push-stream has a monadic interface, which converts to a pull stream through buffering. A pull stream converts to a push-stream when driven by a clock. The dynamic switching of our streams is based on a monadic abstraction called AsyncM that uses continuation passing style, and a form of cancellation token for asynchronous control. Our model is simple and can use threads or event callbacks for concurrency.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tian</first_name>
          <last_name>Zhao</last_name>
          <affiliation>University of Wisconsin-Milwaukee</affiliation>
          <bio>undefined</bio>
          <person_id>tianzhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Adam</first_name>
          <last_name>Berger</last_name>
          <affiliation>University of Wisconsin -- Milwaukee</affiliation>
          <bio>undefined</bio>
          <person_id>adamberger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yonglun</first_name>
          <last_name>Li</last_name>
          <affiliation>University of Wisconsin -- Milwaukee</affiliation>
          <bio>undefined</bio>
          <person_id>yonglunli</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7f2e0f9a-7dcc-4119-b0c3-cbb68cf69f84</subevent_id>
    <title>REBLS: Session 4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/home/rebls-2020</url>
    <url_link_display>REBLS 2020</url_link_display>
    <tracks>
      <track>REBLS 2020</track>
    </tracks>
    <timeslot>
      <slot_id>bcaf7e19-4ffe-452d-be86-1a3a1007f078</slot_id>
      <title>Session: REBLS - Session 4</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/16</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <tracks>
        <track>REBLS 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>217fc35a-8973-4b86-befd-fac28c9e5a98</slot_id>
      <event_id>81120cb9-e729-4f47-bdf6-c1dd61a4585b</event_id>
      <title>Multitier Languages for Reactive Microservice Architectures</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/16</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>15:40</end_time>
      <description>Throughout the last years, Microservice Architectures (MSA) became increasingly popular. This architectural style fosters the design of maintainable applications by composing distributed systems out of small services, each of which provides its own well-delimited set of functionalities. Such Microservices are independently develop- and deployable. However, MSAs force developers to deal with a number of low level programming details like communication protocols, data formats, or interface incompatibility. Additionally, retracing data flow across reactive microservices that use asynchronous event-based communication can be troublesome, as service independence can impede obtaining an overarching view of the system. 
Multitier programming allows developing the components of a distributed system within a single compilation unit, abstracting away the complexity associated with distribution. Details such as remote communication or data conversion are taken care of by the language. The compiler splits the code into the corresponding tiers, adds necessary network communication, and generates the deployment units. 
We present work-in-progress on a novel approach to combine the upsides of both worlds for developing reactive, event-based MSAs by extending the multitier language ScalaLoci with a containerization extension. Our approach provides language-level features to address modular design and development, and compiles down to microservices which are scalable, fault tolerant, and independently deployable. 
This paper is submitted as a work-in-progress paper.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Simon</first_name>
          <last_name>Schoenwaelder</last_name>
          <affiliation>TU Darmstadt</affiliation>
          <bio>undefined</bio>
          <person_id>simonschoenwaelder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pascal</first_name>
          <last_name>Weisenburger</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/pascalweisenburger/bf663f00-24ac-4d12-919b-ef1e2ff8e128/small.jpg</picture_url>
          <person_id>pascalweisenburger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Guido</first_name>
          <last_name>Salvaneschi</last_name>
          <affiliation>University of St. Gallen, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.guidosalvaneschi.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guidosalvaneschi/6f1373d5-57c6-4d68-b6c3-c0a679ee24ed/small.jpg</picture_url>
          <person_id>guidosalvaneschi</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>96056b94-6ccf-45ac-8ca0-3fed15050f9c</slot_id>
      <event_id>10e50b65-6d63-4da2-b988-9967f867f145</event_id>
      <title>Closing remarks</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/16</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>16:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Chair</role>
          <sort_key>1</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Perez</last_name>
          <affiliation>NIA / NASA Formal Methods</affiliation>
          <bio>Researcher @ NIA / NASA Formal Methods | Founder @ Haskell Game Company Keera Studios | Haskell game and mobile app developer.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/ivanperez/c45c544e-ba8b-4bed-8026-1a1bd7ea42a0/small.jpg</picture_url>
          <person_id>ivanperez</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e360dda2-2b3b-4a36-b7f4-def8c7187c4f</subevent_id>
    <title>REBLS: Session 1</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/home/rebls-2020</url>
    <url_link_display>REBLS 2020</url_link_display>
    <tracks>
      <track>REBLS 2020</track>
    </tracks>
    <timeslot>
      <slot_id>887f6817-706a-48b3-944a-9603e09432b4</slot_id>
      <title>Session: REBLS - Session 1</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/16</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Perez</last_name>
          <affiliation>NIA / NASA Formal Methods</affiliation>
          <bio>Researcher @ NIA / NASA Formal Methods | Founder @ Haskell Game Company Keera Studios | Haskell game and mobile app developer.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/ivanperez/c45c544e-ba8b-4bed-8026-1a1bd7ea42a0/small.jpg</picture_url>
          <person_id>ivanperez</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0591c2de-c2dc-4525-ae41-c08aeebd19c4</slot_id>
      <event_id>082e1e0d-bacd-4ae3-ac56-27f980ab277b</event_id>
      <title>Debugging RxJS-based Applications</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/16</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>09:40</end_time>
      <description>RxJS is a popular library to implement data-flow-oriented applications with JavaScript using reactive programming principles. This way of programming bears new challenges for traditional debuggers: Their focus on imperative programming limits their applicability to problems originated in the declarative programming paradigm. The goals of this paper are: (i) to understand how software engineers debug RxJS-based applications, what tools do they use, what techniques they apply; (ii) to understand what are the most prevalent challenges they face while doing so; and (iii) to provide a course of action to resolve these challenges in a future iteration on the topic. We learned about the debugging habits of ten professionals using interviews, and hands-on war story reports. Based on this data, we designed and executed an observational study with four subjects to verify that engineers predominantly augment source code with manuel trace logs instead of using specialized debugging utilities. In the end, we identified the lack of fully integrated RxJS-specific debugging solutions in existing development environments as the most significant reason why engineers do not make use of such tools. We decided to elaborate on how to resolve this situation in detail as the topic for our future work.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Alabor</last_name>
          <affiliation>University of Applied Sciences of Eastern Switzerland (OST)</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://alabor.me</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelalabor/5aa95c3b-1635-43b5-8ab1-a80a50e6a202/small.jpg</picture_url>
          <person_id>manuelalabor</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>921169da-96c0-4e6f-ac99-a9160504ec8e</slot_id>
      <event_id>9bfec7f9-3353-442d-979a-05e4783afd51</event_id>
      <title>Managing Persistent Signals using Signal Classes</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/16</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>10:20</end_time>
      <description>Persistent signals provide a convenient abstraction for time-varying values with their execution histories by implicitly leaving the management of execution histories to the database system. The current design of persistent signals is very rudimental. For example, they do not provide abstractions for representing complex data structures, and they can only be connected using API methods prepared in advance. To make matters worse, dynamic creation of persistent signals is not allowed. In this paper, we show that these problems can be addressed by introducing a new language mechanism called \emph{signal classes}. A signal class packages a network of related persistent signals that comprises a complex data structure. A signal class can be instantiated dynamically, and this instance is considered a ``small world,'' where all signals within it are synchronous. We further show that this synchronous world makes it easy to realize persistent signal networks connected by expressions that are not limited to the API methods. This dynamic creation of signal class instances is managed by a simple lifecycle model where both dynamic lifecycle events and persistency are defined.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tetsuo</first_name>
          <last_name>Kamina</last_name>
          <affiliation>Oita University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plp-www.csis.oita-u.ac.jp/~kamina/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tetsuokamina/6f2756c4-2d16-4c9c-baf5-d893d114a071/small.jpg</picture_url>
          <person_id>tetsuokamina</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tomoyuki</first_name>
          <last_name>Aotani</last_name>
          <affiliation>Mamezou Co.,Ltd.</affiliation>
          <bio>undefined</bio>
          <person_id>tomoyukiaotani1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hidehiko</first_name>
          <last_name>Masuhara</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>Hidehiko Masuhara is a Professor of Mathematical and Computing Science, Tokyo Institute of Technology since April 2013. He received his B.S., M.S., and Ph.D. in Computer Science from Department of Information Science, University of Tokyo in 1992, 1994, and 1999, respectively, and served as an assistant professor, lecturer, and associate professor at Graphics and Computer Science, Graduate School of Arts and Sciences, University of Tokyo from 1995 until 2013.</bio>
          <homepage_url>http://prg.is.titech.ac.jp/people/masuhara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hidehikomasuhara/3ea94269-6fb5-4c6d-8d6f-0435717377d6/small.jpg</picture_url>
          <person_id>hidehikomasuhara</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9f5815a7-2941-4ba2-bcbb-b422c0f8bb1a</subevent_id>
    <title>REBLS: Session 3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/home/rebls-2020</url>
    <url_link_display>REBLS 2020</url_link_display>
    <tracks>
      <track>REBLS 2020</track>
    </tracks>
    <timeslot>
      <slot_id>71d65fcd-3cad-4839-83e8-29eca1702d0e</slot_id>
      <title>Session: REBLS - Session 3</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/16</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <tracks>
        <track>REBLS 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>10416f1d-0a07-4d1a-9ec3-0230185d511b</slot_id>
      <event_id>97fe6ce6-581f-4662-8f03-e7d694d1e02c</event_id>
      <title>Reactive Sorting Networks</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/16</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>14:20</end_time>
      <description>Sorting is a central problem in computer science and one of the key components of many applications. To the best of our knowledge, no reactive programming implementation of sorting algorithms have ever been presented. 
In this paper we present a reactive implementation of so-called sorting networks. Sorting networks are networks of comparators that are wired-up in a particular order. Data enters a sorting network along various input wires and leaves the sorting network on the same number of output wires that carry the data in sorted order. 
This paper shows how sorting networks can be expressed elegantly in a reactive programming language by aligning the visual representation of a sorting network with the canonical DAG representation of reactive programs. We use our own experimental language called Haai to do so. With a limited number of built-in higher-order reactive programs, we are able to express sorting networks for bubble sort, insertion sort, bitonic sort, pairwise sort and Batcher’s odd-even merge sort.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bjarno</first_name>
          <last_name>Oeyen</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/bjarnooeyen/c798be09-5fc6-45f6-9840-071793035cef/small.jpg</picture_url>
          <person_id>bjarnooeyen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Van den Vonder</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>PhD candidate at the Software Languages Lab of the Vrije Universiteit Brussel.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/samvandenvonder/2ccd1dd4-a774-4f8b-b2a1-c601a5adc3d5/small.jpg</picture_url>
          <person_id>samvandenvonder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Wolfgang</first_name>
          <last_name>De Meuter</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/soft/users/wdmeuter</homepage_url>
          <person_id>wolfgangdemeuter</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>abe13ec2-a353-4a32-841e-9c2543255bcd</slot_id>
      <event_id>949dc025-8414-48b0-ba8f-67a4c1855984</event_id>
      <title>An Introduction to Denotative Continuous Spacetime Programming (Work in Progress)</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/16</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>13:40</end_time>
      <description>This work-in-progress paper presents Denotative Continuous Spacetime Programming (DCSP): a purely functional distributed programming language. DCSP extends the time-based semantics of Functional Reactive Programming, which previously enabled functional programming of dynamic and interactive programs, to a spacetime-based semantics. As opposed to previous distributed languages such as Erlang, programs written in DCSP can be composed out of smaller components without the use of processes. This aspect has the potential to make programs both easier to understand and less susceptible to concurrency bugs. 
Besides giving a precise semantics for DCSP, the paper provides a sketch of an implementation strategy which re-uses any sufficiently powerful FRP implementation to implement DSCP, and provides an implementation of an example program to help build intuitions for thinking about distributed programs in purely functional terms.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Adriaan</first_name>
          <last_name>Leijnse</last_name>
          <affiliation>Universidade NOVA de Lisboa</affiliation>
          <bio>undefined</bio>
          <person_id>adriaanleijnse1</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e041af99-08d3-42ef-af05-be388fbee6f4</subevent_id>
    <title>SLE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/16</date>
    <url>https://conf.researchr.org/home/sle-2020</url>
    <url_link_display>SLE (Software Language Engineering) 2020</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>2a9fb29c-5ede-4b70-9bf9-87bb0482824f</slot_id>
      <title>Session: SLE - </title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Vadim</first_name>
          <last_name>Zaytsev</last_name>
          <affiliation>University of Twente, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://grammarware.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vadimzaytsev/fe6c221f-75d5-4fbc-ac41-be9c99349b5d/small.jpg</picture_url>
          <person_id>vadimzaytsev</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>06d3687e-3b7f-46d0-b06f-918d847f0325</slot_id>
      <event_id>bee221c2-518e-4f38-a9b4-996285b8693f</event_id>
      <title>Test Case Generation from Context-Free Grammars using Generalized Traversal of LR-Automata</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>13:20</end_time>
      <description>Test case generation from context-free grammars typically uses the grammar's production rules to directly construct words that cover specific sets of derivations. Here, we investigate test case generation by traversing graphs derived from the LR-automata corresponding to the grammars. We develop a new algorithm that generates positive test cases by covering all edges between pairs of directly connected states in a two-phase breadth-first path search. The algorithm iterates over all edges stemming from shift/reduce and reduce/reduce conflicts, using a technique similar to the stack duplication used in GLR parsing. We then extend our algorithm to generate negative (i.e., syntactically invalid) test cases, by applying different edge mutation operations during the extraction of test cases from paths.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christoff</first_name>
          <last_name>Rossouw</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <person_id>christoffrossouw</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bernd</first_name>
          <last_name>Fischer</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.sun.ac.za/~bfischer/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/berndfischer/b51999f4-390c-48d9-be54-f3d1ceab7ff8/small.jpg</picture_url>
          <person_id>berndfischer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>36aeb701-df11-43fd-9cfa-4feb05ae807d</slot_id>
      <event_id>4e74b197-d3c2-4abe-92e1-faaed4180310</event_id>
      <title>Featherweight Swift: A Core Calculus for Swift’s Type System</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>14:20</end_time>
      <description>Swift is a modern general-purpose programming language, designed to be a replacement for C-based languages. Although primarily directed at development of applications for Apple's operating systems, Swift's adoption has been growing steadily in other domains, ranging from server-side services to machine learning. This success can be partly attributed to a rich type system that enables the design of safe, fast, and expressive programming interfaces. Unfortunately, this richness comes at the cost of complexity, setting a high entry barrier to exploit Swift's full potential. Furthermore, existing documentation typically only relies on examples, leaving new users with little help to build a deeper understanding of the underlying rules and mechanisms. 
This paper aims to tackle this issue by laying out the foundations for a formal framework to reason about Swift's type system. We introduce Featherweight Swift, a minimal language stripped of all features not essential to describe its typing rules. Featherweight Swift features classes and protocol inheritance, supports retroactive modeling, and emulates Swift's overriding mechanisms. Yet its formalization fits on a few pages. We present Featherweight Swift's syntax and semantics. We then elaborate on the usability of our framework to reason about Swift's features, future extensions, and implementation by discussing a bug in Swift's compiler, discovered throughout the design of our calculus.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dimitri</first_name>
          <last_name>Racordon</last_name>
          <affiliation>University of Geneva, Switzerland</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/dimitriracordon/23c16a97-1d4c-47e1-9270-89755cace04c/small.jpg</picture_url>
          <person_id>dimitriracordon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Didier</first_name>
          <last_name>Buchs</last_name>
          <affiliation>University of Geneva, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>didierbuchs</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4ca852ea-7c9c-4d21-8b67-00cce7c0bb2d</slot_id>
      <event_id>b729c3ab-2dd0-40dc-a295-f2f0e47d41fa</event_id>
      <title>An Interactive Feedback System for Grammar Development (Tool Paper)</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>14:00</end_time>
      <description>We describe gtutr, an interactive feedback system designed to assist students in developing context-free grammars and corresponding ANTLR parsers. It intelligently controls students' access to a large test suite for the target language. After each submission, gtutr analyzes any failing tests and uses the Needleman-Wunsch sequence alignment algorithm over the tests' rule traces to identify and eliminate similar failing tests. This reduces the redundancy in the feedback 
given to the students and prevents them from being overloaded. gtutr uses simple gamification to encourage independent problem solving by students: it gives as little information as possible, and students need to prompt the system for further details such as failing tests similar to or different from already seen tests, or even for hints about rules that are the most likely to contain faults. It tracks the students' information requests and uses this to attenuate marks following an instructor-set penalty schema. The system also visualizes test outcomes over multiple submissions, helping students to keep track of the effects of their changes as their grammar development progresses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chelsea</first_name>
          <last_name>Barraball</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <person_id>chelseabarraball</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Moeketsi</first_name>
          <last_name>Raselimo</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <person_id>moeketsiraselimo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bernd</first_name>
          <last_name>Fischer</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.sun.ac.za/~bfischer/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/berndfischer/b51999f4-390c-48d9-be54-f3d1ceab7ff8/small.jpg</picture_url>
          <person_id>berndfischer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>718be37b-8f56-4cea-ba0e-6211cbedfd86</slot_id>
      <event_id>01e48462-0a2e-4222-8656-48d10e93dac1</event_id>
      <title>Grammar-Based Testing for Little Languages: An Experience Report with Student Compilers</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>13:40</end_time>
      <description>We report on our experience in using various grammar-based test suite generation methods to test 61 single-pass compilers that undergraduate students submitted for the practical project of a computer architecture course. 
We show that (1) all test suites constructed systematically following different grammar coverage criteria fall far behind the instructor's test suite in achieved code coverage, in the number of triggered semantic errors, and in detected failures and crashes; (2) a medium-sized positive random test suite triggers more crashes than the instructor's test suite, but achieves lower code coverage and triggers fewer non-crashing errors; and (3) a combination of the systematic and random test suites performs as well or better than the instructor's test suite in all aspects and identifies errors or crashes in every single submission. 
We then develop a light-weight extension of the basic grammar-based testing framework to capture contextual constraints, by encoding scoping and typing information as ``semantic mark-up tokens'' in the grammar rules. These mark-up tokens are interpreted by a small generic core engine when the tests are rendered, and tests with a syntactic structure that cannot be completed into a valid program by choosing appropriate identifiers are discarded. % We formalize individual error models by overwriting individual mark-up tokens, and generate tests that are guaranteed to break specific contextual properties of the language. We show that a fully automatically generated random test suite with 15 error models achieves roughly the same coverage as the instructor's test suite, and outperforms it in the number of triggered semantic errors and detected failures and crashes. Moreover, all failing tests indicate real errors, and we have detected errors even in the instructor's reference implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Phillip</first_name>
          <last_name>van Heerden</last_name>
          <affiliation>Stellenbosch University</affiliation>
          <bio>undefined</bio>
          <person_id>phillipvanheerden</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Moeketsi</first_name>
          <last_name>Raselimo</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <person_id>moeketsiraselimo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Konstantinos (Kostis)</first_name>
          <last_name>Sagonas</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/kostissagonas/4dd586b1-8ffe-446f-a179-dad1b81db63a/small.jpg</picture_url>
          <person_id>kostissagonas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Bernd</first_name>
          <last_name>Fischer</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.sun.ac.za/~bfischer/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/berndfischer/b51999f4-390c-48d9-be54-f3d1ceab7ff8/small.jpg</picture_url>
          <person_id>berndfischer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8a25ceea-453c-4eed-a697-6392ef59f1cc</subevent_id>
    <title>HATRA: Design</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/home/hatra-2020</url>
    <url_link_display>Human Aspects of Types and Reasoning Assistants</url_link_display>
    <tracks>
      <track>Human Aspects of Types and Reasoning Assistants</track>
    </tracks>
    <timeslot>
      <slot_id>9064c6bc-6b07-4a4e-a50a-456586094e71</slot_id>
      <title>Session: HATRA - Design</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/18</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6ca64786-5e66-4c53-94fc-de5c89d40768</slot_id>
      <event_id>addeeaff-b053-4bb2-8a94-c96ce5b8ea0f</event_id>
      <title>User-Centered Programming Language Design: A Course-Based Case Study</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/18</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>15:40</end_time>
      <description>Recently, user-centered methods have been proposed to improve the design of programming languages. In order to explore what benefits these methods might have for novice programming language designers, we taught a collection of user-centered programming language design methods to a group of eight students. We observed that natural programming and usability studies helped the students refine their language designs and identify opportunities for improvement, even in the short duration of a course project.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Coblenz</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umd.edu/~mcoblenz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelcoblenz/aa74b306-529b-44d4-987f-a5e4fd6d3ca2/small.jpg</picture_url>
          <person_id>michaelcoblenz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ariel</first_name>
          <last_name>Davis</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>arieldavis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Megan</first_name>
          <last_name>Hofmann</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>meganhofmann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Vivian</first_name>
          <last_name>Huang</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>vivianhuang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Siyue</first_name>
          <last_name>Jin</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>siyuejin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Max</first_name>
          <last_name>Krieger</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>maxkrieger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Kyle</first_name>
          <last_name>Liang</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>kyleliang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Brian</first_name>
          <last_name>Wei</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>brianwei</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Mengchen Sam</first_name>
          <last_name>Yong</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>mengchensamyong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>10</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a23a54fd-973b-4657-afba-ba22cd6bec0c</slot_id>
      <event_id>ac7a1f97-e173-4a5c-9872-6587a4c4a2bf</event_id>
      <title>Programming languages shouldn't and needn't be Turing complete</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/18</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>15:20</end_time>
      <description>Any algorithmic problem faced by application programmers in the wild can in principle be solved using a Turing incomplete programming language. [Rice 1953] suggests that Turing completeness bears a heavy price, fundamentally limiting the ability of automatic assistants to help programmers be more productive, create less bugs and write safer software. Nevertheless, no widespread programming language is Turing incomplete. While there are some strongly-normalizing dependently typed languages, they require in-depth academic knowledge and currently lack affordances for practical application development. We contend that the pervasive choice of Turing completeness across programming languages has been driven by ill-placed expediency rather than necessity. In particular, loops and recursion are common ”Turing-traps”: Sources of Turing completeness, whether accidental or intentional. We present an approach to eliminating Turing-traps during the language design process, with several examples suitable for non-academic languages. Designers of modern practical programming languages should strongly consider evading Turing completeness and enabling better verification, security, automated testing and distributed computing.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gabriel</first_name>
          <last_name>Pickard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>gabrielpickard</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a313c8aa-4824-4e78-94e6-446a9f9ffa37</slot_id>
      <event_id>014280e4-2499-4b26-ae62-b093ed4917b6</event_id>
      <title>Day 1 Discussion</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/18</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>16:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6315fe44-fd2f-4734-a7c0-adc2169d6f4a</subevent_id>
    <title>HATRA: Formal Methods</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-IV</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/home/hatra-2020</url>
    <url_link_display>Human Aspects of Types and Reasoning Assistants</url_link_display>
    <tracks>
      <track>Human Aspects of Types and Reasoning Assistants</track>
    </tracks>
    <timeslot>
      <slot_id>6aedc0f4-5769-4de9-b05e-fb7d4807c427</slot_id>
      <title>Session: HATRA - Formal Methods</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/18</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8ea85aba-c6c1-475a-a9c1-fc7543465651</slot_id>
      <event_id>7afd8e45-ec12-4b08-89ad-cfb172548d50</event_id>
      <title>Welcome and Introductions</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/18</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>11:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ad52add5-367a-4578-8317-2f9109c4afdd</slot_id>
      <event_id>cb29b5ec-2aa7-4bba-8783-5ffdedd60564</event_id>
      <title>Towards making formal methods normal: meeting developers where they are</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/18</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>12:00</end_time>
      <description>Formal verification of software has a reputation of being a niche and heroic activity; it is only applied to systems of particular sensitivity and is performed by verification engineers with specialized skills to produce software with unusually high level of assurance. This paper considers whether it would be possible to increase adoption of formal methods by melding it with developers’ existing practices and workflows. We do not believe that widespread adoption will follow from evangelizing the prevailing formal methods argument that correct software is more important than engineering teams realize. Instead, our focus is on what we would need to do to show programmers that formal verification tools can offer a higher level of assurance without the heroics. We do this by considering how we might make verification tooling that both serves developers’ needs and fits easily into their existing development lifecycle. We propose a target of 2-3 orders of magnitude increase in adoption within a decade driven by ensuring a positive ‘weekly cost:benefit’ ratio for developer time invested.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alastair</first_name>
          <last_name>Reid</last_name>
          <affiliation>Arm Ltd</affiliation>
          <bio>Researcher at Arm Ltd (UK) since 2004 
 
 model checking processor pipelines (newest) 
 formal architecture specifications 
 wide SIMD instruction set 
 pipeline parallelism 
 software defined radio 
 vectorising compilers (oldest) 
 
Researcher at University of Utah (USA), 1998-2004 
 
 component based operating system kernels 
 
Researcher at Yale University (USA), 1994-1998 
 
 Haskell foreign function interface 
 Functional Reactive Programming 
 Visual Tracking in Haskell 
 Haskell library/compiler development 
 
Researcher at University of Glasgow (UK), 1988-1994 
 
 Formal Specification and Verification 
 GHC foreign function interface 
</bio>
          <homepage_url>https://alastairreid.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alastairreid/abeed76b-bca7-4e3e-9339-f5cdf8c7db80/small.jpg</picture_url>
          <person_id>alastairreid</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Luke</first_name>
          <last_name>Church</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.lukechurch.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lukechurch/3ab26f57-3738-4a38-a8be-8f6d1b69cd8f/small.jpg</picture_url>
          <person_id>lukechurch</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Shaked</first_name>
          <last_name>Flur</last_name>
          <affiliation>Google Research</affiliation>
          <bio>undefined</bio>
          <person_id>shakedflur1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sarah</first_name>
          <last_name>de Haas</last_name>
          <affiliation>Google Research</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/sarahdehaas/450f2456-0fe0-465f-a371-51662896ff99/small.jpg</picture_url>
          <person_id>sarahdehaas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Maritza</first_name>
          <last_name>Johnson</last_name>
          <affiliation>Google Research</affiliation>
          <bio>undefined</bio>
          <person_id>maritzajohnson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Ben</first_name>
          <last_name>Laurie</last_name>
          <affiliation>Google Research</affiliation>
          <bio>undefined</bio>
          <person_id>benlaurie</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e4d1f825-36f5-41b9-ad26-9f703775377d</slot_id>
      <event_id>5c12bae9-7f34-429c-a8e1-e21281088853</event_id>
      <title>Towards user-friendliness in proof assistants: automated strategies algebraic effects and handlers</title>
      <room>Online | SPLASH-IV</room>
      <date>2020/11/18</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>11:40</end_time>
      <description>Proof assistants provide a framework for the modelling and verification of theories, as well as trustworthy software. However, such power is usually only available to experts. We propose a new approach, based on algebraic effects and handlers, to integrate different automated proof strategies that enable newcomers to take advantage of proof assistants without an in-depth understanding of underlying theory. Our approach gives newcomers an effect system, a handful of effectful strategies (tactics, proof search, and SMT solvers) and their handlers under a shared interface, while advanced users can extend our system with new effects and new handlers. Lastly, we prototype the system as a library in Agda. While our prototype is minimal, it shows how easily proofs can be carried out so long as the user has the correct intuition. We believe our system empowers non-experts and has the potential to bring verified software to relevant industries, such as finance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>April</first_name>
          <last_name>Gonçalves</last_name>
          <affiliation>Roskilde University, Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cyberglot.space</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aprilgoncalves/7cb647d7-f4c2-4c0f-81a7-d498a1e3bf6b/small.jpg</picture_url>
          <person_id>aprilgoncalves</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>25f6c367-a0e4-4ad8-af0d-d8b3a35ee997</subevent_id>
    <title>SLE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/16</date>
    <url>https://conf.researchr.org/home/sle-2020</url>
    <url_link_display>SLE (Software Language Engineering) 2020</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>25dd4c5b-be21-4183-b2a5-6196cf276b86</slot_id>
      <title>Session: SLE - </title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Laurence</first_name>
          <last_name>Tratt</last_name>
          <affiliation>King's College London</affiliation>
          <bio>Programmer / researcher.</bio>
          <homepage_url>https://tratt.net/laurie/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/laurencetratt/f715fc31-2c46-4e48-9a13-d715343fdd4d/small.jpg</picture_url>
          <person_id>laurencetratt</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>08eded9f-a693-4f57-b125-026c3e730b8c</slot_id>
      <event_id>8418bc21-ddd2-4ae2-aef7-57450c6d8922</event_id>
      <title>A Search-Based and Fault-Tolerant Approach to Concurrent Model Synchronisation</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>12:20</end_time>
      <description>In collaboration scenarios, we often encounter situations in which semantically interrelated models are changed concurrently. Concurrent model synchronization denotes the task of keeping these models consistent by propagating changes between them. This is challenging as changes can contradict each other and thus be in conflict. A problem with current synchronisation approaches is that they are often nondeterministic, i.e., the order in which changes are propagated is essential for the result. Furthermore, a common limitation is that the involved models must have been in a consistent state at some point, and that the applied changes are at least valid for the domain in which they were made. We propose a hybrid approach based on Triple Graph Grammars (TGGs) and Integer Linear Programming (ILP) to overcome these issues: TGGs are a grammar-based means that supplies us with a superset of possible synchronization solutions, forming a search space from which an optimum solution incorporating user-defined preferences can be chosen by ILP. Therefore, the proposed method combines configurability by comprising expert knowledge via TGGs with the flexible input handling of search-based techniques: By accepting arbitrary graph structures as input models, the approach is tolerant towards errors induced during the modelling process, i.e., it can cope with input models which do not conform to their metamodel or which cannot be generated by the TGG at hand. The approach is implemented in the model transformation tool eMoflon and evaluated regarding scalability for growing model sizes and an increasing number of changes.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nils</first_name>
          <last_name>Weidmann</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>nilsweidmann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lars</first_name>
          <last_name>Fritsche</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>larsfritsche1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anthony</first_name>
          <last_name>Anjorin</last_name>
          <affiliation>Paderborn University, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/anthonyanjorin1/158aeedd-1bac-498b-9521-79557507e112/small.jpg</picture_url>
          <person_id>anthonyanjorin1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1ff4d0b0-d384-452e-9d6b-2db75e8925c7</slot_id>
      <event_id>0579642d-68a8-476d-85c0-4a8d1667dd31</event_id>
      <title>Behavior Trees in Action: A Study of Robotics Applications</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>12:00</end_time>
      <description>Autonomous robots combine a variety of skills to form increasingly complex behaviors called missions. While the skills are often programmed at a relatively low level of abstraction, their coordination is architecturally separated and often expressed in higher-level languages or frameworks. Recently, the language of Behavior Trees gained attention among roboticists for this reason. Originally designed for computer games to model autonomous actors, Behavior Trees offer an extensible tree-based representation of missions. However, even though, several implementations of the language are in use, little is known about its usage and scope in the real world. How do behavior trees relate to traditional languages for describing behavior? How are behavior tree concepts used in applications? What are the benefits of using them? 
We present a study of the key language concepts in Behavior Trees and their use in real-world robotic applications. We identify behavior tree languages and compare their semantics to the most well-known behavior modeling languages: state and activity diagrams. We mine open source repositories for robotics applications that use the language and analyze this usage. We find that Behavior Trees are a pragmatic language, not fully specified, allowing projects to extend it even for just one model. Behavior trees clearly resemble the models-at-runtime paradigm. We contribute a dataset of real-world behavior models, hoping to inspire the community to use and further develop this language, associated tools, and analysis techniques.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Razan</first_name>
          <last_name>Ghzouli</last_name>
          <affiliation>Chalmers University of Technology &amp; University of Gothenburg</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://orcid.org/0000-0002-5428-8113</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/razanghzouli/4a1d42cd-e90e-427e-8686-f823139700f3/small.jpg</picture_url>
          <person_id>razanghzouli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thorsten</first_name>
          <last_name>Berger</last_name>
          <affiliation>Chalmers University of Technology, Sweden / University of Gothenburg, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.chalmers.se/~bergert</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/thorstenberger/d2f325bb-820f-49b8-985d-e62ac888dedd/small.jpg</picture_url>
          <person_id>thorstenberger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Einar</first_name>
          <last_name>Broch Johnsen</last_name>
          <affiliation>University of Oslo</affiliation>
          <bio>undefined</bio>
          <person_id>einarbrochjohnsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Swaib</first_name>
          <last_name>Dragule</last_name>
          <affiliation>Chalmers | University of Gothenburg</affiliation>
          <bio>undefined</bio>
          <person_id>swaibdragule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Andrzej</first_name>
          <last_name>Wąsowski</last_name>
          <affiliation>IT University of Copenhagen, Denmark</affiliation>
          <bio>MSc Eng from Warsaw University of Technology (2000) PhD from IT University of Copenhagen (2005) 
Interested in developing repeatable software engineering methods, supported by innovative tools and technology, to solve domain specific problems (safety critical systems, industry automation, robotics, legacy systems, and personal data protection).</bio>
          <homepage_url>http://www.itu.dk/people/wasowski</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andrzejwasowski/36304e96-b840-4d13-933d-7f422b4a3ddc/small.jpg</picture_url>
          <person_id>andrzejwasowski</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>93feb3a2-bc6a-4851-ac84-ba18ada31b88</slot_id>
      <event_id>96904519-a65b-454a-beea-44c4b59c05c4</event_id>
      <title>Example-Driven Software Language Engineering</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:40</end_time>
      <description>Language workbenches—tools to define software languages together with their IDEs—are designed to simplify language engineering and implementation: they free language engineers from many meticulous tasks, but oftentimes have a very steep learning curve even for experienced software professionals. With the assumption that meta-definitions are one of the key factors that hinder language engineering, we introduce an example-driven approach to language definition. We describe in this paper our vision of a web-based tool aimed at beginner language engineers, and list possible requirements for such a tool. A language is defined by giving examples of code written in it using illustrative syntax definition. These examples are then annotated to specify different concerns of language definition—abstract syntax, typing rules, validation rules, formatting rules, and dynamic semantics.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mikhail</first_name>
          <last_name>Barash</last_name>
          <affiliation>University of Bergen, Norway</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://dsl-course.org/mikbar/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mikhailbarash/d876d731-3779-4e11-8aee-de2bcef5e938/small.jpg</picture_url>
          <person_id>mikhailbarash</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ac6407d5-2f67-43af-a45f-1a36618840fe</slot_id>
      <event_id>606ec49c-4792-4253-89ec-4010e21d70de</event_id>
      <title>A Precedence-Driven Approach for Concurrent Model Synchronization Scenarios using Triple Graph Grammars</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:20</end_time>
      <description>Concurrent model synchronization is the task of restoring consistency between two correlated models after they have been changed concurrently and independently. To determine whether such concurrent model changes conflict with each other and to resolve these conflicts taking domain- or user-specific preferences into account is highly challenging. In this paper, we present a framework for concurrent model synchronization algorithms based on Triple Graph Grammars (TGGs). TGGs specify the consistency of correlated models using grammar rules; these rules can be used to derive different consistency restoration operations. Using TGGs, we infer a causal dependency relation for model elements that enables us to detect conflicts non-invasively. Different kinds of conflicts are detected first and resolved by the subsequent conflict resolution process. Users configure the overall synchronization process by orchestrating the application of consistency restoration fragments according to several conflict resolution strategies to achieve individual synchronization goals. As proof of concept, we have implemented this framework in the model transformation tool eMoflon. Our initial evaluation shows that the runtime of our presented approach scales with the size of model changes and conflicts, rather than model size.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lars</first_name>
          <last_name>Fritsche</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>larsfritsche1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jens</first_name>
          <last_name>Kosiol</last_name>
          <affiliation>University of Marburg, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>jenskosiol1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Adrian</first_name>
          <last_name>Möller</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>adrianmoller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Andy</first_name>
          <last_name>Schürr</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/andyschurr/b3c83371-9583-4f5a-b3ca-1240bf1f9bda/small.jpg</picture_url>
          <person_id>andyschurr</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Gabriele</first_name>
          <last_name>Taentzer</last_name>
          <affiliation>University of Marburg, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.uni-marburg.de/fb12/swt/gabi-taentzer</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gabrieletaentzer/c2ef5fee-d409-4762-87a4-ad92dda7413b/small.jpg</picture_url>
          <person_id>gabrieletaentzer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7905b151-d2f6-4457-87d3-7346e353bf9f</subevent_id>
    <title>SLE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/17</date>
    <url>https://conf.researchr.org/home/sle-2020</url>
    <url_link_display>SLE (Software Language Engineering) 2020</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>ab5b4802-9f35-4f2a-a712-0d11bb61cdc7</slot_id>
      <title>Session: SLE - </title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Vadim</first_name>
          <last_name>Zaytsev</last_name>
          <affiliation>University of Twente, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://grammarware.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vadimzaytsev/fe6c221f-75d5-4fbc-ac41-be9c99349b5d/small.jpg</picture_url>
          <person_id>vadimzaytsev</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a8b4b4ab-b9be-489b-8e16-9df281665d8c</slot_id>
      <event_id>01e48462-0a2e-4222-8656-48d10e93dac1</event_id>
      <title>Grammar-Based Testing for Little Languages: An Experience Report with Student Compilers</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>01:40</end_time>
      <description>We report on our experience in using various grammar-based test suite generation methods to test 61 single-pass compilers that undergraduate students submitted for the practical project of a computer architecture course. 
We show that (1) all test suites constructed systematically following different grammar coverage criteria fall far behind the instructor's test suite in achieved code coverage, in the number of triggered semantic errors, and in detected failures and crashes; (2) a medium-sized positive random test suite triggers more crashes than the instructor's test suite, but achieves lower code coverage and triggers fewer non-crashing errors; and (3) a combination of the systematic and random test suites performs as well or better than the instructor's test suite in all aspects and identifies errors or crashes in every single submission. 
We then develop a light-weight extension of the basic grammar-based testing framework to capture contextual constraints, by encoding scoping and typing information as ``semantic mark-up tokens'' in the grammar rules. These mark-up tokens are interpreted by a small generic core engine when the tests are rendered, and tests with a syntactic structure that cannot be completed into a valid program by choosing appropriate identifiers are discarded. % We formalize individual error models by overwriting individual mark-up tokens, and generate tests that are guaranteed to break specific contextual properties of the language. We show that a fully automatically generated random test suite with 15 error models achieves roughly the same coverage as the instructor's test suite, and outperforms it in the number of triggered semantic errors and detected failures and crashes. Moreover, all failing tests indicate real errors, and we have detected errors even in the instructor's reference implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Phillip</first_name>
          <last_name>van Heerden</last_name>
          <affiliation>Stellenbosch University</affiliation>
          <bio>undefined</bio>
          <person_id>phillipvanheerden</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Moeketsi</first_name>
          <last_name>Raselimo</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <person_id>moeketsiraselimo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Konstantinos (Kostis)</first_name>
          <last_name>Sagonas</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/kostissagonas/4dd586b1-8ffe-446f-a179-dad1b81db63a/small.jpg</picture_url>
          <person_id>kostissagonas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Bernd</first_name>
          <last_name>Fischer</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.sun.ac.za/~bfischer/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/berndfischer/b51999f4-390c-48d9-be54-f3d1ceab7ff8/small.jpg</picture_url>
          <person_id>berndfischer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bc5f86a9-b34b-4908-817a-173422d97159</slot_id>
      <event_id>b729c3ab-2dd0-40dc-a295-f2f0e47d41fa</event_id>
      <title>An Interactive Feedback System for Grammar Development (Tool Paper)</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>02:00</end_time>
      <description>We describe gtutr, an interactive feedback system designed to assist students in developing context-free grammars and corresponding ANTLR parsers. It intelligently controls students' access to a large test suite for the target language. After each submission, gtutr analyzes any failing tests and uses the Needleman-Wunsch sequence alignment algorithm over the tests' rule traces to identify and eliminate similar failing tests. This reduces the redundancy in the feedback 
given to the students and prevents them from being overloaded. gtutr uses simple gamification to encourage independent problem solving by students: it gives as little information as possible, and students need to prompt the system for further details such as failing tests similar to or different from already seen tests, or even for hints about rules that are the most likely to contain faults. It tracks the students' information requests and uses this to attenuate marks following an instructor-set penalty schema. The system also visualizes test outcomes over multiple submissions, helping students to keep track of the effects of their changes as their grammar development progresses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chelsea</first_name>
          <last_name>Barraball</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <person_id>chelseabarraball</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Moeketsi</first_name>
          <last_name>Raselimo</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <person_id>moeketsiraselimo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bernd</first_name>
          <last_name>Fischer</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.sun.ac.za/~bfischer/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/berndfischer/b51999f4-390c-48d9-be54-f3d1ceab7ff8/small.jpg</picture_url>
          <person_id>berndfischer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c08205b5-d47b-4724-8ade-82776d75d6cf</slot_id>
      <event_id>4e74b197-d3c2-4abe-92e1-faaed4180310</event_id>
      <title>Featherweight Swift: A Core Calculus for Swift’s Type System</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>02:20</end_time>
      <description>Swift is a modern general-purpose programming language, designed to be a replacement for C-based languages. Although primarily directed at development of applications for Apple's operating systems, Swift's adoption has been growing steadily in other domains, ranging from server-side services to machine learning. This success can be partly attributed to a rich type system that enables the design of safe, fast, and expressive programming interfaces. Unfortunately, this richness comes at the cost of complexity, setting a high entry barrier to exploit Swift's full potential. Furthermore, existing documentation typically only relies on examples, leaving new users with little help to build a deeper understanding of the underlying rules and mechanisms. 
This paper aims to tackle this issue by laying out the foundations for a formal framework to reason about Swift's type system. We introduce Featherweight Swift, a minimal language stripped of all features not essential to describe its typing rules. Featherweight Swift features classes and protocol inheritance, supports retroactive modeling, and emulates Swift's overriding mechanisms. Yet its formalization fits on a few pages. We present Featherweight Swift's syntax and semantics. We then elaborate on the usability of our framework to reason about Swift's features, future extensions, and implementation by discussing a bug in Swift's compiler, discovered throughout the design of our calculus.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dimitri</first_name>
          <last_name>Racordon</last_name>
          <affiliation>University of Geneva, Switzerland</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/dimitriracordon/23c16a97-1d4c-47e1-9270-89755cace04c/small.jpg</picture_url>
          <person_id>dimitriracordon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Didier</first_name>
          <last_name>Buchs</last_name>
          <affiliation>University of Geneva, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>didierbuchs</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d513fec9-067f-49f6-9454-682efb07f149</slot_id>
      <event_id>bee221c2-518e-4f38-a9b4-996285b8693f</event_id>
      <title>Test Case Generation from Context-Free Grammars using Generalized Traversal of LR-Automata</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>01:20</end_time>
      <description>Test case generation from context-free grammars typically uses the grammar's production rules to directly construct words that cover specific sets of derivations. Here, we investigate test case generation by traversing graphs derived from the LR-automata corresponding to the grammars. We develop a new algorithm that generates positive test cases by covering all edges between pairs of directly connected states in a two-phase breadth-first path search. The algorithm iterates over all edges stemming from shift/reduce and reduce/reduce conflicts, using a technique similar to the stack duplication used in GLR parsing. We then extend our algorithm to generate negative (i.e., syntactically invalid) test cases, by applying different edge mutation operations during the extraction of test cases from paths.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christoff</first_name>
          <last_name>Rossouw</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <person_id>christoffrossouw</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bernd</first_name>
          <last_name>Fischer</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.sun.ac.za/~bfischer/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/berndfischer/b51999f4-390c-48d9-be54-f3d1ceab7ff8/small.jpg</picture_url>
          <person_id>berndfischer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>18a87997-4c48-4150-85cb-1a622d48d7a2</subevent_id>
    <title>TAPAS: Session 1</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-V</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/home/tapas-2020</url>
    <url_link_display>TAPAS</url_link_display>
    <tracks>
      <track>TAPAS</track>
    </tracks>
    <timeslot>
      <slot_id>e902acae-b864-43c7-bb16-58d7de63978c</slot_id>
      <title>Session: TAPAS - Session 1</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/19</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <tracks>
        <track>TAPAS</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>18651d39-c7c1-42a5-b031-9217530543d5</slot_id>
      <event_id>4d1bd8e2-6b61-4067-b6f2-dfc101785f4d</event_id>
      <title>Data Dependence for Object-Oriented Programs</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/19</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>04:00</end_time>
      <description>The System Dependence Graph (SDG) is a program representation used in several static analyses. In particular, it is the basis of program slicing, a technique that extracts the part of the program that may directly or indirectly affect the values computed at a given program point (known as the slicing criterion). Several approaches have enhanced the SDG representation to deal with object-oriented situations like inheritance, polymorphism, or dynamic bindings. Currently, the most advanced approach is the Java System Dependence Graph (JSysDG), which subsumes previous approaches and that is able to represent all those situations. In this paper, we show that even the JSysDG does not produce complete slices in all cases when some object variables are selected as the slicing criterion. To solve this limitation, we first identify the source of the problem: the representation of dependences between partial definitions of objects is insufficient in the JSysDG, leading to a loss of precision in many cases. Then, we extend the JSysDG with the addition of a specific flow dependence for object type variables called object-flow dependence. This extension provides a more accurate flow representation between object variables and its data members and allows us to obtain complete slices when an object variable is considered as slicing criterion.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Carlos</first_name>
          <last_name>Galindo</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>carlosgalindo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sergio</first_name>
          <last_name>Perez Rubio</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>sergioperezrubio</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Josep</first_name>
          <last_name>Silva</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>josepsilva</person_id>
        </person>
      </persons>
      <tracks>
        <track>TAPAS</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>47aab634-9488-43fe-964d-cb0f0a1502e2</slot_id>
      <event_id>487f5a89-b7f0-4fe6-ba04-a7543e34f535</event_id>
      <title>MetaCG: Annotated call-graphs to facilitate whole-program analysis</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/19</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>03:40</end_time>
      <description>The paper presents the extendable C/C++ whole-program call-graph tool MetaCG. We introduce its graph library, the Clang-based tool CGCollector to construct the call graph and attach meta information, and, CGValidate to check for missing edges given a particular execution. MetaCG offers extendability through its metadata function-annotation mechanism to transfer information between tools. It preserves inheritance hierarchies and can be serialized into json. We evaluate CGCollector’s ability to construct whole-program call-graphs for C/C++ code and, subsequently, present a performance profiler and a memory sanitizer that rely on MetaCG for whole-program call-graph information.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jan-Patrick</first_name>
          <last_name>Lehr</last_name>
          <affiliation>Scientific Computing, TU Darmstadt</affiliation>
          <bio>I studied computer science at TU Darmstadt before joining the Institute for Scientific Computing at TU Darmstadt. In between my Bachelor’s and my Master’s I joined the ROSE compiler team at Lawrence Livermore National Lab for an internship. 
Since the Corona virus situation emerged I am a regular participant of the open and informal weekly HPC huddle meetings and maintain the website of the HPC Hallway.</bio>
          <homepage_url>https://www.jplehr.de</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janpatricklehr/b81db061-ef17-42ac-ba64-097fc84738cf/small.jpg</picture_url>
          <person_id>janpatricklehr</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Hück</last_name>
          <affiliation>Institute for Scientific Computing, TU Darmstadt</affiliation>
          <bio>undefined</bio>
          <person_id>alexanderhuck</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yannic</first_name>
          <last_name>Fischler</last_name>
          <affiliation>TU Darmstadt</affiliation>
          <bio>undefined</bio>
          <person_id>yannicfischler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Christian</first_name>
          <last_name>Bischof</last_name>
          <affiliation>Scientific Computing, TU Darmstadt</affiliation>
          <bio>undefined</bio>
          <person_id>christianbischof</person_id>
        </person>
      </persons>
      <tracks>
        <track>TAPAS</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4fd207f5-6a64-4393-a876-025ff39c14b0</slot_id>
      <event_id>78f76a1f-c120-4861-959d-69f32c4d272b</event_id>
      <title>Program Slicing with Exception Handling</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/19</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>03:20</end_time>
      <description>Program slicing is a technique for program analysis and transformation with many different applications such as program debugging, program specialization, and parallelization. The system dependence graph (SDG) is the most commonly used data structure for program slicing. In this paper, we show that the presence of exception-handling constructs can make the SDG produce incorrect and sometimes even incomplete slices. We showcase the instances of incorrectness and incompleteness and we propose a framework for correctly handling exception-related instructions, which includes representation of all possible exception throwing and catching mechanisms, and a new kind of control dependence: conditional control dependence; which produces more precise slices in the presence of catch statements.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Carlos</first_name>
          <last_name>Galindo</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>carlosgalindo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sergio</first_name>
          <last_name>Perez Rubio</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>sergioperezrubio</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Josep</first_name>
          <last_name>Silva</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>josepsilva</person_id>
        </person>
      </persons>
      <tracks>
        <track>TAPAS</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>64f46daf-a5f3-42bf-bc25-5eb095948a70</slot_id>
      <event_id>291a6632-3243-473a-8333-aed7e2fe5e48</event_id>
      <title>Type checking beyond type checkers, via Slice &amp; Run</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/19</date>
      <start_time>04:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>04:20</end_time>
      <description>Type checkers are the most commonly used form of static analysis, but their design is coupled to the rest of the language, making it hard or impossible to bring new kinds of reasoning to existing, unmodified code. 
We propose a novel approach to checking advanced type invariants and properties in unmodified source code, while approaching the speed and ease of simple, syntax directed type checkers. The insight is that by combining a deep program analysis (symbolic execution) with a cheaper program abstraction (based on program slicing), it appears possible to reconstitute type-checking in the context of an underapproximate analysis. When the program’s ‘type level’ can be opportunistically disentangled from the ‘value level’, this is done by the program abstraction step, in some cases removing the underapproximation. 
We implement a simple prototype that demonstrates this idea by checking the safety of generic pointers in C, pointing to benefits such as safe homogeneous and heterogeneous generic data structures.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Justus</first_name>
          <last_name>Adam</last_name>
          <affiliation>University of Kent, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://justus.science</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/justusadam/a9fe90ea-76ae-447d-8c07-12dccce8d425/small.jpg</picture_url>
          <person_id>justusadam</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Kell</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.kent.ac.uk/people/staff/srk21</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stephenkell/53088184-3e8c-4a2c-b34f-b2a290cff411/small.jpg</picture_url>
          <person_id>stephenkell</person_id>
        </person>
      </persons>
      <tracks>
        <track>TAPAS</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>83acb484-c102-480b-8ed4-e0596b9509bb</subevent_id>
    <title>TAPAS: Session 4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-V</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/home/tapas-2020</url>
    <url_link_display>TAPAS</url_link_display>
    <tracks>
      <track>TAPAS</track>
    </tracks>
    <timeslot>
      <slot_id>af0e0f52-1d9b-4200-a0fc-bf01c481520c</slot_id>
      <title>Session: TAPAS - Session 4</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/19</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>TAPAS</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6884dd92-27e7-4a9d-aff3-418b93fe5171</slot_id>
      <event_id>98a3bab7-5098-4ffa-8a3c-1c64ef2bd80c</event_id>
      <title>Closing</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/19</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>12:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>TAPAS</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e5faf0eb-31aa-4f9f-8e3f-0197fb756968</slot_id>
      <event_id>b87a2c4b-ac97-4735-bfb2-b42e565fc3a5</event_id>
      <title>Moving Fast with High Reliability using Pluggable Types</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/19</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>12:00</end_time>
      <description>For many real-world applications, software reliability is of critical importance. At the same time, developers need to be able to move fast in developing new features and products. In this talk, I will describe recent work on using pluggable type systems to reduce the tension between these seemingly-conflicting needs. First, I will present NullAway, a novel nullability type system for Java. NullAway improves on previous work by reducing build-time overhead and requiring fewer annotations through carefully-targeted unsoundness. Then, I will describe more recent work on performing lightweight and modular typestate analysis using pluggable types, by targeting a class of typestate properties that can be checked soundly without heavyweight alias analysis. I will present two instantiations of this approach: the Object Construction Checker, a novel type system to ensure the safe usage of builders and other complex initialization schemes, and work in progress on preventing resource leaks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manu</first_name>
          <last_name>Sridharan</last_name>
          <affiliation>University of California at Riverside, USA</affiliation>
          <bio>I’m an associate professor at the University of California, Riverside. Previously I worked at IBM Research, Samsung Research, and Uber. My research focuses on developing tools and techniques to make large-scale software more reliable, performant, secure, and maintainable. For more details, see my homepage.</bio>
          <homepage_url>http://manu.sridharan.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manusridharan/00859147-2155-45a9-9a48-7565ce5356ac/small.jpg</picture_url>
          <person_id>manusridharan</person_id>
        </person>
      </persons>
      <tracks>
        <track>TAPAS</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9dfd9e53-d92f-44b4-9129-ea6cc4421cb2</subevent_id>
    <title>TAPAS: Session 2</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-V</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/home/tapas-2020</url>
    <url_link_display>TAPAS</url_link_display>
    <tracks>
      <track>TAPAS</track>
    </tracks>
    <timeslot>
      <slot_id>8563df07-f77a-4079-a051-99ee8a325630</slot_id>
      <title>Session: TAPAS - Session 2</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/19</date>
      <start_time>05:00</start_time>
      <end_time>07:00</end_time>
      <tracks>
        <track>TAPAS</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2b267a6b-4122-404d-bc7b-c2d6473f0a07</slot_id>
      <event_id>bf774f92-a0a1-4ba8-b4f4-a0bf056a74fa</event_id>
      <title>Toward More Scalable Symbolic Execution via Code Chopping</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/19</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>06:00</end_time>
      <description>Dynamic symbolic execution is a program analysis technique that can automatically explore and analyse paths through a program. It is now a key ingredient in many computer science areas, such as software engineering, computer security, and software systems, to name just a few. 
For many tasks, such as failure reproduction, coverage augmentation and patch testing, many parts of the code are irrelevant and could be safely skipped. Chopped symbolic execution is a technique that can aggressively skip potentially irrelevant parts of the code, lazily executing paths through them if and only if they are needed later on. In this talk, I will introduce chopped symbolic execution, show how its precision can be improved via a novel past-sensitive pointer analysis, and present promising preliminary results on failure reproduction and coverage augmentation. 
The talk is based on joint work with David Trabish, Noam Rinetzky, Timotej Kapus and Andrea Mattavelli.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cristian</first_name>
          <last_name>Cadar</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>Cristian Cadar is Professor of Software Reliability in the Department of Computing at Imperial College London, where he leads the Software Reliability Group, working on automatic techniques for increasing the reliability and security of software systems. Cristian’s research has been recognised by several prestigious awards, including the EuroSys Jochen Liedtke Award, the HVC Award, the BCS Roger Needham Award, the ACM SIGOPS Hall of Fame Award, and the ACM CCS Test of Time Award. He also received an ERC Consolidator Grant and an EPSRC Early-Career Fellowship. Many of the research techniques he co-authored have been open-sourced and used by several groups in both academia and industry. In particular, he is co-author and the principal maintainer of the KLEE symbolic execution system, a popular system with a large user base. Cristian has a PhD in Computer Science from Stanford University, and undergraduate and Master’s degrees from the Massachusetts Institute of Technology.</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~cristic</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cristiancadar/d7b508cd-771f-4383-957c-05f26b603716/small.jpg</picture_url>
          <person_id>cristiancadar</person_id>
        </person>
      </persons>
      <tracks>
        <track>TAPAS</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4479d975-68a9-4b7e-80ad-613a9780111f</slot_id>
      <event_id>83b49ed8-da4c-455d-96c2-81cb33a95d67</event_id>
      <title>Enterprise-scale static analysis: A Pinpoint experience</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/19</date>
      <start_time>06:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>07:00</end_time>
      <description>Despite years of research and practice, modern static analysis techniques still cannot detect oldest and extremely well understood software bugs such as the Heartbleed, one of the most “spectacular” security flaws of the recent decade. A remedy, as what we have attempted through the successful commercialization of the Pinpoint platform (PLDI 18), is to make static program analysis aware of the basic characteristics of the modern enterprise-scale software system. The talk focuses on discussing these characteristics and how Pinpoint addresses them pragmatically as well as its future directions. Pinpoint is a LLVM-based cross-language static analysis platform and deployed in major Chinese tech companies such as Tencent, Baidu, Huawei, and Alibaba. 
This will be the same talk shared from the REBASE-track.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Charles</first_name>
          <last_name>Zhang</last_name>
          <affiliation>The Hong Kong University of Science and Technology</affiliation>
          <bio>My general research interest centers around the use of both static and dynamic programming analysis techniques for making complex software systems more secure and reliable. I’m an Associate Professor and director of the Cybersecurity Lab at HKUST. My research received an ICSE and a PLDI distinguished paper award, as well as the ACM SIGSOFT Doctoral Dissertation Award, and IBM PhD fellowships. I co-founded and served as the chairman of Sourcebrella Inc, a static analysis tool vendor.</bio>
          <homepage_url>http://www.cse.ust.hk/~charlesz</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/charleszhang/059321fa-d896-44bf-b4a8-02ec597c0b3b/small.jpg</picture_url>
          <person_id>charleszhang</person_id>
        </person>
      </persons>
      <tracks>
        <track>TAPAS</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>99918eae-1460-48b5-a555-4f7aa445994d</subevent_id>
    <title>TAPAS: Session 3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-V</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/home/tapas-2020</url>
    <url_link_display>TAPAS</url_link_display>
    <tracks>
      <track>TAPAS</track>
    </tracks>
    <timeslot>
      <slot_id>b138e93d-7fa2-4379-9f76-74ab4f745dcb</slot_id>
      <title>Session: TAPAS - Session 3</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/19</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>TAPAS</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>284b5a64-3bd9-40f5-9a4e-f5cb7dc45420</slot_id>
      <event_id>595dcb42-a600-4dba-8a48-2a1adaa02551</event_id>
      <title>Online Verification of Commutativity</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/19</date>
      <start_time>09:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>09:40</end_time>
      <description>Systems of transformations arise in many programming systems, such as in type graphs of implicit type conversion functions. It is important to ensure that these diagrams commute: that any composing path of transformations from the same source to the same destination yields the same result. However, a straightforward approach to verifying commutativity must contend with cycles, and even so it runs in exponential time. Previous work has shown how to verify commutativity in the special case of acyclic diagrams in O(|V|^4|E|^2) time, but this is a batch algorithm: the entire diagram must be known ahead of time. We present an online algorithm that efficiently verifies that a commutative diagram remains commutative when adding a new edge. The new incremental algorithm runs in O(|V|^2(|E|+|V|)) time. For the case when checking the equality of paths is expensive, we also present an optimization that runs in O(|V|^4) time but reduces to the minimum possible number of equality checks.We implement the algorithms and compare them to batch baselines, and we demonstrate their practical application in the compiler of a domain-specific language for geometry types. To study the algorithms’ scalability to large diagrams, we apply them to discover discrepancies in currency conversion graphs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aditi</first_name>
          <last_name>Kabra</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>aditikabra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dietrich</first_name>
          <last_name>Geisler</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>dietrichgeisler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Adrian</first_name>
          <last_name>Sampson</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://adriansampson.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adriansampson/adaa9202-3352-4410-b03a-1eb4718543d5/small.jpg</picture_url>
          <person_id>adriansampson</person_id>
        </person>
      </persons>
      <tracks>
        <track>TAPAS</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5008349c-bc09-427f-876a-a20983039a3d</slot_id>
      <event_id>74cc07d9-4454-4cd8-a079-1c8ccee20b30</event_id>
      <title>API Analytics for Curating Static Analysis Rules</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/19</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>09:20</end_time>
      <description>Use of third-party library APIs is pervasive, but can be error-prone. API-usage errors can be detected via static analysis if specifications of correct usage are available, but manually creating such specifications is a bottleneck. We showcase a semi-automated “big code” solution, where we use large code corpora to mine patterns in API usage, and ask human experts to perform analytics on those patterns to create static analysis rules.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vineeth</first_name>
          <last_name>Kashyap</last_name>
          <affiliation>GrammaTech, Inc.</affiliation>
          <bio>Senior Scientist at GrammaTech, Inc.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/vineethkashyap/ff461ca4-bc23-41a7-ac13-46b4abe02ff2/small.jpg</picture_url>
          <person_id>vineethkashyap</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roger</first_name>
          <last_name>Scott</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>rogerscott</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Joseph</first_name>
          <last_name>Ranieri</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>josephranieri</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>David</first_name>
          <last_name>Melski</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>davidmelski1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Lucja</first_name>
          <last_name>Kot</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>lucjakot</person_id>
        </person>
      </persons>
      <tracks>
        <track>TAPAS</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>93359c35-0d1a-4f70-bb72-028f6d437384</slot_id>
      <event_id>afea23ec-9321-4496-9bf2-994ad5e1301b</event_id>
      <title>Towards Checkpoint Placement for Dynamic Memory Allocation in Intermittent Computing</title>
      <room>Online | SPLASH-V</room>
      <date>2020/11/19</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>10:00</end_time>
      <description>Energy harvesting allows computational devices to run without a battery, opening new application domains of computing. Such devices work under an intermittent computing model, where the system may power cycle several times a second. The main approach to ensuring progress in intermittent computing is to use checkpoints, with much work being dedicated to this direction. However, no existing approaches handle programs using dynamically allocated memory in the intermittent computing model. We pose this as a challenge area, demonstrate the complexities of checkpoint in this space, and propose key characteristics an effective solution.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nicholas</first_name>
          <last_name>Shoemaker</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>nicholasshoemaker</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ruzica</first_name>
          <last_name>Piskac</last_name>
          <affiliation>Yale University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/~piskac/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ruzicapiskac/5643c034-322b-49cb-9686-ebb925bd37ed/small.jpg</picture_url>
          <person_id>ruzicapiskac</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mark</first_name>
          <last_name>Santolucito</last_name>
          <affiliation>Barnard College, Columbia University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.marksantolucito.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/marksantolucito/51821284-64c1-46e0-b979-96e8324079bf/small.jpg</picture_url>
          <person_id>marksantolucito</person_id>
        </person>
      </persons>
      <tracks>
        <track>TAPAS</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8b594881-7bc5-4354-b9a3-131dc9ff4a09</subevent_id>
    <title>SPLASH Posters: Posters Session 2</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-VII</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot>
      <slot_id>c69190d8-daba-4a04-a930-31ac927ea013</slot_id>
      <title>Session: SPLASH Posters - Posters Session 2</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_time>11:00</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0550ceac-3117-44cd-b9d5-d31a84c786d5</slot_id>
      <event_id>0efaef5b-077a-4a01-b9f2-f5e784b674ef</event_id>
      <title>Resolution as Intersection Subtyping via Modus Ponens</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description>Resolution and subtyping are two common mechanisms in programming languages. Resolution is used by features such as type classes or Scala-style implicits to synthesize values automatically from contextual type information. Subtyping is commonly used to automatically convert the type of a value into another compatible type. So far the two mechanisms have been considered independently of each other. This paper shows that, with a small extension, subtyping with intersection types can subsume resolution. This has three main consequences. Firstly, resolution does not need to be implemented as a separate mechanism. Secondly, the interaction between resolution and subtyping becomes apparent. Finally, the integration of resolution into subtyping enables first-class (implicit) environments. The extension that recovers the power of resolution via subtyping is the modus ponens rule of propositional logic. While it is easily added to declarative subtyping, significant care needs to be taken to retain desirable properties, such as transitivity and decidability of algorithmic subtyping, and coherence. To materialize these ideas we develop λ_MP, a calculus that extends a previous calculus with disjoint intersection types, and develop its metatheory in the Coq theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Klara</first_name>
          <last_name>Mardirosian</last_name>
          <affiliation>KU Leuven, Belgium</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/klaramardirosian/15cf04a1-de90-4f6d-b88d-cd1a230da0e4/small.jpg</picture_url>
          <person_id>klaramardirosian</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Georgios</first_name>
          <last_name>Karachalias</last_name>
          <affiliation>Tweag I/O, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://gkaracha.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/georgekarachalias/cb10a8f5-6b72-4883-aef0-c9978070378a/small.jpg</picture_url>
          <person_id>georgekarachalias</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0a02d108-31d2-425b-a26c-e04d0431dfb9</slot_id>
      <event_id>e544c068-9f0c-4363-ba0b-f43ffe949ce2</event_id>
      <title>Macros For Domain-Specific Languages</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description>Macros provide a powerful means of extending languages. They have proven useful in both general-purpose and domain-specific programming contexts. This paper presents an architecture for implementing macro-extensible DSLs on top of macro-extensible host languages. The macro expanders of these DSLs inherit the syntax system, hygienic expansion, and more from the host. They transform the extensible DSL syntax into a DSL core language. This arrangement has several important consequences. It becomes straightforward to integrate the syntax of various DSLs and the host language when their expanders share these inherited components. Also, a DSL compiler can rely on a fixed core language for compilation, even for an extensible DSL. Finally, macros empower programmers to safely grow DSLs on their own and tailor them to their needs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Ballantyne</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>Michael Ballantyne is a PhD student at the Northeastern University Programming Research Laboratory, advised by Matthias Felleisen. He envisions a future where mainstream programmers regularly create, extend, and fluidly intermix domain-specific languages, with excellent support from their programming language and environment. Recently he’s been developing a formal characterization of macro hygiene that accounts for the full range of program transformations used in embedded DSL implementation, and also improving the type systems as macros approach to integrate macro expansion and typechecking.</bio>
          <homepage_url>http://mballantyne.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelballantyne/0fb0042c-454e-437b-938c-bd6fb195d0cb/small.jpg</picture_url>
          <person_id>michaelballantyne</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexis</first_name>
          <last_name>King</last_name>
          <affiliation>Northwestern University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexisking/4d4403cc-a825-40f3-a69d-089d8403e71a/small.jpg</picture_url>
          <person_id>alexisking</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Felleisen</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/matthias/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthiasfelleisen/3781509a-02f7-4e22-822d-04481501e833/small.jpg</picture_url>
          <person_id>matthiasfelleisen</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0e1e6012-96dc-4e15-942b-505b622e2fb4</slot_id>
      <event_id>e5ecd345-1255-4cc9-9519-5f9f7c17c472</event_id>
      <title>Precise Inference of Expressive Units of Measurement Types</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description>Ensuring computations are unit-wise consistent is an important task in software development. Numeric computations are usually performed with primitive types instead of abstract data types, which results in very weak static guarantees about correct usage and conversion of units. This paper presents PUnits, a pluggable type system for expressive units of measurement types and a precise, whole-program inference approach for these types. PUnits can be used in three modes: (1) modularly check the correctness of a program, (2) ensure a possible unit typing exist, (3) annotate a program with units. Annotation mode allows human inspection and is essential since having a valid typing does not guarantee that the inferred specification expresses design intent. PUnits is the first units type system with this capability. Compared to prior work, PUnits strikes a novel balance between expressiveness, inference complexity, and annotation effort. We implement PUnits for Java and evaluate it by specifying the correct usage of frequently used JDK methods. We analyzed 234k lines of code from eight open-source scientific computing projects with PUnits, which inferred 87 scientific units and generated well-specified applications. The experiments show that PUnits provides an effective, sound, and scalable alternative to using encapsulation-based units APIs (like javax.measure), enabling Java developers to reap the performance benefits of using primitive types instead of abstract data types for unit-wise consistent scientific computations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tongtong</first_name>
          <last_name>Xiang</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>tongtongxiang1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jeff Y.</first_name>
          <last_name>Luo</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>jeffluo1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Werner</first_name>
          <last_name>Dietl</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ece.uwaterloo.ca/~wdietl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/wernerdietl/f6ddc3ef-7134-4260-a182-a71ed88842cb/small.jpg</picture_url>
          <person_id>wernerdietl</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0e760bb8-ffd2-4675-b25d-80434f093f46</slot_id>
      <event_id>929402eb-9328-4a8b-8a75-cece307c4691</event_id>
      <title>Guiding Dynamic Programing via Structural Probability for Accelerating Programming by Example</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description>Programming by example (PBE) is an important subproblem of program synthesis and the techniques of PBE have been applied to many domains. Though many techniques for accelerating PBE systems have been explored, the scalability remains one of the main challenges: there is still a gap between the performances of state-of-the-art synthesizers and the industrial requirement. To further speed up solving PBE tasks, in this paper we propose a novel PBE framework MaxFlash, which uses the naturalness of programs to guide a search based on dynamic programming, such that the search will focus on subproblems that form more natural programs, and avoid unnatural programs. Our evaluation shows that MaxFlash achieves $\times 5.097- \times 2321$ speed-ups against state-of-the-art solvers on $244$ real-world tasks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ruyi</first_name>
          <last_name>Ji</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <person_id>ruyiji</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yican</first_name>
          <last_name>Sun</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <person_id>yicansun1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yingfei</first_name>
          <last_name>Xiong</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>Associate Professor</bio>
          <homepage_url>http://sei.pku.edu.cn/~xiongyf04/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yingfeixiong/18fb7368-4f14-462a-b038-9990eebb7a9c/small.jpg</picture_url>
          <person_id>yingfeixiong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhenjiang</first_name>
          <last_name>Hu</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sei.pku.edu.cn/~hu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhenjianghu/5d426480-5589-46be-b4f6-f98cf2acc80e/small.jpg</picture_url>
          <person_id>zhenjianghu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>28709fdb-01ca-4805-a08f-291196a28856</slot_id>
      <event_id>c665785c-df10-4875-a920-66060d2f1bb9</event_id>
      <title>A Sparse Iteration Space Transformation Framework for Sparse Tensor Algebra</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description>We address the problem of optimizing sparse tensor algebra in a compiler and show how to define standard loop transformations—split, collapse, and reorder—on sparse iteration spaces. The key idea is to track the transformation functions that map the original iteration space to derived iteration spaces. These functions are needed by the code generator to emit code that maps coordinates between iteration spaces at runtime, since the coordinates in the sparse data structures remain in the original iteration space. We further demonstrate that derived iteration spaces can tile both the universe of coordinates and the subset of nonzero coordinates: the former is analogous to tiling dense iteration spaces, while the latter tiles sparse iteration spaces into statically load-balanced blocks of nonzeros. Tiling the space of nonzeros lets the generated code efficiently exploit heterogeneous compute resources such as threads, vector units, and GPUs. 
We implement these concepts by extending the sparse iteration theory implementation in the TACO system. The associated scheduling API can be used by performance engineers or it can be the target of an automatic scheduling system. We outline one heuristic autoscheduling system, but other systems are possible. Using the scheduling API, we show how to optimize mixed sparse-dense tensor algebra expressions on CPUs and GPUs. Our results show that the sparse transformations are sufficient to generate code with competitive performance to hand-optimized implementations from the literature, while generalizing to all of the tensor algebra.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ryan</first_name>
          <last_name>Senanayake</last_name>
          <affiliation>Reservoir Labs, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.RSenApps.com</homepage_url>
          <person_id>ryansenanayake</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Changwan</first_name>
          <last_name>Hong</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>changwanhong2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziheng</first_name>
          <last_name>Wang</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>zihengwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Amalee</first_name>
          <last_name>Wilson</last_name>
          <affiliation>Stanford University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>amaleewilson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chou</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/s3chou</homepage_url>
          <person_id>stephenchou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Shoaib</first_name>
          <last_name>Kamil</last_name>
          <affiliation>Adobe, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shoaibkamil/2bc60aee-bda5-437e-9e74-e00f5a55c9ef/small.jpg</picture_url>
          <person_id>shoaibkamil</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Saman</first_name>
          <last_name>Amarasinghe</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>Prof. Saman Amarasinghe leads the Commit compiler research group in MIT’s Computer Science &amp;amp; Artificial Intelligence Laboratory (CSAIL), which focuses on programming languages and compilers that maximize application performance on modern computing platforms. He is a world leader in the field of high-performance domain-specific languages. Prof. Amarasinghe’s group developed the Halide, TACO, Simit, StreamIt, StreamJIT, PetaBricks, MILK, Cimple, and GraphIt domain-specific languages and compilers, all of which combine language design and sophisticated compilation techniques to deliver unprecedented performance for targeted application domains such as image processing, stream computations, and graph analytics. Dr. Amarasinghe also pioneered the application of machine learning for compiler optimizations, from Meta optimization in 2003 to OpenTuner extendable autotuner today. With professor Anant Agarwal, he co-led the Raw architecture project, which did pioneering work on scalable multicores. Prof. Amarasinghe’s entrepreneurship activities include founding Determina, Inc. (acquired by VMWare) based on computer security research pioneered in his research group at MIT and co-founding Lanka Internet Services, Ltd., the first Internet Service Provider in Sri Lanka. Prof. Amarasinghe is also the faculty director of MIT Global Startup Labs, whose summer programs in 17 countries have helped to create more than 20 thriving startups. Prof. Amarasinghe developed the popular Performance Engineering of Software Systems (6.172) class with Professor Charles Leiserson. He also created individualized software project classes such as the Open Source Software Project Lab, the Open Source Entrepreneurship Lab, and the Bring Your Own Software Project Lab.</bio>
          <homepage_url>http://people.csail.mit.edu/saman</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/samanamarasinghe/9e4ed1ad-ff3e-468e-b1a8-36ffb2c882ef/small.jpg</picture_url>
          <person_id>samanamarasinghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>46790d50-8c11-4194-a440-52b7d6aeace7</slot_id>
      <event_id>468d3ce3-f4e2-4841-8860-e07f77f04412</event_id>
      <title>Learning Semantic Program Embeddings with Graph Interval Neural Network</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description>Learning distributed representations of source code has been a challenging task for machine learning models. Earlier works treated programs as text so that natural language methods can be readily applied. Unfortunately, such approaches do not capitalize on the rich structural information possessed by source code. Of late, Graph Neural Network (GNN) was proposed to learn embeddings of programs from their graph representations. Due to the homogeneous (i.e. do not take advantage of the program-specific graph characteristics) and expensive (i.e. require heavy information exchange among nodes in the graph) message-passing procedure, GNN can suffer from precision issues, especially when dealing with programs rendered into large graphs. In this paper, we present a new graph neural architecture, called Graph Interval Neural Network (GINN), to tackle the weaknesses of the existing GNN. Unlike the standard GNN, GINN generalizes from a curated graph representation obtained through an abstraction method designed to aid models to learn. In particular, GINN focuses exclusively on intervals (generally manifested in looping construct) for mining the feature representation of a program, furthermore, GINN operates on a hierarchy of intervals for scaling the learning to large graphs. 
We evaluate GINN for two popular downstream applications: variable misuse prediction and method name prediction. Results show in both cases GINN outperforms the state-of-the-art models by a comfortable margin. We have also created a neural bug detector based on GINN to catch null pointer deference bugs in Java code. While learning from the same 9,000 methods extracted from 64 projects, GINN-based bug detector significantly outperforms GNN-based bug detector on 13 unseen test projects. Next, we deploy our trained GINN-based bug detector and Facebook Infer, arguably the state-of-the-art static analysis tool, to scan the codebase of 20 highly starred projects on GitHub. Through our manual inspection, we confirm 38 bugs out of 102 warnings raised by GINN-based bug detector compared to 34 bugs out of 129 warnings for Facebook Infer. We have reported 38 bugs GINN caught to developers, among which 11 have been fixed and 12 have been confirmed (fix pending). GINN has shown to be a general, powerful deep neural network for learning precise, semantic program embeddings.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yu</first_name>
          <last_name>Wang</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <person_id>yuwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ke</first_name>
          <last_name>Wang</last_name>
          <affiliation>Visa Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kbwang.bitbucket.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/kewang/37ef656e-ca92-475f-8a51-902dbe44fb72/small.jpg</picture_url>
          <person_id>kewang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Fengjuan</first_name>
          <last_name>Gao</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <person_id>fenjuangao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Linzhang</first_name>
          <last_name>Wang</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <person_id>linzhangwang</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>54382f16-d130-4365-aa5f-1ceab87c3555</slot_id>
      <event_id>242d728b-7429-46a7-b7af-5fc2ae5830da</event_id>
      <title>Statically Verified Refinements for Multiparty Protocols</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description>With distributed computing becoming ubiquitous in the modern era, safe distributed programming is an open challenge. To address this, multiparty session types (MPST) provide a typing discipline for message-passing concurrency, guaranteeing communication safety properties such as deadlock freedom. 
While originally MPST focus on the communication aspects, and employ a simple typing system for communication payloads, communication protocols in the real world usually contain \emph{constraints} on the payload. We introduce \emph{refined multiparty session types (RMPST)}, an extension of MPST, that express data dependent protocols via \emph{refinement types} on the data types. 
We provide an implementation of RMPST, in a toolchain called Session*, using Scribble, a multiparty protocol description toolchain, and targeting F*, a verification-oriented functional programming language. Users can describe a protocol in Scribble and implement the endpoints in F* using \emph{refinement-typed} APIs generated from the protocol. The F* compiler can then statically verify the refinements. Moreover, we use a novel approach of callback-styled API generation, providing \emph{static} linearity guarantees with the inversion of control. We evaluate our approach with real world examples and show that it has little overhead compared to a naive implementation, while guaranteeing safety properties from the underlying theory.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fangyi</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/fangyizhou/c1ff2787-4ce8-45c7-a584-0cc8f627722c/small.jpg</picture_url>
          <person_id>fangyizhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Francisco</first_name>
          <last_name>Ferreira</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~fferre16/</homepage_url>
          <person_id>franciscoferreira1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Raymond</first_name>
          <last_name>Hu</last_name>
          <affiliation>University of Hertfordshire, UK</affiliation>
          <bio>undefined</bio>
          <person_id>raymondhu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rumyana</first_name>
          <last_name>Neykova</last_name>
          <affiliation>Brunel University London, UK</affiliation>
          <bio>Rumyana Neykova is a lecturer at Brunel University London, previously completed a PhD degree under the supervision of Prof. Nobuko Yoshida at Imperial College London, where she was also research fellow. Her research interests are in the area of distributed systems and networks, as well as type systems and language design. Her PhD focuses on development and applications of a type theory (called session types) for runtime verification of concurrent and distributed systems.</bio>
          <homepage_url>https://www.brunel.ac.uk/people/rumyana-neykova</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rumyananeykova/66457b0a-8e8b-471e-b278-37d7f4242bcb/small.jpg</picture_url>
          <person_id>rumyananeykova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>57a59748-3155-429b-ab76-49555b0f0d2d</slot_id>
      <event_id>af8e6f28-2af5-46c3-a09c-9868af9f587a</event_id>
      <title>Towards a Formal Foundation of Intermittent Computing</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description>Intermittently powered devices enable new applications in harsh or inaccessible environments, such as space or in-body implants, but also introduce problems in programmability and correctness. Researchers have developed programming models to ensure that programs make progress and do not produce erroneous results due to memory inconsistencies caused by intermittent executions. As the technology has matured, more and more features are added to intermittently powered devices, such as I/O. Prior work has shown that all existing intermittent execution models have problems with repeated device or sensor inputs (RIO). RIOs could leave intermittent executions in an inconsistent state. Such problems and the proliferation of existing intermittent execution models necessitate a formal foundation for intermittent computing. 
In this paper, we formalize intermittent execution models, their correctness properties with respect to memory consistency and inputs, and identify the invariants needed to prove systems correct. We prove equivalence between several existing intermittent systems. To address RIO problems, we define an algorithm for identifying variables affected by RIOs that need to be restored after reboot and prove the algorithm correct. Finally, we implement the algorithm in a novel intermittent runtime system that is correct with respect to input operations and evaluate its performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Milijana</first_name>
          <last_name>Surbatovich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>milijanasurbatovich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Brandon</first_name>
          <last_name>Lucia</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Brandon is a Professor at Carnegie Mellon University working on hardware and software computer systems to answer the question: “How capable can a computing system be, given physical restrictions on its form factor, input power, energy storage, or other resource constraints?” His research has been recognized with 8 best paper awards, the 2019 IEEE TCCA Young Computer Architect Award and the 2015 Bell Labs Prize.</bio>
          <homepage_url>http://brandonlucia.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brandonlucia/e10fc900-d74f-44e7-a793-5e2f21a7dd0b/small.jpg</picture_url>
          <person_id>brandonlucia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Limin</first_name>
          <last_name>Jia</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.andrew.cmu.edu/user/liminjia/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/liminjia/6bc50ee1-2333-4b59-bc4f-3bf74d1e3b64/small.jpg</picture_url>
          <person_id>liminjia</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5deaae8c-35a5-48c4-9bea-5c4a6dbd088b</slot_id>
      <event_id>bc9f313e-e00d-4f1b-bf2a-415dd6945a37</event_id>
      <title>Incremental Predicate Analysis for Regression Verification</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description>Software products are evolving during their life cycles. Ideally, every revision need be formally verified to ensure software quality. Yet repeated formal verification requires significant computing resources. Verifying each and every revision can be very challenging. It is desirable to ameliorate regression verification for practical purposes. In this paper, we regard predicate analysis as a process of assertion annotation. We propose to reuse the previously-yielded assertion annotation in regression verification. A light-weight impact-analysis technique is proposed to analyze the reusability of assertions. A novel assertion strengthening technique is furthermore developed to improve reusability of annotation. With these techniques, we present an incremental predicate analysis technique for regression verification. Correctness of our incremental technique is formally proved. We performed comprehensive experiments on revisions of Linux kernel device drivers. Our technique outperforms the state-of-the-art program verification tool CPAchecker by getting x1.4 speedup in analysis time and solving additional 78 tasks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Qianshan</first_name>
          <last_name>Yu</last_name>
          <affiliation>Tsinghua University, China</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/qianshanyu/5ab95d6b-de0b-48ef-8655-f7b92c2938c8/small.jpg</picture_url>
          <person_id>qianshanyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fei</first_name>
          <last_name>He</last_name>
          <affiliation>Tsinghua University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://feihe.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/feihe/8546030e-3821-4cb3-8f33-23a258579461/small.jpg</picture_url>
          <person_id>feihe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bow-Yaw</first_name>
          <last_name>Wang</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <person_id>bowyawwang1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7111dae1-052c-458e-abeb-062bad747aca</slot_id>
      <event_id>b716e5a3-2e60-4d4f-9e24-7ca957c0f786</event_id>
      <title>StreamQL: A Query Language for Processing Streaming Time Series</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description>Real-time data analysis applications increasingly rely on complex streaming computations over time-series data. We propose StreamQL, a language that facilitates the high-level specification of complex analyses over streaming time series. StreamQL is built upon stream transformations, which allows it to integrate three language-based approaches for data stream processing: relational queries, dataflow composition, and temporal formalisms. The relational constructs are useful for specifying simple transformations, aggregations, and the partitioning of data into key-based groups or windows. The dataflow abstractions enable the modular description of a computation as a pipeline of stages or, more generally, as a directed graph of independent tasks. Finally, temporal constructs can be used to specify complex temporal patterns and time-varying computations. These three constructs can be composed freely to describe complex streaming computations. 
StreamQL has a formal denotational semantics, which we use to prove the expressive completeness of the language. We provide an implementation of StreamQL as a lightweight Java library, which we use to experimentally evaluate our approach. The experiments show that the throughput of our implementation is consistently higher than that of state-of-the-art streaming engines.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lingkun</first_name>
          <last_name>Kong</last_name>
          <affiliation>Rice University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>lingkunkong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Mamouras</last_name>
          <affiliation>Rice University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>konstantinosmamouras1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7c0c9ab8-ab62-47e2-840d-bcf408119f6c</slot_id>
      <event_id>ce620984-5c4d-4b94-8f1e-f5c1dda732a1</event_id>
      <title>SATUNE: Synthesizing Efficient SAT Encoders</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description>Modern SAT solvers are extremely efficient at solving boolean satisfiability problems, enabling a wide spectrum of techniques for checking, verifying, and validating real-world programs. What remains challenging, though, is how to encode a domain problem (e.g., model checking) into a SAT formula because the same problem can have multiple distinct encodings, which can yield performance results that are orders-of-magnitude apart, regardless of the underlying solvers used. We develop SATUNE, a tool that can automatically synthesize SAT encoders for different problem domains. SATUNE employs a DSL that allows developers to express domain problems at a high level and a search algorithm that can effectively find efficient solutions. The search process is guided by observations made over example encodings and their performance for the domain and hence SATUNE can quickly synthesize a high-performance encoder by incorporating patterns from examples that yield good performance. A thorough evaluation with JMCR, SyPet, Dirk, Hexiom, Sudoku, and KillerSudoku demonstrates that SATUNE can easily synthesize high-performance encoders for different domains including model checking, synthesis, and games. These encodings generate constraint problems that are often several orders of magnitude faster to solve than the original encodings used by the tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hamed</first_name>
          <last_name>Gorjiara</last_name>
          <affiliation>University of California at Irvine, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gorjiara.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hamedgorjiara/ac3c3dcb-0d83-409b-91a3-d369cd445f3b/small.jpg</picture_url>
          <person_id>hamedgorjiara</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guoqing Harry</first_name>
          <last_name>Xu</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am an Associate Professor of Computer Science at University of California, Los Angeles (UCLA). I am interested broadly in software and hardware systems — including programming languages, compilers, big data analytics, distributed systems, and computer architecture.</bio>
          <homepage_url>http://web.cs.ucla.edu/~harryxu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/harryxu/5d680c47-2b02-4f5f-a2fb-55c72b5d63ed/small.jpg</picture_url>
          <person_id>harryxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brian</first_name>
          <last_name>Demsky</last_name>
          <affiliation>University of California at Irvine, USA</affiliation>
          <bio>undefined</bio>
          <person_id>briandemsky</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8cef0ad3-678e-4e6d-ae0a-2045f368f033</slot_id>
      <event_id>bda72afd-3a6a-4812-8ecd-1d6b77c646ce</event_id>
      <title>Scaling Exact Inference for Discrete Probabilistic Programs</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description>Probabilistic programming languages (PPLs) are an expressive means of representing and reasoning about probabilistic models. The computational challenge of probabilistic inference remains the primary roadblock for applying PPLs in practice. Inference is fundamentally hard, so there is no one-size-fits all solution. In this work, we target scalable inference for an important class of probabilistic programs: those whose probability distributions are discrete. Discrete distributions are common in many fields, including text analysis, network verification, artificial intelligence, and graph analysis, but they prove to be challenging for existing PPLs. 
We develop a domain-specific probabilistic programming language called Dice that features a new approach to exact discrete probabilistic program inference. Dice exploits program structure in order to factorize inference, enabling us to perform exact inference on probabilistic programs with hundreds of thousands of random variables. Our key technical contribution is a new reduction from discrete probabilistic programs to weighted model counting (WMC). This reduction separates the structure of the distribution from its parameters, enabling logical reasoning tools to exploit that structure for probabilistic inference. We (1) show how to compositionally reduce Dice inference to WMC, (2) prove this compilation correct with respect to a denotational semantics, (3) empirically demonstrate the performance benefits over prior approaches, and (4) analyze the types of structure that allow Dice to scale to large probabilistic programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Steven</first_name>
          <last_name>Holtzen</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am a PhD. student at U.C.L.A., co-advised by Guy Van den Broeck and Todd Millstein.</bio>
          <homepage_url>http://web.cs.ucla.edu/~sholtzen</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stevenholtzen/db2263a6-7a88-4167-9d73-86a4d4b97fc9/small.jpg</picture_url>
          <person_id>stevenholtzen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guy</first_name>
          <last_name>Van den Broeck</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am an Associate Professor and Samueli Fellow at UCLA, in the Computer Science Department. My research interests are in Machine Learning (Statistical Relational Learning), Knowledge Representation and Reasoning (Graphical Models, Lifted Probabilistic Inference), Applications of Probabilistic Reasoning and Learning (Probabilistic Programming, Probabilistic Databases), and Artificial Intelligence in general. I previously was a postdoctoral researcher at UCLA’s Automated Reasoning lab and KU Leuven’s Declarative Languages and Artificial Intelligence lab.</bio>
          <homepage_url>http://web.cs.ucla.edu/~guyvdb/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guyvandenbroeck/4c8a474f-a124-4434-a370-43b4892bbe2c/small.jpg</picture_url>
          <person_id>guyvandenbroeck</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Todd</first_name>
          <last_name>Millstein</last_name>
          <affiliation>University of California, Los Angeles</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.cs.ucla.edu/~todd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/toddmillstein1/a55642b6-6fa2-40f6-99ba-8b9003ee61d9/small.jpg</picture_url>
          <person_id>toddmillstein1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a6e265c3-05c7-4d4f-ba8f-c032b3396ff4</slot_id>
      <event_id>af83d347-a934-48f4-a73a-35f960446055</event_id>
      <title>Certified and Efficient Instruction Scheduling</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description>CompCert is a moderately optimizing C compiler with a formal, machine-checked, proof of correctness: after successful compilation, the assembly code has a behavior faithful to the source code. Previously, it only supported target instruction sets with sequential semantics, and did not attempt reordering instructions for optimization. 
We present here a CompCert backend for a VLIW core (i.e., with explicit parallelism at the instruction level), the first CompCert backend providing scalable and efficient instruction scheduling. Furthermore, its highly modular implementation can be easily adapted to other VLIW or non-VLIW pipelined processors.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sylvain</first_name>
          <last_name>Boulmé</last_name>
          <affiliation>Grenoble Alps University, France / CNRS, France / Grenoble INP, France / VERIMAG, France</affiliation>
          <bio>undefined</bio>
          <person_id>sylvainboulme</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Cyril</first_name>
          <last_name>Six</last_name>
          <affiliation>Kalray, France / Grenoble Alps University, France / CNRS, France / Grenoble INP, France / VERIMAG, France</affiliation>
          <bio>undefined</bio>
          <person_id>cyrilsix</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Monniaux</last_name>
          <affiliation>Grenoble Alps University, France / CNRS, France / Grenoble INP, France / VERIMAG, France</affiliation>
          <bio>David Monniaux obtained his PhD in 2001 in Paris under Prof Patrick Cousot; his dissertation was on the static analysis of probabilistic programs by abstract interpretation. He then joined CNRS as a junior researcher and first worked on the Astrée static analyzer, still in Paris. In 2007 he transferred to VERIMAG in Grenoble, where he works on various aspects of program verification (decision procedures, abstract interpretation…). 
He now is a senior researcher at CNRS and an adjunct professor at École polytechnique.</bio>
          <homepage_url>http://www-verimag.imag.fr/~monniaux/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidmonniaux/d285baca-8e32-4918-b3c6-c724e98fc7b3/small.jpg</picture_url>
          <person_id>davidmonniaux</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b2363249-2bdc-4b55-94d2-b907acc14eb8</slot_id>
      <event_id>6180c33e-cd3b-42a1-9d1c-7a789ca7072d</event_id>
      <title>Revisiting Iso-Recursive Subtyping</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description>The Amber rules are well-known and widely used for subtyping iso-recursive types. They were first briefly and informally introduced in 1985 by Cardelli in a manuscript describing the Amber language. Despite their use over many years, important aspects of the metatheory of the iso-recursive style Amber rules have not been studied in depth or turn out to be quite challenging to formalize. This paper aims to revisit the problem of subtyping iso-recursive types. We start by introducing a novel declarative specification that we believe captures the “spirit” of Amber-style iso-recursive subtyping. Informally, the specification states that two recursive types are subtypes \emph{if all their finite unfoldings are subtypes}. The Amber rules are shown to be sound with respect to this declarative specification. We then derive a \emph{sound}, \emph{complete} and \emph{decidable} algorithmic formulation of subtyping that employs a novel \emph{double unfolding} rule. Compared to the Amber rules, the double unfolding rule has the advantage of: 1) \emph{being modular}; 2) \emph{not requiring reflexivity} to be built in; and 3) leading to an \emph{easy proof of transitivity of subtyping}. This work sheds new insights on the theory of subtyping iso-recursive types, and the new double unfolding rule has important advantages over the original Amber rules for both implementations and metatheoretical studies involving recursive types. All results are mechanically formalized in the Coq theorem prover. Furthermore, as far as we know, this is the first comprehensive treatment of iso-recursive subtyping in a theorem prover, which can deal with \emph{unrestricted} recursive types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yaoda</first_name>
          <last_name>Zhou</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <person_id>yaodazhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jinxu</first_name>
          <last_name>Zhao</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <person_id>jinxuzhao</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b9a1acea-0b10-4dbd-a876-ec37949de772</slot_id>
      <event_id>eae9a815-c985-40c1-9208-cd4565b52e3d</event_id>
      <title>Guided Linking: Dynamic Linking Without the Costs</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description>Dynamic linking is extremely common in modern software systems, thanks to the flexibility and space savings it offers. However, this flexibility comes at a cost: every library call has an extra layer of indirection, and it’s impossible to perform interprocedural optimizations that involve calls to a dynamic library. The basic problem is that the run-time behavior of the dynamic linker can’t be predicted at compile time, so the compiler can make no assumptions about how external calls will behave. 
This paper introduces guided linking, a technique for optimizing dynamically linked software when some information about the dynamic linker’s behavior is known in advance. The developer provides an arbitrary set of programs, libraries, and plugins to our tool, along with constraints that limit the possible dynamic linking behavior of the software. Given a software set and a list of constraints, our tool takes advantage of the constraints to optimize the software for speed and size. For example, the “no dynamic redefinitions” constraint can be applied to a function when the developer knows the function will never be unexpectedly overridden with a different definition at run time; this constraint allows dynamic references between libraries in the set to be resolved to static references, which can then be optimized with standard link-time optimizations. As an additional optimization, we deduplicate identical functions that appear anywhere in the software set. 
By applying guided linking to a dynamically linked distribution of Clang and LLVM, and using the constraint that no other software will use the LLVM libraries, we can increase speed by 6% and reduce file size by 11%. If we relax the constraint to allow other software to use the LLVM libraries, we can still increase speed by 5.5% and reduce file size by 3%. If we apply guided linking to the Python interpreter and a set of loadable Python modules, applying the constraint that no other programs or modules will be used, we can increase speed by an average of 6.6%. If we use guided linking to combine 11 different versions of the Boost library, applying minimal constraints, we can reduce the total library size by 57%.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sean</first_name>
          <last_name>Bartell</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <person_id>seanbartell</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Will</first_name>
          <last_name>Dietz</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wdtz.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/willdietz/f5b6948e-d200-44b1-ba05-8d21549414f8/small.jpg</picture_url>
          <person_id>willdietz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Vikram S.</first_name>
          <last_name>Adve</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>Vikram Adve is the Donald B. Gillies Professor of Computer Science at the University of Illinois at Urbana-Champaign and a Professor in Electrical and Computer Engineering. He is a Co-founder and Co-Director of the Center for Digital Agriculture and leads AIFARMS, a $20M National Artificial Intelligence Research Institute funded by NIFA and NSF. Adve’s research interests lie in developing and using compiler techniques to improve the performance, programmability and reliability of computer systems. Adve and his Ph.D. student, Chris Lattner, co-designed the LLVM Compiler Infrastructure, which enables a novel approach to “lifelong compilation” of programs in a wide range of general-purpose programming languages. For example, most mobile apps for the iPhone, iPad, Apple Watch and Apple TV are shipped by developers to Apple in the LLVM compiler representation called “LLVM bitcode” and then compiled and specialized for the various end-user devices. LLVM is widely used in industry today, ranging from mobile devices (e.g., iOS and Android) to supercomputers (e.g., at NVIDIA, Cray, IBM and Intel) to data centers (e.g., at Google). Adve, Lattner and Evan Cheng received the ACM Software System Award in 2012 for co-developing LLVM. Adve has won a ten-year-retrospective Most Influential Paper award at CGO 2004, and distinguished paper awards at several conferences including PLDI 2005, SOSP 2007 and ICSE 2011. He has served as the Associate Editor for the ACM Transactions on Programming Languages and Systems, and co-chaired the Program Committees for ASPLOS 2010, VEE 2008, and LCPC 2007. One of Adve’s Ph.D. students, Robert Bocchino, won the 2010 ACM SIGPLAN Outstanding Dissertation Award and another student, John Criswell, won Honorable Mentions for both the 2014 ACM SIGOPS Dissertation Award and the 2014 ACM Doctoral Dissertation Award. Adve is a Fellow of the ACM and was named a University Scholar at the University of Illinois in 2015. He served as Interim Head of the Computer Science Department from 2017 to 2019.</bio>
          <homepage_url>http://vikram.cs.illinois.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vikramadve/a99a9248-20e3-4738-9200-173c353c5fcb/small.jpg</picture_url>
          <person_id>vikramadve</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b9a25aca-9b19-4c9f-8e5f-0d5a64db7cd0</slot_id>
      <event_id>900edfcd-fbb8-4c27-ace5-283161a9908d</event_id>
      <title>Unifying Execution of Imperative Generators and Declarative Specifications</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description>We present Deuterium—a framework for implementing Java methods as executable contracts. Deuterium introduces a novel, type-safe way to write method contracts entirely in Java, as a combination of imperative generators and declarative specifications (written in a first-order relational logic with transitive closure). Existing approaches are typically based on encoding both the specification and the program heap into a constraint language, and then using an off-the-shelf constraint solver—without any additional guidance—to search for a new program heap that satisfies the specification. Deuterium takes the advantage of user-provided generators to prune the search space and reduce incurred overhead of constraint solving. Deuterium supports two ways to solving declarative constraints: SAT-based and search-based with in-memory state exploration. We evaluate our approach on a suite of data structures, established as a standard benchmark by prior work. Furthermore, we use random and sequence-based test generation to create a new benchmark designed to mimic more realistic execution scenarios. Our results show that generators improve performance of executable contracts and that in-memory state exploration is the algorithm of choice when heap sizes are small.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pengyu</first_name>
          <last_name>Nie</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>I’m a Ph.D. student at the University of Texas at Austin. I work with Prof. Milos Gligoric. My research interests focus on the fusion of software engineering, programming languages, and natural language processing. Specific topics include languages for writing executable contracts and executable comments, updating natural language elements for evolving software, and utilizing runtime context to improve ML models for software.</bio>
          <homepage_url>http://cozy.ece.utexas.edu/~pynie/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/pengyunie/eb2ae7b4-4e42-4cbe-ba27-0b4f2fac274a/small.jpg</picture_url>
          <person_id>pengyunie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marinela</first_name>
          <last_name>Parovic</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>marinelaparovic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhiqiang</first_name>
          <last_name>Zang</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>zhiqiangzang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sarfraz</first_name>
          <last_name>Khurshid</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/sarfrazkhurshid/b998e03f-4c99-458b-a9f9-b6c470511e3b/small.jpg</picture_url>
          <person_id>sarfrazkhurshid</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Aleksandar</first_name>
          <last_name>Milicevic</last_name>
          <affiliation>Microsoft, n.n.</affiliation>
          <bio>undefined</bio>
          <person_id>aleksandarmilicevic2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Milos</first_name>
          <last_name>Gligoric</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/milosgligoric/4d0671ae-937e-4f08-b499-092379ff7ad3/small.jpg</picture_url>
          <person_id>milosgligoric</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c742b494-8266-4698-8fdb-76c4a27bd79e</slot_id>
      <event_id>dc63a9f0-ab34-41e2-a618-62f4112a139f</event_id>
      <title>CompCertELF: Verified Separate Compilation of C Programs into ELF Object Files</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description>We present CompCertELF, the first extension to CompCert that supports verified compilation from C programs all the way to a standard binary file format, i.e., the ELF object format. Previous work on Stack-Aware CompCert provides a verified compilation chain from C programs to assembly programs with a realistic machine memory model. We build CompCertELF by modifying and extending this compilation chain with a verified assembler which further transforms assembly programs into ELF object files. 
CompCert supports large-scale verification via verified separate compilation: C modules can be written and compiled separately, and then linked together to get a target program that refines the semantics of the program linked from the source modules. However, verified separate compilation in CompCert only works for compilation to assembly programs, not to object files. For the latter, the main difficulty is to bridge the two different views of linking: one for CompCert’s programs that allows arbitrary shuffling of global definitions by linking and the other for ELF object files that treats blocks of encoded definitions as unanalyzable and indivisible units. 
We propose a lightweight approach that solves the above problem without any modification to CompCert’s framework for verified separate compilation: by introducing a notion of syntactical equivalence between programs and proving the commutativity between syntactical equivalence and the two different kinds of linking, we are able to transit from the more abstract linking operation in CompCert to the more concrete one for ELF object files. By applying this approach to CompCertELF, we obtain the first compiler that supports verified separate compilation of C programs into ELF object files.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuting</first_name>
          <last_name>Wang</last_name>
          <affiliation>Shanghai Jiao Tong University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jhc.sjtu.edu.cn/~yutingwang/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yutingwang/963979f5-1f61-418e-9435-0abbb408ef37/small.jpg</picture_url>
          <person_id>yutingwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xiangzhe</first_name>
          <last_name>Xu</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <person_id>xiangzhexu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pierre</first_name>
          <last_name>WILKE</last_name>
          <affiliation>CentraleSupélec, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pwilke.fr/pwilke-en.html</homepage_url>
          <person_id>pierrewilke1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhong</first_name>
          <last_name>Shao</last_name>
          <affiliation>Yale University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/shao/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhongshao/18a2973a-020f-46ed-9073-85bd70626116/small.jpg</picture_url>
          <person_id>zhongshao</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1fb2e673-6a78-40dd-8caa-644d495f0c60</subevent_id>
    <title>SPLASH Posters: Cocktails in New York</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot>
      <slot_id>f56bbeb0-416f-4f45-a42b-90e1f480d780</slot_id>
      <title>Session: SPLASH Posters - Cocktails in New York</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_time>21:00</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cca741b1-895d-4a7a-abb7-2cc2d0ed2621</slot_id>
      <event_id>b14951c0-1b3a-4b54-ba3f-453e8d37ae2d</event_id>
      <title>Posters Session 1</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:00</end_time>
      <description> 
  A Case Study in Language-Based Security: Building an I/O Library for Wyvern. Jennifer A. Fish, Darya Melicher, and Jonathan Aldrich  
  A Type-Directed Operational Semantics for a Calculus with a Merge Operator. Xuejing Huang and Bruno C. d. S. Oliveira  
  Analogy-Making as a Core Primitive in the Software Engineering Toolbox. Matthew Sotoudeh, and Aditya V. Thakur  
  CAMP: Cost-Aware Multiparty Session Protocols. David Castro-Perez and Nobuko Yoshida  
  Can Advanced Type Systems Be Usable? An Empirical Study of Ownership, Assets, and Typestate in Obsidian. Michael Coblenz, Jonathan Aldrich, Brad Myers, and Joshua Sunshine  
  Demystifying Dependence. James Koppel and Daniel Jackson  
  Formulog: Datalog for SMT-Based Static Analysis. Aaron Bembenek, Michael Greenberg, and Stephen Chong  
  Geometry Types for Graphics Programming. Dietrich Geisler, Irene Yoon, Aditi Kabra, Horace He, Yinnon Sanders, and Adrian Sampson  
  Gradual Verification of Recursive Heap Data Structures. Jenna Wise, Johannes Bader, Cameron Wong, Jonathan Aldrich, Éric Tanter, and Joshua Sunshine  
  Knowing When to Ask: Sound Scheduling of Name Resolution in Type Checkers Derived from Declarative Specifications. Arjen Rouvoet, Hendrik van Antwerpen, Casper Bach Poulsen, Robbert Krebbers, and Eelco Visser  
  Multiparty Session Programming with Global Protocol Combinators. Keigo Imai, Rumyana Neykova, Nobuko Yoshida, and Shoji Yuen  
  On the Unusual Effectiveness of Type-Aware Operator Mutations for Testing SMT Solvers. Dominik Winterer, Chengyu Zhang, and Zhendong Su  
  Owicki-Gries Reasoning for C11 RAR. Sadegh Dalvandi, Simon Doherty, Brijesh Dongol, and Heike Wehrheim  
  Reshape Your Layouts, Not Your Programs: A Safe Language Extension for Better Cache Locality. Alexandros TasosI, Juliana Franco, Sophia Drossopoulou, Tobias Wrigstad, and Susan Eisenbach  
  Row and Bounded Polymorphism via Disjoint Polymorphism. Ningning Xie, Bruno C. d. S. Oliveira, Xuan Bi, and Tom Schrijvers  
  Static Race Detection and Mutex Safety and Liveness for Go Programs. Julia Gabet and Nobuko Yoshida  
</description>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b0dc92e9-b7ec-4074-a38b-955df5f67d62</subevent_id>
    <title>SPLASH Posters: Posters Session 2 Mirror</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-VII</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot>
      <slot_id>71ff1524-c74c-45b7-9320-76dfc31ee6fd</slot_id>
      <title>Session: SPLASH Posters - Posters Session 2 Mirror</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_time>23:00</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>04088f32-936a-47ab-83c0-b0a4775203aa</slot_id>
      <event_id>468d3ce3-f4e2-4841-8860-e07f77f04412</event_id>
      <title>Learning Semantic Program Embeddings with Graph Interval Neural Network</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description>Learning distributed representations of source code has been a challenging task for machine learning models. Earlier works treated programs as text so that natural language methods can be readily applied. Unfortunately, such approaches do not capitalize on the rich structural information possessed by source code. Of late, Graph Neural Network (GNN) was proposed to learn embeddings of programs from their graph representations. Due to the homogeneous (i.e. do not take advantage of the program-specific graph characteristics) and expensive (i.e. require heavy information exchange among nodes in the graph) message-passing procedure, GNN can suffer from precision issues, especially when dealing with programs rendered into large graphs. In this paper, we present a new graph neural architecture, called Graph Interval Neural Network (GINN), to tackle the weaknesses of the existing GNN. Unlike the standard GNN, GINN generalizes from a curated graph representation obtained through an abstraction method designed to aid models to learn. In particular, GINN focuses exclusively on intervals (generally manifested in looping construct) for mining the feature representation of a program, furthermore, GINN operates on a hierarchy of intervals for scaling the learning to large graphs. 
We evaluate GINN for two popular downstream applications: variable misuse prediction and method name prediction. Results show in both cases GINN outperforms the state-of-the-art models by a comfortable margin. We have also created a neural bug detector based on GINN to catch null pointer deference bugs in Java code. While learning from the same 9,000 methods extracted from 64 projects, GINN-based bug detector significantly outperforms GNN-based bug detector on 13 unseen test projects. Next, we deploy our trained GINN-based bug detector and Facebook Infer, arguably the state-of-the-art static analysis tool, to scan the codebase of 20 highly starred projects on GitHub. Through our manual inspection, we confirm 38 bugs out of 102 warnings raised by GINN-based bug detector compared to 34 bugs out of 129 warnings for Facebook Infer. We have reported 38 bugs GINN caught to developers, among which 11 have been fixed and 12 have been confirmed (fix pending). GINN has shown to be a general, powerful deep neural network for learning precise, semantic program embeddings.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yu</first_name>
          <last_name>Wang</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <person_id>yuwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ke</first_name>
          <last_name>Wang</last_name>
          <affiliation>Visa Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kbwang.bitbucket.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/kewang/37ef656e-ca92-475f-8a51-902dbe44fb72/small.jpg</picture_url>
          <person_id>kewang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Fengjuan</first_name>
          <last_name>Gao</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <person_id>fenjuangao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Linzhang</first_name>
          <last_name>Wang</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <person_id>linzhangwang</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3a1a9808-a437-4fbc-a480-cce842ff1ad7</slot_id>
      <event_id>af8e6f28-2af5-46c3-a09c-9868af9f587a</event_id>
      <title>Towards a Formal Foundation of Intermittent Computing</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description>Intermittently powered devices enable new applications in harsh or inaccessible environments, such as space or in-body implants, but also introduce problems in programmability and correctness. Researchers have developed programming models to ensure that programs make progress and do not produce erroneous results due to memory inconsistencies caused by intermittent executions. As the technology has matured, more and more features are added to intermittently powered devices, such as I/O. Prior work has shown that all existing intermittent execution models have problems with repeated device or sensor inputs (RIO). RIOs could leave intermittent executions in an inconsistent state. Such problems and the proliferation of existing intermittent execution models necessitate a formal foundation for intermittent computing. 
In this paper, we formalize intermittent execution models, their correctness properties with respect to memory consistency and inputs, and identify the invariants needed to prove systems correct. We prove equivalence between several existing intermittent systems. To address RIO problems, we define an algorithm for identifying variables affected by RIOs that need to be restored after reboot and prove the algorithm correct. Finally, we implement the algorithm in a novel intermittent runtime system that is correct with respect to input operations and evaluate its performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Milijana</first_name>
          <last_name>Surbatovich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>milijanasurbatovich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Brandon</first_name>
          <last_name>Lucia</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Brandon is a Professor at Carnegie Mellon University working on hardware and software computer systems to answer the question: “How capable can a computing system be, given physical restrictions on its form factor, input power, energy storage, or other resource constraints?” His research has been recognized with 8 best paper awards, the 2019 IEEE TCCA Young Computer Architect Award and the 2015 Bell Labs Prize.</bio>
          <homepage_url>http://brandonlucia.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brandonlucia/e10fc900-d74f-44e7-a793-5e2f21a7dd0b/small.jpg</picture_url>
          <person_id>brandonlucia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Limin</first_name>
          <last_name>Jia</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.andrew.cmu.edu/user/liminjia/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/liminjia/6bc50ee1-2333-4b59-bc4f-3bf74d1e3b64/small.jpg</picture_url>
          <person_id>liminjia</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>56cc58f5-a8f5-4875-9670-100d093e73c8</slot_id>
      <event_id>b716e5a3-2e60-4d4f-9e24-7ca957c0f786</event_id>
      <title>StreamQL: A Query Language for Processing Streaming Time Series</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description>Real-time data analysis applications increasingly rely on complex streaming computations over time-series data. We propose StreamQL, a language that facilitates the high-level specification of complex analyses over streaming time series. StreamQL is built upon stream transformations, which allows it to integrate three language-based approaches for data stream processing: relational queries, dataflow composition, and temporal formalisms. The relational constructs are useful for specifying simple transformations, aggregations, and the partitioning of data into key-based groups or windows. The dataflow abstractions enable the modular description of a computation as a pipeline of stages or, more generally, as a directed graph of independent tasks. Finally, temporal constructs can be used to specify complex temporal patterns and time-varying computations. These three constructs can be composed freely to describe complex streaming computations. 
StreamQL has a formal denotational semantics, which we use to prove the expressive completeness of the language. We provide an implementation of StreamQL as a lightweight Java library, which we use to experimentally evaluate our approach. The experiments show that the throughput of our implementation is consistently higher than that of state-of-the-art streaming engines.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lingkun</first_name>
          <last_name>Kong</last_name>
          <affiliation>Rice University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>lingkunkong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Mamouras</last_name>
          <affiliation>Rice University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>konstantinosmamouras1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>66bded73-273d-4203-a59e-fe45cec71ab0</slot_id>
      <event_id>bc9f313e-e00d-4f1b-bf2a-415dd6945a37</event_id>
      <title>Incremental Predicate Analysis for Regression Verification</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description>Software products are evolving during their life cycles. Ideally, every revision need be formally verified to ensure software quality. Yet repeated formal verification requires significant computing resources. Verifying each and every revision can be very challenging. It is desirable to ameliorate regression verification for practical purposes. In this paper, we regard predicate analysis as a process of assertion annotation. We propose to reuse the previously-yielded assertion annotation in regression verification. A light-weight impact-analysis technique is proposed to analyze the reusability of assertions. A novel assertion strengthening technique is furthermore developed to improve reusability of annotation. With these techniques, we present an incremental predicate analysis technique for regression verification. Correctness of our incremental technique is formally proved. We performed comprehensive experiments on revisions of Linux kernel device drivers. Our technique outperforms the state-of-the-art program verification tool CPAchecker by getting x1.4 speedup in analysis time and solving additional 78 tasks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Qianshan</first_name>
          <last_name>Yu</last_name>
          <affiliation>Tsinghua University, China</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/qianshanyu/5ab95d6b-de0b-48ef-8655-f7b92c2938c8/small.jpg</picture_url>
          <person_id>qianshanyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fei</first_name>
          <last_name>He</last_name>
          <affiliation>Tsinghua University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://feihe.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/feihe/8546030e-3821-4cb3-8f33-23a258579461/small.jpg</picture_url>
          <person_id>feihe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bow-Yaw</first_name>
          <last_name>Wang</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <person_id>bowyawwang1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>672a1b1f-67bf-41c4-a838-757f08e47f9d</slot_id>
      <event_id>ce620984-5c4d-4b94-8f1e-f5c1dda732a1</event_id>
      <title>SATUNE: Synthesizing Efficient SAT Encoders</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description>Modern SAT solvers are extremely efficient at solving boolean satisfiability problems, enabling a wide spectrum of techniques for checking, verifying, and validating real-world programs. What remains challenging, though, is how to encode a domain problem (e.g., model checking) into a SAT formula because the same problem can have multiple distinct encodings, which can yield performance results that are orders-of-magnitude apart, regardless of the underlying solvers used. We develop SATUNE, a tool that can automatically synthesize SAT encoders for different problem domains. SATUNE employs a DSL that allows developers to express domain problems at a high level and a search algorithm that can effectively find efficient solutions. The search process is guided by observations made over example encodings and their performance for the domain and hence SATUNE can quickly synthesize a high-performance encoder by incorporating patterns from examples that yield good performance. A thorough evaluation with JMCR, SyPet, Dirk, Hexiom, Sudoku, and KillerSudoku demonstrates that SATUNE can easily synthesize high-performance encoders for different domains including model checking, synthesis, and games. These encodings generate constraint problems that are often several orders of magnitude faster to solve than the original encodings used by the tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hamed</first_name>
          <last_name>Gorjiara</last_name>
          <affiliation>University of California at Irvine, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gorjiara.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hamedgorjiara/ac3c3dcb-0d83-409b-91a3-d369cd445f3b/small.jpg</picture_url>
          <person_id>hamedgorjiara</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guoqing Harry</first_name>
          <last_name>Xu</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am an Associate Professor of Computer Science at University of California, Los Angeles (UCLA). I am interested broadly in software and hardware systems — including programming languages, compilers, big data analytics, distributed systems, and computer architecture.</bio>
          <homepage_url>http://web.cs.ucla.edu/~harryxu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/harryxu/5d680c47-2b02-4f5f-a2fb-55c72b5d63ed/small.jpg</picture_url>
          <person_id>harryxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brian</first_name>
          <last_name>Demsky</last_name>
          <affiliation>University of California at Irvine, USA</affiliation>
          <bio>undefined</bio>
          <person_id>briandemsky</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8e5e9504-9659-4c10-9f80-379f0661ece9</slot_id>
      <event_id>c665785c-df10-4875-a920-66060d2f1bb9</event_id>
      <title>A Sparse Iteration Space Transformation Framework for Sparse Tensor Algebra</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description>We address the problem of optimizing sparse tensor algebra in a compiler and show how to define standard loop transformations—split, collapse, and reorder—on sparse iteration spaces. The key idea is to track the transformation functions that map the original iteration space to derived iteration spaces. These functions are needed by the code generator to emit code that maps coordinates between iteration spaces at runtime, since the coordinates in the sparse data structures remain in the original iteration space. We further demonstrate that derived iteration spaces can tile both the universe of coordinates and the subset of nonzero coordinates: the former is analogous to tiling dense iteration spaces, while the latter tiles sparse iteration spaces into statically load-balanced blocks of nonzeros. Tiling the space of nonzeros lets the generated code efficiently exploit heterogeneous compute resources such as threads, vector units, and GPUs. 
We implement these concepts by extending the sparse iteration theory implementation in the TACO system. The associated scheduling API can be used by performance engineers or it can be the target of an automatic scheduling system. We outline one heuristic autoscheduling system, but other systems are possible. Using the scheduling API, we show how to optimize mixed sparse-dense tensor algebra expressions on CPUs and GPUs. Our results show that the sparse transformations are sufficient to generate code with competitive performance to hand-optimized implementations from the literature, while generalizing to all of the tensor algebra.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ryan</first_name>
          <last_name>Senanayake</last_name>
          <affiliation>Reservoir Labs, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.RSenApps.com</homepage_url>
          <person_id>ryansenanayake</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Changwan</first_name>
          <last_name>Hong</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>changwanhong2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziheng</first_name>
          <last_name>Wang</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>zihengwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Amalee</first_name>
          <last_name>Wilson</last_name>
          <affiliation>Stanford University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>amaleewilson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chou</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/s3chou</homepage_url>
          <person_id>stephenchou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Shoaib</first_name>
          <last_name>Kamil</last_name>
          <affiliation>Adobe, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shoaibkamil/2bc60aee-bda5-437e-9e74-e00f5a55c9ef/small.jpg</picture_url>
          <person_id>shoaibkamil</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Saman</first_name>
          <last_name>Amarasinghe</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>Prof. Saman Amarasinghe leads the Commit compiler research group in MIT’s Computer Science &amp;amp; Artificial Intelligence Laboratory (CSAIL), which focuses on programming languages and compilers that maximize application performance on modern computing platforms. He is a world leader in the field of high-performance domain-specific languages. Prof. Amarasinghe’s group developed the Halide, TACO, Simit, StreamIt, StreamJIT, PetaBricks, MILK, Cimple, and GraphIt domain-specific languages and compilers, all of which combine language design and sophisticated compilation techniques to deliver unprecedented performance for targeted application domains such as image processing, stream computations, and graph analytics. Dr. Amarasinghe also pioneered the application of machine learning for compiler optimizations, from Meta optimization in 2003 to OpenTuner extendable autotuner today. With professor Anant Agarwal, he co-led the Raw architecture project, which did pioneering work on scalable multicores. Prof. Amarasinghe’s entrepreneurship activities include founding Determina, Inc. (acquired by VMWare) based on computer security research pioneered in his research group at MIT and co-founding Lanka Internet Services, Ltd., the first Internet Service Provider in Sri Lanka. Prof. Amarasinghe is also the faculty director of MIT Global Startup Labs, whose summer programs in 17 countries have helped to create more than 20 thriving startups. Prof. Amarasinghe developed the popular Performance Engineering of Software Systems (6.172) class with Professor Charles Leiserson. He also created individualized software project classes such as the Open Source Software Project Lab, the Open Source Entrepreneurship Lab, and the Bring Your Own Software Project Lab.</bio>
          <homepage_url>http://people.csail.mit.edu/saman</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/samanamarasinghe/9e4ed1ad-ff3e-468e-b1a8-36ffb2c882ef/small.jpg</picture_url>
          <person_id>samanamarasinghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9aadf2cf-9e54-401d-815e-e0fb554e649b</slot_id>
      <event_id>900edfcd-fbb8-4c27-ace5-283161a9908d</event_id>
      <title>Unifying Execution of Imperative Generators and Declarative Specifications</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description>We present Deuterium—a framework for implementing Java methods as executable contracts. Deuterium introduces a novel, type-safe way to write method contracts entirely in Java, as a combination of imperative generators and declarative specifications (written in a first-order relational logic with transitive closure). Existing approaches are typically based on encoding both the specification and the program heap into a constraint language, and then using an off-the-shelf constraint solver—without any additional guidance—to search for a new program heap that satisfies the specification. Deuterium takes the advantage of user-provided generators to prune the search space and reduce incurred overhead of constraint solving. Deuterium supports two ways to solving declarative constraints: SAT-based and search-based with in-memory state exploration. We evaluate our approach on a suite of data structures, established as a standard benchmark by prior work. Furthermore, we use random and sequence-based test generation to create a new benchmark designed to mimic more realistic execution scenarios. Our results show that generators improve performance of executable contracts and that in-memory state exploration is the algorithm of choice when heap sizes are small.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pengyu</first_name>
          <last_name>Nie</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>I’m a Ph.D. student at the University of Texas at Austin. I work with Prof. Milos Gligoric. My research interests focus on the fusion of software engineering, programming languages, and natural language processing. Specific topics include languages for writing executable contracts and executable comments, updating natural language elements for evolving software, and utilizing runtime context to improve ML models for software.</bio>
          <homepage_url>http://cozy.ece.utexas.edu/~pynie/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/pengyunie/eb2ae7b4-4e42-4cbe-ba27-0b4f2fac274a/small.jpg</picture_url>
          <person_id>pengyunie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marinela</first_name>
          <last_name>Parovic</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>marinelaparovic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhiqiang</first_name>
          <last_name>Zang</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>zhiqiangzang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sarfraz</first_name>
          <last_name>Khurshid</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/sarfrazkhurshid/b998e03f-4c99-458b-a9f9-b6c470511e3b/small.jpg</picture_url>
          <person_id>sarfrazkhurshid</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Aleksandar</first_name>
          <last_name>Milicevic</last_name>
          <affiliation>Microsoft, n.n.</affiliation>
          <bio>undefined</bio>
          <person_id>aleksandarmilicevic2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Milos</first_name>
          <last_name>Gligoric</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/milosgligoric/4d0671ae-937e-4f08-b499-092379ff7ad3/small.jpg</picture_url>
          <person_id>milosgligoric</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9fcceaf6-9558-4873-b928-347a33d84206</slot_id>
      <event_id>242d728b-7429-46a7-b7af-5fc2ae5830da</event_id>
      <title>Statically Verified Refinements for Multiparty Protocols</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description>With distributed computing becoming ubiquitous in the modern era, safe distributed programming is an open challenge. To address this, multiparty session types (MPST) provide a typing discipline for message-passing concurrency, guaranteeing communication safety properties such as deadlock freedom. 
While originally MPST focus on the communication aspects, and employ a simple typing system for communication payloads, communication protocols in the real world usually contain \emph{constraints} on the payload. We introduce \emph{refined multiparty session types (RMPST)}, an extension of MPST, that express data dependent protocols via \emph{refinement types} on the data types. 
We provide an implementation of RMPST, in a toolchain called Session*, using Scribble, a multiparty protocol description toolchain, and targeting F*, a verification-oriented functional programming language. Users can describe a protocol in Scribble and implement the endpoints in F* using \emph{refinement-typed} APIs generated from the protocol. The F* compiler can then statically verify the refinements. Moreover, we use a novel approach of callback-styled API generation, providing \emph{static} linearity guarantees with the inversion of control. We evaluate our approach with real world examples and show that it has little overhead compared to a naive implementation, while guaranteeing safety properties from the underlying theory.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fangyi</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/fangyizhou/c1ff2787-4ce8-45c7-a584-0cc8f627722c/small.jpg</picture_url>
          <person_id>fangyizhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Francisco</first_name>
          <last_name>Ferreira</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~fferre16/</homepage_url>
          <person_id>franciscoferreira1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Raymond</first_name>
          <last_name>Hu</last_name>
          <affiliation>University of Hertfordshire, UK</affiliation>
          <bio>undefined</bio>
          <person_id>raymondhu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rumyana</first_name>
          <last_name>Neykova</last_name>
          <affiliation>Brunel University London, UK</affiliation>
          <bio>Rumyana Neykova is a lecturer at Brunel University London, previously completed a PhD degree under the supervision of Prof. Nobuko Yoshida at Imperial College London, where she was also research fellow. Her research interests are in the area of distributed systems and networks, as well as type systems and language design. Her PhD focuses on development and applications of a type theory (called session types) for runtime verification of concurrent and distributed systems.</bio>
          <homepage_url>https://www.brunel.ac.uk/people/rumyana-neykova</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rumyananeykova/66457b0a-8e8b-471e-b278-37d7f4242bcb/small.jpg</picture_url>
          <person_id>rumyananeykova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b30c1eb2-a44a-4b88-a7dd-aa97e0ec473a</slot_id>
      <event_id>929402eb-9328-4a8b-8a75-cece307c4691</event_id>
      <title>Guiding Dynamic Programing via Structural Probability for Accelerating Programming by Example</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description>Programming by example (PBE) is an important subproblem of program synthesis and the techniques of PBE have been applied to many domains. Though many techniques for accelerating PBE systems have been explored, the scalability remains one of the main challenges: there is still a gap between the performances of state-of-the-art synthesizers and the industrial requirement. To further speed up solving PBE tasks, in this paper we propose a novel PBE framework MaxFlash, which uses the naturalness of programs to guide a search based on dynamic programming, such that the search will focus on subproblems that form more natural programs, and avoid unnatural programs. Our evaluation shows that MaxFlash achieves $\times 5.097- \times 2321$ speed-ups against state-of-the-art solvers on $244$ real-world tasks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ruyi</first_name>
          <last_name>Ji</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <person_id>ruyiji</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yican</first_name>
          <last_name>Sun</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <person_id>yicansun1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yingfei</first_name>
          <last_name>Xiong</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>Associate Professor</bio>
          <homepage_url>http://sei.pku.edu.cn/~xiongyf04/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yingfeixiong/18fb7368-4f14-462a-b038-9990eebb7a9c/small.jpg</picture_url>
          <person_id>yingfeixiong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhenjiang</first_name>
          <last_name>Hu</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sei.pku.edu.cn/~hu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhenjianghu/5d426480-5589-46be-b4f6-f98cf2acc80e/small.jpg</picture_url>
          <person_id>zhenjianghu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b45b043a-8fe6-444e-a16e-6a9c47a99f8f</slot_id>
      <event_id>6180c33e-cd3b-42a1-9d1c-7a789ca7072d</event_id>
      <title>Revisiting Iso-Recursive Subtyping</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description>The Amber rules are well-known and widely used for subtyping iso-recursive types. They were first briefly and informally introduced in 1985 by Cardelli in a manuscript describing the Amber language. Despite their use over many years, important aspects of the metatheory of the iso-recursive style Amber rules have not been studied in depth or turn out to be quite challenging to formalize. This paper aims to revisit the problem of subtyping iso-recursive types. We start by introducing a novel declarative specification that we believe captures the “spirit” of Amber-style iso-recursive subtyping. Informally, the specification states that two recursive types are subtypes \emph{if all their finite unfoldings are subtypes}. The Amber rules are shown to be sound with respect to this declarative specification. We then derive a \emph{sound}, \emph{complete} and \emph{decidable} algorithmic formulation of subtyping that employs a novel \emph{double unfolding} rule. Compared to the Amber rules, the double unfolding rule has the advantage of: 1) \emph{being modular}; 2) \emph{not requiring reflexivity} to be built in; and 3) leading to an \emph{easy proof of transitivity of subtyping}. This work sheds new insights on the theory of subtyping iso-recursive types, and the new double unfolding rule has important advantages over the original Amber rules for both implementations and metatheoretical studies involving recursive types. All results are mechanically formalized in the Coq theorem prover. Furthermore, as far as we know, this is the first comprehensive treatment of iso-recursive subtyping in a theorem prover, which can deal with \emph{unrestricted} recursive types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yaoda</first_name>
          <last_name>Zhou</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <person_id>yaodazhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jinxu</first_name>
          <last_name>Zhao</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <person_id>jinxuzhao</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b70d878b-9c60-446a-a981-7a1ad51ca964</slot_id>
      <event_id>e544c068-9f0c-4363-ba0b-f43ffe949ce2</event_id>
      <title>Macros For Domain-Specific Languages</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description>Macros provide a powerful means of extending languages. They have proven useful in both general-purpose and domain-specific programming contexts. This paper presents an architecture for implementing macro-extensible DSLs on top of macro-extensible host languages. The macro expanders of these DSLs inherit the syntax system, hygienic expansion, and more from the host. They transform the extensible DSL syntax into a DSL core language. This arrangement has several important consequences. It becomes straightforward to integrate the syntax of various DSLs and the host language when their expanders share these inherited components. Also, a DSL compiler can rely on a fixed core language for compilation, even for an extensible DSL. Finally, macros empower programmers to safely grow DSLs on their own and tailor them to their needs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Ballantyne</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>Michael Ballantyne is a PhD student at the Northeastern University Programming Research Laboratory, advised by Matthias Felleisen. He envisions a future where mainstream programmers regularly create, extend, and fluidly intermix domain-specific languages, with excellent support from their programming language and environment. Recently he’s been developing a formal characterization of macro hygiene that accounts for the full range of program transformations used in embedded DSL implementation, and also improving the type systems as macros approach to integrate macro expansion and typechecking.</bio>
          <homepage_url>http://mballantyne.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelballantyne/0fb0042c-454e-437b-938c-bd6fb195d0cb/small.jpg</picture_url>
          <person_id>michaelballantyne</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexis</first_name>
          <last_name>King</last_name>
          <affiliation>Northwestern University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexisking/4d4403cc-a825-40f3-a69d-089d8403e71a/small.jpg</picture_url>
          <person_id>alexisking</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Felleisen</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/matthias/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthiasfelleisen/3781509a-02f7-4e22-822d-04481501e833/small.jpg</picture_url>
          <person_id>matthiasfelleisen</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c68f6394-b967-4b3a-a0af-f3164f3352e8</slot_id>
      <event_id>dc63a9f0-ab34-41e2-a618-62f4112a139f</event_id>
      <title>CompCertELF: Verified Separate Compilation of C Programs into ELF Object Files</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description>We present CompCertELF, the first extension to CompCert that supports verified compilation from C programs all the way to a standard binary file format, i.e., the ELF object format. Previous work on Stack-Aware CompCert provides a verified compilation chain from C programs to assembly programs with a realistic machine memory model. We build CompCertELF by modifying and extending this compilation chain with a verified assembler which further transforms assembly programs into ELF object files. 
CompCert supports large-scale verification via verified separate compilation: C modules can be written and compiled separately, and then linked together to get a target program that refines the semantics of the program linked from the source modules. However, verified separate compilation in CompCert only works for compilation to assembly programs, not to object files. For the latter, the main difficulty is to bridge the two different views of linking: one for CompCert’s programs that allows arbitrary shuffling of global definitions by linking and the other for ELF object files that treats blocks of encoded definitions as unanalyzable and indivisible units. 
We propose a lightweight approach that solves the above problem without any modification to CompCert’s framework for verified separate compilation: by introducing a notion of syntactical equivalence between programs and proving the commutativity between syntactical equivalence and the two different kinds of linking, we are able to transit from the more abstract linking operation in CompCert to the more concrete one for ELF object files. By applying this approach to CompCertELF, we obtain the first compiler that supports verified separate compilation of C programs into ELF object files.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuting</first_name>
          <last_name>Wang</last_name>
          <affiliation>Shanghai Jiao Tong University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jhc.sjtu.edu.cn/~yutingwang/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yutingwang/963979f5-1f61-418e-9435-0abbb408ef37/small.jpg</picture_url>
          <person_id>yutingwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xiangzhe</first_name>
          <last_name>Xu</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <person_id>xiangzhexu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pierre</first_name>
          <last_name>WILKE</last_name>
          <affiliation>CentraleSupélec, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pwilke.fr/pwilke-en.html</homepage_url>
          <person_id>pierrewilke1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhong</first_name>
          <last_name>Shao</last_name>
          <affiliation>Yale University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/shao/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhongshao/18a2973a-020f-46ed-9073-85bd70626116/small.jpg</picture_url>
          <person_id>zhongshao</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d196c8b6-b0b1-4c4c-b0f6-8c46c268a916</slot_id>
      <event_id>af83d347-a934-48f4-a73a-35f960446055</event_id>
      <title>Certified and Efficient Instruction Scheduling</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description>CompCert is a moderately optimizing C compiler with a formal, machine-checked, proof of correctness: after successful compilation, the assembly code has a behavior faithful to the source code. Previously, it only supported target instruction sets with sequential semantics, and did not attempt reordering instructions for optimization. 
We present here a CompCert backend for a VLIW core (i.e., with explicit parallelism at the instruction level), the first CompCert backend providing scalable and efficient instruction scheduling. Furthermore, its highly modular implementation can be easily adapted to other VLIW or non-VLIW pipelined processors.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sylvain</first_name>
          <last_name>Boulmé</last_name>
          <affiliation>Grenoble Alps University, France / CNRS, France / Grenoble INP, France / VERIMAG, France</affiliation>
          <bio>undefined</bio>
          <person_id>sylvainboulme</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Cyril</first_name>
          <last_name>Six</last_name>
          <affiliation>Kalray, France / Grenoble Alps University, France / CNRS, France / Grenoble INP, France / VERIMAG, France</affiliation>
          <bio>undefined</bio>
          <person_id>cyrilsix</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Monniaux</last_name>
          <affiliation>Grenoble Alps University, France / CNRS, France / Grenoble INP, France / VERIMAG, France</affiliation>
          <bio>David Monniaux obtained his PhD in 2001 in Paris under Prof Patrick Cousot; his dissertation was on the static analysis of probabilistic programs by abstract interpretation. He then joined CNRS as a junior researcher and first worked on the Astrée static analyzer, still in Paris. In 2007 he transferred to VERIMAG in Grenoble, where he works on various aspects of program verification (decision procedures, abstract interpretation…). 
He now is a senior researcher at CNRS and an adjunct professor at École polytechnique.</bio>
          <homepage_url>http://www-verimag.imag.fr/~monniaux/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidmonniaux/d285baca-8e32-4918-b3c6-c724e98fc7b3/small.jpg</picture_url>
          <person_id>davidmonniaux</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d8bd5703-567d-4b04-8226-d9299e3c23ae</slot_id>
      <event_id>0efaef5b-077a-4a01-b9f2-f5e784b674ef</event_id>
      <title>Resolution as Intersection Subtyping via Modus Ponens</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description>Resolution and subtyping are two common mechanisms in programming languages. Resolution is used by features such as type classes or Scala-style implicits to synthesize values automatically from contextual type information. Subtyping is commonly used to automatically convert the type of a value into another compatible type. So far the two mechanisms have been considered independently of each other. This paper shows that, with a small extension, subtyping with intersection types can subsume resolution. This has three main consequences. Firstly, resolution does not need to be implemented as a separate mechanism. Secondly, the interaction between resolution and subtyping becomes apparent. Finally, the integration of resolution into subtyping enables first-class (implicit) environments. The extension that recovers the power of resolution via subtyping is the modus ponens rule of propositional logic. While it is easily added to declarative subtyping, significant care needs to be taken to retain desirable properties, such as transitivity and decidability of algorithmic subtyping, and coherence. To materialize these ideas we develop λ_MP, a calculus that extends a previous calculus with disjoint intersection types, and develop its metatheory in the Coq theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Klara</first_name>
          <last_name>Mardirosian</last_name>
          <affiliation>KU Leuven, Belgium</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/klaramardirosian/15cf04a1-de90-4f6d-b88d-cd1a230da0e4/small.jpg</picture_url>
          <person_id>klaramardirosian</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Georgios</first_name>
          <last_name>Karachalias</last_name>
          <affiliation>Tweag I/O, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://gkaracha.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/georgekarachalias/cb10a8f5-6b72-4883-aef0-c9978070378a/small.jpg</picture_url>
          <person_id>georgekarachalias</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>db214e57-35b3-4e66-80df-8b27f839cc29</slot_id>
      <event_id>e5ecd345-1255-4cc9-9519-5f9f7c17c472</event_id>
      <title>Precise Inference of Expressive Units of Measurement Types</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description>Ensuring computations are unit-wise consistent is an important task in software development. Numeric computations are usually performed with primitive types instead of abstract data types, which results in very weak static guarantees about correct usage and conversion of units. This paper presents PUnits, a pluggable type system for expressive units of measurement types and a precise, whole-program inference approach for these types. PUnits can be used in three modes: (1) modularly check the correctness of a program, (2) ensure a possible unit typing exist, (3) annotate a program with units. Annotation mode allows human inspection and is essential since having a valid typing does not guarantee that the inferred specification expresses design intent. PUnits is the first units type system with this capability. Compared to prior work, PUnits strikes a novel balance between expressiveness, inference complexity, and annotation effort. We implement PUnits for Java and evaluate it by specifying the correct usage of frequently used JDK methods. We analyzed 234k lines of code from eight open-source scientific computing projects with PUnits, which inferred 87 scientific units and generated well-specified applications. The experiments show that PUnits provides an effective, sound, and scalable alternative to using encapsulation-based units APIs (like javax.measure), enabling Java developers to reap the performance benefits of using primitive types instead of abstract data types for unit-wise consistent scientific computations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tongtong</first_name>
          <last_name>Xiang</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>tongtongxiang1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jeff Y.</first_name>
          <last_name>Luo</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>jeffluo1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Werner</first_name>
          <last_name>Dietl</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ece.uwaterloo.ca/~wdietl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/wernerdietl/f6ddc3ef-7134-4260-a182-a71ed88842cb/small.jpg</picture_url>
          <person_id>wernerdietl</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f4060e57-3ae5-4dbd-931c-3074f7151d55</slot_id>
      <event_id>eae9a815-c985-40c1-9208-cd4565b52e3d</event_id>
      <title>Guided Linking: Dynamic Linking Without the Costs</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description>Dynamic linking is extremely common in modern software systems, thanks to the flexibility and space savings it offers. However, this flexibility comes at a cost: every library call has an extra layer of indirection, and it’s impossible to perform interprocedural optimizations that involve calls to a dynamic library. The basic problem is that the run-time behavior of the dynamic linker can’t be predicted at compile time, so the compiler can make no assumptions about how external calls will behave. 
This paper introduces guided linking, a technique for optimizing dynamically linked software when some information about the dynamic linker’s behavior is known in advance. The developer provides an arbitrary set of programs, libraries, and plugins to our tool, along with constraints that limit the possible dynamic linking behavior of the software. Given a software set and a list of constraints, our tool takes advantage of the constraints to optimize the software for speed and size. For example, the “no dynamic redefinitions” constraint can be applied to a function when the developer knows the function will never be unexpectedly overridden with a different definition at run time; this constraint allows dynamic references between libraries in the set to be resolved to static references, which can then be optimized with standard link-time optimizations. As an additional optimization, we deduplicate identical functions that appear anywhere in the software set. 
By applying guided linking to a dynamically linked distribution of Clang and LLVM, and using the constraint that no other software will use the LLVM libraries, we can increase speed by 6% and reduce file size by 11%. If we relax the constraint to allow other software to use the LLVM libraries, we can still increase speed by 5.5% and reduce file size by 3%. If we apply guided linking to the Python interpreter and a set of loadable Python modules, applying the constraint that no other programs or modules will be used, we can increase speed by an average of 6.6%. If we use guided linking to combine 11 different versions of the Boost library, applying minimal constraints, we can reduce the total library size by 57%.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sean</first_name>
          <last_name>Bartell</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <person_id>seanbartell</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Will</first_name>
          <last_name>Dietz</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wdtz.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/willdietz/f5b6948e-d200-44b1-ba05-8d21549414f8/small.jpg</picture_url>
          <person_id>willdietz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Vikram S.</first_name>
          <last_name>Adve</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>Vikram Adve is the Donald B. Gillies Professor of Computer Science at the University of Illinois at Urbana-Champaign and a Professor in Electrical and Computer Engineering. He is a Co-founder and Co-Director of the Center for Digital Agriculture and leads AIFARMS, a $20M National Artificial Intelligence Research Institute funded by NIFA and NSF. Adve’s research interests lie in developing and using compiler techniques to improve the performance, programmability and reliability of computer systems. Adve and his Ph.D. student, Chris Lattner, co-designed the LLVM Compiler Infrastructure, which enables a novel approach to “lifelong compilation” of programs in a wide range of general-purpose programming languages. For example, most mobile apps for the iPhone, iPad, Apple Watch and Apple TV are shipped by developers to Apple in the LLVM compiler representation called “LLVM bitcode” and then compiled and specialized for the various end-user devices. LLVM is widely used in industry today, ranging from mobile devices (e.g., iOS and Android) to supercomputers (e.g., at NVIDIA, Cray, IBM and Intel) to data centers (e.g., at Google). Adve, Lattner and Evan Cheng received the ACM Software System Award in 2012 for co-developing LLVM. Adve has won a ten-year-retrospective Most Influential Paper award at CGO 2004, and distinguished paper awards at several conferences including PLDI 2005, SOSP 2007 and ICSE 2011. He has served as the Associate Editor for the ACM Transactions on Programming Languages and Systems, and co-chaired the Program Committees for ASPLOS 2010, VEE 2008, and LCPC 2007. One of Adve’s Ph.D. students, Robert Bocchino, won the 2010 ACM SIGPLAN Outstanding Dissertation Award and another student, John Criswell, won Honorable Mentions for both the 2014 ACM SIGOPS Dissertation Award and the 2014 ACM Doctoral Dissertation Award. Adve is a Fellow of the ACM and was named a University Scholar at the University of Illinois in 2015. He served as Interim Head of the Computer Science Department from 2017 to 2019.</bio>
          <homepage_url>http://vikram.cs.illinois.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vikramadve/a99a9248-20e3-4738-9200-173c353c5fcb/small.jpg</picture_url>
          <person_id>vikramadve</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fcd99f2f-d792-47c8-b866-0c81a8cd8cb6</slot_id>
      <event_id>bda72afd-3a6a-4812-8ecd-1d6b77c646ce</event_id>
      <title>Scaling Exact Inference for Discrete Probabilistic Programs</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description>Probabilistic programming languages (PPLs) are an expressive means of representing and reasoning about probabilistic models. The computational challenge of probabilistic inference remains the primary roadblock for applying PPLs in practice. Inference is fundamentally hard, so there is no one-size-fits all solution. In this work, we target scalable inference for an important class of probabilistic programs: those whose probability distributions are discrete. Discrete distributions are common in many fields, including text analysis, network verification, artificial intelligence, and graph analysis, but they prove to be challenging for existing PPLs. 
We develop a domain-specific probabilistic programming language called Dice that features a new approach to exact discrete probabilistic program inference. Dice exploits program structure in order to factorize inference, enabling us to perform exact inference on probabilistic programs with hundreds of thousands of random variables. Our key technical contribution is a new reduction from discrete probabilistic programs to weighted model counting (WMC). This reduction separates the structure of the distribution from its parameters, enabling logical reasoning tools to exploit that structure for probabilistic inference. We (1) show how to compositionally reduce Dice inference to WMC, (2) prove this compilation correct with respect to a denotational semantics, (3) empirically demonstrate the performance benefits over prior approaches, and (4) analyze the types of structure that allow Dice to scale to large probabilistic programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Steven</first_name>
          <last_name>Holtzen</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am a PhD. student at U.C.L.A., co-advised by Guy Van den Broeck and Todd Millstein.</bio>
          <homepage_url>http://web.cs.ucla.edu/~sholtzen</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stevenholtzen/db2263a6-7a88-4167-9d73-86a4d4b97fc9/small.jpg</picture_url>
          <person_id>stevenholtzen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guy</first_name>
          <last_name>Van den Broeck</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am an Associate Professor and Samueli Fellow at UCLA, in the Computer Science Department. My research interests are in Machine Learning (Statistical Relational Learning), Knowledge Representation and Reasoning (Graphical Models, Lifted Probabilistic Inference), Applications of Probabilistic Reasoning and Learning (Probabilistic Programming, Probabilistic Databases), and Artificial Intelligence in general. I previously was a postdoctoral researcher at UCLA’s Automated Reasoning lab and KU Leuven’s Declarative Languages and Artificial Intelligence lab.</bio>
          <homepage_url>http://web.cs.ucla.edu/~guyvdb/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guyvandenbroeck/4c8a474f-a124-4434-a370-43b4892bbe2c/small.jpg</picture_url>
          <person_id>guyvandenbroeck</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Todd</first_name>
          <last_name>Millstein</last_name>
          <affiliation>University of California, Los Angeles</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.cs.ucla.edu/~todd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/toddmillstein1/a55642b6-6fa2-40f6-99ba-8b9003ee61d9/small.jpg</picture_url>
          <person_id>toddmillstein1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d9e55313-d653-4316-b2c6-4567e06ef67b</subevent_id>
    <title>SPLASH Posters: Lunch in Tokyo</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot>
      <slot_id>592fed09-55b7-4db0-a6ca-a5564f7a469b</slot_id>
      <title>Session: SPLASH Posters - Lunch in Tokyo</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_time>23:00</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>54740de7-ac57-4272-92b4-196c45bd1e25</slot_id>
      <event_id>e75966a6-7f3d-4bbb-8ad0-e933f61183f2</event_id>
      <title>Posters Session 2</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description> 
  A Sparse Iteration Space Transformation Framework for Sparse Tensor Algebra. Ryan Senanayake, Changwan Hong, Ziheng Wang, Amalee Wilson, Stephen Chou, Shoaib Kamil, Saman Amarasinghe, and Fredrik Kjolstad  
  Certified and Efficient Instruction Scheduling. Cyril Six, Sylvain Boulmé, and David Monniaux  
  CompCertELF: Verified Separate Compilation of C Programs into ELF Object Files. Yuting Wang, Xiangzhe Xu, Pierre Wilke, and Zhong Shao  
  Guided Linking: Dynamic Linking without the Costs. Sean Bartell, Will Dietz, and Vikram S. Adve  
  Guiding Dynamic Programing via Structural Probability for Accelerating Programming by Example. Ruyi Ji, Yican Sun, Yingfei Xiong, and Zhenjiang Hu  
  Incremental Predicate Analysis for Regression Verification. Qianshan Yu, Fei He, and Bow-Yaw Wang  
  Learning Semantic Program Embeddings with Graph Interval Neural Network. Yu Wang, Ke Wang, Fengjuan Gao, and Linzhang Wang  
  Macros for Domain-Specific Languages. Michael Ballantyne, Alexis King, and Matthias Felleisen  
  Precise Inference of Expressive Units of Measurement Types. Tongtong Xiang, Jeff Y. Luo, and Werner Dietl  
  Resolution as Intersection Subtyping via Modus Ponens. Koar Marntirosian, Tom Schrijvers, Bruno C. d. S. Oliveira, and Georgios Karachalias  
  Revisiting Iso-Recursive Subtyping. Yaoda Zhou, Bruno C. d. S. Oliveira, and Jinxu Zhao  
  SATUNE: Synthesizing Efficient SAT Encoders. Hamed Gorjiara, Harry Xu ,and Brian Demsky  
  Scaling Exact Inference for Discrete Probabilistic Programs. Steven Holtzen and Guy Van den Broeck, and Todd Millstein  
  Statically Verified Refinements for Multiparty Protocols. Fangyi Zhou, Francisco Ferreira, Raymond Hu, Rumyana Neykova, and Nobuko Yoshida  
  StreamQL: A Query Language for Processing Streaming Time Series. Lingkun Kong and Konstantinos Mamouras  
  Towards a Formal Foundation of Intermittent Computing. Milijana Surbatovich, Brandon Lucia, and Limin Jia  
  Unifying Execution of Imperative Generators and Declarative Specifications. Pengyu Nie, Marinela Parovic, Zhiqiang Zang, Sarfraz Khurshid, Aleksandar Milicevic, and Milos Gligoric  
</description>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>42d7d32b-8974-420b-9251-f41a3adc7127</subevent_id>
    <title>SPLASH Posters: Posters Session 1</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-VII</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot>
      <slot_id>e14e14d6-4674-48de-aa1c-e8641fe18237</slot_id>
      <title>Session: SPLASH Posters - Posters Session 1</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0620ba26-d094-416b-8b58-f9f8b62e5187</slot_id>
      <event_id>aeb95fc0-4c63-4e89-886e-631404993ed1</event_id>
      <title>Formulog: Datalog for SMT-based Static Analysis</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:00</end_time>
      <description>Satisfiability modulo theories (SMT) solving has become a critical part of many static analyses, including symbolic execution, refinement type checking, and model checking. We propose Formulog, a domain-specific language that makes it possible to write a range of SMT-based static analyses in a way that is both close to their formal specifications and amenable to high-level optimizations and efficient evaluation. 
Formulog extends the logic programming language Datalog with a first-order functional language and mechanisms for representing and reasoning about SMT formulas; a novel type system supports the construction of expressive formulas, while ensuring that neither normal evaluation nor SMT solving goes wrong. Our case studies demonstrate that a range of SMT-based analyses can naturally and concisely be encoded in Formulog, and that — thanks to this encoding — high-level Datalog-style optimizations can be automatically and advantageously applied to these analyses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Bembenek</last_name>
          <affiliation>Harvard University, USA</affiliation>
          <bio>Aaron Bembenek is currently a computer science PhD candidate at Harvard University working under Stephen Chong. He previously earned an undergraduate degree in classics from Princeton University.</bio>
          <homepage_url>http://people.seas.harvard.edu/~bembenek/index.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aaronbembenek/def526d3-8049-43ee-a891-2437ec903da6/small.jpg</picture_url>
          <person_id>aaronbembenek</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Greenberg</last_name>
          <affiliation>Pomona College, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.pomona.edu/~michael/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
          <person_id>michaelgreenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chong</last_name>
          <affiliation>Harvard University, USA</affiliation>
          <bio>Stephen Chong is a Gordon McKay Professor of Computer Science in the Harvard John A. Paulson School of Engineering and Applied Sciences. Steve’s research focuses on programming languages, information security, and the intersection of these two areas. He is the recipient of an NSF CAREER award, an AFOSR Young Investigator award, and a Sloan Research Fellowship. He received a PhD from Cornell University, and a bachelor’s degree from Victoria University of Wellington, New Zealand.</bio>
          <homepage_url>https://people.seas.harvard.edu/~chong/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stephenchong/91e43651-bcd6-40dc-b231-4c92711b0e95/small.jpg</picture_url>
          <person_id>stephenchong</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>084c552f-7724-4396-9ebf-2b3cf60c33d4</slot_id>
      <event_id>c3aed59f-f991-4edf-b2c5-502e961b1d09</event_id>
      <title>Analogy-Making as a Core Primitive in the Software Engineering Toolbox</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:00</end_time>
      <description>An analogy is an identification of structural similarities and correspondences between two objects. Computational models of analogy making have been studied extensively in the field of cognitive science to better understand high-level human cognition. For instance, Melanie Mitchell and Douglas Hofstadter sought to better understand high-level perception by developing the Copycat algorithm for completing analogies between letter sequences. In this paper, we argue that analogy making should be seen as a core primitive in software engineering. We motivate this argument by showing how complex software engineering problems such as program understanding and source-code transformation learning can be reduced to an instance of the analogy-making problem. We demonstrate this idea using Sifter, a new analogy-making algorithm suitable for software engineering applications that adapts and extends ideas from Copycat. In particular, Sifter reduces analogy-making to searching for a sequence of update rule applications. Sifter uses a novel representation for mathematical structures capable of effectively representing the wide variety of information embedded in software. We conclude by listing major areas of future work for Sifter and analogy-making in software engineering.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Sotoudeh</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://masot.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthewsotoudeh/32b819f5-05ef-4b0a-8a19-d59eed661278/small.jpg</picture_url>
          <person_id>matthewsotoudeh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aditya V.</first_name>
          <last_name>Thakur</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://thakur.cs.ucdavis.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adityavthakur/89eb0287-7273-4261-b8a5-47ccfc8799b0/small.jpg</picture_url>
          <person_id>adityavthakur</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0d11cdaf-b33f-4359-a213-36790935d673</slot_id>
      <event_id>99de77d9-920e-40fb-a2a8-dfe5011da1fe</event_id>
      <title>Row and Bounded Polymorphism via Disjoint Polymorphism</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:00</end_time>
      <description>Polymorphism and subtyping are important features in mainstream OO languages. The most common way to integrate the two is via F&amp;lt;: style bounded quantification. A closely related mechanism is row polymorphism, which provides an alternative to subtyping, while still enabling many of the same applications. Yet another approach is to have type systems with intersection types and polymorphism. A recent addition to this design space are calculi with disjoint intersection types and disjoint polymorphism. With all these alternatives it is natural to wonder how they are related. 
This paper provides an answer to this question. We show that disjoint polymorphism can recover forms of both row polymorphism and bounded polymorphism, while retaining key desirable properties, such as type-safety and decidability. Furthermore, we identify the extra power of disjoint polymorphism which enables additional features that cannot be easily encoded in calculi with row polymorphism or bounded quantification alone. Ultimately we expect that our work is useful to inform language designers about the expressive power of those common features, and to simplify implementations and metatheory of feature-rich languages with polymorphism and subtyping.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ningning</first_name>
          <last_name>Xie</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://xnning.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ningningxie/99787204-daa9-484a-bea5-4b2b88551687/small.jpg</picture_url>
          <person_id>ningningxie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xuan</first_name>
          <last_name>Bi</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <person_id>xuanbi1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2c7015fd-d5aa-4d60-8f13-73ec12666edb</slot_id>
      <event_id>9c6add07-d7ab-47f4-b15b-e12b936f5fd7</event_id>
      <title>Gradual Verification of Recursive Heap Data Structures</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:00</end_time>
      <description>Current static verification techniques do not provide good support for incrementality, making it difficult for developers to focus their limited effort on specifying and verifying the properties and components that are most important. Dynamic verification approaches support incrementality, but cannot provide static guarantees. To bridge this gap, prior work proposed gradual verification, which supports incrementality by allowing every assertion to be complete, partial, or omitted, and provides sound verification that smoothly scales from dynamic to static checking. The prior approach to gradual verification, however, was limited to toy programs without recursive data structures. This paper extends gradual verification to realistic programs that manipulate recursive, mutable data structures on the heap. We solve key technical challenges, semantically connecting iso- and equi-recursive interpretations of abstract predicates as well as gradual verification of heap ownership. Our work thus lays the foundation for future tools that work on realistic programs and support verification within an engineering process in which cost-benefit trade-offs can be made.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jenna</first_name>
          <last_name>Wise</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jlwise/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jennawise/614a00d0-d8ab-4b2f-8ec7-96abcb5c3d5b/small.jpg</picture_url>
          <person_id>jennawise</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Johannes</first_name>
          <last_name>Bader</last_name>
          <affiliation>Jane Street</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.johannes-bader.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johannesbader/0b7e635c-fba7-4113-a53d-4451edd44ca5/small.jpg</picture_url>
          <person_id>johannesbader</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Cameron</first_name>
          <last_name>Wong</last_name>
          <affiliation>Jane Street</affiliation>
          <bio>Wannabe type theorist.</bio>
          <homepage_url>https://camdar.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cameronwong/1e4412d3-e79b-4f6a-8465-6b756986e1d0/small.jpg</picture_url>
          <person_id>cameronwong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile, Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
          <person_id>etanter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Sunshine</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jssunshi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joshuasunshine/474067e5-86e8-476c-9622-5c89be145f4b/small.jpg</picture_url>
          <person_id>joshuasunshine</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>423384ea-7584-452e-9b71-fefd0cabc1a3</slot_id>
      <event_id>88a7fb9c-c6d8-4976-ab8e-554ac4921725</event_id>
      <title>Owicki-Gries Reasoning for C11 RAR</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:00</end_time>
      <description>Owicki-Gries reasoning for concurrent programs uses Hoare logic together with an interference freedom rule for concurrency. In this paper, we develop a new proof calculus for the C11 RAR memory model (a fragment of C11 with both relaxed and release-acquire accesses) that allows all Owicki-Gries proof rules for compound statements, including non-interference, to remain unchanged. Our proof method features novel assertions specifying thread-specific views on the state of programs. This is combined with a set of Hoare logic rules that describe how these assertions are affected by atomic program steps. We demonstrate the utility of our proof calculus by verifying a number of standard C11 litmus tests and Peterson’s algorithm adapted for C11. Our proof calculus and its application to program verification have been fully mechanised in the theorem prover</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sadegh</first_name>
          <last_name>Dalvandi</last_name>
          <affiliation>University of Surrey</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dalvandi.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mohammadsadeghdalvandi/c22dc5e6-1b7d-4d4b-bc5d-0c19608c2c89/small.jpg</picture_url>
          <person_id>mohammadsadeghdalvandi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Doherty</last_name>
          <affiliation>University of Sheffield</affiliation>
          <bio>undefined</bio>
          <person_id>simondoherty</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brijesh</first_name>
          <last_name>Dongol</last_name>
          <affiliation>University of Surrey</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/brijeshdongol/1a40f0ae-7a59-4232-b09e-a69a66272c0f/small.jpg</picture_url>
          <person_id>brijeshdongol</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Heike</first_name>
          <last_name>Wehrheim</last_name>
          <affiliation>Paderborn University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.uni-paderborn.de/en/person/573/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/heikewehrheim/77537d51-60d9-4a1d-8187-78047b1f330c/small.jpg</picture_url>
          <person_id>heikewehrheim</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>52834d51-0c77-47d2-9da0-97c0732403b9</slot_id>
      <event_id>810a4501-575d-45e8-92bd-d7c7a3cde3ba</event_id>
      <title>Demystifying Dependence</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:00</end_time>
      <description>Programmers are told “depend on interfaces, not implementations.” But, given a program, is it possible even to assess objectively whether such advice has been followed? 
Programmers frequently talk in ways like this about dependence, but the very term, like many used in software engineering, has hitherto eluded precise definition. In this work, we resolve a variety of confusions about dependence, and present a formal definition unifying multiple varieties of software dependence, grounded in Halpern and Pearl’s theory of actual causation. This definition is parameterized by the formal system characterizing the property of interest, and by constraints on “reasonable changes” to the program. By picking different choices of formal system, one can specialize our definition to characterize dynamic dependence (slicing), static dependence (correctness), and dependence of performance properties. Overall, our work provides a path to making conversations about software dependence fully objective, and might serve as a basis for future work automatically checking forms of dependence which were previously too abstract or high-level to be candidates for tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>James</first_name>
          <last_name>Koppel</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>www.jameskoppel.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jameskoppel/285bb202-88a1-4b77-bf13-bd39911247ef/small.jpg</picture_url>
          <person_id>jameskoppel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Jackson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/dnj/</homepage_url>
          <person_id>danieljackson</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5b4de742-36b8-41bd-93b3-dbfe7f14cd6a</slot_id>
      <event_id>e02523f3-98c1-467e-8542-8216dc5523b7</event_id>
      <title>Can Advanced Type Systems Be Usable? An Empirical Study of Ownership, Assets, and Typestate in Obsidian</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:00</end_time>
      <description>Some blockchain programs (smart contracts) have included serious security vulnerabilities. Obsidian is a new typestate-oriented programming language that uses a strong type system to rule out some of these vulnerabilities. Although Obsidian was designed to promote usability to make it as easy as possible to write programs, strong type systems can cause a language to be difficult to use. In particular, ownership, typestate, and assets, which Obsidian uses to provide safety guarantees, have not seen broad adoption in popular languages and result in significant usability challenges. We performed an empirical study with 20 participants comparing Obsidian to Solidity, which is the language most commonly used for writing smart contracts today. We observed that Obsidian participants were able to successfully complete more of the programming tasks than the Solidity participants. We also found that asset-related bugs, which Obsidian detects at compile time, were commonly accidentally inserted by the Solidity participants.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Coblenz</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umd.edu/~mcoblenz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelcoblenz/aa74b306-529b-44d4-987f-a5e4fd6d3ca2/small.jpg</picture_url>
          <person_id>michaelcoblenz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brad</first_name>
          <last_name>Myers</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~bam/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/bradmyers/7d93ede9-5674-40e8-9ba5-f9dfab4873e1/small.jpg</picture_url>
          <person_id>bradmyers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Sunshine</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jssunshi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joshuasunshine/474067e5-86e8-476c-9622-5c89be145f4b/small.jpg</picture_url>
          <person_id>joshuasunshine</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>74c90b72-b935-4502-8213-32db44379d0a</slot_id>
      <event_id>9fdddded-43c7-4b9e-add3-f53efe3421be</event_id>
      <title>Multiparty Session Programming with Global Protocol Combinators</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:00</end_time>
      <description>Multiparty Session Types (MPST) is a typing discipline for communication protocols. It ensures the absence of communication errors and deadlocks for well-typed communicating processes. The state of the art implementations of the MPST theory rely on (1) runtime linearity checks to ensure correct usage of communication channels and (2) external domain-specific languages for specifying and verifying of multiparty protocols. 
To overcome these limitations, we propose a library for programming with global combinators – a set of functions for writing and verifying multiparty protocols in OCaml. Local behaviours for all processes in a protocol are inferred at once from a global combinator. We formalise global combinators and prove a sound realisability of global combinators – a well-typed global combinator derives a set of local types, by which typed endpoint programs can ensure type and communication safety. Our approach enables fully-static verification and implementation of the whole protocol, from the protocol specification to the process implementations, to happen in the same language. 
We compare our implementation to untyped and continuation-passing style implementations, and demonstrate its expressiveness by implementing a plethora of protocols. We show our library can interoperate with existing libraries and services, implementing DNS (Domain Name Service) protocol and the OAuth (Open Authentication) protocol.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Keigo</first_name>
          <last_name>Imai</last_name>
          <affiliation>Gifu University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/keigoimai/70b0be2a-fa97-45a6-a037-57682ad05bf9/small.jpg</picture_url>
          <person_id>keigoimai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rumyana</first_name>
          <last_name>Neykova</last_name>
          <affiliation>Brunel University London, UK</affiliation>
          <bio>Rumyana Neykova is a lecturer at Brunel University London, previously completed a PhD degree under the supervision of Prof. Nobuko Yoshida at Imperial College London, where she was also research fellow. Her research interests are in the area of distributed systems and networks, as well as type systems and language design. Her PhD focuses on development and applications of a type theory (called session types) for runtime verification of concurrent and distributed systems.</bio>
          <homepage_url>https://www.brunel.ac.uk/people/rumyana-neykova</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rumyananeykova/66457b0a-8e8b-471e-b278-37d7f4242bcb/small.jpg</picture_url>
          <person_id>rumyananeykova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Shoji</first_name>
          <last_name>Yuen</last_name>
          <affiliation>Nagoya University</affiliation>
          <bio>undefined</bio>
          <person_id>shojiyuen</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>803ec537-a03e-498b-aa59-99584e44cbbb</slot_id>
      <event_id>9e0ae049-b867-4cd1-9715-da33fb9ef501</event_id>
      <title>Static Race Detection and Mutex Safety and Liveness for Go Programs</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:00</end_time>
      <description>Go is a popular concurrent programming language thanks to its ability to efficiently combine concurrency and systems programming. In Go programs, a number of concurrency bugs can be caused by a mixture of data races and communication problems. In this paper, we develop a theory based on behavioural types to statically detect data races and deadlocks in Go programs. We first specify lock safety/liveness and data race properties over a Go program model, using the happens-before relation defined in the Go memory model. We represent these properties of programs in a µ-calculus model of types, and validate them using type-level model-checking. We then extend the framework to account for Go’s channels, and implement a static verification tool which can detect concurrency errors. This is, to the best of our knowledge, the first static verification framework of this kind for the Go language, uniformly analysing concurrency errors caused by a mix of shared memory accesses and asynchronous message-passing communications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julia</first_name>
          <last_name>Gabet</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <person_id>juliagabet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>82308a8f-0f9e-448d-ba3c-989350c92126</slot_id>
      <event_id>52887fc8-e85e-4aa3-a067-3b109a7bc852</event_id>
      <title>CAMP: Cost-Aware Multiparty Session Protocols</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:00</end_time>
      <description>This paper presents CAMP, a new static performance analysis framework for message-passing concurrent and distributed systems, based on the theory of multiparty session types (MPST). Understanding the run-time performance of concurrent and distributed systems is of great importance for the identification of bottlenecks and optimisation opportunities. In the message-passing setting, these bottlenecks are generally communication overheads and synchronisation times. Despite its importance, reasoning about these intensional properties of software, such as performance, has received little attention, compared to verifying extensional properties, such as correctness. Behavioural protocol specifications based on sessions types capture not only extensional, but also intensional properties of concurrent and distributed systems. CAMP augments MPST with annotations of communication latency and local computation cost, defined as estimated execution times, that we use to extract cost equations from protocol descriptions. CAMP is also extendable to analyse asynchronous communication optimisation built on a recent advance of session type theories. We apply our tool to different existing benchmarks and usecases in the literature with a wide range of communication protocols, implemented in C, MPI-C, Java, Go and OCaml. Our benchmarks show that, in most of the cases, we predict an upper-bound on the real execution costs with &amp;lt; 15 % error.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Castro</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <person_id>davidcastro</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>846dc281-a616-4961-9fcf-0d8fc26d722d</slot_id>
      <event_id>c85e8b32-d0e7-45bc-ad8d-614d19ed58e0</event_id>
      <title>A Case Study in Language-Based Security: Building an I/O Library for Wyvern</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:00</end_time>
      <description>As the impact of vulnerabilities increases in practice, it is imperative for programming languages to include security as a first-class design consideration. While a number of security-related language features have been proposed to address this need, in many cases, we do not know enough about whether it is practical and useful to build software systems in languages with these features. 
In this paper, we begin to investigate this question, using a case study methodology. The setting of our case study is Wyvern, a recently designed language we selected because it incorporates three advanced security-related features: capability safety for enforcing the principle of least privilege, an effect system for tracking the secure use of resources, and a language extension feature that mitigates command injection. In our case study, we built a small standard I/O library, seeking to use the new language features to create a library that is less vulnerable to misuse and can serve as a building block for more secure programs, compared to conventional I/O library designs. Our study suggests that these features are indeed practicable and useful, and thus potentially promising for inclusion in other future language designs. It also sheds light on the value and cost of these features and suggests directions for future research on security-focused language design.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jennifer</first_name>
          <last_name>Fish</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>jenniferfish</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Darya</first_name>
          <last_name>Melicher</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://scholar.google.com/citations?user=KoIZBqwAAAAJ</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/daryamelicher/dd1aba2a-1ed3-43a6-ae6e-b9905a5a8bc2/small.jpg</picture_url>
          <person_id>daryamelicher</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>871e0888-b28f-4186-83b5-77516350f0c3</slot_id>
      <event_id>d11441e2-ddf7-4e97-8ae2-6997a5fcf8cc</event_id>
      <title>On the Unusual Effectiveness of Type-aware Operator Mutations for Testing SMT Solvers</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:00</end_time>
      <description>We propose type-aware operator mutation, a simple, but unusually effective approach for testing SMT solvers. The key idea is to mutate operators of conforming types within the seed formulas to generate well-typed mutant formulas. These mutant formulas are then used as the test cases for SMT solvers. We realized type-aware operator mutation within the OpFuzz tool and used it to stress-test Z3 and CVC4, two state-of-the-art SMT solvers. Type-aware operator mutations are unusually effective: During nine months of extensive testing with OpFuzz, we reported 909 bugs in Z3 and CVC4, out of which 632 bugs were confirmed and 531 of the confirmed bugs were fixed by the developers. The detected bugs are highly diverse — we found bugs of many different types (soundness bugs, invalid model bugs, crashes, etc.), logics and solver configurations. We have further conducted an in-depth study on the bugs found by OpFuzz. The study results show that the bugs found by OpFuzz are of high quality. Many of them affect core components of the SMT solvers’ codebases, and some required major changes for the developers to fix. Among the 909 bugs found by OpFuzz, 130 were soundness bugs, the most critical bugs in SMT solvers, and 501 were in the default modes of the solvers. Notably, OpFuzz found 16 critical soundness bugs in CVC4, which has proved to be a very stable SMT solver.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dominik</first_name>
          <last_name>Winterer</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/dominikwinterer/f89f4b13-8156-4541-b618-d5128446e27f/small.jpg</picture_url>
          <person_id>dominikwinterer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chengyu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>East China Normal University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.chengyuzhang.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/chengyuzhang/eee80413-7fee-43ac-88d2-72212b8b352a/small.jpg</picture_url>
          <person_id>chengyuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a8f65fa2-fbdc-4f52-947a-af2f84918dea</slot_id>
      <event_id>b128c01e-db4d-4a75-8071-91747e32d214</event_id>
      <title>Knowing When to Ask: Sound Scheduling of Name Resolution in Type Checkers Derived from Declarative Specifications</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:00</end_time>
      <description>There is a large gap between the specification of type systems and the implementation of their type checkers, which impedes reasoning about the soundness of the type checker with respect to the specification. A vision to close this gap involves automatically obtaining type checkers from declarative programming language specifications. This moves the burden of proving correctness from a case-by-case basis for concrete languages, to a single correctness proof for the specification language. 
This vision is obstructed by an aspect common to all programming languages: name resolution. Naming and scoping are pervasive and complex aspects of the static semantics of programming languages. Implementations of type checkers for languages with name binding features such as modules, imports, classes, and inheritance interleave collection of binding information (i.e., declarations, scoping structure, and imports) and querying that information. This requires scheduling those two aspects in such a way that query answers are stable—i.e., they are computed only after all relevant binding structure has been collected. Type checkers for concrete languages accomplish stability using language-specific knowledge about the type system. 
In this paper we give a language independent characterization of necessary and sufficient conditions to guarantee stability of name and type queries during type checking in terms of critical edges in an incomplete scope graph. We use critical edges to give a formal small-step operational semantics to a declarative specification language for type systems, delaying queries that may depend on missing information. This yields type checkers for the specified languages that are safe-by-construction—i.e., they safely schedule queries and only accept programs that are name- and type-correct according to the declarative language specification. We implement this approach, and evaluate it against specifications of a small module and record language, as well as subsets of Java and Scala.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Arjen</first_name>
          <last_name>Rouvoet</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ajrouvoet.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjenrouvoet/72c0e303-43d5-4252-a170-5b61600fac4d/small.jpg</picture_url>
          <person_id>arjenrouvoet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hendrik</first_name>
          <last_name>van Antwerpen</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hendrik.van-antwerpen.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hendrikvanantwerpen/2d3f530b-7183-483e-b3b6-80dd4159a4bd/small.jpg</picture_url>
          <person_id>hendrikvanantwerpen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Casper</first_name>
          <last_name>Bach Poulsen</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://casperbp.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/casperbachpoulsen/2cddd6a9-d920-4f73-9fcf-f4d9462eb0e3/small.jpg</picture_url>
          <person_id>casperbachpoulsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Robbert</first_name>
          <last_name>Krebbers</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://robbertkrebbers.nl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/robbertkrebbers/7c0562b5-da08-4f27-aa28-918e54dcaf3d/small.jpg</picture_url>
          <person_id>robbertkrebbers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science at Delft University of Technology. He received a master’s and doctorate in computer science from the University of Amsterdam in 1993 and 1997, respectively. Previously he served as postdoc at the Oregon Graduate Institute, as Assistant Professor at Utrecht University, and as Associate Professor at TU Delft. 
His research interests include programming languages, software language engineering, domain-specific programming languages, program transformation, syntax definition, and parsing. With his students he has designed and implemented the Spoofax language workbench, as well as many domain-specific languages, including DSLs for syntax definition (SDF2, SDF3), program transformation (Stratego), static semantics (NaBL, Statix), dynamic semantics (DynSem), software deployment (Nix), web application development (WebDSL), and mobile phone applications (mobl). In the language designer’s workbench project he is pursuing high-level declarative language definition that serves for language implementation and verification.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bc899f67-e1c5-415a-9043-f0380d1abc4b</slot_id>
      <event_id>ed880ad5-1891-4cd2-92b1-2ec787931970</event_id>
      <title>Reshape Your Layouts, Not Your Programs: A Safe Language Extension for Better Cache Locality</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:00</end_time>
      <description>The vast divide between the speed of CPU and RAM means that effective use of CPU caches is often a prerequisite for high performance on modern architectures. Hence, developers need to consider how to place data in memory so as to exploit spatial locality and achieve high memory bandwidth. Such manual memory optimisations are common in unmanaged languages (e.g. C, C++), but they sacrifice readability, maintainability, memory safety, and object abstraction. In managed languages, such as Java and C#, where the runtime abstracts away the memory from the developer, such optimisations are almost impossible. 
We present a language extension called SHAPES, which aims to offer developers more fine-grained control over the placement of data, without sacrificing memory safety or object abstraction. In SHAPES, programmers group related objects into pools, and specify how objects are laid out in these pools. Classes and types are annotated by pool parameters, which allow placement aspects to be changed orthogonally to the code that operates on the objects in the pool. These design decisions disentangle business logic and memory concerns. 
We give a formal model of SHAPES, present its type and memory safety model, and present its translation to a low-level language. We argue why we expect this translation to be efficient in terms of runtime representation of objects and access to their fields. We argue that SHAPES can be incorporated into existing managed and unmanaged language runtimes and fit well with garbage collection.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexandros</first_name>
          <last_name>Tasos</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexandrostasos/131f6a5e-4994-4195-b143-5eb7d52f3317/small.jpg</picture_url>
          <person_id>alexandrostasos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Juliana</first_name>
          <last_name>Franco</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>julianafranco1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sophia</first_name>
          <last_name>Drossopoulou</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Professor of Programming Languages in the Department of Computing, Imperial College, London, UK.</bio>
          <homepage_url>https://wp.doc.ic.ac.uk/sd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sophiadrossopoulou/f9f2890b-55bd-4796-94ab-fe3291277c90/small.jpg</picture_url>
          <person_id>sophiadrossopoulou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Wrigstad</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wrigstad.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tobiaswrigstad/51b1bbdb-d077-4128-ad29-ec14657617a7/small.jpg</picture_url>
          <person_id>tobiaswrigstad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Susan</first_name>
          <last_name>Eisenbach</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wp.doc.ic.ac.uk/susan/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/susaneisenbach/100322fa-6296-48e2-8238-10431036ea30/small.jpg</picture_url>
          <person_id>susaneisenbach</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bea94d41-3b01-4d40-8516-b23f244e454f</slot_id>
      <event_id>44bbb98f-75ad-43ac-a8b4-ee98dfbaadbb</event_id>
      <title>A Type-Directed Operational Semantics for a Calculus with a Merge Operator</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:00</end_time>
      <description>Calculi with disjoint intersection types and a merge operator provide general mechanisms that can subsume various other features. Such calculi can also encode highly dynamic forms of object composition, which capture common programming patterns in dynamically typed languages (such as JavaScript) in a fully statically typed manner. Unfortunately, unlike many other foundational calculi (such as System $F$, System $F_{&amp;lt;:}$ or Featherweight Java), recent calculi with the merge operator lack a (direct) operational semantics with standard and expected properties such as determinism and subject-reduction. Furthermore the metatheory for such calculi can only account for terminating programs, which is a significant restriction in practice. 
This paper proposes a type-directed operational semantics (TDOS) for $\lambda_{i}^{:}$: a calculus with intersection types and a merge operator. The calculus is inspired by two closely related calculi by Dunfield (2014) and Oliveira et al. (2016). Although Dunfield proposes a direct small-step semantics for his calculus, his semantics lacks both determinism and subject-reduction. Using our TDOS we obtain a direct semantics for $\lambda_{i}^{:}$ that has both properties. To fully obtain determinism, the $\lambda_{i}^{:}$ calculus employs a disjointness restriction proposed in Oliveira et al.’s $\lambda_{i}$ calculus. As an added benefit the TDOS approach deals with recursion in a straightforward way, unlike $\lambda_{i}$ and subsequent calculi where recursion is problematic. To further relate $\lambda_{i}^{:}$ to the calculi by Dunfield and Oliveira et al. we show two results. Firstly, the semantics of $\lambda_{i}^{:}$ is sound with respect to Dunfield’s small-step semantics. Secondly, we show that the type system of $\lambda_{i}^{:}$ is complete with respect to the $\lambda_{i}$ type system. All results have been fully formalized in the Coq theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xuejing</first_name>
          <last_name>Huang</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/huangxuejing/b875ad52-4b3e-4a4e-9b2e-b6b48436a581/small.jpg</picture_url>
          <person_id>huangxuejing</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d9f1ef79-14ce-4705-8e4e-df08a9845081</slot_id>
      <event_id>893a6ed0-04ac-438a-9294-a78d5945e0fd</event_id>
      <title>Geometry Types for Graphics Programming</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:00</end_time>
      <description>In domains that deal with physical space and geometry, programmers need to track the coordinate systems that underpin a computation. We identify a class of geometry bugs that arise from confusing which coordinate system a vector belongs to. These bugs are not ruled out by current languages for vector-oriented computing, are difficult to check for at run time, and can generate subtly incorrect output that can be hard to test for. 
We introduce a type system and language that prevents geometry bugs by reflecting the coordinate system for each geometric object. A value’s geometry type encodes its reference frame, the kind of geometric object (such as a point or a direction), and the computational representation (such as Cartesian or spherical coordinates). We show how these types can rule out geometrically incorrect operations, and we show how to use them to automatically generate correct-by-construction code to transform vectors between coordinate systems. We implement a language for graphics programming, Gator, that checks geometry types and compiles to OpenGL’s shading language, GLSL. Using case studies, we demonstrate that Gator can raise the level of abstraction for shader programming and prevent common errors without inducing significant annotation overhead or performance cost.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dietrich</first_name>
          <last_name>Geisler</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>dietrichgeisler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Irene</first_name>
          <last_name>Yoon</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://seas.upenn.edu/~euisuny</homepage_url>
          <person_id>ireneyoon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aditi</first_name>
          <last_name>Kabra</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>aditikabra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Horace</first_name>
          <last_name>He</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>horacehe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yinnon</first_name>
          <last_name>Sanders</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>yinnonsanders</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Adrian</first_name>
          <last_name>Sampson</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://adriansampson.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adriansampson/adaa9202-3352-4410-b03a-1eb4718543d5/small.jpg</picture_url>
          <person_id>adriansampson</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>267a657f-3ecd-47cd-b9be-dc8ccdc92cdb</subevent_id>
    <title>SPLASH Posters: Posters Session 1 Mirror</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-VII</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot>
      <slot_id>ceb39efe-d3ce-4149-9057-46c889fdb159</slot_id>
      <title>Session: SPLASH Posters - Posters Session 1 Mirror</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_time>21:00</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2e857fab-c472-4dd5-a74a-934f7309d638</slot_id>
      <event_id>c3aed59f-f991-4edf-b2c5-502e961b1d09</event_id>
      <title>Analogy-Making as a Core Primitive in the Software Engineering Toolbox</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:00</end_time>
      <description>An analogy is an identification of structural similarities and correspondences between two objects. Computational models of analogy making have been studied extensively in the field of cognitive science to better understand high-level human cognition. For instance, Melanie Mitchell and Douglas Hofstadter sought to better understand high-level perception by developing the Copycat algorithm for completing analogies between letter sequences. In this paper, we argue that analogy making should be seen as a core primitive in software engineering. We motivate this argument by showing how complex software engineering problems such as program understanding and source-code transformation learning can be reduced to an instance of the analogy-making problem. We demonstrate this idea using Sifter, a new analogy-making algorithm suitable for software engineering applications that adapts and extends ideas from Copycat. In particular, Sifter reduces analogy-making to searching for a sequence of update rule applications. Sifter uses a novel representation for mathematical structures capable of effectively representing the wide variety of information embedded in software. We conclude by listing major areas of future work for Sifter and analogy-making in software engineering.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Sotoudeh</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://masot.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthewsotoudeh/32b819f5-05ef-4b0a-8a19-d59eed661278/small.jpg</picture_url>
          <person_id>matthewsotoudeh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aditya V.</first_name>
          <last_name>Thakur</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://thakur.cs.ucdavis.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adityavthakur/89eb0287-7273-4261-b8a5-47ccfc8799b0/small.jpg</picture_url>
          <person_id>adityavthakur</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>313dfd6f-d2b9-4157-bb85-5522aaf10c85</slot_id>
      <event_id>9e0ae049-b867-4cd1-9715-da33fb9ef501</event_id>
      <title>Static Race Detection and Mutex Safety and Liveness for Go Programs</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:00</end_time>
      <description>Go is a popular concurrent programming language thanks to its ability to efficiently combine concurrency and systems programming. In Go programs, a number of concurrency bugs can be caused by a mixture of data races and communication problems. In this paper, we develop a theory based on behavioural types to statically detect data races and deadlocks in Go programs. We first specify lock safety/liveness and data race properties over a Go program model, using the happens-before relation defined in the Go memory model. We represent these properties of programs in a µ-calculus model of types, and validate them using type-level model-checking. We then extend the framework to account for Go’s channels, and implement a static verification tool which can detect concurrency errors. This is, to the best of our knowledge, the first static verification framework of this kind for the Go language, uniformly analysing concurrency errors caused by a mix of shared memory accesses and asynchronous message-passing communications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julia</first_name>
          <last_name>Gabet</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <person_id>juliagabet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4a009cf6-9b4b-41d5-bef5-4d01fa563bdb</slot_id>
      <event_id>d11441e2-ddf7-4e97-8ae2-6997a5fcf8cc</event_id>
      <title>On the Unusual Effectiveness of Type-aware Operator Mutations for Testing SMT Solvers</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:00</end_time>
      <description>We propose type-aware operator mutation, a simple, but unusually effective approach for testing SMT solvers. The key idea is to mutate operators of conforming types within the seed formulas to generate well-typed mutant formulas. These mutant formulas are then used as the test cases for SMT solvers. We realized type-aware operator mutation within the OpFuzz tool and used it to stress-test Z3 and CVC4, two state-of-the-art SMT solvers. Type-aware operator mutations are unusually effective: During nine months of extensive testing with OpFuzz, we reported 909 bugs in Z3 and CVC4, out of which 632 bugs were confirmed and 531 of the confirmed bugs were fixed by the developers. The detected bugs are highly diverse — we found bugs of many different types (soundness bugs, invalid model bugs, crashes, etc.), logics and solver configurations. We have further conducted an in-depth study on the bugs found by OpFuzz. The study results show that the bugs found by OpFuzz are of high quality. Many of them affect core components of the SMT solvers’ codebases, and some required major changes for the developers to fix. Among the 909 bugs found by OpFuzz, 130 were soundness bugs, the most critical bugs in SMT solvers, and 501 were in the default modes of the solvers. Notably, OpFuzz found 16 critical soundness bugs in CVC4, which has proved to be a very stable SMT solver.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dominik</first_name>
          <last_name>Winterer</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/dominikwinterer/f89f4b13-8156-4541-b618-d5128446e27f/small.jpg</picture_url>
          <person_id>dominikwinterer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chengyu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>East China Normal University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.chengyuzhang.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/chengyuzhang/eee80413-7fee-43ac-88d2-72212b8b352a/small.jpg</picture_url>
          <person_id>chengyuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4cb55fb9-b9db-4532-9e94-1f5ce86de576</slot_id>
      <event_id>44bbb98f-75ad-43ac-a8b4-ee98dfbaadbb</event_id>
      <title>A Type-Directed Operational Semantics for a Calculus with a Merge Operator</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:00</end_time>
      <description>Calculi with disjoint intersection types and a merge operator provide general mechanisms that can subsume various other features. Such calculi can also encode highly dynamic forms of object composition, which capture common programming patterns in dynamically typed languages (such as JavaScript) in a fully statically typed manner. Unfortunately, unlike many other foundational calculi (such as System $F$, System $F_{&amp;lt;:}$ or Featherweight Java), recent calculi with the merge operator lack a (direct) operational semantics with standard and expected properties such as determinism and subject-reduction. Furthermore the metatheory for such calculi can only account for terminating programs, which is a significant restriction in practice. 
This paper proposes a type-directed operational semantics (TDOS) for $\lambda_{i}^{:}$: a calculus with intersection types and a merge operator. The calculus is inspired by two closely related calculi by Dunfield (2014) and Oliveira et al. (2016). Although Dunfield proposes a direct small-step semantics for his calculus, his semantics lacks both determinism and subject-reduction. Using our TDOS we obtain a direct semantics for $\lambda_{i}^{:}$ that has both properties. To fully obtain determinism, the $\lambda_{i}^{:}$ calculus employs a disjointness restriction proposed in Oliveira et al.’s $\lambda_{i}$ calculus. As an added benefit the TDOS approach deals with recursion in a straightforward way, unlike $\lambda_{i}$ and subsequent calculi where recursion is problematic. To further relate $\lambda_{i}^{:}$ to the calculi by Dunfield and Oliveira et al. we show two results. Firstly, the semantics of $\lambda_{i}^{:}$ is sound with respect to Dunfield’s small-step semantics. Secondly, we show that the type system of $\lambda_{i}^{:}$ is complete with respect to the $\lambda_{i}$ type system. All results have been fully formalized in the Coq theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xuejing</first_name>
          <last_name>Huang</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/huangxuejing/b875ad52-4b3e-4a4e-9b2e-b6b48436a581/small.jpg</picture_url>
          <person_id>huangxuejing</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6fac8564-df99-4c39-a114-b025c8ab7f1e</slot_id>
      <event_id>c85e8b32-d0e7-45bc-ad8d-614d19ed58e0</event_id>
      <title>A Case Study in Language-Based Security: Building an I/O Library for Wyvern</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:00</end_time>
      <description>As the impact of vulnerabilities increases in practice, it is imperative for programming languages to include security as a first-class design consideration. While a number of security-related language features have been proposed to address this need, in many cases, we do not know enough about whether it is practical and useful to build software systems in languages with these features. 
In this paper, we begin to investigate this question, using a case study methodology. The setting of our case study is Wyvern, a recently designed language we selected because it incorporates three advanced security-related features: capability safety for enforcing the principle of least privilege, an effect system for tracking the secure use of resources, and a language extension feature that mitigates command injection. In our case study, we built a small standard I/O library, seeking to use the new language features to create a library that is less vulnerable to misuse and can serve as a building block for more secure programs, compared to conventional I/O library designs. Our study suggests that these features are indeed practicable and useful, and thus potentially promising for inclusion in other future language designs. It also sheds light on the value and cost of these features and suggests directions for future research on security-focused language design.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jennifer</first_name>
          <last_name>Fish</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>jenniferfish</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Darya</first_name>
          <last_name>Melicher</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://scholar.google.com/citations?user=KoIZBqwAAAAJ</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/daryamelicher/dd1aba2a-1ed3-43a6-ae6e-b9905a5a8bc2/small.jpg</picture_url>
          <person_id>daryamelicher</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>926c8da5-44cc-4657-9a62-d6561bd47ed6</slot_id>
      <event_id>52887fc8-e85e-4aa3-a067-3b109a7bc852</event_id>
      <title>CAMP: Cost-Aware Multiparty Session Protocols</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:00</end_time>
      <description>This paper presents CAMP, a new static performance analysis framework for message-passing concurrent and distributed systems, based on the theory of multiparty session types (MPST). Understanding the run-time performance of concurrent and distributed systems is of great importance for the identification of bottlenecks and optimisation opportunities. In the message-passing setting, these bottlenecks are generally communication overheads and synchronisation times. Despite its importance, reasoning about these intensional properties of software, such as performance, has received little attention, compared to verifying extensional properties, such as correctness. Behavioural protocol specifications based on sessions types capture not only extensional, but also intensional properties of concurrent and distributed systems. CAMP augments MPST with annotations of communication latency and local computation cost, defined as estimated execution times, that we use to extract cost equations from protocol descriptions. CAMP is also extendable to analyse asynchronous communication optimisation built on a recent advance of session type theories. We apply our tool to different existing benchmarks and usecases in the literature with a wide range of communication protocols, implemented in C, MPI-C, Java, Go and OCaml. Our benchmarks show that, in most of the cases, we predict an upper-bound on the real execution costs with &amp;lt; 15 % error.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Castro</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <person_id>davidcastro</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>94c6e70d-2462-4068-a1af-ec7b48a8b079</slot_id>
      <event_id>88a7fb9c-c6d8-4976-ab8e-554ac4921725</event_id>
      <title>Owicki-Gries Reasoning for C11 RAR</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:00</end_time>
      <description>Owicki-Gries reasoning for concurrent programs uses Hoare logic together with an interference freedom rule for concurrency. In this paper, we develop a new proof calculus for the C11 RAR memory model (a fragment of C11 with both relaxed and release-acquire accesses) that allows all Owicki-Gries proof rules for compound statements, including non-interference, to remain unchanged. Our proof method features novel assertions specifying thread-specific views on the state of programs. This is combined with a set of Hoare logic rules that describe how these assertions are affected by atomic program steps. We demonstrate the utility of our proof calculus by verifying a number of standard C11 litmus tests and Peterson’s algorithm adapted for C11. Our proof calculus and its application to program verification have been fully mechanised in the theorem prover</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sadegh</first_name>
          <last_name>Dalvandi</last_name>
          <affiliation>University of Surrey</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dalvandi.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mohammadsadeghdalvandi/c22dc5e6-1b7d-4d4b-bc5d-0c19608c2c89/small.jpg</picture_url>
          <person_id>mohammadsadeghdalvandi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Doherty</last_name>
          <affiliation>University of Sheffield</affiliation>
          <bio>undefined</bio>
          <person_id>simondoherty</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brijesh</first_name>
          <last_name>Dongol</last_name>
          <affiliation>University of Surrey</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/brijeshdongol/1a40f0ae-7a59-4232-b09e-a69a66272c0f/small.jpg</picture_url>
          <person_id>brijeshdongol</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Heike</first_name>
          <last_name>Wehrheim</last_name>
          <affiliation>Paderborn University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.uni-paderborn.de/en/person/573/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/heikewehrheim/77537d51-60d9-4a1d-8187-78047b1f330c/small.jpg</picture_url>
          <person_id>heikewehrheim</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9dcb1052-7737-4365-8622-8073312c25a8</slot_id>
      <event_id>aeb95fc0-4c63-4e89-886e-631404993ed1</event_id>
      <title>Formulog: Datalog for SMT-based Static Analysis</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:00</end_time>
      <description>Satisfiability modulo theories (SMT) solving has become a critical part of many static analyses, including symbolic execution, refinement type checking, and model checking. We propose Formulog, a domain-specific language that makes it possible to write a range of SMT-based static analyses in a way that is both close to their formal specifications and amenable to high-level optimizations and efficient evaluation. 
Formulog extends the logic programming language Datalog with a first-order functional language and mechanisms for representing and reasoning about SMT formulas; a novel type system supports the construction of expressive formulas, while ensuring that neither normal evaluation nor SMT solving goes wrong. Our case studies demonstrate that a range of SMT-based analyses can naturally and concisely be encoded in Formulog, and that — thanks to this encoding — high-level Datalog-style optimizations can be automatically and advantageously applied to these analyses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Bembenek</last_name>
          <affiliation>Harvard University, USA</affiliation>
          <bio>Aaron Bembenek is currently a computer science PhD candidate at Harvard University working under Stephen Chong. He previously earned an undergraduate degree in classics from Princeton University.</bio>
          <homepage_url>http://people.seas.harvard.edu/~bembenek/index.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aaronbembenek/def526d3-8049-43ee-a891-2437ec903da6/small.jpg</picture_url>
          <person_id>aaronbembenek</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Greenberg</last_name>
          <affiliation>Pomona College, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.pomona.edu/~michael/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
          <person_id>michaelgreenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chong</last_name>
          <affiliation>Harvard University, USA</affiliation>
          <bio>Stephen Chong is a Gordon McKay Professor of Computer Science in the Harvard John A. Paulson School of Engineering and Applied Sciences. Steve’s research focuses on programming languages, information security, and the intersection of these two areas. He is the recipient of an NSF CAREER award, an AFOSR Young Investigator award, and a Sloan Research Fellowship. He received a PhD from Cornell University, and a bachelor’s degree from Victoria University of Wellington, New Zealand.</bio>
          <homepage_url>https://people.seas.harvard.edu/~chong/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stephenchong/91e43651-bcd6-40dc-b231-4c92711b0e95/small.jpg</picture_url>
          <person_id>stephenchong</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9f5eef6f-d565-410e-b090-9baa14ca6175</slot_id>
      <event_id>810a4501-575d-45e8-92bd-d7c7a3cde3ba</event_id>
      <title>Demystifying Dependence</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:00</end_time>
      <description>Programmers are told “depend on interfaces, not implementations.” But, given a program, is it possible even to assess objectively whether such advice has been followed? 
Programmers frequently talk in ways like this about dependence, but the very term, like many used in software engineering, has hitherto eluded precise definition. In this work, we resolve a variety of confusions about dependence, and present a formal definition unifying multiple varieties of software dependence, grounded in Halpern and Pearl’s theory of actual causation. This definition is parameterized by the formal system characterizing the property of interest, and by constraints on “reasonable changes” to the program. By picking different choices of formal system, one can specialize our definition to characterize dynamic dependence (slicing), static dependence (correctness), and dependence of performance properties. Overall, our work provides a path to making conversations about software dependence fully objective, and might serve as a basis for future work automatically checking forms of dependence which were previously too abstract or high-level to be candidates for tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>James</first_name>
          <last_name>Koppel</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>www.jameskoppel.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jameskoppel/285bb202-88a1-4b77-bf13-bd39911247ef/small.jpg</picture_url>
          <person_id>jameskoppel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Jackson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/dnj/</homepage_url>
          <person_id>danieljackson</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9f94dec3-ea13-4695-8327-d58fd97e9e4a</slot_id>
      <event_id>b128c01e-db4d-4a75-8071-91747e32d214</event_id>
      <title>Knowing When to Ask: Sound Scheduling of Name Resolution in Type Checkers Derived from Declarative Specifications</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:00</end_time>
      <description>There is a large gap between the specification of type systems and the implementation of their type checkers, which impedes reasoning about the soundness of the type checker with respect to the specification. A vision to close this gap involves automatically obtaining type checkers from declarative programming language specifications. This moves the burden of proving correctness from a case-by-case basis for concrete languages, to a single correctness proof for the specification language. 
This vision is obstructed by an aspect common to all programming languages: name resolution. Naming and scoping are pervasive and complex aspects of the static semantics of programming languages. Implementations of type checkers for languages with name binding features such as modules, imports, classes, and inheritance interleave collection of binding information (i.e., declarations, scoping structure, and imports) and querying that information. This requires scheduling those two aspects in such a way that query answers are stable—i.e., they are computed only after all relevant binding structure has been collected. Type checkers for concrete languages accomplish stability using language-specific knowledge about the type system. 
In this paper we give a language independent characterization of necessary and sufficient conditions to guarantee stability of name and type queries during type checking in terms of critical edges in an incomplete scope graph. We use critical edges to give a formal small-step operational semantics to a declarative specification language for type systems, delaying queries that may depend on missing information. This yields type checkers for the specified languages that are safe-by-construction—i.e., they safely schedule queries and only accept programs that are name- and type-correct according to the declarative language specification. We implement this approach, and evaluate it against specifications of a small module and record language, as well as subsets of Java and Scala.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Arjen</first_name>
          <last_name>Rouvoet</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ajrouvoet.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjenrouvoet/72c0e303-43d5-4252-a170-5b61600fac4d/small.jpg</picture_url>
          <person_id>arjenrouvoet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hendrik</first_name>
          <last_name>van Antwerpen</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hendrik.van-antwerpen.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hendrikvanantwerpen/2d3f530b-7183-483e-b3b6-80dd4159a4bd/small.jpg</picture_url>
          <person_id>hendrikvanantwerpen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Casper</first_name>
          <last_name>Bach Poulsen</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://casperbp.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/casperbachpoulsen/2cddd6a9-d920-4f73-9fcf-f4d9462eb0e3/small.jpg</picture_url>
          <person_id>casperbachpoulsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Robbert</first_name>
          <last_name>Krebbers</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://robbertkrebbers.nl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/robbertkrebbers/7c0562b5-da08-4f27-aa28-918e54dcaf3d/small.jpg</picture_url>
          <person_id>robbertkrebbers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science at Delft University of Technology. He received a master’s and doctorate in computer science from the University of Amsterdam in 1993 and 1997, respectively. Previously he served as postdoc at the Oregon Graduate Institute, as Assistant Professor at Utrecht University, and as Associate Professor at TU Delft. 
His research interests include programming languages, software language engineering, domain-specific programming languages, program transformation, syntax definition, and parsing. With his students he has designed and implemented the Spoofax language workbench, as well as many domain-specific languages, including DSLs for syntax definition (SDF2, SDF3), program transformation (Stratego), static semantics (NaBL, Statix), dynamic semantics (DynSem), software deployment (Nix), web application development (WebDSL), and mobile phone applications (mobl). In the language designer’s workbench project he is pursuing high-level declarative language definition that serves for language implementation and verification.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>adda370f-e599-4b25-bbed-97eccf81435b</slot_id>
      <event_id>99de77d9-920e-40fb-a2a8-dfe5011da1fe</event_id>
      <title>Row and Bounded Polymorphism via Disjoint Polymorphism</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:00</end_time>
      <description>Polymorphism and subtyping are important features in mainstream OO languages. The most common way to integrate the two is via F&amp;lt;: style bounded quantification. A closely related mechanism is row polymorphism, which provides an alternative to subtyping, while still enabling many of the same applications. Yet another approach is to have type systems with intersection types and polymorphism. A recent addition to this design space are calculi with disjoint intersection types and disjoint polymorphism. With all these alternatives it is natural to wonder how they are related. 
This paper provides an answer to this question. We show that disjoint polymorphism can recover forms of both row polymorphism and bounded polymorphism, while retaining key desirable properties, such as type-safety and decidability. Furthermore, we identify the extra power of disjoint polymorphism which enables additional features that cannot be easily encoded in calculi with row polymorphism or bounded quantification alone. Ultimately we expect that our work is useful to inform language designers about the expressive power of those common features, and to simplify implementations and metatheory of feature-rich languages with polymorphism and subtyping.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ningning</first_name>
          <last_name>Xie</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://xnning.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ningningxie/99787204-daa9-484a-bea5-4b2b88551687/small.jpg</picture_url>
          <person_id>ningningxie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xuan</first_name>
          <last_name>Bi</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <person_id>xuanbi1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b48ba781-6108-4f2e-ab14-c8f0f1ec244c</slot_id>
      <event_id>ed880ad5-1891-4cd2-92b1-2ec787931970</event_id>
      <title>Reshape Your Layouts, Not Your Programs: A Safe Language Extension for Better Cache Locality</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:00</end_time>
      <description>The vast divide between the speed of CPU and RAM means that effective use of CPU caches is often a prerequisite for high performance on modern architectures. Hence, developers need to consider how to place data in memory so as to exploit spatial locality and achieve high memory bandwidth. Such manual memory optimisations are common in unmanaged languages (e.g. C, C++), but they sacrifice readability, maintainability, memory safety, and object abstraction. In managed languages, such as Java and C#, where the runtime abstracts away the memory from the developer, such optimisations are almost impossible. 
We present a language extension called SHAPES, which aims to offer developers more fine-grained control over the placement of data, without sacrificing memory safety or object abstraction. In SHAPES, programmers group related objects into pools, and specify how objects are laid out in these pools. Classes and types are annotated by pool parameters, which allow placement aspects to be changed orthogonally to the code that operates on the objects in the pool. These design decisions disentangle business logic and memory concerns. 
We give a formal model of SHAPES, present its type and memory safety model, and present its translation to a low-level language. We argue why we expect this translation to be efficient in terms of runtime representation of objects and access to their fields. We argue that SHAPES can be incorporated into existing managed and unmanaged language runtimes and fit well with garbage collection.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexandros</first_name>
          <last_name>Tasos</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexandrostasos/131f6a5e-4994-4195-b143-5eb7d52f3317/small.jpg</picture_url>
          <person_id>alexandrostasos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Juliana</first_name>
          <last_name>Franco</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>julianafranco1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sophia</first_name>
          <last_name>Drossopoulou</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Professor of Programming Languages in the Department of Computing, Imperial College, London, UK.</bio>
          <homepage_url>https://wp.doc.ic.ac.uk/sd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sophiadrossopoulou/f9f2890b-55bd-4796-94ab-fe3291277c90/small.jpg</picture_url>
          <person_id>sophiadrossopoulou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Wrigstad</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wrigstad.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tobiaswrigstad/51b1bbdb-d077-4128-ad29-ec14657617a7/small.jpg</picture_url>
          <person_id>tobiaswrigstad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Susan</first_name>
          <last_name>Eisenbach</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wp.doc.ic.ac.uk/susan/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/susaneisenbach/100322fa-6296-48e2-8238-10431036ea30/small.jpg</picture_url>
          <person_id>susaneisenbach</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d5b6bf0b-0d58-46f1-b69d-4acf6379044c</slot_id>
      <event_id>9c6add07-d7ab-47f4-b15b-e12b936f5fd7</event_id>
      <title>Gradual Verification of Recursive Heap Data Structures</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:00</end_time>
      <description>Current static verification techniques do not provide good support for incrementality, making it difficult for developers to focus their limited effort on specifying and verifying the properties and components that are most important. Dynamic verification approaches support incrementality, but cannot provide static guarantees. To bridge this gap, prior work proposed gradual verification, which supports incrementality by allowing every assertion to be complete, partial, or omitted, and provides sound verification that smoothly scales from dynamic to static checking. The prior approach to gradual verification, however, was limited to toy programs without recursive data structures. This paper extends gradual verification to realistic programs that manipulate recursive, mutable data structures on the heap. We solve key technical challenges, semantically connecting iso- and equi-recursive interpretations of abstract predicates as well as gradual verification of heap ownership. Our work thus lays the foundation for future tools that work on realistic programs and support verification within an engineering process in which cost-benefit trade-offs can be made.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jenna</first_name>
          <last_name>Wise</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jlwise/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jennawise/614a00d0-d8ab-4b2f-8ec7-96abcb5c3d5b/small.jpg</picture_url>
          <person_id>jennawise</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Johannes</first_name>
          <last_name>Bader</last_name>
          <affiliation>Jane Street</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.johannes-bader.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johannesbader/0b7e635c-fba7-4113-a53d-4451edd44ca5/small.jpg</picture_url>
          <person_id>johannesbader</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Cameron</first_name>
          <last_name>Wong</last_name>
          <affiliation>Jane Street</affiliation>
          <bio>Wannabe type theorist.</bio>
          <homepage_url>https://camdar.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cameronwong/1e4412d3-e79b-4f6a-8465-6b756986e1d0/small.jpg</picture_url>
          <person_id>cameronwong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile, Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
          <person_id>etanter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Sunshine</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jssunshi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joshuasunshine/474067e5-86e8-476c-9622-5c89be145f4b/small.jpg</picture_url>
          <person_id>joshuasunshine</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e2d721a4-a655-4e40-a5b7-0120add80e72</slot_id>
      <event_id>9fdddded-43c7-4b9e-add3-f53efe3421be</event_id>
      <title>Multiparty Session Programming with Global Protocol Combinators</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:00</end_time>
      <description>Multiparty Session Types (MPST) is a typing discipline for communication protocols. It ensures the absence of communication errors and deadlocks for well-typed communicating processes. The state of the art implementations of the MPST theory rely on (1) runtime linearity checks to ensure correct usage of communication channels and (2) external domain-specific languages for specifying and verifying of multiparty protocols. 
To overcome these limitations, we propose a library for programming with global combinators – a set of functions for writing and verifying multiparty protocols in OCaml. Local behaviours for all processes in a protocol are inferred at once from a global combinator. We formalise global combinators and prove a sound realisability of global combinators – a well-typed global combinator derives a set of local types, by which typed endpoint programs can ensure type and communication safety. Our approach enables fully-static verification and implementation of the whole protocol, from the protocol specification to the process implementations, to happen in the same language. 
We compare our implementation to untyped and continuation-passing style implementations, and demonstrate its expressiveness by implementing a plethora of protocols. We show our library can interoperate with existing libraries and services, implementing DNS (Domain Name Service) protocol and the OAuth (Open Authentication) protocol.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Keigo</first_name>
          <last_name>Imai</last_name>
          <affiliation>Gifu University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/keigoimai/70b0be2a-fa97-45a6-a037-57682ad05bf9/small.jpg</picture_url>
          <person_id>keigoimai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rumyana</first_name>
          <last_name>Neykova</last_name>
          <affiliation>Brunel University London, UK</affiliation>
          <bio>Rumyana Neykova is a lecturer at Brunel University London, previously completed a PhD degree under the supervision of Prof. Nobuko Yoshida at Imperial College London, where she was also research fellow. Her research interests are in the area of distributed systems and networks, as well as type systems and language design. Her PhD focuses on development and applications of a type theory (called session types) for runtime verification of concurrent and distributed systems.</bio>
          <homepage_url>https://www.brunel.ac.uk/people/rumyana-neykova</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rumyananeykova/66457b0a-8e8b-471e-b278-37d7f4242bcb/small.jpg</picture_url>
          <person_id>rumyananeykova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Shoji</first_name>
          <last_name>Yuen</last_name>
          <affiliation>Nagoya University</affiliation>
          <bio>undefined</bio>
          <person_id>shojiyuen</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e91a8355-84c2-401f-b167-19bed152d17d</slot_id>
      <event_id>e02523f3-98c1-467e-8542-8216dc5523b7</event_id>
      <title>Can Advanced Type Systems Be Usable? An Empirical Study of Ownership, Assets, and Typestate in Obsidian</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:00</end_time>
      <description>Some blockchain programs (smart contracts) have included serious security vulnerabilities. Obsidian is a new typestate-oriented programming language that uses a strong type system to rule out some of these vulnerabilities. Although Obsidian was designed to promote usability to make it as easy as possible to write programs, strong type systems can cause a language to be difficult to use. In particular, ownership, typestate, and assets, which Obsidian uses to provide safety guarantees, have not seen broad adoption in popular languages and result in significant usability challenges. We performed an empirical study with 20 participants comparing Obsidian to Solidity, which is the language most commonly used for writing smart contracts today. We observed that Obsidian participants were able to successfully complete more of the programming tasks than the Solidity participants. We also found that asset-related bugs, which Obsidian detects at compile time, were commonly accidentally inserted by the Solidity participants.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Coblenz</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umd.edu/~mcoblenz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelcoblenz/aa74b306-529b-44d4-987f-a5e4fd6d3ca2/small.jpg</picture_url>
          <person_id>michaelcoblenz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brad</first_name>
          <last_name>Myers</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~bam/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/bradmyers/7d93ede9-5674-40e8-9ba5-f9dfab4873e1/small.jpg</picture_url>
          <person_id>bradmyers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Sunshine</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jssunshi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joshuasunshine/474067e5-86e8-476c-9622-5c89be145f4b/small.jpg</picture_url>
          <person_id>joshuasunshine</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ec404a3c-efb1-4d37-92aa-f0f326366f58</slot_id>
      <event_id>893a6ed0-04ac-438a-9294-a78d5945e0fd</event_id>
      <title>Geometry Types for Graphics Programming</title>
      <room>Online | SPLASH-VII</room>
      <date>2020/11/15</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:00</end_time>
      <description>In domains that deal with physical space and geometry, programmers need to track the coordinate systems that underpin a computation. We identify a class of geometry bugs that arise from confusing which coordinate system a vector belongs to. These bugs are not ruled out by current languages for vector-oriented computing, are difficult to check for at run time, and can generate subtly incorrect output that can be hard to test for. 
We introduce a type system and language that prevents geometry bugs by reflecting the coordinate system for each geometric object. A value’s geometry type encodes its reference frame, the kind of geometric object (such as a point or a direction), and the computational representation (such as Cartesian or spherical coordinates). We show how these types can rule out geometrically incorrect operations, and we show how to use them to automatically generate correct-by-construction code to transform vectors between coordinate systems. We implement a language for graphics programming, Gator, that checks geometry types and compiles to OpenGL’s shading language, GLSL. Using case studies, we demonstrate that Gator can raise the level of abstraction for shader programming and prevent common errors without inducing significant annotation overhead or performance cost.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dietrich</first_name>
          <last_name>Geisler</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>dietrichgeisler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Irene</first_name>
          <last_name>Yoon</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://seas.upenn.edu/~euisuny</homepage_url>
          <person_id>ireneyoon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aditi</first_name>
          <last_name>Kabra</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>aditikabra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Horace</first_name>
          <last_name>He</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>horacehe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yinnon</first_name>
          <last_name>Sanders</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>yinnonsanders</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Adrian</first_name>
          <last_name>Sampson</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://adriansampson.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adriansampson/adaa9202-3352-4410-b03a-1eb4718543d5/small.jpg</picture_url>
          <person_id>adriansampson</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>34e939f5-5272-46b6-b6cf-d397c3fe31b1</subevent_id>
    <title>SPLASH Posters: Breakfast in Chicago</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot>
      <slot_id>b13c3c1e-42d5-4d9d-9a12-79e126613053</slot_id>
      <title>Session: SPLASH Posters - Breakfast in Chicago</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8eacf6e6-a5b3-431c-ab07-6a547443c652</slot_id>
      <event_id>b14951c0-1b3a-4b54-ba3f-453e8d37ae2d</event_id>
      <title>Posters Session 1</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:00</end_time>
      <description> 
  A Case Study in Language-Based Security: Building an I/O Library for Wyvern. Jennifer A. Fish, Darya Melicher, and Jonathan Aldrich  
  A Type-Directed Operational Semantics for a Calculus with a Merge Operator. Xuejing Huang and Bruno C. d. S. Oliveira  
  Analogy-Making as a Core Primitive in the Software Engineering Toolbox. Matthew Sotoudeh, and Aditya V. Thakur  
  CAMP: Cost-Aware Multiparty Session Protocols. David Castro-Perez and Nobuko Yoshida  
  Can Advanced Type Systems Be Usable? An Empirical Study of Ownership, Assets, and Typestate in Obsidian. Michael Coblenz, Jonathan Aldrich, Brad Myers, and Joshua Sunshine  
  Demystifying Dependence. James Koppel and Daniel Jackson  
  Formulog: Datalog for SMT-Based Static Analysis. Aaron Bembenek, Michael Greenberg, and Stephen Chong  
  Geometry Types for Graphics Programming. Dietrich Geisler, Irene Yoon, Aditi Kabra, Horace He, Yinnon Sanders, and Adrian Sampson  
  Gradual Verification of Recursive Heap Data Structures. Jenna Wise, Johannes Bader, Cameron Wong, Jonathan Aldrich, Éric Tanter, and Joshua Sunshine  
  Knowing When to Ask: Sound Scheduling of Name Resolution in Type Checkers Derived from Declarative Specifications. Arjen Rouvoet, Hendrik van Antwerpen, Casper Bach Poulsen, Robbert Krebbers, and Eelco Visser  
  Multiparty Session Programming with Global Protocol Combinators. Keigo Imai, Rumyana Neykova, Nobuko Yoshida, and Shoji Yuen  
  On the Unusual Effectiveness of Type-Aware Operator Mutations for Testing SMT Solvers. Dominik Winterer, Chengyu Zhang, and Zhendong Su  
  Owicki-Gries Reasoning for C11 RAR. Sadegh Dalvandi, Simon Doherty, Brijesh Dongol, and Heike Wehrheim  
  Reshape Your Layouts, Not Your Programs: A Safe Language Extension for Better Cache Locality. Alexandros TasosI, Juliana Franco, Sophia Drossopoulou, Tobias Wrigstad, and Susan Eisenbach  
  Row and Bounded Polymorphism via Disjoint Polymorphism. Ningning Xie, Bruno C. d. S. Oliveira, Xuan Bi, and Tom Schrijvers  
  Static Race Detection and Mutex Safety and Liveness for Go Programs. Julia Gabet and Nobuko Yoshida  
</description>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>42b9230b-424c-40ec-8c81-1f548578c01a</subevent_id>
    <title>SPLASH Posters: Breakfast in Seattle</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot>
      <slot_id>bb13c36f-8031-4d45-a4eb-a94085f194a9</slot_id>
      <title>Session: SPLASH Posters - Breakfast in Seattle</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_time>11:00</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fd873380-2706-40ba-8b4e-ac39cb97cf2d</slot_id>
      <event_id>e75966a6-7f3d-4bbb-8ad0-e933f61183f2</event_id>
      <title>Posters Session 2</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description> 
  A Sparse Iteration Space Transformation Framework for Sparse Tensor Algebra. Ryan Senanayake, Changwan Hong, Ziheng Wang, Amalee Wilson, Stephen Chou, Shoaib Kamil, Saman Amarasinghe, and Fredrik Kjolstad  
  Certified and Efficient Instruction Scheduling. Cyril Six, Sylvain Boulmé, and David Monniaux  
  CompCertELF: Verified Separate Compilation of C Programs into ELF Object Files. Yuting Wang, Xiangzhe Xu, Pierre Wilke, and Zhong Shao  
  Guided Linking: Dynamic Linking without the Costs. Sean Bartell, Will Dietz, and Vikram S. Adve  
  Guiding Dynamic Programing via Structural Probability for Accelerating Programming by Example. Ruyi Ji, Yican Sun, Yingfei Xiong, and Zhenjiang Hu  
  Incremental Predicate Analysis for Regression Verification. Qianshan Yu, Fei He, and Bow-Yaw Wang  
  Learning Semantic Program Embeddings with Graph Interval Neural Network. Yu Wang, Ke Wang, Fengjuan Gao, and Linzhang Wang  
  Macros for Domain-Specific Languages. Michael Ballantyne, Alexis King, and Matthias Felleisen  
  Precise Inference of Expressive Units of Measurement Types. Tongtong Xiang, Jeff Y. Luo, and Werner Dietl  
  Resolution as Intersection Subtyping via Modus Ponens. Koar Marntirosian, Tom Schrijvers, Bruno C. d. S. Oliveira, and Georgios Karachalias  
  Revisiting Iso-Recursive Subtyping. Yaoda Zhou, Bruno C. d. S. Oliveira, and Jinxu Zhao  
  SATUNE: Synthesizing Efficient SAT Encoders. Hamed Gorjiara, Harry Xu ,and Brian Demsky  
  Scaling Exact Inference for Discrete Probabilistic Programs. Steven Holtzen and Guy Van den Broeck, and Todd Millstein  
  Statically Verified Refinements for Multiparty Protocols. Fangyi Zhou, Francisco Ferreira, Raymond Hu, Rumyana Neykova, and Nobuko Yoshida  
  StreamQL: A Query Language for Processing Streaming Time Series. Lingkun Kong and Konstantinos Mamouras  
  Towards a Formal Foundation of Intermittent Computing. Milijana Surbatovich, Brandon Lucia, and Limin Jia  
  Unifying Execution of Imperative Generators and Declarative Specifications. Pengyu Nie, Marinela Parovic, Zhiqiang Zang, Sarfraz Khurshid, Aleksandar Milicevic, and Milos Gligoric  
</description>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>be85a0e9-8c1b-4f55-bde3-0b2e0afac1cc</subevent_id>
    <title>SPLASH Keynotes: S</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>5f9f92fa-5e48-46f1-887c-a26b9c581986</slot_id>
      <title>Session: SPLASH Keynotes - S</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>19:20</start_time>
      <end_time>20:20</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3f629580-500b-4082-ad17-53b871f536f9</slot_id>
      <event_id>a5f428b0-d93e-412f-a7d4-36adba3203c1</event_id>
      <title>Fitzcarraldo — or How to Hack Academia to Build Stuff</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>19:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>20:20</end_time>
      <description>What does a movie about a monomaniacal quest to build an opera house in the Amazon Basin has to do with science? Programming language research is at a crossroads. While formal language techniques are advancing steadily, the transfer of ideas to practice is much slower. Applied research is based on experimentation which is becoming prohibitively onerous. To evaluate any novel idea requires dealing with the complex language ecosystems of the day. Even the simplest innovation may take years of work to try out. Without a realistic evaluation, papers are rejected, and underlying hypotheses remain untested. Academic researchers are in a particularly precarious position. On the one hand, they must compete with industrial R&amp;amp;D teams with massively more resources, and on the other hand, they are beholden to an incentive system that rewards copious publication rates at select conferences. How can we build stuff that matters in such an environment? Are we doomed to failure? In this talk I argue that trying to build stuff is the necessary starting point, failure is expected and should be embraced, as, without it, we are not working on anything that matters. Based on my experience it is possible to navigate the academic system and come up with ideas that occasionally matter. 
This talk is given by the recipient of the Dahl Nygaard Senior prize. 
The AMA following this talk will be moderated by Sophia Drossopoulou.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University, USA / Czech Technical University, Czechia</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>eabe7236-c150-48bb-8409-7d5c24794427</subevent_id>
    <title>SPLASH Keynotes: W</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>622169a6-26f7-47ce-a4ca-37dd03d39c59</slot_id>
      <title>Session: SPLASH Keynotes - W</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Hridesh</first_name>
          <last_name>Rajan</last_name>
          <affiliation>Iowa State University, USA</affiliation>
          <bio>Hridesh Rajan is a Professor and Chair of Computer Science at Iowa State University, where he has been since 2005. Professor Rajan earned his MS and Ph.D. from the University of Virginia in 2004 and 2005 respectively. Professor Rajan’s recent research and educational activities are aimed at decreasing the barrier to entry to data-driven sciences to broaden participation. His work on the Boa project is aimed at the invention and refinement of programming languages and cyberinfrastructures that democratize data-driven science &amp;amp; engineering, including software engineering. His work on the Midwest Big Data Summer School is experimenting with broadly accessible data science curricula. Professor Rajan was the founding general chair of the Midwest Big Data Summer School. Professor Rajan’s research interests also include programming language design and implementation, and software engineering. He leads two research projects: Panini, whose goals are to enable modular reasoning about concurrent programs, and Boa that was established in Summer 2012 as an end-to-end infrastructure for analyzing large-scale software repositories and other open data sets. Professor Rajan is the director of the Laboratory for Software Design at Iowa State University, director of graduate admissions and recruitment for the Department of Computer Science. He serves as the department chair of the Department of Computer Science and served as the Professor-In-Charge of the Data Science education programs at Iowa State University from 2017-2019, and chair of the information technology committee for the university from 2015-2019. Professor Rajan served on the steering committee of the Midwest Big Data Hub, a consortium of universities in the Midwest region of the United States focused on promoting data science activities. Professor Rajan is a recipient of the National Science Foundation CAREER award in 2009, LAS Award for Early Achievement in Research in 2010, a Big-12 Fellowship in 2012. He is a 2018-19 Fulbright U.S. Scholar, a distinguished member of the ACM, and a member of IEEE, and AAAS. He is also the inaugural holder of the Kingland Professorship in the Department of Computer Science.</bio>
          <homepage_url>https://hridesh.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hrideshrajan/f57a0842-20af-4fd4-b79f-5d673c2c485c/small.jpg</picture_url>
          <person_id>hrideshrajan</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d7369bc9-e0dc-49a7-add9-56eb88b344fb</slot_id>
      <event_id>524d2a59-9a05-498f-879b-750d10430c79</event_id>
      <title>Models and Programs: Better Together</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>10:20</end_time>
      <description>Over the past decade, we have seen ubiquitous adoption of Machine Learning (ML) models across many different application domains. In this talk, we explore the connections between ML models and programs, and argue that there are significant advantages in combining ML models with programmatic representations. We present results from our work across different Machine Learning approaches in support of this hypothesis, including Supervised Learning, Bayesian Learning, and Reinforcement Learning. In each case, we show advantages in constructing human readable and interpretable programmatic representations of ML models, and in combining tools and techniques from program analysis and program synthesis with machine learning. We conclude with opportunities in using programming language techniques to make ML models efficient, robust, interpretable, and verifiable.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Sriram</first_name>
          <last_name>Rajamani</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Sriram Rajamani is Distinguished Scientist and Managing Director of Microsoft Research India. His research interests are in designing, building and analyzing computer systems in a principled manner. Over the years he has worked on various topics including Hardware and Software Verification, Type Systems, Language Design, Distributed Systems, Security and Privacy. His current research interest is in combining Program Synthesis and Machine Learning. Together with Tom Ball, he was awarded the CAV 2011 Award for “contributions to software model checking, specifically the development of the SLAM/SDV software model checker that successfully demonstrated computer-aided verification techniques on real programs.” Sriram was elected ACM Fellow in 2015 for contributions to software analysis and defect detection. Recently, Sriram has been elected Fellow of Indian National Academy of Engineering. Sriram has a PhD from UC Berkeley, MS from University of Virginia and BEng from College of Engineering, Guindy, all with specialization in Computer Science. Sriram was general chair for POPL 2015 in India, and was program Co-Chair for CAV 2005. He co-founded the Mysore Park Series, and the ISEC conference series in India. He serves on the CACM editorial board as co-chair for special regional sections, to bring computing innovations from around the world to CACM.</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/sriram/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sriramrajamani/85dbb2f3-41e7-493b-af72-d9a3338eea4e/small.jpg</picture_url>
          <person_id>sriramrajamani</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1cd0c692-fba3-49a0-9132-ecff862e1b04</subevent_id>
    <title>SPLASH Keynotes: T</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>9d400dfc-ade8-42ec-8d5f-de93b8ce0e0c</slot_id>
      <title>Session: SPLASH Keynotes - T</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>19:00</start_time>
      <end_time>20:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Steve</first_name>
          <last_name>Blackburn</last_name>
          <affiliation>Australian National University</affiliation>
          <bio>My research interests are centered on the challenge of making software run faster and more power-efficiently on modern hardware. My primary interests include: microarchitectural support for managed languages, fast and efficient garbage collection, and the design and implementation of virtual machines. As a backdrop to this I have a longstanding interest in role of sound methodology and infrastructure in successful research innovation.</bio>
          <homepage_url>http://users.cecs.anu.edu.au/~steveb/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/steveblackburn/1deee732-405d-4403-a974-a418751399c2/small.jpg</picture_url>
          <person_id>steveblackburn</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5410aa9a-4256-46d1-8f83-72b488706446</slot_id>
      <event_id>d9dc8414-a9f1-4c0d-8f5f-a8619dba3298</event_id>
      <title>Testing Deep Neural Networks</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>20:20</end_time>
      <description>The reliability of software that has a Deep Neural Network (DNN) as a component is urgently important today given the increasing number of critical applications being deployed with DNNs. The need for reliability raises a need for rigorous testing of the safety and trustworthiness of these systems. In the last few years, there have been a number of research efforts focused on testing DNNs. However, the test generation techniques proposed so far lack a check to determine whether the test inputs they are generating are valid, and thus invalid inputs are produced. To illustrate this situation, we explored three recent DNN testing techniques. Using deep generative model based input validation, we show that all the three techniques generate significant number of invalid test inputs. We further analyzed the test coverage achieved by the test inputs generated by the DNN testing techniques and showed how invalid test inputs can falsely inflate test coverage metrics. To overcome the inclusion of invalid inputs in testing, we propose a technique to incorporate the valid input space of the DNN model under test in the test generation process. Our technique uses a deep generative model-based algorithm to generate only valid inputs. Results of our empirical studies show that our technique is effective in eliminating invalid tests and boosting the number of valid test inputs generated.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Mary</first_name>
          <last_name>Lou Soffa</last_name>
          <affiliation>University of Virginia</affiliation>
          <bio>Mary Lou Ehnot Soffa is the Owen R. Cheatham Professor of Sciences at the Computer Science Department at the University of Virginia. From 2004 to 2012, she served as the Department Chair at UVA.&amp;nbsp; From 1977 to 2004, she was a Professor of Computer Science at the University of Pittsburgh and also served as the Dean of Graduate Studies in the College of Arts and Sciences from 1991 to 1996. Her research interests include optimizing compilers, virtual execution environments, software testing, program analysis, software security,&amp;nbsp; and software systems for multi-core architectures.&amp;nbsp; She has published over 175 articles and&amp;nbsp; has directed 32 Ph.D. students to completion, half of whom are women.&amp;nbsp; Mary Lou is both&amp;nbsp; an IEEE Fellow and&amp;nbsp; an ACM Fellow. She&amp;nbsp; received the Anita Borg Technical Leadership Award, the Ken Kennedy Award and the Computing Research Association (CRA) Nico Habermann Award.</bio>
          <homepage_url>http://www.cs.virginia.edu/~soffa</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/marylousoffa/40ba6646-fc3d-49d6-937a-c663f01f3942/small.jpg</picture_url>
          <person_id>marylousoffa</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ad16110e-1ba7-4dca-8cfb-17d68d6f5943</subevent_id>
    <title>SPLASH Keynotes: F</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>cef981a6-517a-4855-9161-df5ee9cda560</slot_id>
      <title>Session: SPLASH Keynotes - F</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Kell</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.kent.ac.uk/people/staff/srk21</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stephenkell/53088184-3e8c-4a2c-b34f-b2a290cff411/small.jpg</picture_url>
          <person_id>stephenkell</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Didier</first_name>
          <last_name>Verna</last_name>
          <affiliation>EPITA / LRDE</affiliation>
          <bio>Didier Verna has a Ph.D. and an habilitation in Computer Science, and is currently working as a professor for EPITA, a private Computer Science university located in Paris. He gives or has given lectures on Operating Systems, Computer Graphics, Object-Oriented, Functional Programming and Typesetting. His main research interests are multi-paradigm approaches to genericity and performance. 
Didier Verna is the president of the European Lisp Symposium steering committee and serves or has served as a program committee member in various conferences (International Lisp Conference, European Lisp Symposium, Dynamic Languages Symposium, ACM Symposium on Applied Computing, Onward!, Context-Oriented Programming workshop etc. ). 
Didier Verna is also quite involved in free software: he was one of the core maintainers of XEmacs for more than 15 years, a contributor to Gnus and BBDB, and an occasional contributor to other Free Software projects (the GNU Autotools most notably; he was one of the technical reviewers for the “Goat Book”). He is the author of several LaTeX packages and Common Lisp libraries. 
All of this is in fact half-true: two days a week, Didier Verna drops his scientific hat and wears the semi-professional Jazz musician one instead (he has released 3 albums with his quartet). He also is a certified Aikido teacher, and gives coaching sessions on the theme “Aikido and Conflict Management” for large companies.</bio>
          <homepage_url>https://www.lrde.epita.fr/~didier</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/didierverna/854d6aef-85b1-4d6e-a0e3-fa0dc86e3927/small.jpg</picture_url>
          <person_id>didierverna</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3fffe650-d3ce-4dd7-9e02-fc4e926a5265</slot_id>
      <event_id>82b7b87c-7cf9-4eb4-b576-e5df43418f5e</event_id>
      <title>Towards Building Ethically-Sound Data-Driven Software</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>18:20</end_time>
      <description>More and more, society is augmenting and even replacing human decision-making with software. Often, the decisions that these software systems make are provided by machine learning models that have been integrated into the software. Despite the widespread use of these technologies, there Is still much we don’t understand about guaranteeing equitable, safe outcomes in practice. This is supported by numerous real-world examples that display the potential of these systems to behave in unexpected, undesirable ways that have negative impacts on society. To prevent these behaviors, we need support for improving how we design, build, analyze, and validate data-driven software with potential fairness or ethical concerns. In this talk, I will present recent research efforts in supporting the development of fair, ethically-sound data-driven software. I will also describe open problems in supporting ethical software development practices and ways we can potentially fill these gaps in practice. Overall, I will argue that enabling and ensuring software ethics requires an interdisciplinary approach to solving research challenges across computer science and throughout the data-driven software development pipeline.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Brittany</first_name>
          <last_name>Johnson</last_name>
          <affiliation>George Mason University</affiliation>
          <bio>I am an Assistant Professor in the Department of Computer Science at George Mason University. I am currently recruiting students to work in my lab! 
I received my Ph.D. in Computer Science from North Carolina State University (2017), after getting my B.A. in Computer Science from the College of Charleston (2011). My research focuses on improving developer productivity and satisfaction through evaluating and improving the tools and processes they use to develop software. My current focus is on software fairness and ethical software engineering practices. My research is interdisciplinary, cross-cutting with research in software engineering, human-computer interaction, and machine learning. 
Outside of work, I enjoy doing anything that allows me to be creative. From painting on canvas to painting my nails, I love to express myself! I also have a passion for mentoring and encouraging others to reach for the stars (while never forgetting who you are or where you started).</bio>
          <homepage_url>http://brittjay.me</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brittanyjohnson/0f798300-3acb-4bd2-b6cc-ad6e59fe7007/small.jpg</picture_url>
          <person_id>brittanyjohnson</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d2d2d500-9881-4de9-8227-88aca395b599</subevent_id>
    <title>SPLASH Keynotes: M</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>aff4a4fd-bedd-4aed-a046-9c3f1f6502d4</slot_id>
      <title>Session: SPLASH Keynotes - M</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2124306f-4801-478c-8b45-c74b16b934c0</slot_id>
      <event_id>48b85f95-7161-4225-83e8-da63006ee69c</event_id>
      <title>Catching More Bugs with Fewer False Alarms</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>10:20</end_time>
      <description>The line between high-assurance and general-purpose software is increasingly blurred, as nowadays nearly any insecure or buggy software can have severe economic consequences. When developers release software, it is critical that there be as few defects (and vulnerabilities) as possible. To check the quality of their code, developers typically write and run test cases, and some may also use static analyses that inspect their code. Yet code is still released with bugs and critical vulnerabilities: testing can not prove the absence of defects, and static analyses often overwhelm developers with false positive reports, making them difficult for the average developer to use. I argue that new dynamic program analyses can act as a force multiplier for developers’ test suites: increasing the number of defects that tests can find without burdening developers with false positive reports. In this talk, I will describe some of my recent work building dynamic analysis systems for taint tracking and checkpointing of JVM-based systems, along with several examples of how these analyses can be integrated with developer-written tests to improve the reliability and fault finding power of those tests. 
This talk is given by the recipient of the Dahl Nygaard Junior prize. 
The AMA following this talk will be moderated by Gail Kaiser and Darko Marinov.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Bell</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>Jon is an Assistant Professor directing research in Software Engineering and Software Systems at Northeastern University. His research makes it easier for developers to create reliable and secure software by improving software testing and program analysis. Jon’s work on accelerating software testing has been recognized with an ACM SIGSOFT Distinguished Paper Award (ICSE ’14 – Unit Test Virtualization with VMVM), and was the basis for an industrial collaboration with Electric Cloud. His program analysis research has resulted in several widely adopted runtime systems for the JVM, including the Phosphor taint tracking system (OOPSLA ’14) and CROCHET checkpoint/rollback tool (ECOOP ’18). His research has been funded by the NSA and the NSF, and he is the recipient of the NSF CAREER award. At George Mason, Jon taught courses in distributed systems, web development, and program analysis. His teaching at GMU has been recognized with a departmental award. Jon serves on a variety of program committees and was recently co-chair of the PLDI 2020 Artifact Evaluation Committee. As part of his efforts to broaden the participation of underrepresented groups in computing, Jon co-organizes the PL/SE mentoring workshop at SPLASH (in 2017, 2018, 2019 and 2020).</bio>
          <homepage_url>http://jonbell.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanbell/1ef3641d-0ed6-4021-aab6-b13b53962e3d/small.jpg</picture_url>
          <person_id>jonathanbell</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b74572a3-95d1-41a7-982e-9e2d01dc8ef5</subevent_id>
    <title>SPLASH Keynotes: R</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>9970eaef-2167-4135-8666-3e849884b75f</slot_id>
      <title>Session: SPLASH Keynotes - R</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>19:00</start_time>
      <end_time>20:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Grove</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>I am a Distinguished Research Staff Member at the IBM T.J. Watson Research Center. I joined IBM Research in 1998 after completing my PhD at the University of Washington. I am a software systems researcher, working primarily on problems in programming language implementation and scalable runtime systems. 
I have contributed to a number of technical topics in programming language design and implementation including the analysis and optimization of object-oriented languages, virtual machine design and implementation, scalable runtime systems, Just-In-Time compilation, online feedback-directed optimization, and garbage collection.</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-groved</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidgrove/5524049e-7d0a-4799-ad8c-93e1e76a77ec/small.jpg</picture_url>
          <person_id>davidgrove</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cb7b9dbf-7f9c-4bc1-a1db-73139f05dcc8</slot_id>
      <event_id>f92281cc-89bc-4c25-a94f-18dd4bb6f87f</event_id>
      <title>Why Digital Agriculture is Fertile Ground for Software Systems Research</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>20:20</end_time>
      <description>In this talk, I will try to make a case that more computer systems researchers, including those working on programming languages and software systems, should look for new research opportunities in the field of Digital Agriculture. I will start by describing briefly several examples of broad computing challenges in this field. I will then drill deeper into a few specific examples of past or ongoing software systems projects, both from our research and that of other research groups, where new research was needed to solve important digital agriculture challenges. I will briefly discuss a wide range of federal funding opportunities available for collaborative research spanning Computer Science and many different aspects of agriculture. The key observation is that digital agriculture raises difficult and interesting research challenges for Computer Science researchers in general, and software systems researchers in particular.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Vikram S.</first_name>
          <last_name>Adve</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>Vikram Adve is the Donald B. Gillies Professor of Computer Science at the University of Illinois at Urbana-Champaign and a Professor in Electrical and Computer Engineering. He is a Co-founder and Co-Director of the Center for Digital Agriculture and leads AIFARMS, a $20M National Artificial Intelligence Research Institute funded by NIFA and NSF. Adve’s research interests lie in developing and using compiler techniques to improve the performance, programmability and reliability of computer systems. Adve and his Ph.D. student, Chris Lattner, co-designed the LLVM Compiler Infrastructure, which enables a novel approach to “lifelong compilation” of programs in a wide range of general-purpose programming languages. For example, most mobile apps for the iPhone, iPad, Apple Watch and Apple TV are shipped by developers to Apple in the LLVM compiler representation called “LLVM bitcode” and then compiled and specialized for the various end-user devices. LLVM is widely used in industry today, ranging from mobile devices (e.g., iOS and Android) to supercomputers (e.g., at NVIDIA, Cray, IBM and Intel) to data centers (e.g., at Google). Adve, Lattner and Evan Cheng received the ACM Software System Award in 2012 for co-developing LLVM. Adve has won a ten-year-retrospective Most Influential Paper award at CGO 2004, and distinguished paper awards at several conferences including PLDI 2005, SOSP 2007 and ICSE 2011. He has served as the Associate Editor for the ACM Transactions on Programming Languages and Systems, and co-chaired the Program Committees for ASPLOS 2010, VEE 2008, and LCPC 2007. One of Adve’s Ph.D. students, Robert Bocchino, won the 2010 ACM SIGPLAN Outstanding Dissertation Award and another student, John Criswell, won Honorable Mentions for both the 2014 ACM SIGOPS Dissertation Award and the 2014 ACM Doctoral Dissertation Award. Adve is a Fellow of the ACM and was named a University Scholar at the University of Illinois in 2015. He served as Interim Head of the Computer Science Department from 2017 to 2019.</bio>
          <homepage_url>http://vikram.cs.illinois.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vikramadve/a99a9248-20e3-4738-9200-173c353c5fcb/small.jpg</picture_url>
          <person_id>vikramadve</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>17c79bfd-eaa8-4fbd-bd79-2bd74a37b002</subevent_id>
    <title>SPLASH Keynotes: M</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>6736f291-7c9f-4565-b8cb-b766bbe9b118</slot_id>
      <title>Session: SPLASH Keynotes - M</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>21:00</start_time>
      <end_time>22:20</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5ffd6ef4-f021-4a93-890b-ae1e8c9cd6c8</slot_id>
      <event_id>48b85f95-7161-4225-83e8-da63006ee69c</event_id>
      <title>Catching More Bugs with Fewer False Alarms</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>22:20</end_time>
      <description>The line between high-assurance and general-purpose software is increasingly blurred, as nowadays nearly any insecure or buggy software can have severe economic consequences. When developers release software, it is critical that there be as few defects (and vulnerabilities) as possible. To check the quality of their code, developers typically write and run test cases, and some may also use static analyses that inspect their code. Yet code is still released with bugs and critical vulnerabilities: testing can not prove the absence of defects, and static analyses often overwhelm developers with false positive reports, making them difficult for the average developer to use. I argue that new dynamic program analyses can act as a force multiplier for developers’ test suites: increasing the number of defects that tests can find without burdening developers with false positive reports. In this talk, I will describe some of my recent work building dynamic analysis systems for taint tracking and checkpointing of JVM-based systems, along with several examples of how these analyses can be integrated with developer-written tests to improve the reliability and fault finding power of those tests. 
This talk is given by the recipient of the Dahl Nygaard Junior prize. 
The AMA following this talk will be moderated by Gail Kaiser and Darko Marinov.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Bell</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>Jon is an Assistant Professor directing research in Software Engineering and Software Systems at Northeastern University. His research makes it easier for developers to create reliable and secure software by improving software testing and program analysis. Jon’s work on accelerating software testing has been recognized with an ACM SIGSOFT Distinguished Paper Award (ICSE ’14 – Unit Test Virtualization with VMVM), and was the basis for an industrial collaboration with Electric Cloud. His program analysis research has resulted in several widely adopted runtime systems for the JVM, including the Phosphor taint tracking system (OOPSLA ’14) and CROCHET checkpoint/rollback tool (ECOOP ’18). His research has been funded by the NSA and the NSF, and he is the recipient of the NSF CAREER award. At George Mason, Jon taught courses in distributed systems, web development, and program analysis. His teaching at GMU has been recognized with a departmental award. Jon serves on a variety of program committees and was recently co-chair of the PLDI 2020 Artifact Evaluation Committee. As part of his efforts to broaden the participation of underrepresented groups in computing, Jon co-organizes the PL/SE mentoring workshop at SPLASH (in 2017, 2018, 2019 and 2020).</bio>
          <homepage_url>http://jonbell.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanbell/1ef3641d-0ed6-4021-aab6-b13b53962e3d/small.jpg</picture_url>
          <person_id>jonathanbell</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a5158b9d-2145-45a9-94e1-46104667ee3c</subevent_id>
    <title>SPLASH Keynotes: S</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>9c34d67b-301a-4ed8-bedb-ad867d606bb3</slot_id>
      <title>Session: SPLASH Keynotes - S</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>07:20</start_time>
      <end_time>08:20</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bde0f112-ddc4-4beb-af9c-07d84d408c35</slot_id>
      <event_id>a5f428b0-d93e-412f-a7d4-36adba3203c1</event_id>
      <title>Fitzcarraldo — or How to Hack Academia to Build Stuff</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>07:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>08:20</end_time>
      <description>What does a movie about a monomaniacal quest to build an opera house in the Amazon Basin has to do with science? Programming language research is at a crossroads. While formal language techniques are advancing steadily, the transfer of ideas to practice is much slower. Applied research is based on experimentation which is becoming prohibitively onerous. To evaluate any novel idea requires dealing with the complex language ecosystems of the day. Even the simplest innovation may take years of work to try out. Without a realistic evaluation, papers are rejected, and underlying hypotheses remain untested. Academic researchers are in a particularly precarious position. On the one hand, they must compete with industrial R&amp;amp;D teams with massively more resources, and on the other hand, they are beholden to an incentive system that rewards copious publication rates at select conferences. How can we build stuff that matters in such an environment? Are we doomed to failure? In this talk I argue that trying to build stuff is the necessary starting point, failure is expected and should be embraced, as, without it, we are not working on anything that matters. Based on my experience it is possible to navigate the academic system and come up with ideas that occasionally matter. 
This talk is given by the recipient of the Dahl Nygaard Senior prize. 
The AMA following this talk will be moderated by Sophia Drossopoulou.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University, USA / Czech Technical University, Czechia</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>489d5c0e-7f24-40c3-bd23-7fc717422246</subevent_id>
    <title>SPLASH Keynotes: W</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>8ed6fc7d-cb9c-4434-a445-af59ca18cf4f</slot_id>
      <title>Session: SPLASH Keynotes - W</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>21:00</start_time>
      <end_time>22:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Hridesh</first_name>
          <last_name>Rajan</last_name>
          <affiliation>Iowa State University, USA</affiliation>
          <bio>Hridesh Rajan is a Professor and Chair of Computer Science at Iowa State University, where he has been since 2005. Professor Rajan earned his MS and Ph.D. from the University of Virginia in 2004 and 2005 respectively. Professor Rajan’s recent research and educational activities are aimed at decreasing the barrier to entry to data-driven sciences to broaden participation. His work on the Boa project is aimed at the invention and refinement of programming languages and cyberinfrastructures that democratize data-driven science &amp;amp; engineering, including software engineering. His work on the Midwest Big Data Summer School is experimenting with broadly accessible data science curricula. Professor Rajan was the founding general chair of the Midwest Big Data Summer School. Professor Rajan’s research interests also include programming language design and implementation, and software engineering. He leads two research projects: Panini, whose goals are to enable modular reasoning about concurrent programs, and Boa that was established in Summer 2012 as an end-to-end infrastructure for analyzing large-scale software repositories and other open data sets. Professor Rajan is the director of the Laboratory for Software Design at Iowa State University, director of graduate admissions and recruitment for the Department of Computer Science. He serves as the department chair of the Department of Computer Science and served as the Professor-In-Charge of the Data Science education programs at Iowa State University from 2017-2019, and chair of the information technology committee for the university from 2015-2019. Professor Rajan served on the steering committee of the Midwest Big Data Hub, a consortium of universities in the Midwest region of the United States focused on promoting data science activities. Professor Rajan is a recipient of the National Science Foundation CAREER award in 2009, LAS Award for Early Achievement in Research in 2010, a Big-12 Fellowship in 2012. He is a 2018-19 Fulbright U.S. Scholar, a distinguished member of the ACM, and a member of IEEE, and AAAS. He is also the inaugural holder of the Kingland Professorship in the Department of Computer Science.</bio>
          <homepage_url>https://hridesh.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hrideshrajan/f57a0842-20af-4fd4-b79f-5d673c2c485c/small.jpg</picture_url>
          <person_id>hrideshrajan</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ab61fe80-20f5-4202-933b-00648b3a1b7f</slot_id>
      <event_id>524d2a59-9a05-498f-879b-750d10430c79</event_id>
      <title>Models and Programs: Better Together</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>22:20</end_time>
      <description>Over the past decade, we have seen ubiquitous adoption of Machine Learning (ML) models across many different application domains. In this talk, we explore the connections between ML models and programs, and argue that there are significant advantages in combining ML models with programmatic representations. We present results from our work across different Machine Learning approaches in support of this hypothesis, including Supervised Learning, Bayesian Learning, and Reinforcement Learning. In each case, we show advantages in constructing human readable and interpretable programmatic representations of ML models, and in combining tools and techniques from program analysis and program synthesis with machine learning. We conclude with opportunities in using programming language techniques to make ML models efficient, robust, interpretable, and verifiable.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Sriram</first_name>
          <last_name>Rajamani</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Sriram Rajamani is Distinguished Scientist and Managing Director of Microsoft Research India. His research interests are in designing, building and analyzing computer systems in a principled manner. Over the years he has worked on various topics including Hardware and Software Verification, Type Systems, Language Design, Distributed Systems, Security and Privacy. His current research interest is in combining Program Synthesis and Machine Learning. Together with Tom Ball, he was awarded the CAV 2011 Award for “contributions to software model checking, specifically the development of the SLAM/SDV software model checker that successfully demonstrated computer-aided verification techniques on real programs.” Sriram was elected ACM Fellow in 2015 for contributions to software analysis and defect detection. Recently, Sriram has been elected Fellow of Indian National Academy of Engineering. Sriram has a PhD from UC Berkeley, MS from University of Virginia and BEng from College of Engineering, Guindy, all with specialization in Computer Science. Sriram was general chair for POPL 2015 in India, and was program Co-Chair for CAV 2005. He co-founded the Mysore Park Series, and the ISEC conference series in India. He serves on the CACM editorial board as co-chair for special regional sections, to bring computing innovations from around the world to CACM.</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/sriram/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sriramrajamani/85dbb2f3-41e7-493b-af72-d9a3338eea4e/small.jpg</picture_url>
          <person_id>sriramrajamani</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>cf72f105-5a07-4e32-9ad6-63560feb3883</subevent_id>
    <title>SPLASH Keynotes: R</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>6ef37ff2-e0f1-47f7-aafa-a4260b2084ab</slot_id>
      <title>Session: SPLASH Keynotes - R</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>07:00</start_time>
      <end_time>08:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Grove</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>I am a Distinguished Research Staff Member at the IBM T.J. Watson Research Center. I joined IBM Research in 1998 after completing my PhD at the University of Washington. I am a software systems researcher, working primarily on problems in programming language implementation and scalable runtime systems. 
I have contributed to a number of technical topics in programming language design and implementation including the analysis and optimization of object-oriented languages, virtual machine design and implementation, scalable runtime systems, Just-In-Time compilation, online feedback-directed optimization, and garbage collection.</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-groved</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidgrove/5524049e-7d0a-4799-ad8c-93e1e76a77ec/small.jpg</picture_url>
          <person_id>davidgrove</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>51acb071-0fd1-46b3-b96b-af479bc68e29</slot_id>
      <event_id>f92281cc-89bc-4c25-a94f-18dd4bb6f87f</event_id>
      <title>Why Digital Agriculture is Fertile Ground for Software Systems Research</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>08:20</end_time>
      <description>In this talk, I will try to make a case that more computer systems researchers, including those working on programming languages and software systems, should look for new research opportunities in the field of Digital Agriculture. I will start by describing briefly several examples of broad computing challenges in this field. I will then drill deeper into a few specific examples of past or ongoing software systems projects, both from our research and that of other research groups, where new research was needed to solve important digital agriculture challenges. I will briefly discuss a wide range of federal funding opportunities available for collaborative research spanning Computer Science and many different aspects of agriculture. The key observation is that digital agriculture raises difficult and interesting research challenges for Computer Science researchers in general, and software systems researchers in particular.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Vikram S.</first_name>
          <last_name>Adve</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>Vikram Adve is the Donald B. Gillies Professor of Computer Science at the University of Illinois at Urbana-Champaign and a Professor in Electrical and Computer Engineering. He is a Co-founder and Co-Director of the Center for Digital Agriculture and leads AIFARMS, a $20M National Artificial Intelligence Research Institute funded by NIFA and NSF. Adve’s research interests lie in developing and using compiler techniques to improve the performance, programmability and reliability of computer systems. Adve and his Ph.D. student, Chris Lattner, co-designed the LLVM Compiler Infrastructure, which enables a novel approach to “lifelong compilation” of programs in a wide range of general-purpose programming languages. For example, most mobile apps for the iPhone, iPad, Apple Watch and Apple TV are shipped by developers to Apple in the LLVM compiler representation called “LLVM bitcode” and then compiled and specialized for the various end-user devices. LLVM is widely used in industry today, ranging from mobile devices (e.g., iOS and Android) to supercomputers (e.g., at NVIDIA, Cray, IBM and Intel) to data centers (e.g., at Google). Adve, Lattner and Evan Cheng received the ACM Software System Award in 2012 for co-developing LLVM. Adve has won a ten-year-retrospective Most Influential Paper award at CGO 2004, and distinguished paper awards at several conferences including PLDI 2005, SOSP 2007 and ICSE 2011. He has served as the Associate Editor for the ACM Transactions on Programming Languages and Systems, and co-chaired the Program Committees for ASPLOS 2010, VEE 2008, and LCPC 2007. One of Adve’s Ph.D. students, Robert Bocchino, won the 2010 ACM SIGPLAN Outstanding Dissertation Award and another student, John Criswell, won Honorable Mentions for both the 2014 ACM SIGOPS Dissertation Award and the 2014 ACM Doctoral Dissertation Award. Adve is a Fellow of the ACM and was named a University Scholar at the University of Illinois in 2015. He served as Interim Head of the Computer Science Department from 2017 to 2019.</bio>
          <homepage_url>http://vikram.cs.illinois.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vikramadve/a99a9248-20e3-4738-9200-173c353c5fcb/small.jpg</picture_url>
          <person_id>vikramadve</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d9e93da5-aa31-453c-bfaa-4db6ce80f7bc</subevent_id>
    <title>SPLASH Keynotes: T</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>70b51a47-9cfa-4d0b-8f8e-89c409a29164</slot_id>
      <title>Session: SPLASH Keynotes - T</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>07:00</start_time>
      <end_time>08:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Steve</first_name>
          <last_name>Blackburn</last_name>
          <affiliation>Australian National University</affiliation>
          <bio>My research interests are centered on the challenge of making software run faster and more power-efficiently on modern hardware. My primary interests include: microarchitectural support for managed languages, fast and efficient garbage collection, and the design and implementation of virtual machines. As a backdrop to this I have a longstanding interest in role of sound methodology and infrastructure in successful research innovation.</bio>
          <homepage_url>http://users.cecs.anu.edu.au/~steveb/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/steveblackburn/1deee732-405d-4403-a974-a418751399c2/small.jpg</picture_url>
          <person_id>steveblackburn</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6e91ccd5-704d-45e4-a55b-c074850498c1</slot_id>
      <event_id>d9dc8414-a9f1-4c0d-8f5f-a8619dba3298</event_id>
      <title>Testing Deep Neural Networks</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>08:20</end_time>
      <description>The reliability of software that has a Deep Neural Network (DNN) as a component is urgently important today given the increasing number of critical applications being deployed with DNNs. The need for reliability raises a need for rigorous testing of the safety and trustworthiness of these systems. In the last few years, there have been a number of research efforts focused on testing DNNs. However, the test generation techniques proposed so far lack a check to determine whether the test inputs they are generating are valid, and thus invalid inputs are produced. To illustrate this situation, we explored three recent DNN testing techniques. Using deep generative model based input validation, we show that all the three techniques generate significant number of invalid test inputs. We further analyzed the test coverage achieved by the test inputs generated by the DNN testing techniques and showed how invalid test inputs can falsely inflate test coverage metrics. To overcome the inclusion of invalid inputs in testing, we propose a technique to incorporate the valid input space of the DNN model under test in the test generation process. Our technique uses a deep generative model-based algorithm to generate only valid inputs. Results of our empirical studies show that our technique is effective in eliminating invalid tests and boosting the number of valid test inputs generated.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Mary</first_name>
          <last_name>Lou Soffa</last_name>
          <affiliation>University of Virginia</affiliation>
          <bio>Mary Lou Ehnot Soffa is the Owen R. Cheatham Professor of Sciences at the Computer Science Department at the University of Virginia. From 2004 to 2012, she served as the Department Chair at UVA.&amp;nbsp; From 1977 to 2004, she was a Professor of Computer Science at the University of Pittsburgh and also served as the Dean of Graduate Studies in the College of Arts and Sciences from 1991 to 1996. Her research interests include optimizing compilers, virtual execution environments, software testing, program analysis, software security,&amp;nbsp; and software systems for multi-core architectures.&amp;nbsp; She has published over 175 articles and&amp;nbsp; has directed 32 Ph.D. students to completion, half of whom are women.&amp;nbsp; Mary Lou is both&amp;nbsp; an IEEE Fellow and&amp;nbsp; an ACM Fellow. She&amp;nbsp; received the Anita Borg Technical Leadership Award, the Ken Kennedy Award and the Computing Research Association (CRA) Nico Habermann Award.</bio>
          <homepage_url>http://www.cs.virginia.edu/~soffa</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/marylousoffa/40ba6646-fc3d-49d6-937a-c663f01f3942/small.jpg</picture_url>
          <person_id>marylousoffa</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>aa933de0-b7be-4679-951e-064a37c0c76f</subevent_id>
    <title>SPLASH Keynotes: F</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>0549fd29-95dd-43c5-b529-09083703c6c6</slot_id>
      <title>Session: SPLASH Keynotes - F</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Kell</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.kent.ac.uk/people/staff/srk21</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stephenkell/53088184-3e8c-4a2c-b34f-b2a290cff411/small.jpg</picture_url>
          <person_id>stephenkell</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Didier</first_name>
          <last_name>Verna</last_name>
          <affiliation>EPITA / LRDE</affiliation>
          <bio>Didier Verna has a Ph.D. and an habilitation in Computer Science, and is currently working as a professor for EPITA, a private Computer Science university located in Paris. He gives or has given lectures on Operating Systems, Computer Graphics, Object-Oriented, Functional Programming and Typesetting. His main research interests are multi-paradigm approaches to genericity and performance. 
Didier Verna is the president of the European Lisp Symposium steering committee and serves or has served as a program committee member in various conferences (International Lisp Conference, European Lisp Symposium, Dynamic Languages Symposium, ACM Symposium on Applied Computing, Onward!, Context-Oriented Programming workshop etc. ). 
Didier Verna is also quite involved in free software: he was one of the core maintainers of XEmacs for more than 15 years, a contributor to Gnus and BBDB, and an occasional contributor to other Free Software projects (the GNU Autotools most notably; he was one of the technical reviewers for the “Goat Book”). He is the author of several LaTeX packages and Common Lisp libraries. 
All of this is in fact half-true: two days a week, Didier Verna drops his scientific hat and wears the semi-professional Jazz musician one instead (he has released 3 albums with his quartet). He also is a certified Aikido teacher, and gives coaching sessions on the theme “Aikido and Conflict Management” for large companies.</bio>
          <homepage_url>https://www.lrde.epita.fr/~didier</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/didierverna/854d6aef-85b1-4d6e-a0e3-fa0dc86e3927/small.jpg</picture_url>
          <person_id>didierverna</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>23317518-977d-4bd3-b559-1371718c0031</slot_id>
      <event_id>82b7b87c-7cf9-4eb4-b576-e5df43418f5e</event_id>
      <title>Towards Building Ethically-Sound Data-Driven Software</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>06:20</end_time>
      <description>More and more, society is augmenting and even replacing human decision-making with software. Often, the decisions that these software systems make are provided by machine learning models that have been integrated into the software. Despite the widespread use of these technologies, there Is still much we don’t understand about guaranteeing equitable, safe outcomes in practice. This is supported by numerous real-world examples that display the potential of these systems to behave in unexpected, undesirable ways that have negative impacts on society. To prevent these behaviors, we need support for improving how we design, build, analyze, and validate data-driven software with potential fairness or ethical concerns. In this talk, I will present recent research efforts in supporting the development of fair, ethically-sound data-driven software. I will also describe open problems in supporting ethical software development practices and ways we can potentially fill these gaps in practice. Overall, I will argue that enabling and ensuring software ethics requires an interdisciplinary approach to solving research challenges across computer science and throughout the data-driven software development pipeline.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Brittany</first_name>
          <last_name>Johnson</last_name>
          <affiliation>George Mason University</affiliation>
          <bio>I am an Assistant Professor in the Department of Computer Science at George Mason University. I am currently recruiting students to work in my lab! 
I received my Ph.D. in Computer Science from North Carolina State University (2017), after getting my B.A. in Computer Science from the College of Charleston (2011). My research focuses on improving developer productivity and satisfaction through evaluating and improving the tools and processes they use to develop software. My current focus is on software fairness and ethical software engineering practices. My research is interdisciplinary, cross-cutting with research in software engineering, human-computer interaction, and machine learning. 
Outside of work, I enjoy doing anything that allows me to be creative. From painting on canvas to painting my nails, I love to express myself! I also have a passion for mentoring and encouraging others to reach for the stars (while never forgetting who you are or where you started).</bio>
          <homepage_url>http://brittjay.me</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brittanyjohnson/0f798300-3acb-4bd2-b6cc-ad6e59fe7007/small.jpg</picture_url>
          <person_id>brittanyjohnson</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>041fba4f-f5a3-4e86-90f0-200d2c3c2b06</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/15</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>9b7f0fcf-b9e8-4881-b431-09bceb693f22</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Friedrich</first_name>
          <last_name>Steimann</last_name>
          <affiliation>Fernuniversität</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/friedrichsteimann/0382f30a-7342-49a1-b2f6-cf7d0929220c/small.jpg</picture_url>
          <person_id>friedrichsteimann</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>22477a3d-2625-4c61-9d3b-9945828f38d4</slot_id>
      <event_id>77baa9ff-0f71-458a-b6de-9cff6f8a7642</event_id>
      <title>Principles and Patterns of JastAdd-Style Reference Attribute Grammars</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>14:20</end_time>
      <description>Reference attribute grammars (RAGs) have reached a level of maturity where they are supported by several tools, and have gained traction in both academic and industrial language tool development. However, despite a lot of accumulated knowledge of how to best develop RAGs in practice, there is limited support to guide practitioners. 
In this paper, we address this issue by focusing on one RAG tool, JastAdd, and by defining principles and patterns for development of RAGs with this tool. We evaluate the proposed principles and patterns with an exploratory empirical study with 14 practitioners, with a mix of beginners and experienced users from both academia and industry. The results indicate that the principles and patterns capture the practice of developing JastAdd RAGs well, help practitioners to become aware of useful patterns, and provide a common language to more efficiently reason about the practice of developing JastAdd RAGs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Niklas</first_name>
          <last_name>Fors</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.lth.se/niklas_fors</homepage_url>
          <person_id>niklasfors</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Emma</first_name>
          <last_name>Söderberg</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/emmasoderberg/7abc495e-ac1f-4cae-9f68-15a869dcb648/small.jpg</picture_url>
          <person_id>emmasoderberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Görel</first_name>
          <last_name>Hedin</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/gorelhedin1/889e8014-52c5-4f2f-949a-0f92539b1e59/small.jpg</picture_url>
          <person_id>gorelhedin1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5bcdeb7d-95d0-4a17-abc4-0e44ea5e0d57</slot_id>
      <event_id>4752652a-8405-4b5e-90da-50c7de7fada9</event_id>
      <title>Multi-Stage Programming in the Large with Staged Classes</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>13:20</end_time>
      <description>Multi-stage programming (MSP) holds great promise, allowing the reliable generation of specialized, partially-evaluated code with static type- and scope-safety guarantees. Yet, we argue that MSP has not reached its full potential yet, as it has been traditionally limited to generating expressions, and has lacked principled facilities for generating modular programs and data structures. In that sense, we argue that MSP has been reserved for programming “in the small,” focused on generating efficient kernels of computation on the scale of single function bodies. We present a novel technique called staged classes, which extends MSP with the ability to manipulate class definitions as first-class constructs. This lets programmers use MSP “in the large,” on the level of applications, rather than mere functions. This way, applications can be designed in an abstract and modular way without runtime cost, as staged classes guarantee the removal of all staging-time abstractions, resulting in the generation of efficient specialized modules and data structures. We describe the design of a prototype relational database system in Scala, which uses several stages of runtime compilation to maximize the efficiency of query execution and data storage. We also show that staged classes can be used for defining type- and scope-safe implementations of type providers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lionel</first_name>
          <last_name>Parreaux</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.epfl.ch/lionel.parreaux/?lang=en</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lionelparreaux/292d178a-af9d-419f-9e04-8a4672226fd5/small.jpg</picture_url>
          <person_id>lionelparreaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Amir</first_name>
          <last_name>Shaikhha</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <person_id>amirshaikhha</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>71848002-bf0d-4f39-ae47-abd73320dabb</slot_id>
      <event_id>0547992f-d9b7-49e0-b616-0dc25b5ef4a9</event_id>
      <title>Software Language Engineers’ Worst Nightmare</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>13:40</end_time>
      <description>Many techniques in software language engineering get their first validation by being prototyped to work on one particular language such as Java, Scala, Scheme, or ML, or a subset of such a language. Claims of their generalisability, as well as discussion on potential threats to their external validity, are often based on authors' ad hoc understanding of the world outside their usual comfort zone. To facilitate and simplify such discussions by providing a solid measurable ground, we propose a language called BabyCobol, which was specifically designed to contain features that turn processing legacy programming languages such as COBOL, FORTRAN, PL/I, REXX, CLIST, and 4GLs (fourth generation languages), into such a challenge. The language is minimal by design so that it can help to quickly find weaknesses in frameworks making them inapplicable to dealing with legacy software. However, applying new techniques of software language engineering and reverse engineering to such a small language will not be too tedious and overwhelming. BabyCobol was designed in collaboration with industrial compiler developers by systematically traversing features of several second, third and fourth generation languages to identify the core culprits in making development of compiler for legacy languages difficult.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vadim</first_name>
          <last_name>Zaytsev</last_name>
          <affiliation>University of Twente, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://grammarware.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vadimzaytsev/fe6c221f-75d5-4fbc-ac41-be9c99349b5d/small.jpg</picture_url>
          <person_id>vadimzaytsev</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>91217aa5-b689-49f8-9542-04728b000d7c</slot_id>
      <event_id>2959d666-0f62-48cd-88fd-eb2adec902b9</event_id>
      <title>Reorganizing queries with grouping</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>14:00</end_time>
      <description>Language-integrated query has attracted much attention from researchers and engineers. It enables one to write a database query with high-level abstractions, which makes it possible to compose, iterate, and reuse queries in a sophisticated way. Cheney et al. proposed a two-level language for this purpose, and succeeded in generating efficient queries by program transformation. Recently Okura et al. extended their language to cover grouping (GROUP BY) and aggregate functions in SQL. They decompose a query with grouping into a combination of small primitives and applies Cheney et al.’s translation to eliminate nested data structures. It works, but still has a problem; excessively large queries may sometimes be generated due to decomposition. 
This paper proposes a solution for this problem to complete the picture. Our key idea is re-organization of nested control structures. While Okura et al.’s decomposed form is useful while a query is being transformed by Cheney et al.’s transformation, it is not optimal when SQL queries are generated. We propose an algorithm to unify (or fuse) nested control structures while keeping the absence of nested data structures. An important issue is to avoid correlated subqueries, and our algorithm eliminates them as much as possible. We have applied our technique to various example queries, and conducted performance measurements, which shows the usefulness of our work.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rui</first_name>
          <last_name>Okura</last_name>
          <affiliation>University of Tsukuba</affiliation>
          <bio>undefined</bio>
          <person_id>ruiokura</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yukiyoshi</first_name>
          <last_name>Kameyama</last_name>
          <affiliation>University of Tsukuba, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tsukuba.ac.jp/~kam/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yukiyoshikameyama/a7ae9aee-0992-4ddf-ae1d-6fee59d9e814/small.jpg</picture_url>
          <person_id>yukiyoshikameyama</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d73f0e92-2474-4728-a5fa-ccbe3eb0a032</subevent_id>
    <title>GPCE: GPCE/SLE Opening</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/15</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
    </tracks>
    <timeslot>
      <slot_id>bcac1561-0316-4e2e-9841-c176e63d3980</slot_id>
      <title>Session: GPCE - GPCE/SLE Opening</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>21:00</start_time>
      <end_time>21:40</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Erwig</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.engr.oregonstate.edu/~erwig/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/martinerwig/8fd12ecd-2d70-44d3-a670-d5ef12393f9c/small.jpg</picture_url>
          <person_id>martinerwig</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Jeff</first_name>
          <last_name>Gray</last_name>
          <affiliation>University of Alabama</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gray.cs.ua.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeffgray/1f2fd602-bac6-49dd-86e4-549b5dc88528/small.jpg</picture_url>
          <person_id>jeffgray</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>3</sort_key>
          <first_name>Ralf</first_name>
          <last_name>Lämmel</last_name>
          <affiliation>Facebook London</affiliation>
          <bio>http://www.softlang.org/rlaemmel:bio</bio>
          <homepage_url>http://softlang.wikidot.com/rlaemmel:home</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ralflammel/bc00aec2-e243-40e0-be65-bf9e5e21b0be/small.jpg</picture_url>
          <person_id>ralflammel</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>4</sort_key>
          <first_name>Laurence</first_name>
          <last_name>Tratt</last_name>
          <affiliation>King's College London</affiliation>
          <bio>Programmer / researcher.</bio>
          <homepage_url>https://tratt.net/laurie/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/laurencetratt/f715fc31-2c46-4e48-9a13-d715343fdd4d/small.jpg</picture_url>
          <person_id>laurencetratt</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>5</sort_key>
          <first_name>Juan</first_name>
          <last_name>de Lara</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arantxa.ii.uam.es/~jlara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juandelara/36b5a702-1b04-48b9-8849-869aa603a88d/small.jpg</picture_url>
          <person_id>juandelara</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a12e44d0-227a-4e5d-b405-df9ec6c9afd3</slot_id>
      <event_id>bb9db12e-2afb-4297-aede-22b724436e5a</event_id>
      <title>GPCE/SLE Opening</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:40</end_time>
      <description>undefined</description>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a6e74c7d-e757-4163-94cf-25c2824d0b12</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/15</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>020c3f9a-4a59-4505-ae56-99e5030d08e8</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>09:40</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Laurence</first_name>
          <last_name>Tratt</last_name>
          <affiliation>King's College London</affiliation>
          <bio>Programmer / researcher.</bio>
          <homepage_url>https://tratt.net/laurie/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/laurencetratt/f715fc31-2c46-4e48-9a13-d715343fdd4d/small.jpg</picture_url>
          <person_id>laurencetratt</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Juan</first_name>
          <last_name>de Lara</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arantxa.ii.uam.es/~jlara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juandelara/36b5a702-1b04-48b9-8849-869aa603a88d/small.jpg</picture_url>
          <person_id>juandelara</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>3</sort_key>
          <first_name>Jeff</first_name>
          <last_name>Gray</last_name>
          <affiliation>University of Alabama</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gray.cs.ua.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeffgray/1f2fd602-bac6-49dd-86e4-549b5dc88528/small.jpg</picture_url>
          <person_id>jeffgray</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1e03b49d-b637-4022-97aa-d6b9c5be28c1</slot_id>
      <event_id>4609d389-c96c-41b0-9d37-2e67d40eb626</event_id>
      <title>Gradually Typing Strategies</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>10:20</end_time>
      <description>The Stratego language supports program transformation by means of term rewriting with programmable rewriting strategies. Stratego's traversal primitives support concise definition of generic tree traversals. Stratego is a dynamically typed language because its features cannot be captured fully by a static type system. While dynamic typing makes for a flexible programming model, it also leads to unintended type errors, code that is harder to maintain, and missed opportunities for optimization. 
In this paper, we introduce a gradual type system for Stratego that combines the flexibility of dynamically typed generic programming, where needed, with the safety of statically declared and enforced types, where possible. To make sure that statically typed code cannot go wrong, all access to statically typed code from dynamically typed code is protected by dynamic type checks (casts). The type system is backwards compatible such that types can be introduced incrementally to existing Stratego programs. We formally define a type system for Core Gradual Stratego, discuss its implementation in a new type checker for Stratego, and present an evaluation of its impact on Stratego programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jeff</first_name>
          <last_name>Smits</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>I am a PhD student in the Programming Languages Research Group at Delft University of Technology. I have various research interests around language design and compiler technology. I’ve worked on declarative specification of data-flow analysis, practical incremental compilation for existing languages, and gradual types. I’ve designed FlowSpec, a domain-specific language for the specification of data-flow analysis. For incremental compilation I’ve taken apart the compiler of the Stratego term transformation language, and reassembled it as an incremental compiler. I’m currently working on introducing a gradual type system to Stratego. FlowSpec and Stratego are part of the Spoofax Language Workbench. I am supervised by Eelco Visser.</bio>
          <homepage_url>https://www.jeffsmits.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeffsmits/1298c3fc-d485-44ed-b451-af24ac2f3b7e/small.jpg</picture_url>
          <person_id>jeffsmits</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science at Delft University of Technology. He received a master’s and doctorate in computer science from the University of Amsterdam in 1993 and 1997, respectively. Previously he served as postdoc at the Oregon Graduate Institute, as Assistant Professor at Utrecht University, and as Associate Professor at TU Delft. 
His research interests include programming languages, software language engineering, domain-specific programming languages, program transformation, syntax definition, and parsing. With his students he has designed and implemented the Spoofax language workbench, as well as many domain-specific languages, including DSLs for syntax definition (SDF2, SDF3), program transformation (Stratego), static semantics (NaBL, Statix), dynamic semantics (DynSem), software deployment (Nix), web application development (WebDSL), and mobile phone applications (mobl). In the language designer’s workbench project he is pursuing high-level declarative language definition that serves for language implementation and verification.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5b662b98-0c65-4c16-85b8-fd8916a9684b</slot_id>
      <event_id>db2ef237-4d82-43ee-ae90-0249136f777e</event_id>
      <title>Modeling Black-Box Components with Probabilistic Synthesis</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>10:00</end_time>
      <description>This paper is concerned with synthesizing programs based on \emph{black-box} oracles: we are interested in the case where there exists an executable implementation of a component or library, but its internal structure is unknown. We are just provided with its API or function signature, and aim to synthesize a program with equivalent behavior. 
To attack this problem, we detail Presyn: a program synthesizer designed for flexible interoperation with existing programs and compiler toolchains. By first generating input-output pairs based on a function signature, Presyn uses high-level imperative control-flow structures and a pair of cooperating predictive models to efficiently narrow the space of potential programs. These models can be trained effectively on small corpora of synthesized examples. 
We evaluate Presyn against four leading program synthesizers on a collection of 112 synthesis benchmarks collated from previous studies and real-world software libraries. We show that Presyn is able to synthesize a wider range of programs than each of them with less human input. We present two case studies: accelerator library porting and detection of duplicated library reimplementations that demonstrate the applicability of our approach on real world code and software engineering problems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bruce</first_name>
          <last_name>Collie</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>brucecollie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jackson</first_name>
          <last_name>Woodruff</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>jacksonwoodruff</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>O'Boyle</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>michaeloboyle</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>acc4b2ec-ef14-4a4e-bcf6-8c620d3ba3da</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/15</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>4d308d93-9bc2-4ba1-b672-0e302a6ac641</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>123db14b-432f-4546-98f3-555108e94627</slot_id>
      <event_id>72c19935-2e93-485f-b44c-07eaf52f87ca</event_id>
      <title>Block-Based Syntax from Context-Free Grammars</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>15:40</end_time>
      <description>Block-based programming systems employ a jigsaw metaphor to write programs. They are popular in the domain of programming education (e.g., Scratch), but also used as a programming interface for end-users in other disciplines, such as arts, robotics, and configuration management. In particular, block-based environments promise a convenient interface for Domain-Specific Languages (DSLs) for domain experts who might lack a traditional programming education. However, building a block-based environment for a DSL from scratch requires significant effort. 
This paper presents an approach to engineer block-based language interfaces by reusing existing language artifacts. We present Kogi, a tool for deriving block-based environments from context-free grammars. We identify and define the abstract structure for describing block-based environments. Kogi transforms a context-free grammar into this structure, which then generates a block-based environment based on Google Blockly. The approach is illustrated with four case studies, a DSL for state machines, Sonification Blocks (a DSL for sound synthesis), Pico (a simple programming language), and QL (a DSL for questionnaires). The results show that usable block-based environments can be derived from context-free grammars, and with an order of magnitude reduction in effort.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mauricio</first_name>
          <last_name>Verano Merino</last_name>
          <affiliation>Technische Universiteit Eindhoven</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://maveme.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mauricioveranomerino/e4a3ec56-b66f-4885-9989-c4a230e08446/small.jpg</picture_url>
          <person_id>mauricioveranomerino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tijs</first_name>
          <last_name>van der Storm</last_name>
          <affiliation>CWI &amp; University of Groningen, Netherlands</affiliation>
          <bio>Tijs van der Storm is senior researcher in the Software Analysis and Transformation (SWAT) group at Centrum Wiskunde &amp;amp; Informatica (CWI) in Amsterdam, and full professor in Software Engineering at the University of Groningen in Groningen. His research focuses on improving programmer experience through new and better software languages and developing the tools and techniques to engineer them in a modular and interactive fashion.</bio>
          <homepage_url>http://www.cwi.nl/~storm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tijsvanderstorm/1c2fdfb2-3ce0-4e75-91af-35d9a48f56c5/small.jpg</picture_url>
          <person_id>tijsvanderstorm</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>379fc491-f1ee-4f69-a8ed-83a208d6a7ce</slot_id>
      <event_id>7d0ca593-ff13-49f0-9525-bf519bd5fda8</event_id>
      <title>Extrinsically Typed Operational Semantics for Functional Languages</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>16:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>16:20</end_time>
      <description>We present a type system over language definitions that classifies parts of the operational semantics of a language in input, and models a common language design organization. The resulting typing discipline guarantees that the language at hand is automatically type sound. 
Thanks to the use of types to model language design, our type checker has a high-level view on the language being analyzed and can report messages using the same jargon of language designers. 
We have implemented our type system in the $\textsc{lang-n-check}$ tool, and we have applied it to derive the type soundness of several functional languages, including those with recursive types, polymorphism, exceptions, lists, sums, and several common types and operators.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matteo</first_name>
          <last_name>Cimini</last_name>
          <affiliation>University of Massachusetts at Lowell, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cimini.info</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matteocimini/2ceb8176-9ce7-4024-a7f2-6bf8c93a1f00/small.jpg</picture_url>
          <person_id>matteocimini</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dale</first_name>
          <last_name>Miller</last_name>
          <affiliation>Inria, France / École Polytechnique, France</affiliation>
          <bio>Dale Miller received his Ph.D. in Mathematics in 1983 from Carnegie Mellon University. He has been a professor at the University of Pennsylvania and Ecole Polytechnique (France) and Department Head in Computer Science and Engineering at Pennsylvania State University. He has held visiting positions at the universities of Aix-Marseille, Sienna, Genoa, Pisa, and Edinburgh. He is currently Director of Research (classe exceptionnelle) at Inria Saclay where he was the Scientific Leader of the Parsifal team for 12 years. 
Miller was a two-term editor-in-chief of the ACM Transactions on Computational Logic. He is a member of the editorial board of the Journal of Automated Reasoning and is the General Chair of LICS until 2021. In 2014 he was a PC chair for CSL and LICS. He was awarded an ERC Advanced Grant in 2011 and the LICS Test-of-Time awards in 2011 and 2014 for papers written in 1991 and 1994.</bio>
          <homepage_url>http://www.lix.polytechnique.fr/Labo/Dale.Miller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/dalemiller1/feea0ac3-4b48-4ddb-a086-40503abc9417/small.jpg</picture_url>
          <person_id>dalemiller1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jeremy G.</first_name>
          <last_name>Siek</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>Jeremy Siek is a Professor at Indiana University Bloomington. Jeremy’s areas of research include programming language design, type systems, mechanized theorem proving using proof assistants, and optimizing compilers. Jeremy’s Ph.D. thesis explored foundations for constrained templates, aka the “concepts” proposal for C++. Prior to that, Jeremy developed the Boost Graph Library, a C++ generic library for graph algorithms and data structures. Jeremy post-doc’d at Rice University where he developed the idea of gradual typing: a type system that integrates both dynamic and static typing in the same programming language. Jeremy is currently working on several open questions regarding gradual typing. Is the polymorphic blame calculus really parametric? How should gradual typing be combined with other features such as dependent types? What is the formal criteria for gradually typed languages? Is it possible to create a high-performance implementation of a gradually-typed languages? In 2009 Jeremy received the NSF CAREER award to fund his project: “Bridging the Gap Between Prototyping and Production”. In 2010 and again in 2015, Jeremy was awarded a Distinguished Visiting Fellowship from the Scottish Informatics &amp;amp; Computer Science Alliance.</bio>
          <homepage_url>http://homes.soic.indiana.edu/jsiek/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeremysiek/4365edf9-715f-46e0-8867-4ea5fb6341ad/small.jpg</picture_url>
          <person_id>jeremysiek</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>45b46dcf-d3bd-4f4b-9d6f-a2af6e7235fa</slot_id>
      <event_id>01597700-9cb9-405f-8faa-012932634461</event_id>
      <title>Manipulating GUI Structures Declaratively</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>15:20</end_time>
      <description>GUIs often contain structures that are incidental, not properly manipulatable through well-defined APIs. For example, modifying a list of items in a GUI’s model may require extraneous bookkeeping operations in the view, such as adding and removing event handlers, and updating the menu structure. Observing GUIs in practice alludes to that programmers may find it difficult or tedious to implement complete and convenient sets of operations for manipulating various structures: useful operations for adding, inserting, swapping, or reordering elements are often missing, inconsistent, or limited. This paper introduces a DSL for programming operations that manipulate such incidental structures. The programmer specifies structures via relations between elements, concretely by defining methods that unestablish and establish a relation. This gives the programmer an ability to describe structural transformations via rules that control which relations should hold before and after a rule is applied. The API for structure manipulation is generated from these rules. Our DSL can give an abstract view on ad-hoc structures, making it easier to provide the necessary set of operations for their convenient manipulation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Knut Anders</first_name>
          <last_name>Stokke</last_name>
          <affiliation>University of Bergen, Norway</affiliation>
          <bio>undefined</bio>
          <person_id>knutandersstokke</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mikhail</first_name>
          <last_name>Barash</last_name>
          <affiliation>University of Bergen, Norway</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://dsl-course.org/mikbar/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mikhailbarash/d876d731-3779-4e11-8aee-de2bcef5e938/small.jpg</picture_url>
          <person_id>mikhailbarash</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jaakko</first_name>
          <last_name>Järvi</last_name>
          <affiliation>University of Bergen</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://parasol.tamu.edu/~jarvi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jaakkojarvi/2baa5bc6-a9c0-42a0-a4ca-f7f878dd3381/small.jpg</picture_url>
          <person_id>jaakkojarvi</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a7186f42-0f28-4d45-84f0-34ae12cfb071</slot_id>
      <event_id>a26c3bc5-002a-4c10-8600-68b7c2ad453c</event_id>
      <title>PReGO: a Generative Methodology for Satisfying Real-Time Requirements on COTS-based Systems - Definition and Experience Report</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>16:00</end_time>
      <description>Satisfying real-time requirements in cyber-physical systemsis challenging as timing behaviour depends on the applica-tion software, the embedded hardware, as well as the exe-cution environment. This challenge is exacerbated as real-world, industrial systems often use unpredictable hardwareand software libraries or operating systems with timing haz-ards and proprietary device drivers. All these issues limitor entirely prevent the application of established real-timeanalysis techniques. 
This paper describes PReGO, a partially generative method-ology for satisfying real-time requirements in industrial usecases developed without real-time techniques in mind. Weapply our methodology to a Search &amp;amp; Rescue applicationrunning on a fixed-wing drone with COTS components, in-cluding a NVIDIA Jetson board and a stock Ubuntu/Linux.We empirically evaluate the impact of each integration stepand demonstrate the effectiveness of our methodology inmeeting real-time application requirements in terms of dead-line misses and energy consumption.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Rouxel</last_name>
          <affiliation>University of Amsterdam</affiliation>
          <bio>undefined</bio>
          <person_id>benjaminrouxel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ulrik</first_name>
          <last_name>Schultz</last_name>
          <affiliation>University of Southern Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mmmi.sdu.dk/~ups</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ulrikschultz/102a6087-5b8d-48ec-b10d-8c3b6ab5b193/small.jpg</picture_url>
          <person_id>ulrikschultz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benny</first_name>
          <last_name>Akesson</last_name>
          <affiliation>University of Amsterdam, Netherlands and TNO, the Netherlands Organisation</affiliation>
          <bio>undefined</bio>
          <person_id>bennyakesson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jesper</first_name>
          <last_name>Holst</last_name>
          <affiliation>Sky-Watch, Danemark</affiliation>
          <bio>undefined</bio>
          <person_id>jesperholst</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ole</first_name>
          <last_name>Jorgensen</last_name>
          <affiliation>Sky-Watch, Danemark</affiliation>
          <bio>undefined</bio>
          <person_id>olejorgensen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Clemens</first_name>
          <last_name>Grelck</last_name>
          <affiliation>University of Amsterdam</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://staff.fnwi.uva.nl/c.u.grelck/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/clemensgrelck/09259ddd-cfb8-4f7b-882a-e3c3d2a4c3bd/small.jpg</picture_url>
          <person_id>clemensgrelck</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>aa0329c8-7ac5-4509-be60-0f719436b401</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/16</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>f5324ca0-21f7-41c6-83a1-e6514cb3425a</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>07:00</start_time>
      <end_time>08:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Juan</first_name>
          <last_name>de Lara</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arantxa.ii.uam.es/~jlara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juandelara/36b5a702-1b04-48b9-8849-869aa603a88d/small.jpg</picture_url>
          <person_id>juandelara</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4993d388-408f-4527-96d3-934cf6ec27da</slot_id>
      <event_id>c70da96c-88b3-41a8-acaf-9b1776c8dd25</event_id>
      <title>A Domain-Specific Language for Filtering in Application Level Gateways</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>07:20</end_time>
      <description>Application-level packet filtering is a technique for network access control in which an “application-level gateway” intercepts network packages at the application level (e.g., HTTP, FTP), scans them for security cooncerns and optionally logs, rewrites or discards them. Existing application-level filters express their filtering rules in general-purpose languages, which limits the correctness guarantees available for them. 
We present the first declarative language for application-level network filtering, developed at Advenica AB. Our DSL uses security assertions to express properties that packets must have to be allowed through the network (e.g., “IMAP packet contains no executable attachment” or “SQL reply contains only explicitly permitted columns”), along with remedies that either reject or rewrite undesirable packets. 
We have designed the language around the needs of network filter developers, with a focus on correctness: our language can statically verify several properties of filter programs, such as well-formedness of the outcome, confluence, and termination, with the help of an off-the-shelf SMT solver. 
Our initial results show that the language is sufficiently expressive for a variety of network protocols, closely maps to the application domain, is usable by network filter engineers, and provides strong correctness guarantees.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hampus</first_name>
          <last_name>Balldin</last_name>
          <affiliation>Advenica AB, Malmö</affiliation>
          <bio>undefined</bio>
          <person_id>hampusballdin1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Reichenbach</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/christophreichenbach/04687677-a813-459e-8929-d1e4a32627c6/small.jpg</picture_url>
          <person_id>christophreichenbach</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>77eecf80-0780-4f1c-89a1-140522380bda</slot_id>
      <event_id>bf859d8b-5d82-4d81-92fe-9bffb332dc89</event_id>
      <title>Towards the Optical Character Recognition of DSLs</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>07:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>07:40</end_time>
      <description>OCR engines aim to identify and extract text strings fromdocuments or images. While current efforts focus mostly inmainstream languages, there is little support for program-ming or domain-specific languages (DSLs). In this paper, wepresent our vision about the current state of OCR recognitionfor DSLs and its challenges. We discuss some strategies toimprove the OCR quality applied to DSL textual expressionsby leveraging DSL specifications and domain data. To bettersupport our ideas we present the preliminary results of anempirical study and outline a research roadmap.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jorge</first_name>
          <last_name>Perianez Pascual</last_name>
          <affiliation>University of Extremadura, Spain</affiliation>
          <bio>undefined</bio>
          <person_id>jorgeperianezpascual</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roberto</first_name>
          <last_name>Rodriguez-Echeverria</last_name>
          <affiliation>University of Extremadura, Spain</affiliation>
          <bio>undefined</bio>
          <person_id>robertorodriguezecheverria</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Loli</first_name>
          <last_name>Burgueño</last_name>
          <affiliation>Open University of Catalonia, Spain</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/loliburgueno1/0bb3ad38-66ab-4323-a2cf-a83e634bf3e0/small.jpg</picture_url>
          <person_id>loliburgueno1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jordi</first_name>
          <last_name>Cabot</last_name>
          <affiliation>Open University of Catalonia, Spain</affiliation>
          <bio>I’m an ICREA Research Professor at Internet Interdisciplinary Institute, a Research center of the Open University of Catalonia (UOC) where I’m leading the SOM Research Lab. 
Previously, I’ve been a faculty member at the École des Mines de Nantes and team leader of the AtlanMod Research group on an Inria International Chair and worked in Barcelona (Technical University of Catalonia ), Toronto (University of Toronto) and Milano (Politecnico di Milano). 
My research falls into the broad area of systems and software engineering, especially promoting the rigorous use of software models and engineering principles in all software engineering tasks while keeping an eye on the most unpredictable element in any project: the people involved in it.</bio>
          <homepage_url>http://jordicabot.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jordicabot/5f53d1be-4d39-4b8b-a4f0-8d2167c2f3cd/small.jpg</picture_url>
          <person_id>jordicabot</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>88aec252-611a-4b17-919e-dbe5a2f0748a</slot_id>
      <event_id>c3bbe292-ed84-4022-87c1-1c8489a199ff</event_id>
      <title>Annotating Executable DSLs with Energy Estimation Formulas</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>08:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>08:20</end_time>
      <description>Reducing the energy consumption of a complex, especially cyber-physical, system is a cross-cutting concern through the system layers, and typically requires long feedback loops between experts in several engineering disciplines. Having an immediate automatic estimation of the global system consumption at design-time would significantly accelerate this process, but cross-layer tools are missing in several domains. 
Executable domain-specific modeling languages (xDSLs) can be used to design several layers of the system under development in an integrated view. By including the behavioral specification for software and physical components of the system, they are an effective source artifact for cross-layer energy estimation. 
In this paper we propose EEL, a language for annotating xDSL primitives with energy-related properties, i.e. how their execution would contribute to the energy consumption on a specific runtime platform. Given an xDSL, energy specialists create EEL models of that xDSL for each considered runtime platform. The models are used at design time, to predict the energy consumption of the real systems. This avoids the need of energetic analysis by deployment and measurement on all runtime platforms, that is slow and expensive. 
We augment an existing language workbench for xDSLs with an editor for EEL models and a component that computes energy-consumption estimations during model editing. The evaluation shows that EEL can be used to represent estimation models from literature, and provide useful predictions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thibault</first_name>
          <last_name>Béziers la Fosse</last_name>
          <affiliation>IMT Atlantique, ICAM</affiliation>
          <bio>undefined</bio>
          <person_id>thibaultbezierslafosse</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Massimo</first_name>
          <last_name>Tisi</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>massimotisi2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jean-Marie</first_name>
          <last_name>Mottu</last_name>
          <affiliation>Université de Nantes, LS2N, IMT Atlantique</affiliation>
          <bio>undefined</bio>
          <person_id>jeanmariemottu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gerson</first_name>
          <last_name>Sunyé</last_name>
          <affiliation>Université de Nantes, LS2N</affiliation>
          <bio>undefined</bio>
          <person_id>gersonsunye1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8cc9ff47-9a4f-4519-8e7e-7d026f9f541f</slot_id>
      <event_id>e4746088-06d2-4fa5-811e-53df9aff9450</event_id>
      <title>eFLINT: A Domain-Specific Language for Executable Norm Specifications</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>07:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>08:00</end_time>
      <description>Software systems that share potentially sensitive data are subjected to laws, regulations, policies and/or contracts. The monitoring, control and enforcement processes applied to these systems are currently to a large extent manual, which we rather automate by embedding the processes as dedicated and adaptable software services in order to improve efficiency and effectiveness. This approach requires such regulatory services to be closely aligned with a formal description of the relevant norms. 
This paper presents eFLINT, a domain-specific language developed for formalizing norms. The theoretical foundations of the language are found in transition systems and in Hohfeld’s framework of legal fundamental conceptions. The language can be used to formalize norms from a large variety of sources. The resulting specifications are executable and support several forms of reasoning such as automatic case assessment, manual exploration and simulation. Moreover, the specifications can be used to develop regulatory services for several types of monitoring, control and enforcement. The language is explained through an example, formalizing articles 6(1)(a) and 16 of the General Data Protection Regulation (GDPR). A prototype implementation and formal definition of eFLINT are provided as supplementary material.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>L. Thomas</first_name>
          <last_name>van Binsbergen</last_name>
          <affiliation>Centrum Wiskunde &amp; Informatica</affiliation>
          <bio>Thomas van Binsbergen is designing and implementing domain-specific languages for the formal specification of norms from a variety of sources such as laws, regulations, policies, contracts and codes of conduct. The resulting formalizations are used in policy-enhanced, distributed software architectures for data sharing. By ensuring compliance with the formalized norms, such systems reduce the risk of violating regulations and add value by increasing the trust in sharing activities. 
The SSPDDP project is a collaboration between the knowledge institutes UvA, CWI and VU and the industrial partners ABN AMRO, ING and KLM to develop secure and scalable techniques for policy-enforced data sharing. The project investigates fundamental research questions to develop future-proof, cryptographic solutions to secure and trustworthy data sharing, automatic policy enforcement in distributed systems and bringing the aforementioned data sharing methods to scale. Besides being academically relevant, the outcomes of these investigations suggest a principled, sound and pragmatic mode of operation that can add value to the industry partners in several ways. 
In the past, Van Binsbergen has developed modular techniques for describing the semantics of programming languages as part of the PLanCompS project with Peter Mosses and parser combinators for generalised top-down parsing with Adrian Johnstone and Elizabeth Scott. The results are described in his PhD thesis titled “Executable Formal Specification of Programming Languages with Reusable Components” (http://ltvanbinsbergen.nl/thesis/thesis.pdf). 
Keywords: modular language definition, domain-specific languages, formal specification, modelling languages, policy-enhanced data-sharing, generalised top-down parsing, declarative programming, purely functional programming, I-MSOS, FunCons, attribute grammars, computer science education</bio>
          <homepage_url>http://ltvanbinsbergen.nl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lthomasvanbinsbergen/b276e9a4-2229-45a7-ae0f-e25fb729b0e6/small.jpg</picture_url>
          <person_id>lthomasvanbinsbergen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lu-Chi</first_name>
          <last_name>Liu</last_name>
          <affiliation>University of Amsterdam</affiliation>
          <bio>undefined</bio>
          <person_id>luchiliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Robert</first_name>
          <last_name>van Doesburg</last_name>
          <affiliation>Leibniz Institute, University of Amsterdam / TNO</affiliation>
          <bio>undefined</bio>
          <person_id>robertvandoesburg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tom</first_name>
          <last_name>van Engers</last_name>
          <affiliation>Leibniz Institute, University of Amsterdam / TNO</affiliation>
          <bio>undefined</bio>
          <person_id>tomvanengers</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b52613d4-9f8f-4243-bf00-86a342a74493</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/16</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>72a5dec9-7dde-4145-965d-e8e9f8977411</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Ralf</first_name>
          <last_name>Lämmel</last_name>
          <affiliation>Facebook London</affiliation>
          <bio>http://www.softlang.org/rlaemmel:bio</bio>
          <homepage_url>http://softlang.wikidot.com/rlaemmel:home</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ralflammel/bc00aec2-e243-40e0-be65-bf9e5e21b0be/small.jpg</picture_url>
          <person_id>ralflammel</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0a719586-086e-4902-b9fe-50efcb3ad8fc</slot_id>
      <event_id>2959d666-0f62-48cd-88fd-eb2adec902b9</event_id>
      <title>Reorganizing queries with grouping</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>02:00</end_time>
      <description>Language-integrated query has attracted much attention from researchers and engineers. It enables one to write a database query with high-level abstractions, which makes it possible to compose, iterate, and reuse queries in a sophisticated way. Cheney et al. proposed a two-level language for this purpose, and succeeded in generating efficient queries by program transformation. Recently Okura et al. extended their language to cover grouping (GROUP BY) and aggregate functions in SQL. They decompose a query with grouping into a combination of small primitives and applies Cheney et al.’s translation to eliminate nested data structures. It works, but still has a problem; excessively large queries may sometimes be generated due to decomposition. 
This paper proposes a solution for this problem to complete the picture. Our key idea is re-organization of nested control structures. While Okura et al.’s decomposed form is useful while a query is being transformed by Cheney et al.’s transformation, it is not optimal when SQL queries are generated. We propose an algorithm to unify (or fuse) nested control structures while keeping the absence of nested data structures. An important issue is to avoid correlated subqueries, and our algorithm eliminates them as much as possible. We have applied our technique to various example queries, and conducted performance measurements, which shows the usefulness of our work.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rui</first_name>
          <last_name>Okura</last_name>
          <affiliation>University of Tsukuba</affiliation>
          <bio>undefined</bio>
          <person_id>ruiokura</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yukiyoshi</first_name>
          <last_name>Kameyama</last_name>
          <affiliation>University of Tsukuba, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tsukuba.ac.jp/~kam/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yukiyoshikameyama/a7ae9aee-0992-4ddf-ae1d-6fee59d9e814/small.jpg</picture_url>
          <person_id>yukiyoshikameyama</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>16c173be-953e-4683-b8a8-faacc647609e</slot_id>
      <event_id>77baa9ff-0f71-458a-b6de-9cff6f8a7642</event_id>
      <title>Principles and Patterns of JastAdd-Style Reference Attribute Grammars</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>02:20</end_time>
      <description>Reference attribute grammars (RAGs) have reached a level of maturity where they are supported by several tools, and have gained traction in both academic and industrial language tool development. However, despite a lot of accumulated knowledge of how to best develop RAGs in practice, there is limited support to guide practitioners. 
In this paper, we address this issue by focusing on one RAG tool, JastAdd, and by defining principles and patterns for development of RAGs with this tool. We evaluate the proposed principles and patterns with an exploratory empirical study with 14 practitioners, with a mix of beginners and experienced users from both academia and industry. The results indicate that the principles and patterns capture the practice of developing JastAdd RAGs well, help practitioners to become aware of useful patterns, and provide a common language to more efficiently reason about the practice of developing JastAdd RAGs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Niklas</first_name>
          <last_name>Fors</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.lth.se/niklas_fors</homepage_url>
          <person_id>niklasfors</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Emma</first_name>
          <last_name>Söderberg</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/emmasoderberg/7abc495e-ac1f-4cae-9f68-15a869dcb648/small.jpg</picture_url>
          <person_id>emmasoderberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Görel</first_name>
          <last_name>Hedin</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/gorelhedin1/889e8014-52c5-4f2f-949a-0f92539b1e59/small.jpg</picture_url>
          <person_id>gorelhedin1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9fb2eec4-df84-4a5b-99da-1e0f31883a6e</slot_id>
      <event_id>4752652a-8405-4b5e-90da-50c7de7fada9</event_id>
      <title>Multi-Stage Programming in the Large with Staged Classes</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>01:20</end_time>
      <description>Multi-stage programming (MSP) holds great promise, allowing the reliable generation of specialized, partially-evaluated code with static type- and scope-safety guarantees. Yet, we argue that MSP has not reached its full potential yet, as it has been traditionally limited to generating expressions, and has lacked principled facilities for generating modular programs and data structures. In that sense, we argue that MSP has been reserved for programming “in the small,” focused on generating efficient kernels of computation on the scale of single function bodies. We present a novel technique called staged classes, which extends MSP with the ability to manipulate class definitions as first-class constructs. This lets programmers use MSP “in the large,” on the level of applications, rather than mere functions. This way, applications can be designed in an abstract and modular way without runtime cost, as staged classes guarantee the removal of all staging-time abstractions, resulting in the generation of efficient specialized modules and data structures. We describe the design of a prototype relational database system in Scala, which uses several stages of runtime compilation to maximize the efficiency of query execution and data storage. We also show that staged classes can be used for defining type- and scope-safe implementations of type providers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lionel</first_name>
          <last_name>Parreaux</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.epfl.ch/lionel.parreaux/?lang=en</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lionelparreaux/292d178a-af9d-419f-9e04-8a4672226fd5/small.jpg</picture_url>
          <person_id>lionelparreaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Amir</first_name>
          <last_name>Shaikhha</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <person_id>amirshaikhha</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b5b5e353-1c24-46fb-900a-c6ea6c8b1bda</slot_id>
      <event_id>0547992f-d9b7-49e0-b616-0dc25b5ef4a9</event_id>
      <title>Software Language Engineers’ Worst Nightmare</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>01:40</end_time>
      <description>Many techniques in software language engineering get their first validation by being prototyped to work on one particular language such as Java, Scala, Scheme, or ML, or a subset of such a language. Claims of their generalisability, as well as discussion on potential threats to their external validity, are often based on authors' ad hoc understanding of the world outside their usual comfort zone. To facilitate and simplify such discussions by providing a solid measurable ground, we propose a language called BabyCobol, which was specifically designed to contain features that turn processing legacy programming languages such as COBOL, FORTRAN, PL/I, REXX, CLIST, and 4GLs (fourth generation languages), into such a challenge. The language is minimal by design so that it can help to quickly find weaknesses in frameworks making them inapplicable to dealing with legacy software. However, applying new techniques of software language engineering and reverse engineering to such a small language will not be too tedious and overwhelming. BabyCobol was designed in collaboration with industrial compiler developers by systematically traversing features of several second, third and fourth generation languages to identify the core culprits in making development of compiler for legacy languages difficult.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vadim</first_name>
          <last_name>Zaytsev</last_name>
          <affiliation>University of Twente, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://grammarware.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vadimzaytsev/fe6c221f-75d5-4fbc-ac41-be9c99349b5d/small.jpg</picture_url>
          <person_id>vadimzaytsev</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>264c908a-d666-4d99-9e5b-15e6cc2a14a7</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/15</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>5941b78e-f178-4b2d-b751-f8a81d94b601</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c4615725-b1b1-4229-9c78-d7b4ed9470e7</slot_id>
      <event_id>0634bf8c-79e0-4f7f-afaa-210b311fcbf3</event_id>
      <title>Modular and Distributed IDE</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>11:40</end_time>
      <description>Integrated Development Environments (IDEs) are indispensable companions to programming languages. They are increasingly turning towards Web-based infrastructure. The rise of a protocol such as the Language Server Protocol (LSP) that standardizes the separation between a language-agnostic IDE, and a language server that provides all language services (\emph{e.g.,} auto completion, compiler…) has allowed the emergence of high quality generic Web components to build the IDE part that runs in the browser. However, all language services require different computing capacities and response times to guarantee a user-friendly experience within the IDE. The monolithic distribution of all language services prevents to leverage on the available execution platforms (e.g., local platform, application server, cloud). In contrast with the current approaches that provide IDEs in the form of a monolithic client-server architecture, we explore in this paper the modularization of all language services to support their individual deployment and dynamic adaptation within an IDE. We evaluate the performance impact of the distribution of the language services across the available execution platforms on four EMF-based languages, and demonstrate the benefit of a custom distribution.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fabien</first_name>
          <last_name>Coulon</last_name>
          <affiliation>Obeo, France / University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>fabiencoulon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alex</first_name>
          <last_name>Auvolat</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>alexauvolat</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yérom-David</first_name>
          <last_name>Bromberg</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>yeromdavidbromberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>François</first_name>
          <last_name>Taïani</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>francoistaini</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Barais</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>olivierbarais1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Noël</first_name>
          <last_name>Plouzeau</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>noelplouzeau</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e5fd6677-5483-4c3c-8c19-39d3ea9c186f</slot_id>
      <event_id>404bc9e9-77ae-4014-95e6-150008d75fce</event_id>
      <title>Correctness-by-Construction for Feature-Oriented Software Product Lines</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>12:00</end_time>
      <description>\emph{Software product lines} are increasingly used to handle the growing demand of custom-tailored software variants. They provide systematic reuse of software and other artifacts paired with variability mechanisms in the code to implement whole product families rather than single software products. A common domain of application for product lines are safety-critical systems, which require \emph{behavioral correctness} to omit dangerous situations in-field. While most approaches in academia concentrate on post-hoc verification for product lines, we argue that a stepwise approach to create correct programs may be beneficial for the developer to manage the growing variability. \emph{Correctness-by-construction} is such a stepwise approach to create programs using a set of small, tractable refinement rules that guarantee the correctness of the program with regard to its specification. In this paper, we propose the first approach to develop correct-by-construction software product lines using feature-oriented programming. First, we extend correctness-by-construction by two refinement rules for variation points in the code. Second, we give a proof for the soundness of the proposed rules. Third, we implement our technique in a tool called VarCorC and show the applicability of the tool by conducting two case studies.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tabea</first_name>
          <last_name>Bordis</last_name>
          <affiliation>TU Braunschweig</affiliation>
          <bio>undefined</bio>
          <person_id>tabeabordis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Runge</last_name>
          <affiliation>TU Braunschweig</affiliation>
          <bio>undefined</bio>
          <person_id>tobiasrunge</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ina</first_name>
          <last_name>Schaefer</last_name>
          <affiliation>Technische Universität Braunschweig</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.tu-braunschweig.de/isf/team/schaefer</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/inaschaefer/49ab41dc-9f8c-4f0f-b786-43b70d25d96d/small.jpg</picture_url>
          <person_id>inaschaefer</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>eaa1f0b5-42e0-4f3e-ba22-0a24964746b2</slot_id>
      <event_id>677f497e-d633-4e7c-9fa6-3eb6bdc8a827</event_id>
      <title>Automated Variability Injection for Graphical Modelling Languages</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>11:20</end_time>
      <description>Model-based development approaches, such as Model-Driven Engineering (MDE), heavily rely on the use of modelling languages to achieve and automate software development tasks. To enable the definition of model variants (e.g., supporting the compact description of system families), one solution is to combine MDE with Software Product Lines. However, this is technically costly as it requires adapting many MDE artefacts associated to the modelling language – especially the meta-models and graphical environments. 
To alleviate this situation, we propose a method for the automated injection of variability into graphical modelling languages. Given the meta-model and graphical environment of a particular language, our approach permits configuring the allowed model variability, and the graphical environment is automatically adapted to enable creating models with variability. Our solution is implemented atop the Eclipse Modeling Framework and Sirius, and synthesizes adapted graphical editors integrated with FeatureIDE.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Antonio</first_name>
          <last_name>Garmendia</last_name>
          <affiliation>JKU Linz</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.se.jku.at/antonio-garmendia/</homepage_url>
          <person_id>antoniogarmendia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Wimmer</last_name>
          <affiliation>Johannes Kepler University Linz</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.se.jku.at/manuel-wimmer/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelwimmer/debab079-8b78-46af-8f24-2ce08001b86f/small.jpg</picture_url>
          <person_id>manuelwimmer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Esther</first_name>
          <last_name>Guerra</last_name>
          <affiliation>Universidad Autonoma de Madrid</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/estherguerra/e25b23e7-460a-487a-ac4f-bd6326e36ac7/small.jpg</picture_url>
          <person_id>estherguerra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Elena</first_name>
          <last_name>Gómez-Martínez</last_name>
          <affiliation>Universidad Autonoma de Madrid</affiliation>
          <bio>undefined</bio>
          <person_id>elenagomezmartinez</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Juan</first_name>
          <last_name>de Lara</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arantxa.ii.uam.es/~jlara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juandelara/36b5a702-1b04-48b9-8849-869aa603a88d/small.jpg</picture_url>
          <person_id>juandelara</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>eb2aa814-cfe3-496f-8b07-06ac80dd5502</slot_id>
      <event_id>c32f3297-945e-48d1-95da-9f3daec1ec11</event_id>
      <title>A Family of Languages for Trustworthy Agent-Based Simulation</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>12:20</end_time>
      <description>Simulation is a key tool for researching complex system behaviour. Agent-based simulation has been applied across domains, such as biology, health, economics and urban sciences. However, engineering robust, efficient, maintainable, and reliable agent-based simulations is challenging. We present a vision for engineering agent simulations comprising a family of domain-specific modelling languages (DSMLs) that integrates core software engineering, validation and simulation experimentation. We relate the vision to examples of principled simulation, to show how the DSMLs would improve robustness, efficiency, and maintainability of simulations. Focusing on how to demonstrate the fitness for purpose of a simulator, the envisaged approach supports bi-directional transparency and traceability between the original domain understanding to the implementation, interpretation of results and evaluation of hypotheses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Steffen</first_name>
          <last_name>Zschaler</last_name>
          <affiliation>King's College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.steffen-zschaler.de/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/steffenzschaler/aeac85bf-ae27-4394-b79a-4569c1138728/small.jpg</picture_url>
          <person_id>steffenzschaler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fiona</first_name>
          <last_name>Polack</last_name>
          <affiliation>Keele University</affiliation>
          <bio>undefined</bio>
          <person_id>fionapolack</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>124519e2-fe5f-4d5d-9e22-7d3145e91a4e</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/16</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>5593a36c-7f7e-4030-8ebc-4c5459a40bd0</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>19:00</start_time>
      <end_time>20:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Pearce</last_name>
          <affiliation>Victoria University of Wellington, New Zealand</affiliation>
          <bio>David (@whileydave) graduated with a PhD from Imperial College London in 2005, and took up a lecturer position at Victoria University of Wellington, NZ. David’s PhD thesis was on efficient algorithms for pointer analysis of C, and his techniques have since been incorporated into GCC. His interests are in programming languages, compilers and static analysis. 
Since 2009, he has been developing the Whiley Programming Language (whiley.org) which is designed specifically to simplify program verification. Prior to that, David developed the Java Compiler Kit (JKit), which is an open source Java Compiler aimed at simplifying static analysis. 
David has previously interned at Bell Labs, New Jersey, where he worked on compilers for FPGAs; and also at IBM Hursely, UK, where he worked with the AspectJ development team on profiling systems.</bio>
          <homepage_url>http://homepages.ecs.vuw.ac.nz/~djp/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidpearce/22bf61c2-1912-4f75-a0a6-fc77ea16dd34/small.jpg</picture_url>
          <person_id>davidpearce</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4b2d6eb1-f862-4fd4-a55b-f7368f34e5be</slot_id>
      <event_id>c3bbe292-ed84-4022-87c1-1c8489a199ff</event_id>
      <title>Annotating Executable DSLs with Energy Estimation Formulas</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>20:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>20:20</end_time>
      <description>Reducing the energy consumption of a complex, especially cyber-physical, system is a cross-cutting concern through the system layers, and typically requires long feedback loops between experts in several engineering disciplines. Having an immediate automatic estimation of the global system consumption at design-time would significantly accelerate this process, but cross-layer tools are missing in several domains. 
Executable domain-specific modeling languages (xDSLs) can be used to design several layers of the system under development in an integrated view. By including the behavioral specification for software and physical components of the system, they are an effective source artifact for cross-layer energy estimation. 
In this paper we propose EEL, a language for annotating xDSL primitives with energy-related properties, i.e. how their execution would contribute to the energy consumption on a specific runtime platform. Given an xDSL, energy specialists create EEL models of that xDSL for each considered runtime platform. The models are used at design time, to predict the energy consumption of the real systems. This avoids the need of energetic analysis by deployment and measurement on all runtime platforms, that is slow and expensive. 
We augment an existing language workbench for xDSLs with an editor for EEL models and a component that computes energy-consumption estimations during model editing. The evaluation shows that EEL can be used to represent estimation models from literature, and provide useful predictions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thibault</first_name>
          <last_name>Béziers la Fosse</last_name>
          <affiliation>IMT Atlantique, ICAM</affiliation>
          <bio>undefined</bio>
          <person_id>thibaultbezierslafosse</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Massimo</first_name>
          <last_name>Tisi</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>massimotisi2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jean-Marie</first_name>
          <last_name>Mottu</last_name>
          <affiliation>Université de Nantes, LS2N, IMT Atlantique</affiliation>
          <bio>undefined</bio>
          <person_id>jeanmariemottu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gerson</first_name>
          <last_name>Sunyé</last_name>
          <affiliation>Université de Nantes, LS2N</affiliation>
          <bio>undefined</bio>
          <person_id>gersonsunye1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8662863c-ab2c-4cbe-b5b7-151c440adcc3</slot_id>
      <event_id>bf859d8b-5d82-4d81-92fe-9bffb332dc89</event_id>
      <title>Towards the Optical Character Recognition of DSLs</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>19:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>19:40</end_time>
      <description>OCR engines aim to identify and extract text strings fromdocuments or images. While current efforts focus mostly inmainstream languages, there is little support for program-ming or domain-specific languages (DSLs). In this paper, wepresent our vision about the current state of OCR recognitionfor DSLs and its challenges. We discuss some strategies toimprove the OCR quality applied to DSL textual expressionsby leveraging DSL specifications and domain data. To bettersupport our ideas we present the preliminary results of anempirical study and outline a research roadmap.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jorge</first_name>
          <last_name>Perianez Pascual</last_name>
          <affiliation>University of Extremadura, Spain</affiliation>
          <bio>undefined</bio>
          <person_id>jorgeperianezpascual</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roberto</first_name>
          <last_name>Rodriguez-Echeverria</last_name>
          <affiliation>University of Extremadura, Spain</affiliation>
          <bio>undefined</bio>
          <person_id>robertorodriguezecheverria</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Loli</first_name>
          <last_name>Burgueño</last_name>
          <affiliation>Open University of Catalonia, Spain</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/loliburgueno1/0bb3ad38-66ab-4323-a2cf-a83e634bf3e0/small.jpg</picture_url>
          <person_id>loliburgueno1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jordi</first_name>
          <last_name>Cabot</last_name>
          <affiliation>Open University of Catalonia, Spain</affiliation>
          <bio>I’m an ICREA Research Professor at Internet Interdisciplinary Institute, a Research center of the Open University of Catalonia (UOC) where I’m leading the SOM Research Lab. 
Previously, I’ve been a faculty member at the École des Mines de Nantes and team leader of the AtlanMod Research group on an Inria International Chair and worked in Barcelona (Technical University of Catalonia ), Toronto (University of Toronto) and Milano (Politecnico di Milano). 
My research falls into the broad area of systems and software engineering, especially promoting the rigorous use of software models and engineering principles in all software engineering tasks while keeping an eye on the most unpredictable element in any project: the people involved in it.</bio>
          <homepage_url>http://jordicabot.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jordicabot/5f53d1be-4d39-4b8b-a4f0-8d2167c2f3cd/small.jpg</picture_url>
          <person_id>jordicabot</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9180f1b1-ee1e-45be-bdf9-73441bbbd246</slot_id>
      <event_id>c70da96c-88b3-41a8-acaf-9b1776c8dd25</event_id>
      <title>A Domain-Specific Language for Filtering in Application Level Gateways</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>19:20</end_time>
      <description>Application-level packet filtering is a technique for network access control in which an “application-level gateway” intercepts network packages at the application level (e.g., HTTP, FTP), scans them for security cooncerns and optionally logs, rewrites or discards them. Existing application-level filters express their filtering rules in general-purpose languages, which limits the correctness guarantees available for them. 
We present the first declarative language for application-level network filtering, developed at Advenica AB. Our DSL uses security assertions to express properties that packets must have to be allowed through the network (e.g., “IMAP packet contains no executable attachment” or “SQL reply contains only explicitly permitted columns”), along with remedies that either reject or rewrite undesirable packets. 
We have designed the language around the needs of network filter developers, with a focus on correctness: our language can statically verify several properties of filter programs, such as well-formedness of the outcome, confluence, and termination, with the help of an off-the-shelf SMT solver. 
Our initial results show that the language is sufficiently expressive for a variety of network protocols, closely maps to the application domain, is usable by network filter engineers, and provides strong correctness guarantees.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hampus</first_name>
          <last_name>Balldin</last_name>
          <affiliation>Advenica AB, Malmö</affiliation>
          <bio>undefined</bio>
          <person_id>hampusballdin1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Reichenbach</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/christophreichenbach/04687677-a813-459e-8929-d1e4a32627c6/small.jpg</picture_url>
          <person_id>christophreichenbach</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f8c871a6-27a9-4b3f-b798-c80a781a923c</slot_id>
      <event_id>e4746088-06d2-4fa5-811e-53df9aff9450</event_id>
      <title>eFLINT: A Domain-Specific Language for Executable Norm Specifications</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>19:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>20:00</end_time>
      <description>Software systems that share potentially sensitive data are subjected to laws, regulations, policies and/or contracts. The monitoring, control and enforcement processes applied to these systems are currently to a large extent manual, which we rather automate by embedding the processes as dedicated and adaptable software services in order to improve efficiency and effectiveness. This approach requires such regulatory services to be closely aligned with a formal description of the relevant norms. 
This paper presents eFLINT, a domain-specific language developed for formalizing norms. The theoretical foundations of the language are found in transition systems and in Hohfeld’s framework of legal fundamental conceptions. The language can be used to formalize norms from a large variety of sources. The resulting specifications are executable and support several forms of reasoning such as automatic case assessment, manual exploration and simulation. Moreover, the specifications can be used to develop regulatory services for several types of monitoring, control and enforcement. The language is explained through an example, formalizing articles 6(1)(a) and 16 of the General Data Protection Regulation (GDPR). A prototype implementation and formal definition of eFLINT are provided as supplementary material.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>L. Thomas</first_name>
          <last_name>van Binsbergen</last_name>
          <affiliation>Centrum Wiskunde &amp; Informatica</affiliation>
          <bio>Thomas van Binsbergen is designing and implementing domain-specific languages for the formal specification of norms from a variety of sources such as laws, regulations, policies, contracts and codes of conduct. The resulting formalizations are used in policy-enhanced, distributed software architectures for data sharing. By ensuring compliance with the formalized norms, such systems reduce the risk of violating regulations and add value by increasing the trust in sharing activities. 
The SSPDDP project is a collaboration between the knowledge institutes UvA, CWI and VU and the industrial partners ABN AMRO, ING and KLM to develop secure and scalable techniques for policy-enforced data sharing. The project investigates fundamental research questions to develop future-proof, cryptographic solutions to secure and trustworthy data sharing, automatic policy enforcement in distributed systems and bringing the aforementioned data sharing methods to scale. Besides being academically relevant, the outcomes of these investigations suggest a principled, sound and pragmatic mode of operation that can add value to the industry partners in several ways. 
In the past, Van Binsbergen has developed modular techniques for describing the semantics of programming languages as part of the PLanCompS project with Peter Mosses and parser combinators for generalised top-down parsing with Adrian Johnstone and Elizabeth Scott. The results are described in his PhD thesis titled “Executable Formal Specification of Programming Languages with Reusable Components” (http://ltvanbinsbergen.nl/thesis/thesis.pdf). 
Keywords: modular language definition, domain-specific languages, formal specification, modelling languages, policy-enhanced data-sharing, generalised top-down parsing, declarative programming, purely functional programming, I-MSOS, FunCons, attribute grammars, computer science education</bio>
          <homepage_url>http://ltvanbinsbergen.nl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lthomasvanbinsbergen/b276e9a4-2229-45a7-ae0f-e25fb729b0e6/small.jpg</picture_url>
          <person_id>lthomasvanbinsbergen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lu-Chi</first_name>
          <last_name>Liu</last_name>
          <affiliation>University of Amsterdam</affiliation>
          <bio>undefined</bio>
          <person_id>luchiliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Robert</first_name>
          <last_name>van Doesburg</last_name>
          <affiliation>Leibniz Institute, University of Amsterdam / TNO</affiliation>
          <bio>undefined</bio>
          <person_id>robertvandoesburg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tom</first_name>
          <last_name>van Engers</last_name>
          <affiliation>Leibniz Institute, University of Amsterdam / TNO</affiliation>
          <bio>undefined</bio>
          <person_id>tomvanengers</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9c9dcaa6-1ec0-45f4-9dd2-266ec80052a7</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/15</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>de4aec03-7d1d-4638-a6b1-5f408c6045d2</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>21:40</start_time>
      <end_time>22:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Jeff</first_name>
          <last_name>Gray</last_name>
          <affiliation>University of Alabama</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gray.cs.ua.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeffgray/1f2fd602-bac6-49dd-86e4-549b5dc88528/small.jpg</picture_url>
          <person_id>jeffgray</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Laurence</first_name>
          <last_name>Tratt</last_name>
          <affiliation>King's College London</affiliation>
          <bio>Programmer / researcher.</bio>
          <homepage_url>https://tratt.net/laurie/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/laurencetratt/f715fc31-2c46-4e48-9a13-d715343fdd4d/small.jpg</picture_url>
          <person_id>laurencetratt</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>3</sort_key>
          <first_name>Juan</first_name>
          <last_name>de Lara</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arantxa.ii.uam.es/~jlara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juandelara/36b5a702-1b04-48b9-8849-869aa603a88d/small.jpg</picture_url>
          <person_id>juandelara</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6a551cf0-8d27-4836-8b1f-24590c56a55a</slot_id>
      <event_id>4609d389-c96c-41b0-9d37-2e67d40eb626</event_id>
      <title>Gradually Typing Strategies</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>22:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>22:20</end_time>
      <description>The Stratego language supports program transformation by means of term rewriting with programmable rewriting strategies. Stratego's traversal primitives support concise definition of generic tree traversals. Stratego is a dynamically typed language because its features cannot be captured fully by a static type system. While dynamic typing makes for a flexible programming model, it also leads to unintended type errors, code that is harder to maintain, and missed opportunities for optimization. 
In this paper, we introduce a gradual type system for Stratego that combines the flexibility of dynamically typed generic programming, where needed, with the safety of statically declared and enforced types, where possible. To make sure that statically typed code cannot go wrong, all access to statically typed code from dynamically typed code is protected by dynamic type checks (casts). The type system is backwards compatible such that types can be introduced incrementally to existing Stratego programs. We formally define a type system for Core Gradual Stratego, discuss its implementation in a new type checker for Stratego, and present an evaluation of its impact on Stratego programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jeff</first_name>
          <last_name>Smits</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>I am a PhD student in the Programming Languages Research Group at Delft University of Technology. I have various research interests around language design and compiler technology. I’ve worked on declarative specification of data-flow analysis, practical incremental compilation for existing languages, and gradual types. I’ve designed FlowSpec, a domain-specific language for the specification of data-flow analysis. For incremental compilation I’ve taken apart the compiler of the Stratego term transformation language, and reassembled it as an incremental compiler. I’m currently working on introducing a gradual type system to Stratego. FlowSpec and Stratego are part of the Spoofax Language Workbench. I am supervised by Eelco Visser.</bio>
          <homepage_url>https://www.jeffsmits.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeffsmits/1298c3fc-d485-44ed-b451-af24ac2f3b7e/small.jpg</picture_url>
          <person_id>jeffsmits</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science at Delft University of Technology. He received a master’s and doctorate in computer science from the University of Amsterdam in 1993 and 1997, respectively. Previously he served as postdoc at the Oregon Graduate Institute, as Assistant Professor at Utrecht University, and as Associate Professor at TU Delft. 
His research interests include programming languages, software language engineering, domain-specific programming languages, program transformation, syntax definition, and parsing. With his students he has designed and implemented the Spoofax language workbench, as well as many domain-specific languages, including DSLs for syntax definition (SDF2, SDF3), program transformation (Stratego), static semantics (NaBL, Statix), dynamic semantics (DynSem), software deployment (Nix), web application development (WebDSL), and mobile phone applications (mobl). In the language designer’s workbench project he is pursuing high-level declarative language definition that serves for language implementation and verification.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>788d9b22-2205-4e1b-af97-edfe69dbbac3</slot_id>
      <event_id>db2ef237-4d82-43ee-ae90-0249136f777e</event_id>
      <title>Modeling Black-Box Components with Probabilistic Synthesis</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>21:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>22:00</end_time>
      <description>This paper is concerned with synthesizing programs based on \emph{black-box} oracles: we are interested in the case where there exists an executable implementation of a component or library, but its internal structure is unknown. We are just provided with its API or function signature, and aim to synthesize a program with equivalent behavior. 
To attack this problem, we detail Presyn: a program synthesizer designed for flexible interoperation with existing programs and compiler toolchains. By first generating input-output pairs based on a function signature, Presyn uses high-level imperative control-flow structures and a pair of cooperating predictive models to efficiently narrow the space of potential programs. These models can be trained effectively on small corpora of synthesized examples. 
We evaluate Presyn against four leading program synthesizers on a collection of 112 synthesis benchmarks collated from previous studies and real-world software libraries. We show that Presyn is able to synthesize a wider range of programs than each of them with less human input. We present two case studies: accelerator library porting and detection of duplicated library reimplementations that demonstrate the applicability of our approach on real world code and software engineering problems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bruce</first_name>
          <last_name>Collie</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>brucecollie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jackson</first_name>
          <last_name>Woodruff</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>jacksonwoodruff</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>O'Boyle</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>michaeloboyle</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>664c26fd-3069-4e8c-aacf-cf6a761e5aa3</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/16</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>a961f95c-6670-4d66-b44f-2c125af39ab6</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Friedrich</first_name>
          <last_name>Steimann</last_name>
          <affiliation>Fernuniversität</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/friedrichsteimann/0382f30a-7342-49a1-b2f6-cf7d0929220c/small.jpg</picture_url>
          <person_id>friedrichsteimann</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>207f0df4-d851-4794-9809-f7070cd9603c</slot_id>
      <event_id>741d1273-956c-4747-a5a6-305b9f8931c5</event_id>
      <title>VarSem: Declarative Expression and Automated Inference of Variable Usage Semantics</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>05:20</end_time>
      <description>Programmers declare variables to serve specific implementation purposes that we refer to as \emph{variable usage semantics (VUS)}. Understanding VUS is required for various software engineering tasks, including program comprehension, code audits, and vulnerability detection. To help programmers understand VUS, we present a new program analysis that infers a variable’s usage semantics from its textual and context information (e.g., symbolic name, type, scope, information flow). To support this analysis, we introduce VarSem, a domain-specific language, in which a variable’s semantic category is expressed as a set of declarative rules. VarSem’s execution determines which program variables belong to a given semantic category. VarSem translates high-level declarative rules into low-level program analysis techniques, including natural language processing and data flow, and provides a highly extensible architecture for specifying new rules and analysis techniques. We evaluate VarSem with eight real-world systems to identify their personally identifiable information variables. The evaluation results show that VarSem infers variable semantics with satisfying accuracy/precision and passable recall, thus potentially benefiting both software and security engineers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yin</first_name>
          <last_name>Liu</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.google.com/vt.edu/yinl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yinliu/1bc32554-be71-4a23-8aab-f60279fd51d1/small.jpg</picture_url>
          <person_id>yinliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eli</first_name>
          <last_name>Tilevich</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.vt.edu/~tilevich</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elitilevich/10b9c85c-8a75-4acb-a0fe-e00c91dd0bb6/small.jpg</picture_url>
          <person_id>elitilevich</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4c50a730-8db7-4c7f-9b3d-bc8ace73431e</slot_id>
      <event_id>78bc2344-dbc5-4255-89ef-7567e0b7e707</event_id>
      <title>Monadification of Attribute Grammars</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>05:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>05:40</end_time>
      <description>We describe a monadification process for attribute grammars for more concisely written attribute equations, closer to the style of inference rules used in traditional typing and evaluation specifications. Inference rules specifying, for example, a typing relation typically consider only typable expressions, whereas well-defined attribute grammars explicitly determine attribute values for any term, including untypable ones. The monadification approach lets one represent, for example, types as monadic optional/maybe values, but write non-monadic equations over the value inside the monad that only specify the rules for a correct typing, leading to more concise specifications. The missing failure cases are handled by a rewriting that inserts monadic return, bind, and failure operations to produce a well-defined attribute grammar that handles untypable trees. Thus, one can think in terms of a type T and not the actual monadic type M(T). To formalize this notion, typing and evaluation relations are given for the original and rewritten equations. The rewriting is total, preserves types, and a correctness property relating values of original and rewritten equations is given. A prototype implementation illustrates the benefits with examples such as typing of the simply-typed lambda calculus with Booleans, evaluation of the same, and type inference in Caml Light.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dawn</first_name>
          <last_name>Michaelson</last_name>
          <affiliation>University of Minnesota</affiliation>
          <bio>undefined</bio>
          <person_id>dawnmichaelson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eric</first_name>
          <last_name>Van Wyk</last_name>
          <affiliation>University of Minnesota, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umn.edu/~evw</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ericvanwyk/3e91ebed-d1c2-4d28-a408-dddc41b5affc/small.jpg</picture_url>
          <person_id>ericvanwyk</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>80f65d7a-d8d4-42fe-b6cd-79301697e2e2</slot_id>
      <event_id>134617c3-cba5-44b3-9faf-25e0db401d75</event_id>
      <title>Fluid Quotes: Metaprogramming across Abstraction Boundaries with Dependent Types</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>05:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>06:00</end_time>
      <description>Object-oriented programming, functional programming, and metaprogramming each offer a unique axis of abstraction that enables modular code. Macros, a common technique for metaprogramming, capture ASTs as quotes to let users manipulate them in the host language. However, macros are often at odds with other programming techniques since they can only process code written at the call-site and cannot analyze code behind abstraction boundaries such as variables and methods. Furthermore, the quotes generated for macro expansion only exist at compile-time and cannot be passed around in user code. Multi-stage programming treats quotes as runtime values to address this problem, but introduces the cost of running the compiler when splicing quotes. This forces developers to choose between low runtime overhead and modularity. What if we could have the best of both worlds? We introduce fluid quotes, a new technique that uses dependent types to let users pass quotes through abstraction boundaries in runtime code while splicing them ahead-of-time. This technique enables new metaprogramming capabilities by eliminating the traditional requirement of co-locating parameter expressions with call-sites. Fluid quotes capture not only source code but also associated runtime values to ensure correctness. In addition, they can be composed into larger expressions without any macro code. We demonstrate the capabilities of fluid quotes through two specific applications: optimizing data processing pipelines and making language integrated queries more flexible.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shadaj</first_name>
          <last_name>Laddad</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://shadaj.me</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shadajladdad/d64c98bb-f1a7-4627-8ce4-f30e39b4d77d/small.jpg</picture_url>
          <person_id>shadajladdad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Koushik</first_name>
          <last_name>Sen</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>Koushik Sen is a professor in the Department of Electrical Engineering and Computer Sciences at the University of California, Berkeley. His research interest lies in Software Engineering, Programming Languages, and Formal methods. He is interested in developing software tools and methodologies that improve programmer productivity and software quality. He holds a B.Tech from Indian Institute of Technology, Kanpur, and M.S. and Ph.D. in CS from University of Illinois at Urbana-Champaign.</bio>
          <homepage_url>https://people.eecs.berkeley.edu/~ksen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/koushiksen/9f417f8a-40b9-40a7-866c-9c44cd81859a/small.jpg</picture_url>
          <person_id>koushiksen</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e5da275a-e1c5-4d36-b5c7-c671cb519b31</slot_id>
      <event_id>36eaec1d-fd68-4a11-9fa8-9e7691962e35</event_id>
      <title>Strategic Tree Rewriting in Attribute Grammars</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>06:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>06:20</end_time>
      <description>This paper presents strategy attributes, a seamless integration of strategic term rewriting into attribute grammars. Strategy attributes are specified using rewrite rules with strategies that control their application. The rules can reference contextual information held in attributes on the trees being rewritten. This use of attributes leads to rewriting on decorated trees instead of undecorated terms. During rewriting, attributes are (lazily) computed on new trees to ensure they are correct with respect to their defining equations. Attributes and strategic rewriting can each be used where most appropriate, thus avoiding the cumbersome aspects of each. 
Strategy attributes are essentially higher-order attributes for which the defining equations are automatically generated from the attributes' strategy expressions. They are thus compatible with other attribute grammar features such as reference attributes, forwarding, and attribute flow analyses for well-definedness. A conservative static analysis checks if a strategy is intended to always succeed or to be partial, thus simplifying its use and optimizing its translation. Strategy attributes are demonstrated in the optimization of a simple expression language, evaluation of the lambda calculus, and optimization of strategy attribute translations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lucas</first_name>
          <last_name>Kramer</last_name>
          <affiliation>University of Minnesota</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/lucaskramer/1632792f-4c70-4e79-b2ba-6bfcfd3d5c95/small.jpg</picture_url>
          <person_id>lucaskramer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eric</first_name>
          <last_name>Van Wyk</last_name>
          <affiliation>University of Minnesota, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umn.edu/~evw</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ericvanwyk/3e91ebed-d1c2-4d28-a408-dddc41b5affc/small.jpg</picture_url>
          <person_id>ericvanwyk</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5559a118-f82e-4091-a701-a397b9534e85</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/16</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>200ddb06-968f-451f-a12d-d35c5b766e3c</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Erwan</first_name>
          <last_name>Bousse</last_name>
          <affiliation>University of Nantes</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://bousse-e.univ-nantes.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/erwanbousse/5e6cca31-4ae8-4081-956c-53b51fdca8a3/small.jpg</picture_url>
          <person_id>erwanbousse</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>06612259-050a-4c28-8882-fbac40746d9a</slot_id>
      <event_id>72c19935-2e93-485f-b44c-07eaf52f87ca</event_id>
      <title>Block-Based Syntax from Context-Free Grammars</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>03:40</end_time>
      <description>Block-based programming systems employ a jigsaw metaphor to write programs. They are popular in the domain of programming education (e.g., Scratch), but also used as a programming interface for end-users in other disciplines, such as arts, robotics, and configuration management. In particular, block-based environments promise a convenient interface for Domain-Specific Languages (DSLs) for domain experts who might lack a traditional programming education. However, building a block-based environment for a DSL from scratch requires significant effort. 
This paper presents an approach to engineer block-based language interfaces by reusing existing language artifacts. We present Kogi, a tool for deriving block-based environments from context-free grammars. We identify and define the abstract structure for describing block-based environments. Kogi transforms a context-free grammar into this structure, which then generates a block-based environment based on Google Blockly. The approach is illustrated with four case studies, a DSL for state machines, Sonification Blocks (a DSL for sound synthesis), Pico (a simple programming language), and QL (a DSL for questionnaires). The results show that usable block-based environments can be derived from context-free grammars, and with an order of magnitude reduction in effort.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mauricio</first_name>
          <last_name>Verano Merino</last_name>
          <affiliation>Technische Universiteit Eindhoven</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://maveme.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mauricioveranomerino/e4a3ec56-b66f-4885-9989-c4a230e08446/small.jpg</picture_url>
          <person_id>mauricioveranomerino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tijs</first_name>
          <last_name>van der Storm</last_name>
          <affiliation>CWI &amp; University of Groningen, Netherlands</affiliation>
          <bio>Tijs van der Storm is senior researcher in the Software Analysis and Transformation (SWAT) group at Centrum Wiskunde &amp;amp; Informatica (CWI) in Amsterdam, and full professor in Software Engineering at the University of Groningen in Groningen. His research focuses on improving programmer experience through new and better software languages and developing the tools and techniques to engineer them in a modular and interactive fashion.</bio>
          <homepage_url>http://www.cwi.nl/~storm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tijsvanderstorm/1c2fdfb2-3ce0-4e75-91af-35d9a48f56c5/small.jpg</picture_url>
          <person_id>tijsvanderstorm</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>64eddf6f-9426-4c7c-b787-b8564add5dea</slot_id>
      <event_id>01597700-9cb9-405f-8faa-012932634461</event_id>
      <title>Manipulating GUI Structures Declaratively</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>03:20</end_time>
      <description>GUIs often contain structures that are incidental, not properly manipulatable through well-defined APIs. For example, modifying a list of items in a GUI’s model may require extraneous bookkeeping operations in the view, such as adding and removing event handlers, and updating the menu structure. Observing GUIs in practice alludes to that programmers may find it difficult or tedious to implement complete and convenient sets of operations for manipulating various structures: useful operations for adding, inserting, swapping, or reordering elements are often missing, inconsistent, or limited. This paper introduces a DSL for programming operations that manipulate such incidental structures. The programmer specifies structures via relations between elements, concretely by defining methods that unestablish and establish a relation. This gives the programmer an ability to describe structural transformations via rules that control which relations should hold before and after a rule is applied. The API for structure manipulation is generated from these rules. Our DSL can give an abstract view on ad-hoc structures, making it easier to provide the necessary set of operations for their convenient manipulation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Knut Anders</first_name>
          <last_name>Stokke</last_name>
          <affiliation>University of Bergen, Norway</affiliation>
          <bio>undefined</bio>
          <person_id>knutandersstokke</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mikhail</first_name>
          <last_name>Barash</last_name>
          <affiliation>University of Bergen, Norway</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://dsl-course.org/mikbar/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mikhailbarash/d876d731-3779-4e11-8aee-de2bcef5e938/small.jpg</picture_url>
          <person_id>mikhailbarash</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jaakko</first_name>
          <last_name>Järvi</last_name>
          <affiliation>University of Bergen</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://parasol.tamu.edu/~jarvi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jaakkojarvi/2baa5bc6-a9c0-42a0-a4ca-f7f878dd3381/small.jpg</picture_url>
          <person_id>jaakkojarvi</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7e10df27-e113-4ba8-8beb-da1715680deb</slot_id>
      <event_id>7d0ca593-ff13-49f0-9525-bf519bd5fda8</event_id>
      <title>Extrinsically Typed Operational Semantics for Functional Languages</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>04:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>04:20</end_time>
      <description>We present a type system over language definitions that classifies parts of the operational semantics of a language in input, and models a common language design organization. The resulting typing discipline guarantees that the language at hand is automatically type sound. 
Thanks to the use of types to model language design, our type checker has a high-level view on the language being analyzed and can report messages using the same jargon of language designers. 
We have implemented our type system in the $\textsc{lang-n-check}$ tool, and we have applied it to derive the type soundness of several functional languages, including those with recursive types, polymorphism, exceptions, lists, sums, and several common types and operators.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matteo</first_name>
          <last_name>Cimini</last_name>
          <affiliation>University of Massachusetts at Lowell, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cimini.info</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matteocimini/2ceb8176-9ce7-4024-a7f2-6bf8c93a1f00/small.jpg</picture_url>
          <person_id>matteocimini</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dale</first_name>
          <last_name>Miller</last_name>
          <affiliation>Inria, France / École Polytechnique, France</affiliation>
          <bio>Dale Miller received his Ph.D. in Mathematics in 1983 from Carnegie Mellon University. He has been a professor at the University of Pennsylvania and Ecole Polytechnique (France) and Department Head in Computer Science and Engineering at Pennsylvania State University. He has held visiting positions at the universities of Aix-Marseille, Sienna, Genoa, Pisa, and Edinburgh. He is currently Director of Research (classe exceptionnelle) at Inria Saclay where he was the Scientific Leader of the Parsifal team for 12 years. 
Miller was a two-term editor-in-chief of the ACM Transactions on Computational Logic. He is a member of the editorial board of the Journal of Automated Reasoning and is the General Chair of LICS until 2021. In 2014 he was a PC chair for CSL and LICS. He was awarded an ERC Advanced Grant in 2011 and the LICS Test-of-Time awards in 2011 and 2014 for papers written in 1991 and 1994.</bio>
          <homepage_url>http://www.lix.polytechnique.fr/Labo/Dale.Miller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/dalemiller1/feea0ac3-4b48-4ddb-a086-40503abc9417/small.jpg</picture_url>
          <person_id>dalemiller1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jeremy G.</first_name>
          <last_name>Siek</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>Jeremy Siek is a Professor at Indiana University Bloomington. Jeremy’s areas of research include programming language design, type systems, mechanized theorem proving using proof assistants, and optimizing compilers. Jeremy’s Ph.D. thesis explored foundations for constrained templates, aka the “concepts” proposal for C++. Prior to that, Jeremy developed the Boost Graph Library, a C++ generic library for graph algorithms and data structures. Jeremy post-doc’d at Rice University where he developed the idea of gradual typing: a type system that integrates both dynamic and static typing in the same programming language. Jeremy is currently working on several open questions regarding gradual typing. Is the polymorphic blame calculus really parametric? How should gradual typing be combined with other features such as dependent types? What is the formal criteria for gradually typed languages? Is it possible to create a high-performance implementation of a gradually-typed languages? In 2009 Jeremy received the NSF CAREER award to fund his project: “Bridging the Gap Between Prototyping and Production”. In 2010 and again in 2015, Jeremy was awarded a Distinguished Visiting Fellowship from the Scottish Informatics &amp;amp; Computer Science Alliance.</bio>
          <homepage_url>http://homes.soic.indiana.edu/jsiek/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeremysiek/4365edf9-715f-46e0-8867-4ea5fb6341ad/small.jpg</picture_url>
          <person_id>jeremysiek</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f907cc2e-1020-4241-9c4d-94e6b29f380e</slot_id>
      <event_id>a26c3bc5-002a-4c10-8600-68b7c2ad453c</event_id>
      <title>PReGO: a Generative Methodology for Satisfying Real-Time Requirements on COTS-based Systems - Definition and Experience Report</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>04:00</end_time>
      <description>Satisfying real-time requirements in cyber-physical systemsis challenging as timing behaviour depends on the applica-tion software, the embedded hardware, as well as the exe-cution environment. This challenge is exacerbated as real-world, industrial systems often use unpredictable hardwareand software libraries or operating systems with timing haz-ards and proprietary device drivers. All these issues limitor entirely prevent the application of established real-timeanalysis techniques. 
This paper describes PReGO, a partially generative method-ology for satisfying real-time requirements in industrial usecases developed without real-time techniques in mind. Weapply our methodology to a Search &amp;amp; Rescue applicationrunning on a fixed-wing drone with COTS components, in-cluding a NVIDIA Jetson board and a stock Ubuntu/Linux.We empirically evaluate the impact of each integration stepand demonstrate the effectiveness of our methodology inmeeting real-time application requirements in terms of dead-line misses and energy consumption.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Rouxel</last_name>
          <affiliation>University of Amsterdam</affiliation>
          <bio>undefined</bio>
          <person_id>benjaminrouxel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ulrik</first_name>
          <last_name>Schultz</last_name>
          <affiliation>University of Southern Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mmmi.sdu.dk/~ups</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ulrikschultz/102a6087-5b8d-48ec-b10d-8c3b6ab5b193/small.jpg</picture_url>
          <person_id>ulrikschultz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benny</first_name>
          <last_name>Akesson</last_name>
          <affiliation>University of Amsterdam, Netherlands and TNO, the Netherlands Organisation</affiliation>
          <bio>undefined</bio>
          <person_id>bennyakesson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jesper</first_name>
          <last_name>Holst</last_name>
          <affiliation>Sky-Watch, Danemark</affiliation>
          <bio>undefined</bio>
          <person_id>jesperholst</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ole</first_name>
          <last_name>Jorgensen</last_name>
          <affiliation>Sky-Watch, Danemark</affiliation>
          <bio>undefined</bio>
          <person_id>olejorgensen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Clemens</first_name>
          <last_name>Grelck</last_name>
          <affiliation>University of Amsterdam</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://staff.fnwi.uva.nl/c.u.grelck/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/clemensgrelck/09259ddd-cfb8-4f7b-882a-e3c3d2a4c3bd/small.jpg</picture_url>
          <person_id>clemensgrelck</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d8d0e4cf-ff54-47e3-bb37-b9972b2a86e1</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/15</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>3644edbd-2cdb-4f6f-a600-ba6d0aa9772a</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Marjan</first_name>
          <last_name>Mernik</last_name>
          <affiliation>University of Maribor</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://lpm.feri.um.si/en/members/mernik/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/marjanmernik/bd6c2b12-52ef-49e5-a52a-c499483b00c9/small.jpg</picture_url>
          <person_id>marjanmernik</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0fc2a1c9-532d-42a6-ba07-7f7ac3a53c8e</slot_id>
      <event_id>78bc2344-dbc5-4255-89ef-7567e0b7e707</event_id>
      <title>Monadification of Attribute Grammars</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>17:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>17:40</end_time>
      <description>We describe a monadification process for attribute grammars for more concisely written attribute equations, closer to the style of inference rules used in traditional typing and evaluation specifications. Inference rules specifying, for example, a typing relation typically consider only typable expressions, whereas well-defined attribute grammars explicitly determine attribute values for any term, including untypable ones. The monadification approach lets one represent, for example, types as monadic optional/maybe values, but write non-monadic equations over the value inside the monad that only specify the rules for a correct typing, leading to more concise specifications. The missing failure cases are handled by a rewriting that inserts monadic return, bind, and failure operations to produce a well-defined attribute grammar that handles untypable trees. Thus, one can think in terms of a type T and not the actual monadic type M(T). To formalize this notion, typing and evaluation relations are given for the original and rewritten equations. The rewriting is total, preserves types, and a correctness property relating values of original and rewritten equations is given. A prototype implementation illustrates the benefits with examples such as typing of the simply-typed lambda calculus with Booleans, evaluation of the same, and type inference in Caml Light.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dawn</first_name>
          <last_name>Michaelson</last_name>
          <affiliation>University of Minnesota</affiliation>
          <bio>undefined</bio>
          <person_id>dawnmichaelson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eric</first_name>
          <last_name>Van Wyk</last_name>
          <affiliation>University of Minnesota, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umn.edu/~evw</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ericvanwyk/3e91ebed-d1c2-4d28-a408-dddc41b5affc/small.jpg</picture_url>
          <person_id>ericvanwyk</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cdfa16ae-14bb-465f-8a3d-82f9168a3880</slot_id>
      <event_id>36eaec1d-fd68-4a11-9fa8-9e7691962e35</event_id>
      <title>Strategic Tree Rewriting in Attribute Grammars</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>18:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>18:20</end_time>
      <description>This paper presents strategy attributes, a seamless integration of strategic term rewriting into attribute grammars. Strategy attributes are specified using rewrite rules with strategies that control their application. The rules can reference contextual information held in attributes on the trees being rewritten. This use of attributes leads to rewriting on decorated trees instead of undecorated terms. During rewriting, attributes are (lazily) computed on new trees to ensure they are correct with respect to their defining equations. Attributes and strategic rewriting can each be used where most appropriate, thus avoiding the cumbersome aspects of each. 
Strategy attributes are essentially higher-order attributes for which the defining equations are automatically generated from the attributes' strategy expressions. They are thus compatible with other attribute grammar features such as reference attributes, forwarding, and attribute flow analyses for well-definedness. A conservative static analysis checks if a strategy is intended to always succeed or to be partial, thus simplifying its use and optimizing its translation. Strategy attributes are demonstrated in the optimization of a simple expression language, evaluation of the lambda calculus, and optimization of strategy attribute translations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lucas</first_name>
          <last_name>Kramer</last_name>
          <affiliation>University of Minnesota</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/lucaskramer/1632792f-4c70-4e79-b2ba-6bfcfd3d5c95/small.jpg</picture_url>
          <person_id>lucaskramer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eric</first_name>
          <last_name>Van Wyk</last_name>
          <affiliation>University of Minnesota, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umn.edu/~evw</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ericvanwyk/3e91ebed-d1c2-4d28-a408-dddc41b5affc/small.jpg</picture_url>
          <person_id>ericvanwyk</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d43f39b2-f280-4127-a2fc-1fc74080ccef</slot_id>
      <event_id>134617c3-cba5-44b3-9faf-25e0db401d75</event_id>
      <title>Fluid Quotes: Metaprogramming across Abstraction Boundaries with Dependent Types</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>17:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>18:00</end_time>
      <description>Object-oriented programming, functional programming, and metaprogramming each offer a unique axis of abstraction that enables modular code. Macros, a common technique for metaprogramming, capture ASTs as quotes to let users manipulate them in the host language. However, macros are often at odds with other programming techniques since they can only process code written at the call-site and cannot analyze code behind abstraction boundaries such as variables and methods. Furthermore, the quotes generated for macro expansion only exist at compile-time and cannot be passed around in user code. Multi-stage programming treats quotes as runtime values to address this problem, but introduces the cost of running the compiler when splicing quotes. This forces developers to choose between low runtime overhead and modularity. What if we could have the best of both worlds? We introduce fluid quotes, a new technique that uses dependent types to let users pass quotes through abstraction boundaries in runtime code while splicing them ahead-of-time. This technique enables new metaprogramming capabilities by eliminating the traditional requirement of co-locating parameter expressions with call-sites. Fluid quotes capture not only source code but also associated runtime values to ensure correctness. In addition, they can be composed into larger expressions without any macro code. We demonstrate the capabilities of fluid quotes through two specific applications: optimizing data processing pipelines and making language integrated queries more flexible.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shadaj</first_name>
          <last_name>Laddad</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://shadaj.me</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shadajladdad/d64c98bb-f1a7-4627-8ce4-f30e39b4d77d/small.jpg</picture_url>
          <person_id>shadajladdad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Koushik</first_name>
          <last_name>Sen</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>Koushik Sen is a professor in the Department of Electrical Engineering and Computer Sciences at the University of California, Berkeley. His research interest lies in Software Engineering, Programming Languages, and Formal methods. He is interested in developing software tools and methodologies that improve programmer productivity and software quality. He holds a B.Tech from Indian Institute of Technology, Kanpur, and M.S. and Ph.D. in CS from University of Illinois at Urbana-Champaign.</bio>
          <homepage_url>https://people.eecs.berkeley.edu/~ksen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/koushiksen/9f417f8a-40b9-40a7-866c-9c44cd81859a/small.jpg</picture_url>
          <person_id>koushiksen</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>db3bf9ba-bc9e-4ee5-ab22-00032f163bef</slot_id>
      <event_id>741d1273-956c-4747-a5a6-305b9f8931c5</event_id>
      <title>VarSem: Declarative Expression and Automated Inference of Variable Usage Semantics</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>17:20</end_time>
      <description>Programmers declare variables to serve specific implementation purposes that we refer to as \emph{variable usage semantics (VUS)}. Understanding VUS is required for various software engineering tasks, including program comprehension, code audits, and vulnerability detection. To help programmers understand VUS, we present a new program analysis that infers a variable’s usage semantics from its textual and context information (e.g., symbolic name, type, scope, information flow). To support this analysis, we introduce VarSem, a domain-specific language, in which a variable’s semantic category is expressed as a set of declarative rules. VarSem’s execution determines which program variables belong to a given semantic category. VarSem translates high-level declarative rules into low-level program analysis techniques, including natural language processing and data flow, and provides a highly extensible architecture for specifying new rules and analysis techniques. We evaluate VarSem with eight real-world systems to identify their personally identifiable information variables. The evaluation results show that VarSem infers variable semantics with satisfying accuracy/precision and passable recall, thus potentially benefiting both software and security engineers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yin</first_name>
          <last_name>Liu</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.google.com/vt.edu/yinl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yinliu/1bc32554-be71-4a23-8aab-f60279fd51d1/small.jpg</picture_url>
          <person_id>yinliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eli</first_name>
          <last_name>Tilevich</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.vt.edu/~tilevich</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elitilevich/10b9c85c-8a75-4acb-a0fe-e00c91dd0bb6/small.jpg</picture_url>
          <person_id>elitilevich</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ed04a9db-4792-4985-af9c-7edd1bac90b2</subevent_id>
    <title>GPCE: GPCE/SLE Opening</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/15</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
    </tracks>
    <timeslot>
      <slot_id>13b9dbc0-2460-4852-879d-33b0be6943bf</slot_id>
      <title>Session: GPCE - GPCE/SLE Opening</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>09:00</start_time>
      <end_time>09:40</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Erwig</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.engr.oregonstate.edu/~erwig/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/martinerwig/8fd12ecd-2d70-44d3-a670-d5ef12393f9c/small.jpg</picture_url>
          <person_id>martinerwig</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Jeff</first_name>
          <last_name>Gray</last_name>
          <affiliation>University of Alabama</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gray.cs.ua.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeffgray/1f2fd602-bac6-49dd-86e4-549b5dc88528/small.jpg</picture_url>
          <person_id>jeffgray</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>3</sort_key>
          <first_name>Ralf</first_name>
          <last_name>Lämmel</last_name>
          <affiliation>Facebook London</affiliation>
          <bio>http://www.softlang.org/rlaemmel:bio</bio>
          <homepage_url>http://softlang.wikidot.com/rlaemmel:home</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ralflammel/bc00aec2-e243-40e0-be65-bf9e5e21b0be/small.jpg</picture_url>
          <person_id>ralflammel</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>4</sort_key>
          <first_name>Laurence</first_name>
          <last_name>Tratt</last_name>
          <affiliation>King's College London</affiliation>
          <bio>Programmer / researcher.</bio>
          <homepage_url>https://tratt.net/laurie/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/laurencetratt/f715fc31-2c46-4e48-9a13-d715343fdd4d/small.jpg</picture_url>
          <person_id>laurencetratt</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>5</sort_key>
          <first_name>Juan</first_name>
          <last_name>de Lara</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arantxa.ii.uam.es/~jlara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juandelara/36b5a702-1b04-48b9-8849-869aa603a88d/small.jpg</picture_url>
          <person_id>juandelara</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7886e846-c700-4d5d-a958-cc3ce28ef7cf</slot_id>
      <event_id>bb9db12e-2afb-4297-aede-22b724436e5a</event_id>
      <title>GPCE/SLE Opening</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:40</end_time>
      <description>undefined</description>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e23ee914-1a30-456f-bdab-f3b5ddef2680</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/15</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>b4f8a033-a808-4fb0-868f-b28b7e04aca2</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Sheng</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Louisiana at Lafayette, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.cmix.louisiana.edu/schen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shengchen1/4561e224-57d6-4243-9b1f-0c895b2c49d7/small.jpg</picture_url>
          <person_id>shengchen1</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9e82d3d0-9778-4409-bef3-3f636e4b0da6</slot_id>
      <event_id>0634bf8c-79e0-4f7f-afaa-210b311fcbf3</event_id>
      <title>Modular and Distributed IDE</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>23:40</end_time>
      <description>Integrated Development Environments (IDEs) are indispensable companions to programming languages. They are increasingly turning towards Web-based infrastructure. The rise of a protocol such as the Language Server Protocol (LSP) that standardizes the separation between a language-agnostic IDE, and a language server that provides all language services (\emph{e.g.,} auto completion, compiler…) has allowed the emergence of high quality generic Web components to build the IDE part that runs in the browser. However, all language services require different computing capacities and response times to guarantee a user-friendly experience within the IDE. The monolithic distribution of all language services prevents to leverage on the available execution platforms (e.g., local platform, application server, cloud). In contrast with the current approaches that provide IDEs in the form of a monolithic client-server architecture, we explore in this paper the modularization of all language services to support their individual deployment and dynamic adaptation within an IDE. We evaluate the performance impact of the distribution of the language services across the available execution platforms on four EMF-based languages, and demonstrate the benefit of a custom distribution.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fabien</first_name>
          <last_name>Coulon</last_name>
          <affiliation>Obeo, France / University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>fabiencoulon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alex</first_name>
          <last_name>Auvolat</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>alexauvolat</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yérom-David</first_name>
          <last_name>Bromberg</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>yeromdavidbromberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>François</first_name>
          <last_name>Taïani</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>francoistaini</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Barais</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>olivierbarais1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Noël</first_name>
          <last_name>Plouzeau</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>noelplouzeau</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d79f7ea3-54e9-4214-ab6d-eb9b60137825</slot_id>
      <event_id>677f497e-d633-4e7c-9fa6-3eb6bdc8a827</event_id>
      <title>Automated Variability Injection for Graphical Modelling Languages</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>23:20</end_time>
      <description>Model-based development approaches, such as Model-Driven Engineering (MDE), heavily rely on the use of modelling languages to achieve and automate software development tasks. To enable the definition of model variants (e.g., supporting the compact description of system families), one solution is to combine MDE with Software Product Lines. However, this is technically costly as it requires adapting many MDE artefacts associated to the modelling language – especially the meta-models and graphical environments. 
To alleviate this situation, we propose a method for the automated injection of variability into graphical modelling languages. Given the meta-model and graphical environment of a particular language, our approach permits configuring the allowed model variability, and the graphical environment is automatically adapted to enable creating models with variability. Our solution is implemented atop the Eclipse Modeling Framework and Sirius, and synthesizes adapted graphical editors integrated with FeatureIDE.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Antonio</first_name>
          <last_name>Garmendia</last_name>
          <affiliation>JKU Linz</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.se.jku.at/antonio-garmendia/</homepage_url>
          <person_id>antoniogarmendia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Wimmer</last_name>
          <affiliation>Johannes Kepler University Linz</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.se.jku.at/manuel-wimmer/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelwimmer/debab079-8b78-46af-8f24-2ce08001b86f/small.jpg</picture_url>
          <person_id>manuelwimmer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Esther</first_name>
          <last_name>Guerra</last_name>
          <affiliation>Universidad Autonoma de Madrid</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/estherguerra/e25b23e7-460a-487a-ac4f-bd6326e36ac7/small.jpg</picture_url>
          <person_id>estherguerra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Elena</first_name>
          <last_name>Gómez-Martínez</last_name>
          <affiliation>Universidad Autonoma de Madrid</affiliation>
          <bio>undefined</bio>
          <person_id>elenagomezmartinez</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Juan</first_name>
          <last_name>de Lara</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arantxa.ii.uam.es/~jlara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juandelara/36b5a702-1b04-48b9-8849-869aa603a88d/small.jpg</picture_url>
          <person_id>juandelara</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d8e941eb-b662-487e-b4be-e639415e1c25</slot_id>
      <event_id>c32f3297-945e-48d1-95da-9f3daec1ec11</event_id>
      <title>A Family of Languages for Trustworthy Agent-Based Simulation</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>00:20</end_time>
      <description>Simulation is a key tool for researching complex system behaviour. Agent-based simulation has been applied across domains, such as biology, health, economics and urban sciences. However, engineering robust, efficient, maintainable, and reliable agent-based simulations is challenging. We present a vision for engineering agent simulations comprising a family of domain-specific modelling languages (DSMLs) that integrates core software engineering, validation and simulation experimentation. We relate the vision to examples of principled simulation, to show how the DSMLs would improve robustness, efficiency, and maintainability of simulations. Focusing on how to demonstrate the fitness for purpose of a simulator, the envisaged approach supports bi-directional transparency and traceability between the original domain understanding to the implementation, interpretation of results and evaluation of hypotheses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Steffen</first_name>
          <last_name>Zschaler</last_name>
          <affiliation>King's College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.steffen-zschaler.de/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/steffenzschaler/aeac85bf-ae27-4394-b79a-4569c1138728/small.jpg</picture_url>
          <person_id>steffenzschaler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fiona</first_name>
          <last_name>Polack</last_name>
          <affiliation>Keele University</affiliation>
          <bio>undefined</bio>
          <person_id>fionapolack</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>edcafea1-d711-4105-a1d1-ad7bbde769df</slot_id>
      <event_id>404bc9e9-77ae-4014-95e6-150008d75fce</event_id>
      <title>Correctness-by-Construction for Feature-Oriented Software Product Lines</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/15</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>00:00</end_time>
      <description>\emph{Software product lines} are increasingly used to handle the growing demand of custom-tailored software variants. They provide systematic reuse of software and other artifacts paired with variability mechanisms in the code to implement whole product families rather than single software products. A common domain of application for product lines are safety-critical systems, which require \emph{behavioral correctness} to omit dangerous situations in-field. While most approaches in academia concentrate on post-hoc verification for product lines, we argue that a stepwise approach to create correct programs may be beneficial for the developer to manage the growing variability. \emph{Correctness-by-construction} is such a stepwise approach to create programs using a set of small, tractable refinement rules that guarantee the correctness of the program with regard to its specification. In this paper, we propose the first approach to develop correct-by-construction software product lines using feature-oriented programming. First, we extend correctness-by-construction by two refinement rules for variation points in the code. Second, we give a proof for the soundness of the proposed rules. Third, we implement our technique in a tool called VarCorC and show the applicability of the tool by conducting two case studies.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tabea</first_name>
          <last_name>Bordis</last_name>
          <affiliation>TU Braunschweig</affiliation>
          <bio>undefined</bio>
          <person_id>tabeabordis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Runge</last_name>
          <affiliation>TU Braunschweig</affiliation>
          <bio>undefined</bio>
          <person_id>tobiasrunge</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ina</first_name>
          <last_name>Schaefer</last_name>
          <affiliation>Technische Universität Braunschweig</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.tu-braunschweig.de/isf/team/schaefer</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/inaschaefer/49ab41dc-9f8c-4f0f-b786-43b70d25d96d/small.jpg</picture_url>
          <person_id>inaschaefer</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2f0f8934-4a75-4f18-b5cd-167e29274e2c</subevent_id>
    <title>ECOOP Research Papers: S-3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>8e8df2d3-039d-461a-b9f0-9ac7dfab5755</slot_id>
      <title>Session: ECOOP Research Papers - S-3</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Elisa</first_name>
          <last_name>Gonzalez Boix</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~egonzale</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elisagonzalezboix/8e8a61c4-366e-49b5-a861-7dfbc98ee129/small.jpg</picture_url>
          <person_id>elisagonzalezboix</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Igarashi</last_name>
          <affiliation>Kyoto University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/atsushiigarashi/bbac1695-343a-4091-b33c-b7f01dea73da/small.jpg</picture_url>
          <person_id>atsushiigarashi</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>157fb7bc-e75f-4fb9-896e-0088e6e289ba</slot_id>
      <event_id>a6b2d038-de0e-4dba-afec-21ca56a42e47</event_id>
      <title>Sound regular corecursion in coFJ</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>23:40</end_time>
      <description>The aim of the paper is to provide solid foundations for a programming paradigm natively supporting the creation and manipulation of cyclic data structures. To this end, we describe coFJ, a Java-like calculus where objects can be \emph{infinite} and methods are equipped with a \emph{codefinition} (an alternative body). We provide an abstract semantics of the calculus based on the framework of \emph{inference systems with corules}. In coFJ with this semantics, FJ recursive methods on finite objects can be extended to infinite objects as well, and behave as desired by the programmer, by specifying a codefinition. In the meantime, we describe an operational semantics which can be directly implemented in a programming language, and prove the soundness of such semantics with respect to the abstract one.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Davide</first_name>
          <last_name>Ancona</last_name>
          <affiliation>DIBRIS, University of Genova, Italy</affiliation>
          <bio>Davide Ancona (PhD in Computer Science, University of Pisa, 1998) is Associate Professor at the University of Genova. His main research interests include type systems, object-oriented programming, coinduction methods for programming languages, modules and components, software reuse and maintenance, multi-agent systems, and behavioral types. He is author of more than 70 publications. He is the secretary of the executive board of AITO, Association Internationale pour les Technologies Objets (since Jan 2013, previously Vice-President since Jan 2012), and member of the editorial board of the ACM/SIGAPP Applied Computing Review (ACR), Scientific Programming (Hindawi), and Open Computer Science. He has been guest editor of special issues of Science of Computer Programming and Journal of Object Technology. In 2009 he received, together with G. Lagorio, the best paper prize at ECOOP. He has participated to several national and European projects and has been PC member of several workshops and conferences: WOOD’04, Bytecode 2008, ESOP 2008, DLS 2009, 2010 and 2013, FOOL 2010, RP 2011 and 2012, ECOOP 2013 and 2014, POPL 2015 (ERC), OOPSLA 2016 (ERC), TASE 2016, FTfJP 2016. He has been involved in the organization of several scientific events: organizing chair of ECOOP 2009, program co-chair of FTfJP06 and of OOPS special track at SAC from 2004 through 2017, co-chair of CILC 2015 and VORTEX 2016.</bio>
          <homepage_url>http://www.disi.unige.it/person/AnconaD/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davideancona/50b3fc2f-1782-4ca1-91a5-6718f42ba51b/small.jpg</picture_url>
          <person_id>davideancona</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pietro</first_name>
          <last_name>Barbieri</last_name>
          <affiliation>Università di Genova</affiliation>
          <bio>undefined</bio>
          <person_id>pietrobarbieri</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Dagnino</last_name>
          <affiliation>DIBRIS, University of Genova, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.dibris.unige.it/en/dagnino-francesco</homepage_url>
          <person_id>francescodagnino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Elena</first_name>
          <last_name>Zucca</last_name>
          <affiliation>University of Genova</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.disi.unige.it/person/ZuccaE/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elenazucca/31be5390-fc85-4134-90af-718c3b50c4a3/small.jpg</picture_url>
          <person_id>elenazucca</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4b317c64-c032-4a77-ac76-c7a7c05af3b8</slot_id>
      <event_id>51bcdb71-4f23-4307-a4b8-8565ca1fb7ab</event_id>
      <title>Flow-Sensitive Type-Based Heap Cloning</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>23:20</end_time>
      <description>Flow-sensitive pointer analysis promises more precise results than its flow-insensitive counterpart by respecting program control-flow. However, existing heap abstractions for C/C++ flow-sensitive pointer analysis model the heap by creating one heap object per memory allocation. Two runtime heap objects which originate from the same allocation site are imprecisely modeled using one abstract object, which makes them share the same imprecise points-to sets and thus reduces the benefit of analysing heap objects flow-sensitively. On the other hand, equipping flow-sensitive analysis with context-sensitivity where an abstract heap object is created (cloned) per calling context can yield a more precise heap modeling for flow-sensitive analysis, but at the cost of uncontrollable analysis overhead when analysing larger programs. 
This paper presents TypeClone, a new type-based heap model for flow-sensitive analysis. Our key insight is to differentiate concrete heap objects lazily using the type information at their use sites (e.g., accessed via pointer dereferencing) within the program control-flow. The novelty of TypeClone lies in its lazy heap cloning: an untyped abstract heap object created at an allocation site is killed and replaced with a new (cloned) object uniquely identified by the type information at its use site for flow-sensitive points-to propagation. This yields more precise points-to relations for each program point through well-typed objects where necessary. Thus, heap cloning can be performed within a flow-sensitive analysis without the need for context-sensitivity. Moreover, we extend TypeClone to support new kinds of strong updates for heap objects to filter out imprecise points-to relations at object use sites for programs conforming to the strict aliasing rules based on the standard C/C++ specification. Our method is neither strictly superior nor inferior to context-sensitive heap cloning, but rather, represents a new dimension that achieves a sweet spot between precision and efficiency. Our experimental results also confirm that TypeClone is more precise than flow-sensitive pointer analysis by increasing the percentage of no-alias queries by 12% on average.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohamad</first_name>
          <last_name>Barbar</last_name>
          <affiliation>University of Technology, Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>mohamadbarbar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yulei</first_name>
          <last_name>Sui</last_name>
          <affiliation>University of Technology Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuleisui.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yuleisui/e6ce6e88-3cd8-4595-9c61-a8da6f7319f6/small.jpg</picture_url>
          <person_id>yuleisui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Shiping</first_name>
          <last_name>Chen</last_name>
          <affiliation>Data61 at CSIRO, Australia / UNSW, Australia</affiliation>
          <bio>Dr. Shiping Chen is a principal research scientist in CSIRO Data61. He also holds an conjoint A/Professor title with the University of New Suouth Wales (UNSW) and the University of Sydney through teaching and supervising PhD students. He has been working on distributed systems for over 20 years with focus on performance and security. He has published 150+ research papers in these research areas. He is actively involved in computing research community through publications, journal editorship and conference TPC services, including WWW, EDOC, ICSOC and IEEE ICWS/SCC/CLOUD. His current research interests include application security, blockchain and service-oriented trusted collaboration. He is a senior member of the IEEE.</bio>
          <homepage_url>https://www.cse.unsw.edu.au/~z9195738/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shipingchen/820fa36a-2dfb-43c7-996f-98306efc746b/small.jpg</picture_url>
          <person_id>shipingchen</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d3f58031-0f4f-4e20-b72a-4d67b8e68440</slot_id>
      <event_id>fca401c6-2be9-4344-9688-7495c67214c0</event_id>
      <title>Value Partitioning: A Lightweight Approach to Relational Static Analysis for JavaScript</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>00:00</end_time>
      <description>In static analysis of modern JavaScript libraries, relational analysis at key locations is critical to provide sound and useful results. Prior work addresses this challenge by the use of various forms of trace partitioning and syntactic patterns, which is fragile and does not scale well, or by incorporating complex backwards analysis. 
In this paper, we propose a new lightweight variant of trace partitioning named value partitioning that refines individual abstract values instead of entire abstract states. We describe how this approach can effectively capture important relational properties involving dynamic property accesses, functions with free variables, and predicate functions. 
We extend an existing JavaScript analyzer with value partitioning and demonstrate experimentally that it is a simple, precise, and efficient alternative to the existing approaches for analyzing widely used JavaScript libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Benjamin Barslev</first_name>
          <last_name>Nielsen</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/benjaminbarslevnielsen/7c6acacc-eb83-4ad2-8f27-d9a7ce64e58e/small.jpg</picture_url>
          <person_id>benjaminbarslevnielsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anders</first_name>
          <last_name>Møller</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
          <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
          <person_id>andersmoller</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e9555e5a-4700-47b5-a06f-c0a4a4f39fab</slot_id>
      <event_id>b3bfaad5-f792-4abe-beec-b2c3543839eb</event_id>
      <title>Row and Bounded Polymorphism via Disjoint Polymorphism</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>00:20</end_time>
      <description>Polymorphism and subtyping are important features in mainstream OO languages. The most common way to integrate the two is via F&amp;lt;: style bounded quantification. A closely related mechanism is row polymorphism, which provides an alternative to subtyping, while still enabling many of the same applications. Yet another approach is to have type systems with intersection types and polymorphism. A recent addition to this design space are calculi with disjoint intersection types and disjoint polymorphism. With all these alternatives it is natural to wonder how they are related. 
This paper provides an answer to this question. We show that disjoint polymorphism can recover forms of both row polymorphism and bounded polymorphism, while retaining key desirable properties, such as type-safety and decidability. Furthermore, we identify the extra power of disjoint polymorphism which enables additional features that cannot be easily encoded in calculi with row polymorphism or bounded quantification alone. Ultimately we expect that our work is useful to inform language designers about the expressive power of those common features, and to simplify implementations and metatheory of feature-rich languages with polymorphism and subtyping.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ningning</first_name>
          <last_name>Xie</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://xnning.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ningningxie/99787204-daa9-484a-bea5-4b2b88551687/small.jpg</picture_url>
          <person_id>ningningxie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xuan</first_name>
          <last_name>Bi</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <person_id>xuanbi1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>803c0f1f-3664-4e56-bbcb-17e7c53e7a8c</subevent_id>
    <title>ECOOP Research Papers: S-2</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>2bd94b7b-8665-49ba-b486-24c3226f5375</slot_id>
      <title>Session: ECOOP Research Papers - S-2</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Shigeru</first_name>
          <last_name>Chiba</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.csg.ci.i.u-tokyo.ac.jp/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shigeruchiba/b57db719-4160-4e39-9f41-ef3facc9e449/small.jpg</picture_url>
          <person_id>shigeruchiba</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Yu David</first_name>
          <last_name>Liu</last_name>
          <affiliation>State University of New York (SUNY) Binghamton</affiliation>
          <bio>I am a Professor at State University of New York (SUNY) at Binghamton. I am interested in programming languages, computer systems, and software engineering. My current research focuses are energy-aware programming languages, data-intensive software, programming unmanned aerial vehicles, and type systems. I received my Ph.D. in Computer Science from the Johns Hopkins University, in 2007.</bio>
          <homepage_url>http://www.cs.binghamton.edu/~davidl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yudavidliu/1da5367f-6c86-4df7-859d-ca63bc2a178b/small.jpg</picture_url>
          <person_id>yudavidliu</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2bf84a91-f362-4e4f-8628-d08472689ea6</slot_id>
      <event_id>938f9252-3dc5-4325-a133-eb25a1ebd488</event_id>
      <title>Perfect is the Enemy of Good: Best-Effort Program Synthesis</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>10:20</end_time>
      <description>Program synthesis promises to help software developers with everyday tasks by generating code snippets automatically from input-output examples and other high-level specifications. The conventional wisdom is that a synthesizer must always satisfy the specification exactly. We conjecture that this all-or-nothing paradigm stands in the way of adopting program synthesis as a developer tool: in practice, the user-written specification often contains errors or is simply too hard for the synthesizer to solve within a reasonable time; in these cases, the user is left with a single over-fitted result or, more often then not, no result at all. In this paper we propose a new program synthesis paradigm we call \emph{best-effort program synthesis}, where the synthesizer returns a ranked list of partially-valid results, i.e., programs that satisfy some part of the specification. 
To support this paradigm, we develop \emph{best-effort enumeration}, a new synthesis algorithm that extends a popular program enumeration technique with the ability to accumulate and return multiple partially-valid results with minimal overhead. We implement this algorithm in a tool called Bester, and evaluate it on $79$ synthesis benchmarks from the literature. Contrary to the conventional wisdom, our evaluation shows that Bester returns useful results even when the specification is flawed or too hard: i) for all benchmarks with an error in the specification, the top three Bester results contain the correct solution, and ii) for most hard benchmarks, the top three results contain non-trivial \emph{fragments} of the correct solution. We also performed a small user study, which confirms our intuition that partially-valid results are useful: the study shows that programmers use the output of the synthesizer for comprehension and often incorporate it into their solutions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>58c9938b-ba5c-452c-a79d-6065c9017c76</slot_id>
      <event_id>b1086991-0f35-4b4b-b7a4-78b902ec9ab5</event_id>
      <title>Blame for Null</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>10:00</end_time>
      <description>Multiple modern programming languages, including Kotlin, Scala, Swift, and C#, have type systems where nullability is explicitly specified in the types. All of the above also need to interoperate with languages where types remain implicitly nullable, like Java. This leads to runtime errors that can manifest in subtle ways. In this paper, we show how to reason about the presence and provenance of such nullability errors using the concept of blame from gradual typing. Specifically, we introduce a calculus LambdaNull, where some terms are typed as implicitly nullable and others as explicitly nullable. Just like in the original blame calculus of Wadler and Findler, interactions between both kinds of terms are mediated by casts with attached blame labels, which indicate the origin of errors. On top of LambdaNull, we then define a second calculus, StratifiedLambdaNull, which closely models the interoperability between languages with implicit nullability and languages with explicit nullability, such as Java and Scala. Our main result is a theorem that states that nullability errors in StratifiedLambdaNull can always be blamed on terms with less-precise typing; that is, terms typed as implicitly nullable. By analogy, this would mean that NullPointerExceptions in combined Java/Scala programs are always the result of unsoundness in the Java type system. We summarize our result with the slogan explicitly nullable programs can’t be blamed. All our results are formalized in the Coq proof assistant.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abel</first_name>
          <last_name>Nieto</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://abeln.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/abelnieto/88adb2b6-4aa2-4cc1-af2b-5a23289e9794/small.jpg</picture_url>
          <person_id>abelnieto</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marianna</first_name>
          <last_name>Rapoport</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mrapoport.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mariannarapoport/7f9f1bbc-f804-49b4-b350-26210268c55b/small.jpg</picture_url>
          <person_id>mariannarapoport</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gregor</first_name>
          <last_name>Richards</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://the.gregor.institute/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gregorrichards/bd8bf252-24c9-4721-a495-c06a6949a332/small.jpg</picture_url>
          <person_id>gregorrichards</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>93a6c2bd-a2d6-4f98-9e4d-bc480a389ee9</slot_id>
      <event_id>e5b5bb01-82ec-490b-a4e5-e62389f99279</event_id>
      <title>Abstracting gradual references</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:20</end_time>
      <description>Gradual typing is an effective approach to integrate static and dynamic typing, which supports the smooth transition between both extremes via the imprecision of type annotations. Gradual typing has been applied in many scenarios such as objects, subtyping, effects, ownership, typestates, information-flow typing, parametric polymorphism, etc. In particular, the combination of gradual typing and mutable references has been explored by different authors, giving rise to four different semantics—invariant, guarded, monotonic and permissive references. These semantics were specially crafted to reflect different design decisions with respect to precision and efficiency tradeoffs. Since then, progress has been made in the formulation of methodologies to systematically derive gradual counterparts of statically-typed languages, but these have not been applied to study mutable references. 
In this article, we explore how the Abstracting Gradual Typing (AGT) methodology, which has been shown to be effective in a variety of settings, applies to mutable references. Starting from a standard statically-typed language with references, we systematically derive with AGT a novel gradual language, called λREF˜. We establish the properties of λREF˜; in particular, it is the first gradual language with mutable references that is proven to satisfy the gradual guarantee. We then compare λREF˜ with the main four existing approaches to gradual references, and show that the application of AGT does justify one of the proposed semantics: we formally prove that the treatment of references in λREF˜ corresponds to the guarded semantics, by presenting a bisimilation with the coercion semantics of Herman et al. In the process, we uncover that any direct application of AGT yields a gradual language that is not space-efficient. We consequently adjust the dynamic semantics of λREF˜ to recover space efficiency. We then show how to extend λREF˜ to support both monotonic and permissive references as well. Finally, we provide the first proof of the dynamic gradual guarantee for monotonic references. As a result, this paper sheds further light on the design space of gradual languages with mutable references and contributes to deepening the understanding of the AGT methodology.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matías</first_name>
          <last_name>Toro</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/matiastoro/65656fe4-15fe-4af6-9a50-7f28cdc25fdb/small.jpg</picture_url>
          <person_id>matiastoro</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile, Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
          <person_id>etanter</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b69d84b9-73ff-46bc-96ac-abe82540ccd2</slot_id>
      <event_id>7a123832-31e7-4cda-8509-cfeef5dacfe3</event_id>
      <title>Don't Panic! Better, Fewer, Syntax Errors for LR Parsers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>09:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:40</end_time>
      <description>Syntax errors are generally easy to fix for humans, but not for parsers, in general, and LR parsers, in particular. Traditional `panic mode’ error recovery, though easy to implement and applicable to any grammar, often leads to a cascading chain of errors that drown out the original. More advanced error recovery techniques suffer less from this problem but have seen little practical use because their typical performance was seen as poor, their worst case unbounded, and the repairs they reported arbitrary. In this paper we introduce an algorithm and implementation that addresses these issues. First, we report the complete set of minimum cost repair sequences for a given location, allowing programmers to select the one that best fits their intention. Second, on a corpus of 200,000 real-world syntactically invalid Java programs, we are able to repair 98.38% ± 0.018% of files within a cut-off of 0.5s. Finally, we use the existence of the complete set of minimum cost repair sequences to reduce one of the most frustrating consequences of error reporting: the cascading error problem. Across our corpus, we report 435,823.0 ± 478.0 error locations to the user, while the panic mode algorithm reports 981,628.0 ± 0.0 error locations: in other words, we reduce the cascading error problem by well over half.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lukas</first_name>
          <last_name>Diekmann</last_name>
          <affiliation>King's College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://lukasdiekmann.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lukasdiekmann/a00dd8d1-84fa-4f67-9b77-d5994819208f/small.jpg</picture_url>
          <person_id>lukasdiekmann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Laurence</first_name>
          <last_name>Tratt</last_name>
          <affiliation>King's College London</affiliation>
          <bio>Programmer / researcher.</bio>
          <homepage_url>https://tratt.net/laurie/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/laurencetratt/f715fc31-2c46-4e48-9a13-d715343fdd4d/small.jpg</picture_url>
          <person_id>laurencetratt</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e9bdff7e-a978-4958-b50d-6c1b91895935</subevent_id>
    <title>ECOOP Research Papers: S-5</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>fabe0dbb-fbbf-4ffe-b09d-5d2fb7bc7d27</slot_id>
      <title>Session: ECOOP Research Papers - S-5</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Davide</first_name>
          <last_name>Ancona</last_name>
          <affiliation>DIBRIS, University of Genova, Italy</affiliation>
          <bio>Davide Ancona (PhD in Computer Science, University of Pisa, 1998) is Associate Professor at the University of Genova. His main research interests include type systems, object-oriented programming, coinduction methods for programming languages, modules and components, software reuse and maintenance, multi-agent systems, and behavioral types. He is author of more than 70 publications. He is the secretary of the executive board of AITO, Association Internationale pour les Technologies Objets (since Jan 2013, previously Vice-President since Jan 2012), and member of the editorial board of the ACM/SIGAPP Applied Computing Review (ACR), Scientific Programming (Hindawi), and Open Computer Science. He has been guest editor of special issues of Science of Computer Programming and Journal of Object Technology. In 2009 he received, together with G. Lagorio, the best paper prize at ECOOP. He has participated to several national and European projects and has been PC member of several workshops and conferences: WOOD’04, Bytecode 2008, ESOP 2008, DLS 2009, 2010 and 2013, FOOL 2010, RP 2011 and 2012, ECOOP 2013 and 2014, POPL 2015 (ERC), OOPSLA 2016 (ERC), TASE 2016, FTfJP 2016. He has been involved in the organization of several scientific events: organizing chair of ECOOP 2009, program co-chair of FTfJP06 and of OOPS special track at SAC from 2004 through 2017, co-chair of CILC 2015 and VORTEX 2016.</bio>
          <homepage_url>http://www.disi.unige.it/person/AnconaD/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davideancona/50b3fc2f-1782-4ca1-91a5-6718f42ba51b/small.jpg</picture_url>
          <person_id>davideancona</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Eli</first_name>
          <last_name>Tilevich</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.vt.edu/~tilevich</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elitilevich/10b9c85c-8a75-4acb-a0fe-e00c91dd0bb6/small.jpg</picture_url>
          <person_id>elitilevich</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>10c4644e-4d00-49bb-b129-f75e2f831273</slot_id>
      <event_id>e3347e1a-7339-425c-a4dd-24bd3b8bcf82</event_id>
      <title>Owicki-Gries Reasoning for C11 RAR</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>16:00</end_time>
      <description>Owicki-Gries reasoning for concurrent programs uses Hoare logic together with an interference freedom rule for concurrency. In this paper, we develop a new proof calculus for the C11 RAR memory model (a fragment of C11 with both relaxed and release-acquire accesses) that allows all Owicki-Gries proof rules for compound statements, including non-interference, to remain unchanged. Our proof method features novel assertions specifying thread-specific views on the state of programs. This is combined with a set of Hoare logic rules that describe how these assertions are affected by atomic program steps. We demonstrate the utility of our proof calculus by verifying a number of standard C11 litmus tests and Peterson’s algorithm adapted for C11. Our proof calculus and its application to program verification have been fully mechanised in the theorem prover</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sadegh</first_name>
          <last_name>Dalvandi</last_name>
          <affiliation>University of Surrey</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dalvandi.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mohammadsadeghdalvandi/c22dc5e6-1b7d-4d4b-bc5d-0c19608c2c89/small.jpg</picture_url>
          <person_id>mohammadsadeghdalvandi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Doherty</last_name>
          <affiliation>University of Sheffield</affiliation>
          <bio>undefined</bio>
          <person_id>simondoherty</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brijesh</first_name>
          <last_name>Dongol</last_name>
          <affiliation>University of Surrey</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/brijeshdongol/1a40f0ae-7a59-4232-b09e-a69a66272c0f/small.jpg</picture_url>
          <person_id>brijeshdongol</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Heike</first_name>
          <last_name>Wehrheim</last_name>
          <affiliation>Paderborn University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.uni-paderborn.de/en/person/573/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/heikewehrheim/77537d51-60d9-4a1d-8187-78047b1f330c/small.jpg</picture_url>
          <person_id>heikewehrheim</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>877f1613-9768-4bf7-8850-eb99519daa18</slot_id>
      <event_id>a0edda4b-941b-497b-904d-4736318de222</event_id>
      <title>Test-Case Reduction via Test-Case Generation: Insights From the Hypothesis Reducer</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>16:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>16:20</end_time>
      <description>We describe internal test case reduction, the method of test case reduction employed by the widely-used Hypothesis property-based testing tool for Python. The key idea of internal test-case reduction is that instead of applying test-case reduction externally to generated test cases, we apply it internally, to the sequence of random choices made during generation, so that a test case is reduced by continually re-generating smaller and simpler test cases that continue to trigger some property of interest in the system under test (e.g. a failure). This allows for fully generic test-case reduction without any user intervention and without the need to write a specific test case reducer for a particular application domain. It also significantly mitigates the test-case validity problem of test-case reduction by ensuring that any reduced test case is one that could in principle have been generated. We describe the rationale behind this approach, explain how it is implemented in Hypothesis in practice, and present an extensive evaluation comparing its effectiveness to that of several other test case reducers, including C-Reduce, Picire and the TSTL reducer, on applications including Python auto-formatting, C compilers, and the SymPy symbolic math library. Our hope is that these insights into the reduction mechanism employed by Hypothesis will be useful to researchers interested in randomized testing and test case reduction, as the crux of the approach is fully generic and should be applicable to any random generator of test cases.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>R. MacIver</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidrmaciver/d5f97248-0c54-4660-b99e-00f052f29fa9/small.jpg</picture_url>
          <person_id>davidrmaciver</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alastair</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c5a34823-4913-4378-8d04-3f6a11e707c6</slot_id>
      <event_id>91001d71-626c-479e-b98d-9569a3dda1f7</event_id>
      <title>Putting Randomized Compiler Testing into Production</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>15:40</end_time>
      <description>We describe our experience over the last 15 months on a compiler testing technology transfer project: taking the GraphicsFuzz research project on randomized metamorphic testing of graphics shader compilers, and building the necessary tooling around it to provide a highly automated process for improving the Khronos Vulkan Conformance Test Suite (CTS) with test cases that expose fuzzer-found compiler bugs, or that plug gaps in test coverage. We present this tooling for test automation—gfauto—in detail, as well as our use of differential coverage and test case reduction as a method for automatically synthesising tests that fill coverage gaps. We explain the value that GraphicsFuzz has provided in automatically testing the ecosystem of tools for transforming, optimizing and validating Vulkan shaders, and the challenges brought by testing a tool ecosystem rather than a single tool. We discuss practical issues associated with putting automated metamorphic testing into production, and provide illustrative examples of bugs found during our work.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alastair</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hugues</first_name>
          <last_name>Evrard</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <person_id>huguesevrard1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Paul</first_name>
          <last_name>Thomson</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <person_id>paulthomson1</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c67c3de3-2891-414e-ae1f-905a86d3f115</slot_id>
      <event_id>4bcfde8b-6df2-40b4-9db4-798cf823616a</event_id>
      <title>Model-View-Update-Communicate: Session Types meet the Elm Architecture</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>15:20</end_time>
      <description>Session types are a type discipline for communication channel endpoints which allow conformance to protocols to be checked statically. Safely implementing session types requires linearity, usually in the form of a linear type system. Unfortunately, linear typing is difficult to integrate with graphical user interfaces (GUIs), and to date most programs using session types are command line applications. 
In this paper, we propose the first principled integration of session typing and GUI development by building upon the Model-View-Update (MVU) architecture, pioneered by the Elm programming language. We introduce λMVU, the first formal model of the MVU architecture, and prove it sound. By extending λMVU with commands as found in Elm, along with linearity and model transitions, we show the first formal integration of session typing and GUI programming. We implement our approach in the Links web programming language, and show examples including a two-factor authentication workflow and multi-room chat server.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Simon</first_name>
          <last_name>Fowler</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>I’m currently a Research Associate on the STARDUST project at the University of Glasgow School of Computing Science. 
My research interests centre around typed functional programming languages, in particular functional approaches to concurrency, web programming, and data management.</bio>
          <homepage_url>http://www.simonjf.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/simonfowler/8da87b62-b333-4c60-ac4a-27594510d4b1/small.jpg</picture_url>
          <person_id>simonfowler</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bf0421ef-63e6-479e-b999-23d2e43bd1cf</subevent_id>
    <title>ECOOP Research Papers: M-4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>fcbc7e93-8e15-4dc9-a346-33647a7727d6</slot_id>
      <title>Session: ECOOP Research Papers - M-4</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Rein</last_name>
          <affiliation>Hasso Plattner Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.patrickrein.de</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/patrickrein/0538cdc6-52aa-408d-9042-80e24d2f8260/small.jpg</picture_url>
          <person_id>patrickrein</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Serrano</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-sop.inria.fr/members/Manuel.Serrano/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelserrano/084e3f7c-e031-4d91-ba23-b96148549086/small.jpg</picture_url>
          <person_id>manuelserrano</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>14ea580a-4cbf-4d4b-8629-1b4764dcfe0f</slot_id>
      <event_id>97ef5573-0f58-46e1-9fe7-f39f45954cbf</event_id>
      <title>Designing with Static Capabilities and Effects</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>01:20</end_time>
      <description>Capabilities (whether object or reference capabilities) are fundamentally tools to restrict effects. Thus static capabilities (object or reference) and effect systems take different technical machinery to the same core problem of statically restricting or reasoning about effects in programs. Any time two approaches can in principle address the same sets of problems, it becomes important to understand the trade-offs between the approaches, how these trade-offs might interact with the problem at hand. 
Experts who have worked in these areas tend to find the trade-offs somewhat obvious, having considered them in context before. However, this kind of design discussion is often written down only implicitly as comparison between two approaches for a specific program reasoning problem, rather than as a discussion of general trade-offs between general classes of techniques. As a result, it is not uncommon to set out to solve a problem with one technique, only to find the other better-suited. 
We discuss the trade-offs between static capabilities (specifically reference capabilities) and effect systems, articulating the challenges each approach tends to have in isolation, and how these are sometimes mitigated. We also put our discussion in context, by appealing to examples of how these trade-offs were considered in the course of developing prior systems in the area. Along the way, we highlight how seemingly-minor aspects of type systems – weakening/framing and the mere existence of type contexts – play a subtle role in the efficacy of these systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Colin</first_name>
          <last_name>Gordon</last_name>
          <affiliation>Drexel University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.drexel.edu/~csgordon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/colingordon/d990db47-1ece-4016-bce5-b764428bd0ee/small.jpg</picture_url>
          <person_id>colingordon</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>56adf6f8-881b-48c1-b331-e8bb014f65ff</slot_id>
      <event_id>075e145e-0c8a-47bf-97d2-fd7ed28f0228</event_id>
      <title>Safe, Flexible Aliasing with Deferred Borrows</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>02:00</end_time>
      <description>t.b.a</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chris</first_name>
          <last_name>Fallin</last_name>
          <affiliation>Mozilla</affiliation>
          <bio>undefined</bio>
          <person_id>chrisfallin</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>883db172-d543-47a7-bd1b-2b71c04adb23</slot_id>
      <event_id>fc6c077e-91cb-4f4f-89be-ffca400b2979</event_id>
      <title>Static Analysis of Shape in TensorFlow Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>02:20</end_time>
      <description>Machine learning has been widely adopted in diverse science and engineering domains, aided by reusable libraries and quick development patterns. The TensorFlow library is probably the best-known representative of this trend and most users employ the Python API to its powerful back-end. TensorFlow programs are susceptible to several systematic errors, especially in the dynamic typing setting of Python. We present a static analysis that tracks the shapes of tensors across Python library calls and warns of several possible mismatches. The key technical aspects are a close modeling of library semantics with respect to tensor shape, and an identification of violations and error-prone patterns. Our analysis is powerful enough to statically detect (with 100% precision) 11 of the 14 shape-related TensorFlow bugs in the recent Zhang et al. empirical study—an independent slice of real-world bugs that also includes semantic violations not statically detectable.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sifis</first_name>
          <last_name>Lagouvardos</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/sifislagouvardos/7bff730b-e719-4f0c-935c-245291f18d9d/small.jpg</picture_url>
          <person_id>sifislagouvardos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Julian</first_name>
          <last_name>Dolby</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-dolby</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juliandolby/092667c4-6e51-4476-8ef0-58b41ce9014d/small.jpg</picture_url>
          <person_id>juliandolby</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Neville</first_name>
          <last_name>Grech</last_name>
          <affiliation>University of Malta</affiliation>
          <bio>I am a Lecturer at the University of Malta. My expertise is focused on program analysis, applied to security and other high-level applications. My research work has been recently highlighted by ACM SIGPLAN and Communications of the ACM. I am also interested in the areas of energy efficient systems, smart contracts, semantics and generative programming. My research tools include decompilers and security analyzers for the Ethereum platform (Gigahorse) and Java pointer and taint analysis frameworks (Doop, P/Taint and HeapDL). Previously, I was Reach High Fellow at the University of Athens, a Senior Research Associate at the University of Bristol, and have worked in industry as a Data Scientist and Software Engineer. I hold a PhD from the University of Southampton.</bio>
          <homepage_url>http://www.nevillegrech.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nevillegrech/e0405613-3240-4ef2-a51f-cb7536870dc5/small.jpg</picture_url>
          <person_id>nevillegrech</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Anastasios</first_name>
          <last_name>Antoniadis</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>I am a PhD student at the Department of Informatics and Telecommunications at University of Athens. I started my PhD on October 2016 under the supervision of professor Yannis Smaragdakis and I am a member of the programming languages and software technologies research group of the department—PLaST. 
My main research area is static points-to analysis of Java programs. In particular, my focus is on large-scale Java applications, such as Java EE applications and static analysis scalability under highly precise context-sensitivity. 
In the past I worked as a research assistant at Oracle Labs Australia in 2019 for 5 months. I was also an intern at CERN for a year in 2012-2013.</bio>
          <homepage_url>https://anantoni.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anastasiosantoniadis/fb0f10eb-be87-449a-bb29-3879c99c4bf2/small.jpg</picture_url>
          <person_id>anastasiosantoniadis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>Research Interests: programming languages and software engineering 
 
 Program analysis (static analysis, test generation, invariant inference, symbolic execution) 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality) 
</bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
          <person_id>yannissmaragdakis</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ddd6be82-685b-43e6-8bb5-c9c20bfa1dc4</slot_id>
      <event_id>0e16ed75-4dc8-4d08-a503-c23f55e52859</event_id>
      <title>A Trusted Infrastructure for Symbolic Analysis of Event-Driven Web Applications</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>01:40</end_time>
      <description>We introduce a trusted infrastructure for symbolic analysis of modern event-driven Web applications. This infrastructure consists of reference implementations of the DOM Core Level 1 and UI Events, JavaScript Promises, and the JavaScript async/await APIs, all underpinned by a simple Core Event Semantics that is sufficiently expressive to describe the event models underlying all these APIs. Our reference implementations are trustworthy in that they follow the API respective standards line-by-line and they are thoroughly tested against the appropriate official test-suites, passing all the applicable tests. Using the Core Events Semantics and the reference implementations, we develop JaVerT.Click, a symbolic execution tool for JavaScript that, for the first time, supports reasoning about JavaScript programs that use some (possibly all) these APIs. Using JaVerT.Click, we perform comprehensive symbolic testing of the events module of Cash, a widely-used jQuery alternative, creating a symbolic test suite with 100% line coverage, establishing bounded correctness of several essential properties of the module, and discovering two subtle, previously unknown bugs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gabriela</first_name>
          <last_name>Sampaio</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~gcs817/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gabrielasampaio/48fe961f-74cb-4bbc-b693-f8afcab7dd2d/small.jpg</picture_url>
          <person_id>gabrielasampaio</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>José</first_name>
          <last_name>Fragoso Santos</last_name>
          <affiliation>INESC-ID/Instituto Superior Técnico, Portugal </affiliation>
          <bio>undefined</bio>
          <homepage_url>http://j3fsantos.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/josesantos/601111d4-5a07-4e79-8f6a-8af72ebd6f95/small.jpg</picture_url>
          <person_id>josesantos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Petar</first_name>
          <last_name>Maksimović</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/petarmaksimovic/10dfc861-3a11-48a5-8af6-f58fd86389e3/small.jpg</picture_url>
          <person_id>petarmaksimovic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Philippa</first_name>
          <last_name>Gardner</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Philippa Gardner is a professor in the Department of Computing at Imperial College London and and has a UKRI Established Fellowship from 2018–2023. Her current research focusses on program verification: in particular, reasoning about Web programs (JavaScript and DOM); and reasoning about concurrent programs. She completed her PhD thesis, supervised by Professor Gordon Plotkin FRS at Edinburgh in 1992 and held five years of fellowships at Edinburgh. She moved to Cambridge in 1998 on an EPSRC Advanced Fellowship, hosted by Professor Robin Milner FRS. She obtained a lectureship at Imperial in 2001, and became professor in 2009. She held a Microsoft Research Cambridge/Royal Academy of Engineering Senior Fellowship from 2005 to 2010 at Imperial. Philippa directs the Research Institute on Verified Trustworthy Software Systems (VeTSS), funded by EPSRC, from 2017 to 2022. She chaired the BCS awards committee, 2013-2018, which decides the Lovelace medal (senior) and Roger Needham award (mid-career) for computer science and engineering.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~pg</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippagardner/8031e77a-ebbb-4963-a5de-94895edd7f71/small.jpg</picture_url>
          <person_id>philippagardner</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2a4b049b-7f71-4b55-a33e-152cb3e7f7ac</subevent_id>
    <title>ECOOP Research Papers: S-5</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>ba30e64a-acaa-4c84-a262-550d3a3a518a</slot_id>
      <title>Session: ECOOP Research Papers - S-5</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Davide</first_name>
          <last_name>Ancona</last_name>
          <affiliation>DIBRIS, University of Genova, Italy</affiliation>
          <bio>Davide Ancona (PhD in Computer Science, University of Pisa, 1998) is Associate Professor at the University of Genova. His main research interests include type systems, object-oriented programming, coinduction methods for programming languages, modules and components, software reuse and maintenance, multi-agent systems, and behavioral types. He is author of more than 70 publications. He is the secretary of the executive board of AITO, Association Internationale pour les Technologies Objets (since Jan 2013, previously Vice-President since Jan 2012), and member of the editorial board of the ACM/SIGAPP Applied Computing Review (ACR), Scientific Programming (Hindawi), and Open Computer Science. He has been guest editor of special issues of Science of Computer Programming and Journal of Object Technology. In 2009 he received, together with G. Lagorio, the best paper prize at ECOOP. He has participated to several national and European projects and has been PC member of several workshops and conferences: WOOD’04, Bytecode 2008, ESOP 2008, DLS 2009, 2010 and 2013, FOOL 2010, RP 2011 and 2012, ECOOP 2013 and 2014, POPL 2015 (ERC), OOPSLA 2016 (ERC), TASE 2016, FTfJP 2016. He has been involved in the organization of several scientific events: organizing chair of ECOOP 2009, program co-chair of FTfJP06 and of OOPS special track at SAC from 2004 through 2017, co-chair of CILC 2015 and VORTEX 2016.</bio>
          <homepage_url>http://www.disi.unige.it/person/AnconaD/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davideancona/50b3fc2f-1782-4ca1-91a5-6718f42ba51b/small.jpg</picture_url>
          <person_id>davideancona</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Gibbons</last_name>
          <affiliation>Department of Computer Science, University of Oxford</affiliation>
          <bio>I am Professor of Computing in the Department of Computer Science at the University of Oxford. I also lead the Algebra of Programming research group. I have served as Deputy Head of Department, and as Director of the Software Engineering Programme, which offers part-time professional Masters’ degrees in Software Engineering and in Software and Systems Security. I am Editor-in-Chief of the Journal of Functional Programming, Chair of the ICFP Steering Committee, Past Vice Chair of ACM SIGPLAN, Past Chair of IFIP WG2.1. Before taking up this post in 1999, I held lectureships at Oxford Brookes University and the University of Auckland, New Zealand.</bio>
          <homepage_url>http://www.cs.ox.ac.uk/jeremy.gibbons/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeremygibbons/17403e55-a926-41cf-ae21-08abecea187c/small.jpg</picture_url>
          <person_id>jeremygibbons</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>19ce1727-9acf-493c-bac4-32573cc02fc2</slot_id>
      <event_id>e3347e1a-7339-425c-a4dd-24bd3b8bcf82</event_id>
      <title>Owicki-Gries Reasoning for C11 RAR</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>04:00</end_time>
      <description>Owicki-Gries reasoning for concurrent programs uses Hoare logic together with an interference freedom rule for concurrency. In this paper, we develop a new proof calculus for the C11 RAR memory model (a fragment of C11 with both relaxed and release-acquire accesses) that allows all Owicki-Gries proof rules for compound statements, including non-interference, to remain unchanged. Our proof method features novel assertions specifying thread-specific views on the state of programs. This is combined with a set of Hoare logic rules that describe how these assertions are affected by atomic program steps. We demonstrate the utility of our proof calculus by verifying a number of standard C11 litmus tests and Peterson’s algorithm adapted for C11. Our proof calculus and its application to program verification have been fully mechanised in the theorem prover</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sadegh</first_name>
          <last_name>Dalvandi</last_name>
          <affiliation>University of Surrey</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dalvandi.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mohammadsadeghdalvandi/c22dc5e6-1b7d-4d4b-bc5d-0c19608c2c89/small.jpg</picture_url>
          <person_id>mohammadsadeghdalvandi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Doherty</last_name>
          <affiliation>University of Sheffield</affiliation>
          <bio>undefined</bio>
          <person_id>simondoherty</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brijesh</first_name>
          <last_name>Dongol</last_name>
          <affiliation>University of Surrey</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/brijeshdongol/1a40f0ae-7a59-4232-b09e-a69a66272c0f/small.jpg</picture_url>
          <person_id>brijeshdongol</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Heike</first_name>
          <last_name>Wehrheim</last_name>
          <affiliation>Paderborn University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.uni-paderborn.de/en/person/573/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/heikewehrheim/77537d51-60d9-4a1d-8187-78047b1f330c/small.jpg</picture_url>
          <person_id>heikewehrheim</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2c211dc2-5e8a-4c78-8af1-4de793946440</slot_id>
      <event_id>91001d71-626c-479e-b98d-9569a3dda1f7</event_id>
      <title>Putting Randomized Compiler Testing into Production</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>03:40</end_time>
      <description>We describe our experience over the last 15 months on a compiler testing technology transfer project: taking the GraphicsFuzz research project on randomized metamorphic testing of graphics shader compilers, and building the necessary tooling around it to provide a highly automated process for improving the Khronos Vulkan Conformance Test Suite (CTS) with test cases that expose fuzzer-found compiler bugs, or that plug gaps in test coverage. We present this tooling for test automation—gfauto—in detail, as well as our use of differential coverage and test case reduction as a method for automatically synthesising tests that fill coverage gaps. We explain the value that GraphicsFuzz has provided in automatically testing the ecosystem of tools for transforming, optimizing and validating Vulkan shaders, and the challenges brought by testing a tool ecosystem rather than a single tool. We discuss practical issues associated with putting automated metamorphic testing into production, and provide illustrative examples of bugs found during our work.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alastair</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hugues</first_name>
          <last_name>Evrard</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <person_id>huguesevrard1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Paul</first_name>
          <last_name>Thomson</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <person_id>paulthomson1</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>615f9fc5-8fe9-4c71-8201-0b83626d6776</slot_id>
      <event_id>4bcfde8b-6df2-40b4-9db4-798cf823616a</event_id>
      <title>Model-View-Update-Communicate: Session Types meet the Elm Architecture</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>03:20</end_time>
      <description>Session types are a type discipline for communication channel endpoints which allow conformance to protocols to be checked statically. Safely implementing session types requires linearity, usually in the form of a linear type system. Unfortunately, linear typing is difficult to integrate with graphical user interfaces (GUIs), and to date most programs using session types are command line applications. 
In this paper, we propose the first principled integration of session typing and GUI development by building upon the Model-View-Update (MVU) architecture, pioneered by the Elm programming language. We introduce λMVU, the first formal model of the MVU architecture, and prove it sound. By extending λMVU with commands as found in Elm, along with linearity and model transitions, we show the first formal integration of session typing and GUI programming. We implement our approach in the Links web programming language, and show examples including a two-factor authentication workflow and multi-room chat server.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Simon</first_name>
          <last_name>Fowler</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>I’m currently a Research Associate on the STARDUST project at the University of Glasgow School of Computing Science. 
My research interests centre around typed functional programming languages, in particular functional approaches to concurrency, web programming, and data management.</bio>
          <homepage_url>http://www.simonjf.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/simonfowler/8da87b62-b333-4c60-ac4a-27594510d4b1/small.jpg</picture_url>
          <person_id>simonfowler</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>91bc3d43-46d1-4c17-ab96-fef9df455f6d</slot_id>
      <event_id>a0edda4b-941b-497b-904d-4736318de222</event_id>
      <title>Test-Case Reduction via Test-Case Generation: Insights From the Hypothesis Reducer</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>04:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>04:20</end_time>
      <description>We describe internal test case reduction, the method of test case reduction employed by the widely-used Hypothesis property-based testing tool for Python. The key idea of internal test-case reduction is that instead of applying test-case reduction externally to generated test cases, we apply it internally, to the sequence of random choices made during generation, so that a test case is reduced by continually re-generating smaller and simpler test cases that continue to trigger some property of interest in the system under test (e.g. a failure). This allows for fully generic test-case reduction without any user intervention and without the need to write a specific test case reducer for a particular application domain. It also significantly mitigates the test-case validity problem of test-case reduction by ensuring that any reduced test case is one that could in principle have been generated. We describe the rationale behind this approach, explain how it is implemented in Hypothesis in practice, and present an extensive evaluation comparing its effectiveness to that of several other test case reducers, including C-Reduce, Picire and the TSTL reducer, on applications including Python auto-formatting, C compilers, and the SymPy symbolic math library. Our hope is that these insights into the reduction mechanism employed by Hypothesis will be useful to researchers interested in randomized testing and test case reduction, as the crux of the approach is fully generic and should be applicable to any random generator of test cases.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>R. MacIver</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidrmaciver/d5f97248-0c54-4660-b99e-00f052f29fa9/small.jpg</picture_url>
          <person_id>davidrmaciver</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alastair</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0d0881ed-45fe-45df-b354-94cc42dbaf4f</subevent_id>
    <title>ECOOP Research Papers: S-6</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>8dad22af-f567-46df-bb57-920ca87e3b36</slot_id>
      <title>Session: ECOOP Research Papers - S-6</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Shigeru</first_name>
          <last_name>Chiba</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.csg.ci.i.u-tokyo.ac.jp/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shigeruchiba/b57db719-4160-4e39-9f41-ef3facc9e449/small.jpg</picture_url>
          <person_id>shigeruchiba</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
          <person_id>tiarkrompf</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>13002b65-4ef8-432f-8372-6f3e06a78669</slot_id>
      <event_id>08eaa378-f2f5-4c5f-b1a8-e9c754b3d384</event_id>
      <title>Reference immutability for DOT</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>17:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>17:40</end_time>
      <description>Reference immutability is a type-based technique for controlling mutation that has been thoroughly studied in Java. We explore how reference immutability interacts with the features of Scala by adding it to the Dependent Object Types (DOT) calculus. Our extension shows how reference immutability can be encoded using existing Scala features such as path-dependent, intersection, and union types. We prove type soundness and the immutability guarantee provided by our calculus.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vlastimil</first_name>
          <last_name>Dort</last_name>
          <affiliation>Charles University</affiliation>
          <bio>undefined</bio>
          <person_id>vlastimildort</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>488ebf27-6d3c-459e-b5f7-83feecd65e63</slot_id>
      <event_id>3198f204-28c6-492a-8457-c51ebcc772f0</event_id>
      <title>Static Race Detection and Mutex Safety and Liveness for Go Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>17:20</end_time>
      <description>Go is a popular concurrent programming language thanks to its ability to efficiently combine concurrency and systems programming. In Go programs, a number of concurrency bugs can be caused by a mixture of data races and communication problems. In this paper, we develop a theory based on behavioural types to statically detect data races and deadlocks in Go programs. We first specify lock safety/liveness and data race properties over a Go program model, using the happens-before relation defined in the Go memory model. We represent these properties of programs in a µ-calculus model of types, and validate them using type-level model-checking. We then extend the framework to account for Go’s channels, and implement a static verification tool which can detect concurrency errors. This is, to the best of our knowledge, the first static verification framework of this kind for the Go language, uniformly analysing concurrency errors caused by a mix of shared memory accesses and asynchronous message-passing communications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julia</first_name>
          <last_name>Gabet</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <person_id>juliagabet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7feba1b3-9075-4aa7-88c0-bcba2ecd9f8b</slot_id>
      <event_id>d4d20ec5-085d-4a47-b76e-d1155d4f08c5</event_id>
      <title>Multiparty Session Programming with Global Protocol Combinators</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>17:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>18:00</end_time>
      <description>Multiparty Session Types (MPST) is a typing discipline for communication protocols. It ensures the absence of communication errors and deadlocks for well-typed communicating processes. The state of the art implementations of the MPST theory rely on (1) runtime linearity checks to ensure correct usage of communication channels and (2) external domain-specific languages for specifying and verifying of multiparty protocols. 
To overcome these limitations, we propose a library for programming with global combinators – a set of functions for writing and verifying multiparty protocols in OCaml. Local behaviours for all processes in a protocol are inferred at once from a global combinator. We formalise global combinators and prove a sound realisability of global combinators – a well-typed global combinator derives a set of local types, by which typed endpoint programs can ensure type and communication safety. Our approach enables fully-static verification and implementation of the whole protocol, from the protocol specification to the process implementations, to happen in the same language. 
We compare our implementation to untyped and continuation-passing style implementations, and demonstrate its expressiveness by implementing a plethora of protocols. We show our library can interoperate with existing libraries and services, implementing DNS (Domain Name Service) protocol and the OAuth (Open Authentication) protocol.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Keigo</first_name>
          <last_name>Imai</last_name>
          <affiliation>Gifu University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/keigoimai/70b0be2a-fa97-45a6-a037-57682ad05bf9/small.jpg</picture_url>
          <person_id>keigoimai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rumyana</first_name>
          <last_name>Neykova</last_name>
          <affiliation>Brunel University London, UK</affiliation>
          <bio>Rumyana Neykova is a lecturer at Brunel University London, previously completed a PhD degree under the supervision of Prof. Nobuko Yoshida at Imperial College London, where she was also research fellow. Her research interests are in the area of distributed systems and networks, as well as type systems and language design. Her PhD focuses on development and applications of a type theory (called session types) for runtime verification of concurrent and distributed systems.</bio>
          <homepage_url>https://www.brunel.ac.uk/people/rumyana-neykova</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rumyananeykova/66457b0a-8e8b-471e-b278-37d7f4242bcb/small.jpg</picture_url>
          <person_id>rumyananeykova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Shoji</first_name>
          <last_name>Yuen</last_name>
          <affiliation>Nagoya University</affiliation>
          <bio>undefined</bio>
          <person_id>shojiyuen</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>85a7d672-0c77-4ca0-9ca1-5d9b6bbb5fde</slot_id>
      <event_id>30a683a6-c04e-4827-bf2a-38cbfe60cc03</event_id>
      <title>Scala with Explicit Nulls</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>18:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>18:20</end_time>
      <description>The Scala programming language makes all reference types implicitly nullable. This is a problem, because null references do not support most operations that do make sense on regular objects, leading to runtime errors. In this paper, we present a modification to the Scala type system that makes nullability explicit in the types. Specifically, we make reference types non-nullable by default, while still allowing for nullable types via union types. We have implemented this design for explicit nulls as a fork of the Dotty (Scala 3) compiler. We evaluate our scheme by migrating a number of Scala libraries to use explicit nulls. Finally, we give a denotational semantics of type nullification, the interoperability layer between Java and Scala with explicit nulls. We show a soundness theorem stating that, for variants of System F omega that model Java and Scala, nullification preserves elements of ground types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abel</first_name>
          <last_name>Nieto</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://abeln.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/abelnieto/88adb2b6-4aa2-4cc1-af2b-5a23289e9794/small.jpg</picture_url>
          <person_id>abelnieto</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yaoyu</first_name>
          <last_name>Zhao</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>yaoyuzhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Angela</first_name>
          <last_name>Chang</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>angelachang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Justin</first_name>
          <last_name>Pu</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>justinpu</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7b9bf4e4-0439-4e0f-b440-eeb4097947c7</subevent_id>
    <title>ECOOP Research Papers: M-6B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/16</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>9faf8ccb-987b-4a73-a4b6-f17594dafea3</slot_id>
      <title>Session: ECOOP Research Papers - M-6B</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>17:00</start_time>
      <end_time>17:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Raffi</first_name>
          <last_name>Khatchadourian</last_name>
          <affiliation>City University of New York (CUNY) Hunter College</affiliation>
          <bio>I am an Assistant Professor in the Department of Computer Science at Hunter College and the Graduate Center of the City University of New York (CUNY). My research is centered on techniques for automated software evolution, particularly those related to automated refactoring and source code recommendation systems. My goal is to ease the burden associated with correctly and efficiently evolving large and complex software by providing automated tools that can be easily used by developers. I am also interested in the automated analysis of Object-Oriented and Aspect-Oriented programs. 
I received my MS and Ph.D. degrees in Computer Science from Ohio State University and my BS degree in Computer Science from Monmouth University in New Jersey. Prior to joining CUNY, I was a Software Engineer at Apple, Inc. in Cupertino, California, where I worked on Digital Rights Management (DRM) for iTunes, iBooks, and the App store. I also developed distributed software that tested various features of iPhones, iPads, and iPods. You may also find more information about me by visiting my CUNY Academic Commons profile, my vita, GitHub, and my blog (you can subscribe for updates here).</bio>
          <homepage_url>http://cs.hunter.cuny.edu/~Raffi.Khatchadourian99</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/raffikhatchadourian/5c884f46-e4aa-4dc5-b581-2e37f77d320a/small.jpg</picture_url>
          <person_id>raffikhatchadourian</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Rein</last_name>
          <affiliation>Hasso Plattner Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.patrickrein.de</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/patrickrein/0538cdc6-52aa-408d-9042-80e24d2f8260/small.jpg</picture_url>
          <person_id>patrickrein</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>68b049f7-0772-4dad-b0b1-36053f0c321f</slot_id>
      <event_id>b5cd4295-3dae-4811-a9a2-cd69e93f5866</event_id>
      <title>Space-Efficient Gradual Typing in Coercion-Passing Style</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/16</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>17:20</end_time>
      <description>Herman et al. (2007, 2010) pointed out that the insertion of run-time checks into a gradually typed program could hamper tail-call optimization and, as a result, worsen the space complexity of the program. To address the problem, they proposed a space-efficient coercion calculus, which was subsequently improved by Garcia, et al. (2009) and Siek et al. (2015). The semantics of these calculi involves eager composition of run-time checks expressed by coercions to prevent the size of a term from growing. However, it relies also on a nonstandard reduction rule, which does not seem easy to implement. In fact, no compiler implementation of gradually typed languages fully supports the space-efficient semantics faithfully. 
In this paper, we study coercion-passing style, which Herman et al. have already mentioned, as a technique for straightforward space-efficient implementation of gradually typed languages. A program in coercion-passing style passes “the rest of run-time checks” around—just like continuation-passing style (CPS), in which “the rest of computation” has been passed around—and (unlike CPS) composes coercions eagerly. We give a formal coercion-passing translation from $\lambda$S by Siek et al. to $\lambda$S$_1$, which is a new calculus of first-class coercions tailored for coercion-passing style, and prove correctness of the translation. We also implement our coercion-passing style transformation for the Grift compiler developed by Kuhlenschmidt et al. and give an experimental result.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuya</first_name>
          <last_name>Tsuda</last_name>
          <affiliation>Kyoto University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~tsuda/</homepage_url>
          <person_id>yuyatsuda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Igarashi</last_name>
          <affiliation>Kyoto University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/atsushiigarashi/bbac1695-343a-4091-b33c-b7f01dea73da/small.jpg</picture_url>
          <person_id>atsushiigarashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tomoya</first_name>
          <last_name>Tabuchi</last_name>
          <affiliation>Kyoto University</affiliation>
          <bio>undefined</bio>
          <person_id>tomoyatabuchi</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>59a1e61f-ee14-49e5-9396-498776b80b79</subevent_id>
    <title>ECOOP Research Papers: M-3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>4c965e50-0695-4c45-908b-69f28d95b600</slot_id>
      <title>Session: ECOOP Research Papers - M-3</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Hidehiko</first_name>
          <last_name>Masuhara</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>Hidehiko Masuhara is a Professor of Mathematical and Computing Science, Tokyo Institute of Technology since April 2013. He received his B.S., M.S., and Ph.D. in Computer Science from Department of Information Science, University of Tokyo in 1992, 1994, and 1999, respectively, and served as an assistant professor, lecturer, and associate professor at Graphics and Computer Science, Graduate School of Arts and Sciences, University of Tokyo from 1995 until 2013.</bio>
          <homepage_url>http://prg.is.titech.ac.jp/people/masuhara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hidehikomasuhara/3ea94269-6fb5-4c6d-8d6f-0435717377d6/small.jpg</picture_url>
          <person_id>hidehikomasuhara</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Rein</last_name>
          <affiliation>Hasso Plattner Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.patrickrein.de</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/patrickrein/0538cdc6-52aa-408d-9042-80e24d2f8260/small.jpg</picture_url>
          <person_id>patrickrein</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3f401f66-d6b6-4df7-bfb2-b0baf826d30a</slot_id>
      <event_id>4bf0a52b-ba6b-417a-97bb-1a2326f941ab</event_id>
      <title>Tackling the Awkward Squad for Reactive Programming: The Actor-Reactor Model</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:20</end_time>
      <description>Reactive programming is a programming paradigm whereby programs are internally represented by a dependency graph, which is used to automatically (re)compute parts of a program whenever its input changes. In practice reactive programming can only be used for some parts of an application: a reactive program is usually embedded in an application that is still written in ordinary imperative languages such as JavaScript or Scala. In this paper we investigate this embedding and we distill “the awkward squad for reactive programming” as 3 concerns that are essential for real-world software development, but that do not fit within reactive programming. They are related to long lasting computations, side-effects, and the coordination between imperative and reactive code. To solve these issues we design a new programming model called the Actor-Reactor Model in which programs are split up in a number of actors and reactors. Actors and reactors enforce a strict separation of imperative and reactive code, and they can be composed via a number of composition operators that make use of data streams. We demonstrate the model via our own implementation in a language called Stella.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sam</first_name>
          <last_name>Van den Vonder</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>PhD candidate at the Software Languages Lab of the Vrije Universiteit Brussel.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/samvandenvonder/2ccd1dd4-a774-4f8b-b2a1-c601a5adc3d5/small.jpg</picture_url>
          <person_id>samvandenvonder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thierry</first_name>
          <last_name>Renaux</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <person_id>thierryrenaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bjarno</first_name>
          <last_name>Oeyen</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/bjarnooeyen/c798be09-5fc6-45f6-9840-071793035cef/small.jpg</picture_url>
          <person_id>bjarnooeyen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Joeri</first_name>
          <last_name>De Koster</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/joeridekoster/2f5765d5-6ed1-4a75-acf1-99a86a994912/small.jpg</picture_url>
          <person_id>joeridekoster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Wolfgang</first_name>
          <last_name>De Meuter</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/soft/users/wdmeuter</homepage_url>
          <person_id>wolfgangdemeuter</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8c5bd46d-68b0-437c-9d06-e20bbfe1f548</slot_id>
      <event_id>c6bed3b0-d795-4378-9f4f-f3f70ea00ede</event_id>
      <title>Data Consistency in Transactional Storage Systems: A Centralised Semantics</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>00:20</end_time>
      <description>We introduce an interleaving operational semantics for describing the client-observable behaviour of atomic transactions on distributed key-value stores. Our semantics builds on abstract states comprising centralised, global key-value stores and partial client views. We provide operational definitions of consistency models for our abstract states which we show to be equivalent to the well known declarative definitions of consistency model on abstract executions. We explore two applications, verifying that the COPS replicated database and the Clock-SI partitioned database satisfy their consistency models using trace refinement, and proving invariant properties of client programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shale</first_name>
          <last_name>Xiong</last_name>
          <affiliation>ARM Research</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shalexiong1/1f3bbb1a-1ab1-4f01-9963-e196b6553299/small.jpg</picture_url>
          <person_id>shalexiong1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrea</first_name>
          <last_name>Cerone</last_name>
          <affiliation>Football Radar</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/andreacerone1/ed6fc0c4-5ba2-4bdf-bcc7-e202d5b7328e/small.jpg</picture_url>
          <person_id>andreacerone1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Azalea</first_name>
          <last_name>Raad</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.SoundAndComplete.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/azalearaad/180ee602-475f-483f-a01b-ea187c9e8ac1/small.jpg</picture_url>
          <person_id>azalearaad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Philippa</first_name>
          <last_name>Gardner</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Philippa Gardner is a professor in the Department of Computing at Imperial College London and and has a UKRI Established Fellowship from 2018–2023. Her current research focusses on program verification: in particular, reasoning about Web programs (JavaScript and DOM); and reasoning about concurrent programs. She completed her PhD thesis, supervised by Professor Gordon Plotkin FRS at Edinburgh in 1992 and held five years of fellowships at Edinburgh. She moved to Cambridge in 1998 on an EPSRC Advanced Fellowship, hosted by Professor Robin Milner FRS. She obtained a lectureship at Imperial in 2001, and became professor in 2009. She held a Microsoft Research Cambridge/Royal Academy of Engineering Senior Fellowship from 2005 to 2010 at Imperial. Philippa directs the Research Institute on Verified Trustworthy Software Systems (VeTSS), funded by EPSRC, from 2017 to 2022. She chaired the BCS awards committee, 2013-2018, which decides the Lovelace medal (senior) and Roger Needham award (mid-career) for computer science and engineering.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~pg</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippagardner/8031e77a-ebbb-4963-a5de-94895edd7f71/small.jpg</picture_url>
          <person_id>philippagardner</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>defc4802-da3e-4475-9237-e3a73c08ed77</slot_id>
      <event_id>19f2611f-fa87-46d5-b52e-767476c387fb</event_id>
      <title>Lifting Sequential Effects to Control Operators</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:40</end_time>
      <description>Sequential effect systems are a class of effect system that exploits information about program order, rather than discarding it as traditional commutative effect systems do. This extra expressive power allows effect systems to reason about behavior over time, capturing properties such as atomicity, unstructured lock ownership, or even general safety properties. While we now understand the essential denotational (categorical) models fairly well, application of these ideas to real software is hampered by the variety of source level control flow constructs and control operators in real languages. 
We address this new problem by appeal to a classic idea: macro-expression of commonly-used programming constructs in terms of control operators. We give an effect system for a subset of Racket’s tagged delimited control operators, as a lifting of an effect system for a language without direct control operators. This gives the first account of sequential effects in the presence of general control operators. Using this system, we also re-derive the sequential effect system rules for control flow constructs previously shown sound directly, and derive sequential effect rules for new constructs not previously studied in the context of source-level sequential effect systems. This offers a way to directly extend source-level support for sequential effect systems to real programming languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Colin</first_name>
          <last_name>Gordon</last_name>
          <affiliation>Drexel University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.drexel.edu/~csgordon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/colingordon/d990db47-1ece-4016-bce5-b764428bd0ee/small.jpg</picture_url>
          <person_id>colingordon</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e18b2415-a4be-41d7-96d7-e30c80c6ad66</slot_id>
      <event_id>2d767f19-3b2e-4257-94c7-e2f1d09b2a18</event_id>
      <title>The Duality of Subtyping</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>00:00</end_time>
      <description>Subtyping is a concept frequently encountered in many programming languages and calculi. Various forms of subtyping exist for different type system features, including intersection types, union types or bounded quantification. Normally these features are designed independently of each other, without exploiting obvious similarities (or dualities) between features. This paper proposes a novel methodology for designing subtyping relations that exploits duality between features. At the core of our methodology is a generalization of subtyping relations, which we call Duotyping. Duotyping is parameterized by the mode of the relation. One of these modes is theusual subtyping, while another mode is supertyping (the dual of subtyping). Using the mode it is possible to generalize the usual rules of subtyping to account not only for the intended behaviour of one particular language construct, but also of its dual. Duotyping brings multiple benefits, including: shorter specifications and implementations, dual features that come essentially for free, as well as new proof techniques for various properties of subtyping. To evaluate a design based on Duotyping against traditional designs, we formalized various calculi with common OOP features (including union types, intersection types and bounded quantification) in Coq in both styles. Our results show that the metatheory when using Duotyping does not come at a significant cost: the metatheory with Duotyping has similar complexity and size compared to the metatheory for traditional designs. However, we discover new features as duals to well-known features. Furthermore, we also show that Duotyping can significantly simplify transitivity proofs for many of the calculi studied by us.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shaobo</first_name>
          <last_name>Cui</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>shaobocui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Baber</first_name>
          <last_name>Rehman</last_name>
          <affiliation>University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://baberrehman.github.io/</homepage_url>
          <person_id>baberrehman</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ce6c7af4-5e3b-48d2-9f34-27655320d66c</subevent_id>
    <title>ECOOP Research Papers: S-6</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>b41300bc-f71e-4a28-b511-72a8632b562b</slot_id>
      <title>Session: ECOOP Research Papers - S-6</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Flückiger</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.o1o.ch</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/olivierfluckiger/6051271d-0eac-48f3-b931-bff878bbce61/small.jpg</picture_url>
          <person_id>olivierfluckiger</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Gibbons</last_name>
          <affiliation>Department of Computer Science, University of Oxford</affiliation>
          <bio>I am Professor of Computing in the Department of Computer Science at the University of Oxford. I also lead the Algebra of Programming research group. I have served as Deputy Head of Department, and as Director of the Software Engineering Programme, which offers part-time professional Masters’ degrees in Software Engineering and in Software and Systems Security. I am Editor-in-Chief of the Journal of Functional Programming, Chair of the ICFP Steering Committee, Past Vice Chair of ACM SIGPLAN, Past Chair of IFIP WG2.1. Before taking up this post in 1999, I held lectureships at Oxford Brookes University and the University of Auckland, New Zealand.</bio>
          <homepage_url>http://www.cs.ox.ac.uk/jeremy.gibbons/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeremygibbons/17403e55-a926-41cf-ae21-08abecea187c/small.jpg</picture_url>
          <person_id>jeremygibbons</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>106d37c0-f603-4f5d-95c1-d89cc8375946</slot_id>
      <event_id>3198f204-28c6-492a-8457-c51ebcc772f0</event_id>
      <title>Static Race Detection and Mutex Safety and Liveness for Go Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>05:20</end_time>
      <description>Go is a popular concurrent programming language thanks to its ability to efficiently combine concurrency and systems programming. In Go programs, a number of concurrency bugs can be caused by a mixture of data races and communication problems. In this paper, we develop a theory based on behavioural types to statically detect data races and deadlocks in Go programs. We first specify lock safety/liveness and data race properties over a Go program model, using the happens-before relation defined in the Go memory model. We represent these properties of programs in a µ-calculus model of types, and validate them using type-level model-checking. We then extend the framework to account for Go’s channels, and implement a static verification tool which can detect concurrency errors. This is, to the best of our knowledge, the first static verification framework of this kind for the Go language, uniformly analysing concurrency errors caused by a mix of shared memory accesses and asynchronous message-passing communications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julia</first_name>
          <last_name>Gabet</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <person_id>juliagabet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>13b4f9e0-d6ba-4f23-8ba9-e1541089f70a</slot_id>
      <event_id>d4d20ec5-085d-4a47-b76e-d1155d4f08c5</event_id>
      <title>Multiparty Session Programming with Global Protocol Combinators</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>05:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>06:00</end_time>
      <description>Multiparty Session Types (MPST) is a typing discipline for communication protocols. It ensures the absence of communication errors and deadlocks for well-typed communicating processes. The state of the art implementations of the MPST theory rely on (1) runtime linearity checks to ensure correct usage of communication channels and (2) external domain-specific languages for specifying and verifying of multiparty protocols. 
To overcome these limitations, we propose a library for programming with global combinators – a set of functions for writing and verifying multiparty protocols in OCaml. Local behaviours for all processes in a protocol are inferred at once from a global combinator. We formalise global combinators and prove a sound realisability of global combinators – a well-typed global combinator derives a set of local types, by which typed endpoint programs can ensure type and communication safety. Our approach enables fully-static verification and implementation of the whole protocol, from the protocol specification to the process implementations, to happen in the same language. 
We compare our implementation to untyped and continuation-passing style implementations, and demonstrate its expressiveness by implementing a plethora of protocols. We show our library can interoperate with existing libraries and services, implementing DNS (Domain Name Service) protocol and the OAuth (Open Authentication) protocol.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Keigo</first_name>
          <last_name>Imai</last_name>
          <affiliation>Gifu University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/keigoimai/70b0be2a-fa97-45a6-a037-57682ad05bf9/small.jpg</picture_url>
          <person_id>keigoimai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rumyana</first_name>
          <last_name>Neykova</last_name>
          <affiliation>Brunel University London, UK</affiliation>
          <bio>Rumyana Neykova is a lecturer at Brunel University London, previously completed a PhD degree under the supervision of Prof. Nobuko Yoshida at Imperial College London, where she was also research fellow. Her research interests are in the area of distributed systems and networks, as well as type systems and language design. Her PhD focuses on development and applications of a type theory (called session types) for runtime verification of concurrent and distributed systems.</bio>
          <homepage_url>https://www.brunel.ac.uk/people/rumyana-neykova</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rumyananeykova/66457b0a-8e8b-471e-b278-37d7f4242bcb/small.jpg</picture_url>
          <person_id>rumyananeykova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Shoji</first_name>
          <last_name>Yuen</last_name>
          <affiliation>Nagoya University</affiliation>
          <bio>undefined</bio>
          <person_id>shojiyuen</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1cb3db5b-8e23-4268-9697-8b46e37a10dc</slot_id>
      <event_id>08eaa378-f2f5-4c5f-b1a8-e9c754b3d384</event_id>
      <title>Reference immutability for DOT</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>05:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>05:40</end_time>
      <description>Reference immutability is a type-based technique for controlling mutation that has been thoroughly studied in Java. We explore how reference immutability interacts with the features of Scala by adding it to the Dependent Object Types (DOT) calculus. Our extension shows how reference immutability can be encoded using existing Scala features such as path-dependent, intersection, and union types. We prove type soundness and the immutability guarantee provided by our calculus.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vlastimil</first_name>
          <last_name>Dort</last_name>
          <affiliation>Charles University</affiliation>
          <bio>undefined</bio>
          <person_id>vlastimildort</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>482615e0-5227-4ad9-8bd7-7f6240ba3669</slot_id>
      <event_id>30a683a6-c04e-4827-bf2a-38cbfe60cc03</event_id>
      <title>Scala with Explicit Nulls</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>06:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>06:20</end_time>
      <description>The Scala programming language makes all reference types implicitly nullable. This is a problem, because null references do not support most operations that do make sense on regular objects, leading to runtime errors. In this paper, we present a modification to the Scala type system that makes nullability explicit in the types. Specifically, we make reference types non-nullable by default, while still allowing for nullable types via union types. We have implemented this design for explicit nulls as a fork of the Dotty (Scala 3) compiler. We evaluate our scheme by migrating a number of Scala libraries to use explicit nulls. Finally, we give a denotational semantics of type nullification, the interoperability layer between Java and Scala with explicit nulls. We show a soundness theorem stating that, for variants of System F omega that model Java and Scala, nullification preserves elements of ground types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abel</first_name>
          <last_name>Nieto</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://abeln.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/abelnieto/88adb2b6-4aa2-4cc1-af2b-5a23289e9794/small.jpg</picture_url>
          <person_id>abelnieto</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yaoyu</first_name>
          <last_name>Zhao</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>yaoyuzhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Angela</first_name>
          <last_name>Chang</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>angelachang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Justin</first_name>
          <last_name>Pu</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>justinpu</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8d4ff240-9894-4ee2-8470-74531a6a3000</subevent_id>
    <title>ECOOP Research Papers: M-4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>29f43eaf-390a-40fd-ba27-8fb675150703</slot_id>
      <title>Session: ECOOP Research Papers - M-4</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Anitha</first_name>
          <last_name>Gollamudi</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://scholar.harvard.edu/anithag</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anithagollamudi/8fb48e67-0664-40de-b6fa-163655dda95a/small.jpg</picture_url>
          <person_id>anithagollamudi</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Raffi</first_name>
          <last_name>Khatchadourian</last_name>
          <affiliation>City University of New York (CUNY) Hunter College</affiliation>
          <bio>I am an Assistant Professor in the Department of Computer Science at Hunter College and the Graduate Center of the City University of New York (CUNY). My research is centered on techniques for automated software evolution, particularly those related to automated refactoring and source code recommendation systems. My goal is to ease the burden associated with correctly and efficiently evolving large and complex software by providing automated tools that can be easily used by developers. I am also interested in the automated analysis of Object-Oriented and Aspect-Oriented programs. 
I received my MS and Ph.D. degrees in Computer Science from Ohio State University and my BS degree in Computer Science from Monmouth University in New Jersey. Prior to joining CUNY, I was a Software Engineer at Apple, Inc. in Cupertino, California, where I worked on Digital Rights Management (DRM) for iTunes, iBooks, and the App store. I also developed distributed software that tested various features of iPhones, iPads, and iPods. You may also find more information about me by visiting my CUNY Academic Commons profile, my vita, GitHub, and my blog (you can subscribe for updates here).</bio>
          <homepage_url>http://cs.hunter.cuny.edu/~Raffi.Khatchadourian99</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/raffikhatchadourian/5c884f46-e4aa-4dc5-b581-2e37f77d320a/small.jpg</picture_url>
          <person_id>raffikhatchadourian</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1b02ba5a-d4af-4e2c-bba6-d5a74efacba8</slot_id>
      <event_id>0e16ed75-4dc8-4d08-a503-c23f55e52859</event_id>
      <title>A Trusted Infrastructure for Symbolic Analysis of Event-Driven Web Applications</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>13:40</end_time>
      <description>We introduce a trusted infrastructure for symbolic analysis of modern event-driven Web applications. This infrastructure consists of reference implementations of the DOM Core Level 1 and UI Events, JavaScript Promises, and the JavaScript async/await APIs, all underpinned by a simple Core Event Semantics that is sufficiently expressive to describe the event models underlying all these APIs. Our reference implementations are trustworthy in that they follow the API respective standards line-by-line and they are thoroughly tested against the appropriate official test-suites, passing all the applicable tests. Using the Core Events Semantics and the reference implementations, we develop JaVerT.Click, a symbolic execution tool for JavaScript that, for the first time, supports reasoning about JavaScript programs that use some (possibly all) these APIs. Using JaVerT.Click, we perform comprehensive symbolic testing of the events module of Cash, a widely-used jQuery alternative, creating a symbolic test suite with 100% line coverage, establishing bounded correctness of several essential properties of the module, and discovering two subtle, previously unknown bugs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gabriela</first_name>
          <last_name>Sampaio</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~gcs817/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gabrielasampaio/48fe961f-74cb-4bbc-b693-f8afcab7dd2d/small.jpg</picture_url>
          <person_id>gabrielasampaio</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>José</first_name>
          <last_name>Fragoso Santos</last_name>
          <affiliation>INESC-ID/Instituto Superior Técnico, Portugal </affiliation>
          <bio>undefined</bio>
          <homepage_url>http://j3fsantos.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/josesantos/601111d4-5a07-4e79-8f6a-8af72ebd6f95/small.jpg</picture_url>
          <person_id>josesantos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Petar</first_name>
          <last_name>Maksimović</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/petarmaksimovic/10dfc861-3a11-48a5-8af6-f58fd86389e3/small.jpg</picture_url>
          <person_id>petarmaksimovic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Philippa</first_name>
          <last_name>Gardner</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Philippa Gardner is a professor in the Department of Computing at Imperial College London and and has a UKRI Established Fellowship from 2018–2023. Her current research focusses on program verification: in particular, reasoning about Web programs (JavaScript and DOM); and reasoning about concurrent programs. She completed her PhD thesis, supervised by Professor Gordon Plotkin FRS at Edinburgh in 1992 and held five years of fellowships at Edinburgh. She moved to Cambridge in 1998 on an EPSRC Advanced Fellowship, hosted by Professor Robin Milner FRS. She obtained a lectureship at Imperial in 2001, and became professor in 2009. She held a Microsoft Research Cambridge/Royal Academy of Engineering Senior Fellowship from 2005 to 2010 at Imperial. Philippa directs the Research Institute on Verified Trustworthy Software Systems (VeTSS), funded by EPSRC, from 2017 to 2022. She chaired the BCS awards committee, 2013-2018, which decides the Lovelace medal (senior) and Roger Needham award (mid-career) for computer science and engineering.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~pg</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippagardner/8031e77a-ebbb-4963-a5de-94895edd7f71/small.jpg</picture_url>
          <person_id>philippagardner</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>31511112-67dc-4046-bdbd-ae0a7905b587</slot_id>
      <event_id>97ef5573-0f58-46e1-9fe7-f39f45954cbf</event_id>
      <title>Designing with Static Capabilities and Effects</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>13:20</end_time>
      <description>Capabilities (whether object or reference capabilities) are fundamentally tools to restrict effects. Thus static capabilities (object or reference) and effect systems take different technical machinery to the same core problem of statically restricting or reasoning about effects in programs. Any time two approaches can in principle address the same sets of problems, it becomes important to understand the trade-offs between the approaches, how these trade-offs might interact with the problem at hand. 
Experts who have worked in these areas tend to find the trade-offs somewhat obvious, having considered them in context before. However, this kind of design discussion is often written down only implicitly as comparison between two approaches for a specific program reasoning problem, rather than as a discussion of general trade-offs between general classes of techniques. As a result, it is not uncommon to set out to solve a problem with one technique, only to find the other better-suited. 
We discuss the trade-offs between static capabilities (specifically reference capabilities) and effect systems, articulating the challenges each approach tends to have in isolation, and how these are sometimes mitigated. We also put our discussion in context, by appealing to examples of how these trade-offs were considered in the course of developing prior systems in the area. Along the way, we highlight how seemingly-minor aspects of type systems – weakening/framing and the mere existence of type contexts – play a subtle role in the efficacy of these systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Colin</first_name>
          <last_name>Gordon</last_name>
          <affiliation>Drexel University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.drexel.edu/~csgordon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/colingordon/d990db47-1ece-4016-bce5-b764428bd0ee/small.jpg</picture_url>
          <person_id>colingordon</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4bda5241-e426-4814-8599-1a57bc984cc0</slot_id>
      <event_id>075e145e-0c8a-47bf-97d2-fd7ed28f0228</event_id>
      <title>Safe, Flexible Aliasing with Deferred Borrows</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>14:00</end_time>
      <description>t.b.a</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chris</first_name>
          <last_name>Fallin</last_name>
          <affiliation>Mozilla</affiliation>
          <bio>undefined</bio>
          <person_id>chrisfallin</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>aba8f9ed-ee79-4fb9-8327-9f77d51a764e</slot_id>
      <event_id>fc6c077e-91cb-4f4f-89be-ffca400b2979</event_id>
      <title>Static Analysis of Shape in TensorFlow Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>14:20</end_time>
      <description>Machine learning has been widely adopted in diverse science and engineering domains, aided by reusable libraries and quick development patterns. The TensorFlow library is probably the best-known representative of this trend and most users employ the Python API to its powerful back-end. TensorFlow programs are susceptible to several systematic errors, especially in the dynamic typing setting of Python. We present a static analysis that tracks the shapes of tensors across Python library calls and warns of several possible mismatches. The key technical aspects are a close modeling of library semantics with respect to tensor shape, and an identification of violations and error-prone patterns. Our analysis is powerful enough to statically detect (with 100% precision) 11 of the 14 shape-related TensorFlow bugs in the recent Zhang et al. empirical study—an independent slice of real-world bugs that also includes semantic violations not statically detectable.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sifis</first_name>
          <last_name>Lagouvardos</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/sifislagouvardos/7bff730b-e719-4f0c-935c-245291f18d9d/small.jpg</picture_url>
          <person_id>sifislagouvardos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Julian</first_name>
          <last_name>Dolby</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-dolby</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juliandolby/092667c4-6e51-4476-8ef0-58b41ce9014d/small.jpg</picture_url>
          <person_id>juliandolby</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Neville</first_name>
          <last_name>Grech</last_name>
          <affiliation>University of Malta</affiliation>
          <bio>I am a Lecturer at the University of Malta. My expertise is focused on program analysis, applied to security and other high-level applications. My research work has been recently highlighted by ACM SIGPLAN and Communications of the ACM. I am also interested in the areas of energy efficient systems, smart contracts, semantics and generative programming. My research tools include decompilers and security analyzers for the Ethereum platform (Gigahorse) and Java pointer and taint analysis frameworks (Doop, P/Taint and HeapDL). Previously, I was Reach High Fellow at the University of Athens, a Senior Research Associate at the University of Bristol, and have worked in industry as a Data Scientist and Software Engineer. I hold a PhD from the University of Southampton.</bio>
          <homepage_url>http://www.nevillegrech.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nevillegrech/e0405613-3240-4ef2-a51f-cb7536870dc5/small.jpg</picture_url>
          <person_id>nevillegrech</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Anastasios</first_name>
          <last_name>Antoniadis</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>I am a PhD student at the Department of Informatics and Telecommunications at University of Athens. I started my PhD on October 2016 under the supervision of professor Yannis Smaragdakis and I am a member of the programming languages and software technologies research group of the department—PLaST. 
My main research area is static points-to analysis of Java programs. In particular, my focus is on large-scale Java applications, such as Java EE applications and static analysis scalability under highly precise context-sensitivity. 
In the past I worked as a research assistant at Oracle Labs Australia in 2019 for 5 months. I was also an intern at CERN for a year in 2012-2013.</bio>
          <homepage_url>https://anantoni.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anastasiosantoniadis/fb0f10eb-be87-449a-bb29-3879c99c4bf2/small.jpg</picture_url>
          <person_id>anastasiosantoniadis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>Research Interests: programming languages and software engineering 
 
 Program analysis (static analysis, test generation, invariant inference, symbolic execution) 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality) 
</bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
          <person_id>yannissmaragdakis</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0df7ce27-e66c-41fe-82c0-9bcb78fc8a6f</subevent_id>
    <title>ECOOP Research Papers: M-1</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>12a9697e-184b-4fc7-81cf-be54632a7fdb</slot_id>
      <title>Session: ECOOP Research Papers - M-1</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>07:00</start_time>
      <end_time>08:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Boyland</last_name>
          <affiliation>Univeristy of Wisconsin, Milwaukee</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://uwm.edu/engineering/people/boyland-ph-d-john/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnboyland/a5fe137c-ecb4-475c-99c9-04b21c328c13/small.jpg</picture_url>
          <person_id>johnboyland</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Peter</first_name>
          <last_name>Thiemann</last_name>
          <affiliation>University of Freiburg, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/peterthiemann/43fc0175-1745-4b3a-b626-86e10da76b86/small.jpg</picture_url>
          <person_id>peterthiemann</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>00429097-3bb7-479e-8062-2dae10d9b212</slot_id>
      <event_id>fa9502c6-8ae7-4b07-8206-b46b73a9a756</event_id>
      <title>A Semantics for the Essence of React</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>07:20</end_time>
      <description>Traditionally, web applications have been written as HTML pages with embedded JavaScript code that implements dynamic and interactive features by manipulating the Document Object Model (DOM) through a low-level browser API. However, this unprincipled approach leads to code that is brittle, difficult to understand, non-modular, and does not facilitate incremental update of user-interfaces in response to state changes. 
React is a popular framework for constructing web applications that aims to overcome these problems. React applications are written in a declarative and object-oriented style, and consist of components that are organized in a tree structure. Each component has a set of properties representing input parameters, a state consisting of values that may vary over time, and a render method that declaratively specifies the subcomponents of the component. React’s concept of reconciliation determines the impact of state changes and updates the user-interface incrementally by selective mounting and unmounting of subcomponents. At designated points, the React framework invokes lifecycle hooks that enable programmers to perform actions outside the framework such as acquiring and releasing resources needed by a component. 
These mechanisms exhibit considerable complexity, but, to our knowledge, no formal specification of React’s semantics exists. This paper presents a small-step operational semantics that captures the essence of React, as a first step towards a long-term goal of developing automatic tools for program understanding, automatic testing, and bug finding for React web applications. To demonstrate that key operations such as mounting, unmounting, and reconciliation terminate, we define the notion of a well-behaved component and prove that well-behavedness is preserved by these operations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Frank</first_name>
          <last_name>Tip</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Frank Tip is a Professor and Associate Dean for Graduate Programs at Northeastern University. Previously, he was a Senior Principal Engineer at Samsung Research America in Mountain View, California (2014-2016), a Professor and Cheriton Research Chair in the David R. Cheriton School of Computer Science at the University of Waterloo (2012-2014), and a Research Staff Member and Manager at the Software Technology Department at the IBM T.J. Watson Research Center (1995-2012). He received his PhD in 1995 from the University of Amsterdam.</bio>
          <homepage_url>http://www.franktip.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/franktip/b4b4c804-cf32-45fa-afc8-3058f718b160/small.jpg</picture_url>
          <person_id>franktip</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2913ac75-76fd-4eb6-b428-5f7d01ce72de</slot_id>
      <event_id>1afda63b-ac13-4748-afb4-ec818eef4cfe</event_id>
      <title>A Framework for Resource Dependent EDSLs in a Dependently Typed Language</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>07:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>08:00</end_time>
      <description>Idris’ Effects library demonstrates how to embed resource dependent algebraic effect handlers into a dependently typed host language, providing run-time and compile-time based reasoning on type-level resources. Building upon this work, Resources is a framework for realising Embedded Domain Specific Languages (EDSLs) with type-systems that contain domain specific substructural properties. Differing from Effects, Resources allows a language’s substructural properties to be encoded in a resource that is associated with language variables. Thus, allowing for multiple effect instances to be reasoned about autonomically and without explicit type-level declaration. Type-level predicates are used as proof that the language’s substructural properties hold. Several exemplar EDSLs are presented that illustrates our framework’s operation and how dependent types provide correctness-by-construction guarantees that substructural properties of written programs hold.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jan</first_name>
          <last_name>de Muijnck-Hughes</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>Jan is a Research Associate at the School of Computing at the University of Glasgow, where he investigates the construction of Structural and Behavioural Type-Systems for hardware design. Generally speaking, his research interests are revolved around the Type-Driven Development of Communicating Systems using Dependent Types, Session Types, and Algebraic Effects as presented in the dependently typed programming language Idris.</bio>
          <homepage_url>https://jfdm.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jandemuijnckhughes/6828da0f-67ea-4d2a-9c31-38d84d2e4624/small.jpg</picture_url>
          <person_id>jandemuijnckhughes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Wim</first_name>
          <last_name>Vanderbauwhede</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <person_id>wimvanderbauwhede</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Edwin</first_name>
          <last_name>Brady</last_name>
          <affiliation>University of St. Andrews</affiliation>
          <bio>I am a Lecturer in Computer Science at the University of St Andrews, interested in type theory, dependently typed functional programming, compilers and metaprogramming. I am currently working on a new implementation of Idris, a dependently typed functional programming language. When I’m not doing that, you might find me playing Go (I’m about 2 kyu), walking up a hill, watching a game of cricket, or waiting for a delayed train. I’m afraid I also perpetrated the Whitespace programming language.</bio>
          <homepage_url>https://eb.host.cs.st-andrews.ac.uk</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/edwinbrady/cbff36d2-7476-402e-bc2c-e84d1ceb0ab5/small.jpg</picture_url>
          <person_id>edwinbrady</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>37f0477f-c85b-4d3e-bdb5-c8255e2dd864</slot_id>
      <event_id>d20598bd-55e0-4d3d-9727-0b7b671dbce0</event_id>
      <title>Reconciling Event Structures with Modern Multiprocessors</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>07:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>07:40</end_time>
      <description>Weakestmo is a recently proposed memory consistency model that uses event structures to resolve the infamous “out-of-thin-air” problem, and to enable efficient compilation to hardware. Nevertheless, this latter property—compilation correctness—has not yet been formally established. This paper closes this gap by establishing correctness in Coq of the intended compilation schemes from Weakestmo to a wide range of formal hardware memory models (x86, POWER, ARMv7, ARMv8). Our proof is the first that establishes correctness of compilation of an event-structure-based model that forbids “thin-air” behaviors, as well as the first mechanized compilation proof of a weak memory model supporting sequentially consistent accesses to such a range of hardware platforms. Our compilation proof goes via the recent Intermediate Memory Model (IMM), which we suitably extend with sequentially consistent accesses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Evgenii</first_name>
          <last_name>Moiseenko</last_name>
          <affiliation>St. Petersburg University / JetBrains Research</affiliation>
          <bio>undefined</bio>
          <person_id>evgeniimoiseenko</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anton</first_name>
          <last_name>Podkopaev</last_name>
          <affiliation>NRU HSE, JetBrains Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://podkopaev.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/antonpodkopaev/b00dceb2-5b55-4c0b-afe0-17581b19dfee/small.jpg</picture_url>
          <person_id>antonpodkopaev</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~orilahav/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/orilahav/89b656f6-7634-49d1-9917-4b74da70a976/small.jpg</picture_url>
          <person_id>orilahav</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Orestis</first_name>
          <last_name>Melkonian</last_name>
          <affiliation>Utrecht University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://omelkonian.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/orestismelkonian/823e0ead-bc55-4ee3-b97a-114b787ad406/small.jpg</picture_url>
          <person_id>orestismelkonian</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Vafeiadis</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>Viktor Vafeiadis is a tenured faculty at the Max Planck Institute for Software Systems (MPI-SWS) in Germany. He got his BA and PhD from the University of Cambridge, and held post-doctoral researcher positions at the University of Cambridge and at Microsoft Research Cambridge before joining MPI-SWS in October 2010.</bio>
          <homepage_url>http://www.mpi-sws.org/~viktor/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/viktorvafeiadis/6a063832-47ca-4c32-8047-4bf4f74ae764/small.jpg</picture_url>
          <person_id>viktorvafeiadis</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>796a3f14-d818-422a-91ab-8b8da42502cf</slot_id>
      <event_id>c8f92227-97e4-4cd4-97f8-0dbfb0f80f62</event_id>
      <title>Reshape your layouts, not your programs: A safe language extension for better cache locality</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>08:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>08:20</end_time>
      <description>The vast divide between the speed of CPU and RAM means that effective use of CPU caches is often a prerequisite for high performance on modern architectures. Hence, developers need to consider how to place data in memory so as to exploit spatial locality and achieve high memory bandwidth. Such manual memory optimisations are common in unmanaged languages (e.g. C, C++), but they sacrifice readability, maintainability, memory safety, and object abstraction. In managed languages, such as Java and C#, where the runtime abstracts away the memory from the developer, such optimisations are almost impossible. 
We present a language extension called SHAPES, which aims to offer developers more fine-grained control over the placement of data, without sacrificing memory safety or object abstraction. In SHAPES, programmers group related objects into pools, and specify how objects are laid out in these pools. Classes and types are annotated by pool parameters, which allow placement aspects to be changed orthogonally to the code that operates on the objects in the pool. These design decisions disentangle business logic and memory concerns. 
We give a formal model of SHAPES, present its type and memory safety model, and present its translation to a low-level language. We argue why we expect this translation to be efficient in terms of runtime representation of objects and access to their fields. We argue that SHAPES can be incorporated into existing managed and unmanaged language runtimes and fit well with garbage collection.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexandros</first_name>
          <last_name>Tasos</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexandrostasos/131f6a5e-4994-4195-b143-5eb7d52f3317/small.jpg</picture_url>
          <person_id>alexandrostasos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Juliana</first_name>
          <last_name>Franco</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>julianafranco1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sophia</first_name>
          <last_name>Drossopoulou</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Professor of Programming Languages in the Department of Computing, Imperial College, London, UK.</bio>
          <homepage_url>https://wp.doc.ic.ac.uk/sd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sophiadrossopoulou/f9f2890b-55bd-4796-94ab-fe3291277c90/small.jpg</picture_url>
          <person_id>sophiadrossopoulou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Wrigstad</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wrigstad.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tobiaswrigstad/51b1bbdb-d077-4128-ad29-ec14657617a7/small.jpg</picture_url>
          <person_id>tobiaswrigstad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Susan</first_name>
          <last_name>Eisenbach</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wp.doc.ic.ac.uk/susan/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/susaneisenbach/100322fa-6296-48e2-8238-10431036ea30/small.jpg</picture_url>
          <person_id>susaneisenbach</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bf56d2ad-610c-4f6d-b72b-74e75e8db2a3</subevent_id>
    <title>ECOOP Research Papers: S-4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>0b6e95e5-07a5-4b8b-a06a-d3b8c1112124</slot_id>
      <title>Session: ECOOP Research Papers - S-4</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Elisa</first_name>
          <last_name>Gonzalez Boix</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~egonzale</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elisagonzalezboix/8e8a61c4-366e-49b5-a861-7dfbc98ee129/small.jpg</picture_url>
          <person_id>elisagonzalezboix</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Igarashi</last_name>
          <affiliation>Kyoto University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/atsushiigarashi/bbac1695-343a-4091-b33c-b7f01dea73da/small.jpg</picture_url>
          <person_id>atsushiigarashi</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>29446384-7b2a-45e7-9929-98a58ee22a67</slot_id>
      <event_id>4706f63e-dc56-4e40-bee4-0b030f2b0fcb</event_id>
      <title>A big step from finite to infinite computations</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>02:00</end_time>
      <description>We provide a construction that, given a big-step semantics describing finite computations and their observations, extends it to include infinite computations as well. The basic idea is that the finite behavior uniquely determines the infinite behavior once observations and their composition operators are fixed. Technically, the construction relies on the framework of inference systems with corules. The effectiveness and scope of the approach are illustrated by several examples. The correctness is formally justified by proving that, starting from a big-step semantics equivalent to a reference small-step semantics, this equivalence is preserved by the construction.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Davide</first_name>
          <last_name>Ancona</last_name>
          <affiliation>DIBRIS, University of Genova, Italy</affiliation>
          <bio>Davide Ancona (PhD in Computer Science, University of Pisa, 1998) is Associate Professor at the University of Genova. His main research interests include type systems, object-oriented programming, coinduction methods for programming languages, modules and components, software reuse and maintenance, multi-agent systems, and behavioral types. He is author of more than 70 publications. He is the secretary of the executive board of AITO, Association Internationale pour les Technologies Objets (since Jan 2013, previously Vice-President since Jan 2012), and member of the editorial board of the ACM/SIGAPP Applied Computing Review (ACR), Scientific Programming (Hindawi), and Open Computer Science. He has been guest editor of special issues of Science of Computer Programming and Journal of Object Technology. In 2009 he received, together with G. Lagorio, the best paper prize at ECOOP. He has participated to several national and European projects and has been PC member of several workshops and conferences: WOOD’04, Bytecode 2008, ESOP 2008, DLS 2009, 2010 and 2013, FOOL 2010, RP 2011 and 2012, ECOOP 2013 and 2014, POPL 2015 (ERC), OOPSLA 2016 (ERC), TASE 2016, FTfJP 2016. He has been involved in the organization of several scientific events: organizing chair of ECOOP 2009, program co-chair of FTfJP06 and of OOPS special track at SAC from 2004 through 2017, co-chair of CILC 2015 and VORTEX 2016.</bio>
          <homepage_url>http://www.disi.unige.it/person/AnconaD/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davideancona/50b3fc2f-1782-4ca1-91a5-6718f42ba51b/small.jpg</picture_url>
          <person_id>davideancona</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Dagnino</last_name>
          <affiliation>DIBRIS, University of Genova, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.dibris.unige.it/en/dagnino-francesco</homepage_url>
          <person_id>francescodagnino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jurriaan</first_name>
          <last_name>Rot</last_name>
          <affiliation>Radboud University Nijmegen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jurriaan.me/</homepage_url>
          <person_id>juriaanrot</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Elena</first_name>
          <last_name>Zucca</last_name>
          <affiliation>University of Genova</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.disi.unige.it/person/ZuccaE/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elenazucca/31be5390-fc85-4134-90af-718c3b50c4a3/small.jpg</picture_url>
          <person_id>elenazucca</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>53bb09a0-53c9-423e-b266-4d7a8dd97f56</slot_id>
      <event_id>5fd7f5f9-a5c0-4369-8869-a0e5cfc60db7</event_id>
      <title>K-LLVM: A Relatively Complete Semantics of LLVM IR</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>01:20</end_time>
      <description>LLVM is designed for the compile-time, link-time and run-time optimization of programs written in various programming languages. The language supported by LLVM targeted by modern compilers is LLVM IR. In this paper we define K-LLVM, a reference semantics for LLVM IR. To the best of our knowledge, K-LLVM is the most complete formal LLVM IR semantics to date, including all LLVM IR instructions, intrinsic functions in the LLVM documentation and Standard-C library functions that are necessary to execute many LLVM IR programs. Additionally, K-LLVM formulates an abstract machine that executes all LLVM IR instructions. The machine allows to describe our formal semantics in terms of simulating a conceptual virtual machine that runs LLVM IR programs, including non-deterministic programs. Even though the K-LLVM memory model in this paper is assumed to be a sequentially consistent memory model and does not include all LLVM concurrency memory behaviors, the design of K-LLVM’s data layout allows the K-LLVM abstract machine to execute some LLVM IR programs that previous semantics did not cover, such as the full range of LLVM IR behaviors for the interaction among LLVM IR casting, pointer arithmetic, memory operations and some memory flags (e.g. readonly) of function headers. Additionally, the memory model is modularized in a manner that supports investigating other memory models. To validate K-LLVM, we have implemented it in K [41], which generated an interpreter for LLVM IR. Using this, we ran tests including 1,385 unit test programs and 2,156 concrete LLVM IR programs, and K-LLVM passed all of them.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Liyi</first_name>
          <last_name>Li</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>I am Liyi Li, a PhD student at the University of Illinois at Urbana-Champaign. I will work at the University of Maryland as a PostDoc this fall. My research area is Programming Language, Formal Methods, Compilers and Software Engineering. I am especially interested in verifying compilers. I like to fully verify a compiler in real-world, such as the compiler from Haskell to LLVM. My plan is to define the semantics of the source and target languages, as well as each step in a compiler, and then verify that the compiler step preserves the language meaning after the translation.</bio>
          <homepage_url>https://github.com/liyili2</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/liyili/e99a1880-eb87-4ca2-ab7a-62657f9c7b1f/small.jpg</picture_url>
          <person_id>liyili</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Elsa</first_name>
          <last_name>Gunter</last_name>
          <affiliation>University of Illinois</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://egunter.cs.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elsagunter/fec4e9dd-f691-4462-a2e0-198dd02b8498/small.jpg</picture_url>
          <person_id>elsagunter</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>703bd3c0-f3cb-424d-8f0f-0afd23c5b2e6</slot_id>
      <event_id>c2888fc6-1e65-49f3-89af-b42b99ffa7d1</event_id>
      <title>Static Type Analysis by Abstract Interpretation of Python Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>02:20</end_time>
      <description>Python is an increasingly popular dynamic programming language, particularly used in the scientific community and well-known for its powerful and permissive high-level syntax. Our work aims at detecting statically and automatically type errors. As these type errors are exceptions that can be caught later on, we precisely track all exceptions (raised or caught). We designed a static analysis by abstract interpretation able to infer the possible types of variables, taking into account the full control-flow. It handles both typing paradigms used in Python, nominal and structural, supports Python’s object model, introspection operators allowing dynamic type testing, dynamic attribute addition, as well as exception handling. We present a flow- and context-sensitive analysis with special domains to support containers (such as lists) and infer type equalities (allowing it to express parametric polymorphism). The analysis is soundly derived by abstract interpretation from a concrete semantics of Python developed by Fromherz et al. Our analysis is designed in a modular way as a set of domains abstracting a concrete collecting semantics. It has been implemented into the MOPSA analysis framework, and leverages external type annotations from the Typeshed project to support the vast standard library. We show that it scales to benchmarks a few thousand lines long, and preliminary results show it is able to analyze a small real-life command-line utility called PathPicker. Compared to previous work, it is sound, while it keeps similar efficiency and precision.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Raphaël</first_name>
          <last_name>Monat</last_name>
          <affiliation>Sorbonne Université  — LIP6</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://rmonat.fr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/raphaelmonat/2405755c-6e69-4ac2-a6af-8231b7b11c81/small.jpg</picture_url>
          <person_id>raphaelmonat</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Abdelraouf</first_name>
          <last_name>Ouadjaout</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~ouadjaout/</homepage_url>
          <person_id>abdelraoufouadjaout</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Miné</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~mine/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/antoinemine/77e18473-3b05-4bec-8b27-3e073a24fb34/small.jpg</picture_url>
          <person_id>antoinemine</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c09b13bb-4623-46ea-a3e4-ba136c3d2114</slot_id>
      <event_id>f09653ca-5d68-454b-9a7a-970d4ca62a1a</event_id>
      <title>A Type-Directed Operational Semantics for a Calculus with a Merge Operator</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>01:40</end_time>
      <description>Calculi with disjoint intersection types and a merge operator provide general mechanisms that can subsume various other features. Such calculi can also encode highly dynamic forms of object composition, which capture common programming patterns in dynamically typed languages (such as JavaScript) in a fully statically typed manner. Unfortunately, unlike many other foundational calculi (such as System $F$, System $F_{&amp;lt;:}$ or Featherweight Java), recent calculi with the merge operator lack a (direct) operational semantics with standard and expected properties such as determinism and subject-reduction. Furthermore the metatheory for such calculi can only account for terminating programs, which is a significant restriction in practice. 
This paper proposes a type-directed operational semantics (TDOS) for $\lambda_{i}^{:}$: a calculus with intersection types and a merge operator. The calculus is inspired by two closely related calculi by Dunfield (2014) and Oliveira et al. (2016). Although Dunfield proposes a direct small-step semantics for his calculus, his semantics lacks both determinism and subject-reduction. Using our TDOS we obtain a direct semantics for $\lambda_{i}^{:}$ that has both properties. To fully obtain determinism, the $\lambda_{i}^{:}$ calculus employs a disjointness restriction proposed in Oliveira et al.’s $\lambda_{i}$ calculus. As an added benefit the TDOS approach deals with recursion in a straightforward way, unlike $\lambda_{i}$ and subsequent calculi where recursion is problematic. To further relate $\lambda_{i}^{:}$ to the calculi by Dunfield and Oliveira et al. we show two results. Firstly, the semantics of $\lambda_{i}^{:}$ is sound with respect to Dunfield’s small-step semantics. Secondly, we show that the type system of $\lambda_{i}^{:}$ is complete with respect to the $\lambda_{i}$ type system. All results have been fully formalized in the Coq theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xuejing</first_name>
          <last_name>Huang</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/huangxuejing/b875ad52-4b3e-4a4e-9b2e-b6b48436a581/small.jpg</picture_url>
          <person_id>huangxuejing</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>52017797-bca9-4c9a-9e99-4baef86dcca9</subevent_id>
    <title>ECOOP Research Papers: M-6B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/17</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>46d9f559-2686-42ec-82c6-ccc8f3c267ba</slot_id>
      <title>Session: ECOOP Research Papers - M-6B</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>05:00</start_time>
      <end_time>05:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Rein</last_name>
          <affiliation>Hasso Plattner Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.patrickrein.de</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/patrickrein/0538cdc6-52aa-408d-9042-80e24d2f8260/small.jpg</picture_url>
          <person_id>patrickrein</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Serrano</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-sop.inria.fr/members/Manuel.Serrano/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelserrano/084e3f7c-e031-4d91-ba23-b96148549086/small.jpg</picture_url>
          <person_id>manuelserrano</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5e097435-a31c-47ff-9f51-bdc2527a61e1</slot_id>
      <event_id>b5cd4295-3dae-4811-a9a2-cd69e93f5866</event_id>
      <title>Space-Efficient Gradual Typing in Coercion-Passing Style</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>05:20</end_time>
      <description>Herman et al. (2007, 2010) pointed out that the insertion of run-time checks into a gradually typed program could hamper tail-call optimization and, as a result, worsen the space complexity of the program. To address the problem, they proposed a space-efficient coercion calculus, which was subsequently improved by Garcia, et al. (2009) and Siek et al. (2015). The semantics of these calculi involves eager composition of run-time checks expressed by coercions to prevent the size of a term from growing. However, it relies also on a nonstandard reduction rule, which does not seem easy to implement. In fact, no compiler implementation of gradually typed languages fully supports the space-efficient semantics faithfully. 
In this paper, we study coercion-passing style, which Herman et al. have already mentioned, as a technique for straightforward space-efficient implementation of gradually typed languages. A program in coercion-passing style passes “the rest of run-time checks” around—just like continuation-passing style (CPS), in which “the rest of computation” has been passed around—and (unlike CPS) composes coercions eagerly. We give a formal coercion-passing translation from $\lambda$S by Siek et al. to $\lambda$S$_1$, which is a new calculus of first-class coercions tailored for coercion-passing style, and prove correctness of the translation. We also implement our coercion-passing style transformation for the Grift compiler developed by Kuhlenschmidt et al. and give an experimental result.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuya</first_name>
          <last_name>Tsuda</last_name>
          <affiliation>Kyoto University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~tsuda/</homepage_url>
          <person_id>yuyatsuda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Igarashi</last_name>
          <affiliation>Kyoto University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/atsushiigarashi/bbac1695-343a-4091-b33c-b7f01dea73da/small.jpg</picture_url>
          <person_id>atsushiigarashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tomoya</first_name>
          <last_name>Tabuchi</last_name>
          <affiliation>Kyoto University</affiliation>
          <bio>undefined</bio>
          <person_id>tomoyatabuchi</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a68c180a-de03-42eb-84ff-bc28211f37d3</subevent_id>
    <title>ECOOP Research Papers: S-2</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>762581d5-05f5-4ceb-b4ae-9bfb6b1aff3c</slot_id>
      <title>Session: ECOOP Research Papers - S-2</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>21:00</start_time>
      <end_time>22:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Igarashi</last_name>
          <affiliation>Kyoto University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/atsushiigarashi/bbac1695-343a-4091-b33c-b7f01dea73da/small.jpg</picture_url>
          <person_id>atsushiigarashi</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Hidehiko</first_name>
          <last_name>Masuhara</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>Hidehiko Masuhara is a Professor of Mathematical and Computing Science, Tokyo Institute of Technology since April 2013. He received his B.S., M.S., and Ph.D. in Computer Science from Department of Information Science, University of Tokyo in 1992, 1994, and 1999, respectively, and served as an assistant professor, lecturer, and associate professor at Graphics and Computer Science, Graduate School of Arts and Sciences, University of Tokyo from 1995 until 2013.</bio>
          <homepage_url>http://prg.is.titech.ac.jp/people/masuhara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hidehikomasuhara/3ea94269-6fb5-4c6d-8d6f-0435717377d6/small.jpg</picture_url>
          <person_id>hidehikomasuhara</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2a204cf6-9bc0-4183-853f-573364f39c81</slot_id>
      <event_id>7a123832-31e7-4cda-8509-cfeef5dacfe3</event_id>
      <title>Don't Panic! Better, Fewer, Syntax Errors for LR Parsers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>21:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:40</end_time>
      <description>Syntax errors are generally easy to fix for humans, but not for parsers, in general, and LR parsers, in particular. Traditional `panic mode’ error recovery, though easy to implement and applicable to any grammar, often leads to a cascading chain of errors that drown out the original. More advanced error recovery techniques suffer less from this problem but have seen little practical use because their typical performance was seen as poor, their worst case unbounded, and the repairs they reported arbitrary. In this paper we introduce an algorithm and implementation that addresses these issues. First, we report the complete set of minimum cost repair sequences for a given location, allowing programmers to select the one that best fits their intention. Second, on a corpus of 200,000 real-world syntactically invalid Java programs, we are able to repair 98.38% ± 0.018% of files within a cut-off of 0.5s. Finally, we use the existence of the complete set of minimum cost repair sequences to reduce one of the most frustrating consequences of error reporting: the cascading error problem. Across our corpus, we report 435,823.0 ± 478.0 error locations to the user, while the panic mode algorithm reports 981,628.0 ± 0.0 error locations: in other words, we reduce the cascading error problem by well over half.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lukas</first_name>
          <last_name>Diekmann</last_name>
          <affiliation>King's College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://lukasdiekmann.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lukasdiekmann/a00dd8d1-84fa-4f67-9b77-d5994819208f/small.jpg</picture_url>
          <person_id>lukasdiekmann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Laurence</first_name>
          <last_name>Tratt</last_name>
          <affiliation>King's College London</affiliation>
          <bio>Programmer / researcher.</bio>
          <homepage_url>https://tratt.net/laurie/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/laurencetratt/f715fc31-2c46-4e48-9a13-d715343fdd4d/small.jpg</picture_url>
          <person_id>laurencetratt</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>425f8c75-aee6-49d9-9696-14254316b509</slot_id>
      <event_id>938f9252-3dc5-4325-a133-eb25a1ebd488</event_id>
      <title>Perfect is the Enemy of Good: Best-Effort Program Synthesis</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>22:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>22:20</end_time>
      <description>Program synthesis promises to help software developers with everyday tasks by generating code snippets automatically from input-output examples and other high-level specifications. The conventional wisdom is that a synthesizer must always satisfy the specification exactly. We conjecture that this all-or-nothing paradigm stands in the way of adopting program synthesis as a developer tool: in practice, the user-written specification often contains errors or is simply too hard for the synthesizer to solve within a reasonable time; in these cases, the user is left with a single over-fitted result or, more often then not, no result at all. In this paper we propose a new program synthesis paradigm we call \emph{best-effort program synthesis}, where the synthesizer returns a ranked list of partially-valid results, i.e., programs that satisfy some part of the specification. 
To support this paradigm, we develop \emph{best-effort enumeration}, a new synthesis algorithm that extends a popular program enumeration technique with the ability to accumulate and return multiple partially-valid results with minimal overhead. We implement this algorithm in a tool called Bester, and evaluate it on $79$ synthesis benchmarks from the literature. Contrary to the conventional wisdom, our evaluation shows that Bester returns useful results even when the specification is flawed or too hard: i) for all benchmarks with an error in the specification, the top three Bester results contain the correct solution, and ii) for most hard benchmarks, the top three results contain non-trivial \emph{fragments} of the correct solution. We also performed a small user study, which confirms our intuition that partially-valid results are useful: the study shows that programmers use the output of the synthesizer for comprehension and often incorporate it into their solutions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>92427527-2df8-4356-9033-44d3a8a53933</slot_id>
      <event_id>b1086991-0f35-4b4b-b7a4-78b902ec9ab5</event_id>
      <title>Blame for Null</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>21:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>22:00</end_time>
      <description>Multiple modern programming languages, including Kotlin, Scala, Swift, and C#, have type systems where nullability is explicitly specified in the types. All of the above also need to interoperate with languages where types remain implicitly nullable, like Java. This leads to runtime errors that can manifest in subtle ways. In this paper, we show how to reason about the presence and provenance of such nullability errors using the concept of blame from gradual typing. Specifically, we introduce a calculus LambdaNull, where some terms are typed as implicitly nullable and others as explicitly nullable. Just like in the original blame calculus of Wadler and Findler, interactions between both kinds of terms are mediated by casts with attached blame labels, which indicate the origin of errors. On top of LambdaNull, we then define a second calculus, StratifiedLambdaNull, which closely models the interoperability between languages with implicit nullability and languages with explicit nullability, such as Java and Scala. Our main result is a theorem that states that nullability errors in StratifiedLambdaNull can always be blamed on terms with less-precise typing; that is, terms typed as implicitly nullable. By analogy, this would mean that NullPointerExceptions in combined Java/Scala programs are always the result of unsoundness in the Java type system. We summarize our result with the slogan explicitly nullable programs can’t be blamed. All our results are formalized in the Coq proof assistant.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abel</first_name>
          <last_name>Nieto</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://abeln.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/abelnieto/88adb2b6-4aa2-4cc1-af2b-5a23289e9794/small.jpg</picture_url>
          <person_id>abelnieto</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marianna</first_name>
          <last_name>Rapoport</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mrapoport.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mariannarapoport/7f9f1bbc-f804-49b4-b350-26210268c55b/small.jpg</picture_url>
          <person_id>mariannarapoport</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gregor</first_name>
          <last_name>Richards</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://the.gregor.institute/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gregorrichards/bd8bf252-24c9-4721-a495-c06a6949a332/small.jpg</picture_url>
          <person_id>gregorrichards</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bbc85d8a-1a5c-4dc5-99a1-fb83a8f83a47</slot_id>
      <event_id>e5b5bb01-82ec-490b-a4e5-e62389f99279</event_id>
      <title>Abstracting gradual references</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:20</end_time>
      <description>Gradual typing is an effective approach to integrate static and dynamic typing, which supports the smooth transition between both extremes via the imprecision of type annotations. Gradual typing has been applied in many scenarios such as objects, subtyping, effects, ownership, typestates, information-flow typing, parametric polymorphism, etc. In particular, the combination of gradual typing and mutable references has been explored by different authors, giving rise to four different semantics—invariant, guarded, monotonic and permissive references. These semantics were specially crafted to reflect different design decisions with respect to precision and efficiency tradeoffs. Since then, progress has been made in the formulation of methodologies to systematically derive gradual counterparts of statically-typed languages, but these have not been applied to study mutable references. 
In this article, we explore how the Abstracting Gradual Typing (AGT) methodology, which has been shown to be effective in a variety of settings, applies to mutable references. Starting from a standard statically-typed language with references, we systematically derive with AGT a novel gradual language, called λREF˜. We establish the properties of λREF˜; in particular, it is the first gradual language with mutable references that is proven to satisfy the gradual guarantee. We then compare λREF˜ with the main four existing approaches to gradual references, and show that the application of AGT does justify one of the proposed semantics: we formally prove that the treatment of references in λREF˜ corresponds to the guarded semantics, by presenting a bisimilation with the coercion semantics of Herman et al. In the process, we uncover that any direct application of AGT yields a gradual language that is not space-efficient. We consequently adjust the dynamic semantics of λREF˜ to recover space efficiency. We then show how to extend λREF˜ to support both monotonic and permissive references as well. Finally, we provide the first proof of the dynamic gradual guarantee for monotonic references. As a result, this paper sheds further light on the design space of gradual languages with mutable references and contributes to deepening the understanding of the AGT methodology.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matías</first_name>
          <last_name>Toro</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/matiastoro/65656fe4-15fe-4af6-9a50-7f28cdc25fdb/small.jpg</picture_url>
          <person_id>matiastoro</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile, Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
          <person_id>etanter</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6f4458f5-e5ee-433b-9978-3748103d3e9d</subevent_id>
    <title>ECOOP Research Papers: S-4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>1b95599a-4b52-4b51-b715-3521519d2606</slot_id>
      <title>Session: ECOOP Research Papers - S-4</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Karim</first_name>
          <last_name>Ali</last_name>
          <affiliation>University of Alberta</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://karimali.ca</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/karimali/460ecc0b-764d-462b-a93e-66a3270d72ef/small.jpg</picture_url>
          <person_id>karimali</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Eli</first_name>
          <last_name>Tilevich</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.vt.edu/~tilevich</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elitilevich/10b9c85c-8a75-4acb-a0fe-e00c91dd0bb6/small.jpg</picture_url>
          <person_id>elitilevich</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>576a651f-1c8d-42c2-be36-fb287f2b9f6e</slot_id>
      <event_id>5fd7f5f9-a5c0-4369-8869-a0e5cfc60db7</event_id>
      <title>K-LLVM: A Relatively Complete Semantics of LLVM IR</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>13:20</end_time>
      <description>LLVM is designed for the compile-time, link-time and run-time optimization of programs written in various programming languages. The language supported by LLVM targeted by modern compilers is LLVM IR. In this paper we define K-LLVM, a reference semantics for LLVM IR. To the best of our knowledge, K-LLVM is the most complete formal LLVM IR semantics to date, including all LLVM IR instructions, intrinsic functions in the LLVM documentation and Standard-C library functions that are necessary to execute many LLVM IR programs. Additionally, K-LLVM formulates an abstract machine that executes all LLVM IR instructions. The machine allows to describe our formal semantics in terms of simulating a conceptual virtual machine that runs LLVM IR programs, including non-deterministic programs. Even though the K-LLVM memory model in this paper is assumed to be a sequentially consistent memory model and does not include all LLVM concurrency memory behaviors, the design of K-LLVM’s data layout allows the K-LLVM abstract machine to execute some LLVM IR programs that previous semantics did not cover, such as the full range of LLVM IR behaviors for the interaction among LLVM IR casting, pointer arithmetic, memory operations and some memory flags (e.g. readonly) of function headers. Additionally, the memory model is modularized in a manner that supports investigating other memory models. To validate K-LLVM, we have implemented it in K [41], which generated an interpreter for LLVM IR. Using this, we ran tests including 1,385 unit test programs and 2,156 concrete LLVM IR programs, and K-LLVM passed all of them.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Liyi</first_name>
          <last_name>Li</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>I am Liyi Li, a PhD student at the University of Illinois at Urbana-Champaign. I will work at the University of Maryland as a PostDoc this fall. My research area is Programming Language, Formal Methods, Compilers and Software Engineering. I am especially interested in verifying compilers. I like to fully verify a compiler in real-world, such as the compiler from Haskell to LLVM. My plan is to define the semantics of the source and target languages, as well as each step in a compiler, and then verify that the compiler step preserves the language meaning after the translation.</bio>
          <homepage_url>https://github.com/liyili2</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/liyili/e99a1880-eb87-4ca2-ab7a-62657f9c7b1f/small.jpg</picture_url>
          <person_id>liyili</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Elsa</first_name>
          <last_name>Gunter</last_name>
          <affiliation>University of Illinois</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://egunter.cs.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elsagunter/fec4e9dd-f691-4462-a2e0-198dd02b8498/small.jpg</picture_url>
          <person_id>elsagunter</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b1188690-f1b8-4f25-83b7-ed38415b9dfc</slot_id>
      <event_id>f09653ca-5d68-454b-9a7a-970d4ca62a1a</event_id>
      <title>A Type-Directed Operational Semantics for a Calculus with a Merge Operator</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>13:40</end_time>
      <description>Calculi with disjoint intersection types and a merge operator provide general mechanisms that can subsume various other features. Such calculi can also encode highly dynamic forms of object composition, which capture common programming patterns in dynamically typed languages (such as JavaScript) in a fully statically typed manner. Unfortunately, unlike many other foundational calculi (such as System $F$, System $F_{&amp;lt;:}$ or Featherweight Java), recent calculi with the merge operator lack a (direct) operational semantics with standard and expected properties such as determinism and subject-reduction. Furthermore the metatheory for such calculi can only account for terminating programs, which is a significant restriction in practice. 
This paper proposes a type-directed operational semantics (TDOS) for $\lambda_{i}^{:}$: a calculus with intersection types and a merge operator. The calculus is inspired by two closely related calculi by Dunfield (2014) and Oliveira et al. (2016). Although Dunfield proposes a direct small-step semantics for his calculus, his semantics lacks both determinism and subject-reduction. Using our TDOS we obtain a direct semantics for $\lambda_{i}^{:}$ that has both properties. To fully obtain determinism, the $\lambda_{i}^{:}$ calculus employs a disjointness restriction proposed in Oliveira et al.’s $\lambda_{i}$ calculus. As an added benefit the TDOS approach deals with recursion in a straightforward way, unlike $\lambda_{i}$ and subsequent calculi where recursion is problematic. To further relate $\lambda_{i}^{:}$ to the calculi by Dunfield and Oliveira et al. we show two results. Firstly, the semantics of $\lambda_{i}^{:}$ is sound with respect to Dunfield’s small-step semantics. Secondly, we show that the type system of $\lambda_{i}^{:}$ is complete with respect to the $\lambda_{i}$ type system. All results have been fully formalized in the Coq theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xuejing</first_name>
          <last_name>Huang</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/huangxuejing/b875ad52-4b3e-4a4e-9b2e-b6b48436a581/small.jpg</picture_url>
          <person_id>huangxuejing</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e4257000-b5ec-43be-9a63-6f27ecf1ff08</slot_id>
      <event_id>c2888fc6-1e65-49f3-89af-b42b99ffa7d1</event_id>
      <title>Static Type Analysis by Abstract Interpretation of Python Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>14:20</end_time>
      <description>Python is an increasingly popular dynamic programming language, particularly used in the scientific community and well-known for its powerful and permissive high-level syntax. Our work aims at detecting statically and automatically type errors. As these type errors are exceptions that can be caught later on, we precisely track all exceptions (raised or caught). We designed a static analysis by abstract interpretation able to infer the possible types of variables, taking into account the full control-flow. It handles both typing paradigms used in Python, nominal and structural, supports Python’s object model, introspection operators allowing dynamic type testing, dynamic attribute addition, as well as exception handling. We present a flow- and context-sensitive analysis with special domains to support containers (such as lists) and infer type equalities (allowing it to express parametric polymorphism). The analysis is soundly derived by abstract interpretation from a concrete semantics of Python developed by Fromherz et al. Our analysis is designed in a modular way as a set of domains abstracting a concrete collecting semantics. It has been implemented into the MOPSA analysis framework, and leverages external type annotations from the Typeshed project to support the vast standard library. We show that it scales to benchmarks a few thousand lines long, and preliminary results show it is able to analyze a small real-life command-line utility called PathPicker. Compared to previous work, it is sound, while it keeps similar efficiency and precision.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Raphaël</first_name>
          <last_name>Monat</last_name>
          <affiliation>Sorbonne Université  — LIP6</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://rmonat.fr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/raphaelmonat/2405755c-6e69-4ac2-a6af-8231b7b11c81/small.jpg</picture_url>
          <person_id>raphaelmonat</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Abdelraouf</first_name>
          <last_name>Ouadjaout</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~ouadjaout/</homepage_url>
          <person_id>abdelraoufouadjaout</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Miné</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~mine/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/antoinemine/77e18473-3b05-4bec-8b27-3e073a24fb34/small.jpg</picture_url>
          <person_id>antoinemine</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>feaeeca3-f65c-4714-9a5a-3bd245fd2e95</slot_id>
      <event_id>4706f63e-dc56-4e40-bee4-0b030f2b0fcb</event_id>
      <title>A big step from finite to infinite computations</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>14:00</end_time>
      <description>We provide a construction that, given a big-step semantics describing finite computations and their observations, extends it to include infinite computations as well. The basic idea is that the finite behavior uniquely determines the infinite behavior once observations and their composition operators are fixed. Technically, the construction relies on the framework of inference systems with corules. The effectiveness and scope of the approach are illustrated by several examples. The correctness is formally justified by proving that, starting from a big-step semantics equivalent to a reference small-step semantics, this equivalence is preserved by the construction.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Davide</first_name>
          <last_name>Ancona</last_name>
          <affiliation>DIBRIS, University of Genova, Italy</affiliation>
          <bio>Davide Ancona (PhD in Computer Science, University of Pisa, 1998) is Associate Professor at the University of Genova. His main research interests include type systems, object-oriented programming, coinduction methods for programming languages, modules and components, software reuse and maintenance, multi-agent systems, and behavioral types. He is author of more than 70 publications. He is the secretary of the executive board of AITO, Association Internationale pour les Technologies Objets (since Jan 2013, previously Vice-President since Jan 2012), and member of the editorial board of the ACM/SIGAPP Applied Computing Review (ACR), Scientific Programming (Hindawi), and Open Computer Science. He has been guest editor of special issues of Science of Computer Programming and Journal of Object Technology. In 2009 he received, together with G. Lagorio, the best paper prize at ECOOP. He has participated to several national and European projects and has been PC member of several workshops and conferences: WOOD’04, Bytecode 2008, ESOP 2008, DLS 2009, 2010 and 2013, FOOL 2010, RP 2011 and 2012, ECOOP 2013 and 2014, POPL 2015 (ERC), OOPSLA 2016 (ERC), TASE 2016, FTfJP 2016. He has been involved in the organization of several scientific events: organizing chair of ECOOP 2009, program co-chair of FTfJP06 and of OOPS special track at SAC from 2004 through 2017, co-chair of CILC 2015 and VORTEX 2016.</bio>
          <homepage_url>http://www.disi.unige.it/person/AnconaD/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davideancona/50b3fc2f-1782-4ca1-91a5-6718f42ba51b/small.jpg</picture_url>
          <person_id>davideancona</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Dagnino</last_name>
          <affiliation>DIBRIS, University of Genova, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.dibris.unige.it/en/dagnino-francesco</homepage_url>
          <person_id>francescodagnino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jurriaan</first_name>
          <last_name>Rot</last_name>
          <affiliation>Radboud University Nijmegen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jurriaan.me/</homepage_url>
          <person_id>juriaanrot</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Elena</first_name>
          <last_name>Zucca</last_name>
          <affiliation>University of Genova</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.disi.unige.it/person/ZuccaE/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elenazucca/31be5390-fc85-4134-90af-718c3b50c4a3/small.jpg</picture_url>
          <person_id>elenazucca</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>368fccf5-9b8a-44e2-bfb8-0f2e6c2492a9</subevent_id>
    <title>ECOOP Research Papers: M-3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>b4f5f63a-db1a-4a6f-84b3-ced81d79550b</slot_id>
      <title>Session: ECOOP Research Papers - M-3</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Boyland</last_name>
          <affiliation>Univeristy of Wisconsin, Milwaukee</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://uwm.edu/engineering/people/boyland-ph-d-john/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnboyland/a5fe137c-ecb4-475c-99c9-04b21c328c13/small.jpg</picture_url>
          <person_id>johnboyland</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Peter</first_name>
          <last_name>Thiemann</last_name>
          <affiliation>University of Freiburg, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/peterthiemann/43fc0175-1745-4b3a-b626-86e10da76b86/small.jpg</picture_url>
          <person_id>peterthiemann</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3db4a87b-745d-4406-aa9f-98db36a66344</slot_id>
      <event_id>2d767f19-3b2e-4257-94c7-e2f1d09b2a18</event_id>
      <title>The Duality of Subtyping</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>12:00</end_time>
      <description>Subtyping is a concept frequently encountered in many programming languages and calculi. Various forms of subtyping exist for different type system features, including intersection types, union types or bounded quantification. Normally these features are designed independently of each other, without exploiting obvious similarities (or dualities) between features. This paper proposes a novel methodology for designing subtyping relations that exploits duality between features. At the core of our methodology is a generalization of subtyping relations, which we call Duotyping. Duotyping is parameterized by the mode of the relation. One of these modes is theusual subtyping, while another mode is supertyping (the dual of subtyping). Using the mode it is possible to generalize the usual rules of subtyping to account not only for the intended behaviour of one particular language construct, but also of its dual. Duotyping brings multiple benefits, including: shorter specifications and implementations, dual features that come essentially for free, as well as new proof techniques for various properties of subtyping. To evaluate a design based on Duotyping against traditional designs, we formalized various calculi with common OOP features (including union types, intersection types and bounded quantification) in Coq in both styles. Our results show that the metatheory when using Duotyping does not come at a significant cost: the metatheory with Duotyping has similar complexity and size compared to the metatheory for traditional designs. However, we discover new features as duals to well-known features. Furthermore, we also show that Duotyping can significantly simplify transitivity proofs for many of the calculi studied by us.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shaobo</first_name>
          <last_name>Cui</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>shaobocui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Baber</first_name>
          <last_name>Rehman</last_name>
          <affiliation>University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://baberrehman.github.io/</homepage_url>
          <person_id>baberrehman</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5c268e0c-d05a-4d03-b1c8-d144bb1fec83</slot_id>
      <event_id>c6bed3b0-d795-4378-9f4f-f3f70ea00ede</event_id>
      <title>Data Consistency in Transactional Storage Systems: A Centralised Semantics</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>12:20</end_time>
      <description>We introduce an interleaving operational semantics for describing the client-observable behaviour of atomic transactions on distributed key-value stores. Our semantics builds on abstract states comprising centralised, global key-value stores and partial client views. We provide operational definitions of consistency models for our abstract states which we show to be equivalent to the well known declarative definitions of consistency model on abstract executions. We explore two applications, verifying that the COPS replicated database and the Clock-SI partitioned database satisfy their consistency models using trace refinement, and proving invariant properties of client programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shale</first_name>
          <last_name>Xiong</last_name>
          <affiliation>ARM Research</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shalexiong1/1f3bbb1a-1ab1-4f01-9963-e196b6553299/small.jpg</picture_url>
          <person_id>shalexiong1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrea</first_name>
          <last_name>Cerone</last_name>
          <affiliation>Football Radar</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/andreacerone1/ed6fc0c4-5ba2-4bdf-bcc7-e202d5b7328e/small.jpg</picture_url>
          <person_id>andreacerone1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Azalea</first_name>
          <last_name>Raad</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.SoundAndComplete.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/azalearaad/180ee602-475f-483f-a01b-ea187c9e8ac1/small.jpg</picture_url>
          <person_id>azalearaad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Philippa</first_name>
          <last_name>Gardner</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Philippa Gardner is a professor in the Department of Computing at Imperial College London and and has a UKRI Established Fellowship from 2018–2023. Her current research focusses on program verification: in particular, reasoning about Web programs (JavaScript and DOM); and reasoning about concurrent programs. She completed her PhD thesis, supervised by Professor Gordon Plotkin FRS at Edinburgh in 1992 and held five years of fellowships at Edinburgh. She moved to Cambridge in 1998 on an EPSRC Advanced Fellowship, hosted by Professor Robin Milner FRS. She obtained a lectureship at Imperial in 2001, and became professor in 2009. She held a Microsoft Research Cambridge/Royal Academy of Engineering Senior Fellowship from 2005 to 2010 at Imperial. Philippa directs the Research Institute on Verified Trustworthy Software Systems (VeTSS), funded by EPSRC, from 2017 to 2022. She chaired the BCS awards committee, 2013-2018, which decides the Lovelace medal (senior) and Roger Needham award (mid-career) for computer science and engineering.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~pg</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippagardner/8031e77a-ebbb-4963-a5de-94895edd7f71/small.jpg</picture_url>
          <person_id>philippagardner</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7a717952-485a-495a-8224-17f5f129097e</slot_id>
      <event_id>4bf0a52b-ba6b-417a-97bb-1a2326f941ab</event_id>
      <title>Tackling the Awkward Squad for Reactive Programming: The Actor-Reactor Model</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:20</end_time>
      <description>Reactive programming is a programming paradigm whereby programs are internally represented by a dependency graph, which is used to automatically (re)compute parts of a program whenever its input changes. In practice reactive programming can only be used for some parts of an application: a reactive program is usually embedded in an application that is still written in ordinary imperative languages such as JavaScript or Scala. In this paper we investigate this embedding and we distill “the awkward squad for reactive programming” as 3 concerns that are essential for real-world software development, but that do not fit within reactive programming. They are related to long lasting computations, side-effects, and the coordination between imperative and reactive code. To solve these issues we design a new programming model called the Actor-Reactor Model in which programs are split up in a number of actors and reactors. Actors and reactors enforce a strict separation of imperative and reactive code, and they can be composed via a number of composition operators that make use of data streams. We demonstrate the model via our own implementation in a language called Stella.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sam</first_name>
          <last_name>Van den Vonder</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>PhD candidate at the Software Languages Lab of the Vrije Universiteit Brussel.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/samvandenvonder/2ccd1dd4-a774-4f8b-b2a1-c601a5adc3d5/small.jpg</picture_url>
          <person_id>samvandenvonder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thierry</first_name>
          <last_name>Renaux</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <person_id>thierryrenaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bjarno</first_name>
          <last_name>Oeyen</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/bjarnooeyen/c798be09-5fc6-45f6-9840-071793035cef/small.jpg</picture_url>
          <person_id>bjarnooeyen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Joeri</first_name>
          <last_name>De Koster</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/joeridekoster/2f5765d5-6ed1-4a75-acf1-99a86a994912/small.jpg</picture_url>
          <person_id>joeridekoster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Wolfgang</first_name>
          <last_name>De Meuter</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/soft/users/wdmeuter</homepage_url>
          <person_id>wolfgangdemeuter</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e096ce52-f8ba-4ea3-81ab-207dcc70741c</slot_id>
      <event_id>19f2611f-fa87-46d5-b52e-767476c387fb</event_id>
      <title>Lifting Sequential Effects to Control Operators</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:40</end_time>
      <description>Sequential effect systems are a class of effect system that exploits information about program order, rather than discarding it as traditional commutative effect systems do. This extra expressive power allows effect systems to reason about behavior over time, capturing properties such as atomicity, unstructured lock ownership, or even general safety properties. While we now understand the essential denotational (categorical) models fairly well, application of these ideas to real software is hampered by the variety of source level control flow constructs and control operators in real languages. 
We address this new problem by appeal to a classic idea: macro-expression of commonly-used programming constructs in terms of control operators. We give an effect system for a subset of Racket’s tagged delimited control operators, as a lifting of an effect system for a language without direct control operators. This gives the first account of sequential effects in the presence of general control operators. Using this system, we also re-derive the sequential effect system rules for control flow constructs previously shown sound directly, and derive sequential effect rules for new constructs not previously studied in the context of source-level sequential effect systems. This offers a way to directly extend source-level support for sequential effect systems to real programming languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Colin</first_name>
          <last_name>Gordon</last_name>
          <affiliation>Drexel University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.drexel.edu/~csgordon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/colingordon/d990db47-1ece-4016-bce5-b764428bd0ee/small.jpg</picture_url>
          <person_id>colingordon</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ee5d5ba4-bab0-4d93-9ea9-14e2d9d5874a</subevent_id>
    <title>ECOOP Research Papers: M-1</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>7ce72c03-3ca2-453f-8e32-4753c10206ab</slot_id>
      <title>Session: ECOOP Research Papers - M-1</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>19:00</start_time>
      <end_time>20:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Yu David</first_name>
          <last_name>Liu</last_name>
          <affiliation>State University of New York (SUNY) Binghamton</affiliation>
          <bio>I am a Professor at State University of New York (SUNY) at Binghamton. I am interested in programming languages, computer systems, and software engineering. My current research focuses are energy-aware programming languages, data-intensive software, programming unmanned aerial vehicles, and type systems. I received my Ph.D. in Computer Science from the Johns Hopkins University, in 2007.</bio>
          <homepage_url>http://www.cs.binghamton.edu/~davidl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yudavidliu/1da5367f-6c86-4df7-859d-ca63bc2a178b/small.jpg</picture_url>
          <person_id>yudavidliu</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Hidehiko</first_name>
          <last_name>Masuhara</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>Hidehiko Masuhara is a Professor of Mathematical and Computing Science, Tokyo Institute of Technology since April 2013. He received his B.S., M.S., and Ph.D. in Computer Science from Department of Information Science, University of Tokyo in 1992, 1994, and 1999, respectively, and served as an assistant professor, lecturer, and associate professor at Graphics and Computer Science, Graduate School of Arts and Sciences, University of Tokyo from 1995 until 2013.</bio>
          <homepage_url>http://prg.is.titech.ac.jp/people/masuhara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hidehikomasuhara/3ea94269-6fb5-4c6d-8d6f-0435717377d6/small.jpg</picture_url>
          <person_id>hidehikomasuhara</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2ce00e35-6dd2-414e-9d7b-c11e0e15e83a</slot_id>
      <event_id>fa9502c6-8ae7-4b07-8206-b46b73a9a756</event_id>
      <title>A Semantics for the Essence of React</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>19:20</end_time>
      <description>Traditionally, web applications have been written as HTML pages with embedded JavaScript code that implements dynamic and interactive features by manipulating the Document Object Model (DOM) through a low-level browser API. However, this unprincipled approach leads to code that is brittle, difficult to understand, non-modular, and does not facilitate incremental update of user-interfaces in response to state changes. 
React is a popular framework for constructing web applications that aims to overcome these problems. React applications are written in a declarative and object-oriented style, and consist of components that are organized in a tree structure. Each component has a set of properties representing input parameters, a state consisting of values that may vary over time, and a render method that declaratively specifies the subcomponents of the component. React’s concept of reconciliation determines the impact of state changes and updates the user-interface incrementally by selective mounting and unmounting of subcomponents. At designated points, the React framework invokes lifecycle hooks that enable programmers to perform actions outside the framework such as acquiring and releasing resources needed by a component. 
These mechanisms exhibit considerable complexity, but, to our knowledge, no formal specification of React’s semantics exists. This paper presents a small-step operational semantics that captures the essence of React, as a first step towards a long-term goal of developing automatic tools for program understanding, automatic testing, and bug finding for React web applications. To demonstrate that key operations such as mounting, unmounting, and reconciliation terminate, we define the notion of a well-behaved component and prove that well-behavedness is preserved by these operations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Frank</first_name>
          <last_name>Tip</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Frank Tip is a Professor and Associate Dean for Graduate Programs at Northeastern University. Previously, he was a Senior Principal Engineer at Samsung Research America in Mountain View, California (2014-2016), a Professor and Cheriton Research Chair in the David R. Cheriton School of Computer Science at the University of Waterloo (2012-2014), and a Research Staff Member and Manager at the Software Technology Department at the IBM T.J. Watson Research Center (1995-2012). He received his PhD in 1995 from the University of Amsterdam.</bio>
          <homepage_url>http://www.franktip.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/franktip/b4b4c804-cf32-45fa-afc8-3058f718b160/small.jpg</picture_url>
          <person_id>franktip</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7bd54833-4892-4397-be7f-72214870f047</slot_id>
      <event_id>d20598bd-55e0-4d3d-9727-0b7b671dbce0</event_id>
      <title>Reconciling Event Structures with Modern Multiprocessors</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>19:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>19:40</end_time>
      <description>Weakestmo is a recently proposed memory consistency model that uses event structures to resolve the infamous “out-of-thin-air” problem, and to enable efficient compilation to hardware. Nevertheless, this latter property—compilation correctness—has not yet been formally established. This paper closes this gap by establishing correctness in Coq of the intended compilation schemes from Weakestmo to a wide range of formal hardware memory models (x86, POWER, ARMv7, ARMv8). Our proof is the first that establishes correctness of compilation of an event-structure-based model that forbids “thin-air” behaviors, as well as the first mechanized compilation proof of a weak memory model supporting sequentially consistent accesses to such a range of hardware platforms. Our compilation proof goes via the recent Intermediate Memory Model (IMM), which we suitably extend with sequentially consistent accesses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Evgenii</first_name>
          <last_name>Moiseenko</last_name>
          <affiliation>St. Petersburg University / JetBrains Research</affiliation>
          <bio>undefined</bio>
          <person_id>evgeniimoiseenko</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anton</first_name>
          <last_name>Podkopaev</last_name>
          <affiliation>NRU HSE, JetBrains Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://podkopaev.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/antonpodkopaev/b00dceb2-5b55-4c0b-afe0-17581b19dfee/small.jpg</picture_url>
          <person_id>antonpodkopaev</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~orilahav/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/orilahav/89b656f6-7634-49d1-9917-4b74da70a976/small.jpg</picture_url>
          <person_id>orilahav</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Orestis</first_name>
          <last_name>Melkonian</last_name>
          <affiliation>Utrecht University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://omelkonian.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/orestismelkonian/823e0ead-bc55-4ee3-b97a-114b787ad406/small.jpg</picture_url>
          <person_id>orestismelkonian</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Vafeiadis</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>Viktor Vafeiadis is a tenured faculty at the Max Planck Institute for Software Systems (MPI-SWS) in Germany. He got his BA and PhD from the University of Cambridge, and held post-doctoral researcher positions at the University of Cambridge and at Microsoft Research Cambridge before joining MPI-SWS in October 2010.</bio>
          <homepage_url>http://www.mpi-sws.org/~viktor/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/viktorvafeiadis/6a063832-47ca-4c32-8047-4bf4f74ae764/small.jpg</picture_url>
          <person_id>viktorvafeiadis</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>82f3388b-4997-4341-9da4-7ea46a1cd475</slot_id>
      <event_id>1afda63b-ac13-4748-afb4-ec818eef4cfe</event_id>
      <title>A Framework for Resource Dependent EDSLs in a Dependently Typed Language</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>19:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>20:00</end_time>
      <description>Idris’ Effects library demonstrates how to embed resource dependent algebraic effect handlers into a dependently typed host language, providing run-time and compile-time based reasoning on type-level resources. Building upon this work, Resources is a framework for realising Embedded Domain Specific Languages (EDSLs) with type-systems that contain domain specific substructural properties. Differing from Effects, Resources allows a language’s substructural properties to be encoded in a resource that is associated with language variables. Thus, allowing for multiple effect instances to be reasoned about autonomically and without explicit type-level declaration. Type-level predicates are used as proof that the language’s substructural properties hold. Several exemplar EDSLs are presented that illustrates our framework’s operation and how dependent types provide correctness-by-construction guarantees that substructural properties of written programs hold.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jan</first_name>
          <last_name>de Muijnck-Hughes</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>Jan is a Research Associate at the School of Computing at the University of Glasgow, where he investigates the construction of Structural and Behavioural Type-Systems for hardware design. Generally speaking, his research interests are revolved around the Type-Driven Development of Communicating Systems using Dependent Types, Session Types, and Algebraic Effects as presented in the dependently typed programming language Idris.</bio>
          <homepage_url>https://jfdm.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jandemuijnckhughes/6828da0f-67ea-4d2a-9c31-38d84d2e4624/small.jpg</picture_url>
          <person_id>jandemuijnckhughes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Wim</first_name>
          <last_name>Vanderbauwhede</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <person_id>wimvanderbauwhede</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Edwin</first_name>
          <last_name>Brady</last_name>
          <affiliation>University of St. Andrews</affiliation>
          <bio>I am a Lecturer in Computer Science at the University of St Andrews, interested in type theory, dependently typed functional programming, compilers and metaprogramming. I am currently working on a new implementation of Idris, a dependently typed functional programming language. When I’m not doing that, you might find me playing Go (I’m about 2 kyu), walking up a hill, watching a game of cricket, or waiting for a delayed train. I’m afraid I also perpetrated the Whitespace programming language.</bio>
          <homepage_url>https://eb.host.cs.st-andrews.ac.uk</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/edwinbrady/cbff36d2-7476-402e-bc2c-e84d1ceb0ab5/small.jpg</picture_url>
          <person_id>edwinbrady</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a11f9569-36d1-45ac-8af7-897171004f89</slot_id>
      <event_id>c8f92227-97e4-4cd4-97f8-0dbfb0f80f62</event_id>
      <title>Reshape your layouts, not your programs: A safe language extension for better cache locality</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>20:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>20:20</end_time>
      <description>The vast divide between the speed of CPU and RAM means that effective use of CPU caches is often a prerequisite for high performance on modern architectures. Hence, developers need to consider how to place data in memory so as to exploit spatial locality and achieve high memory bandwidth. Such manual memory optimisations are common in unmanaged languages (e.g. C, C++), but they sacrifice readability, maintainability, memory safety, and object abstraction. In managed languages, such as Java and C#, where the runtime abstracts away the memory from the developer, such optimisations are almost impossible. 
We present a language extension called SHAPES, which aims to offer developers more fine-grained control over the placement of data, without sacrificing memory safety or object abstraction. In SHAPES, programmers group related objects into pools, and specify how objects are laid out in these pools. Classes and types are annotated by pool parameters, which allow placement aspects to be changed orthogonally to the code that operates on the objects in the pool. These design decisions disentangle business logic and memory concerns. 
We give a formal model of SHAPES, present its type and memory safety model, and present its translation to a low-level language. We argue why we expect this translation to be efficient in terms of runtime representation of objects and access to their fields. We argue that SHAPES can be incorporated into existing managed and unmanaged language runtimes and fit well with garbage collection.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexandros</first_name>
          <last_name>Tasos</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexandrostasos/131f6a5e-4994-4195-b143-5eb7d52f3317/small.jpg</picture_url>
          <person_id>alexandrostasos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Juliana</first_name>
          <last_name>Franco</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>julianafranco1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sophia</first_name>
          <last_name>Drossopoulou</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Professor of Programming Languages in the Department of Computing, Imperial College, London, UK.</bio>
          <homepage_url>https://wp.doc.ic.ac.uk/sd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sophiadrossopoulou/f9f2890b-55bd-4796-94ab-fe3291277c90/small.jpg</picture_url>
          <person_id>sophiadrossopoulou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Wrigstad</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wrigstad.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tobiaswrigstad/51b1bbdb-d077-4128-ad29-ec14657617a7/small.jpg</picture_url>
          <person_id>tobiaswrigstad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Susan</first_name>
          <last_name>Eisenbach</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wp.doc.ic.ac.uk/susan/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/susaneisenbach/100322fa-6296-48e2-8238-10431036ea30/small.jpg</picture_url>
          <person_id>susaneisenbach</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4b8d9f85-ec15-433b-b6b4-e895e845b115</subevent_id>
    <title>ECOOP Research Papers: S-3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>b13f8bbd-b83a-485c-a954-fbfff331ecc3</slot_id>
      <title>Session: ECOOP Research Papers - S-3</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Carl Friedrich</first_name>
          <last_name>Bolz-Tereick</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cfbolz.de</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/carlfriedrichbolz/6fde7d02-8d5c-4f4c-8d17-0d8999f6a2aa/small.jpg</picture_url>
          <person_id>carlfriedrichbolz</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Anitha</first_name>
          <last_name>Gollamudi</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://scholar.harvard.edu/anithag</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anithagollamudi/8fb48e67-0664-40de-b6fa-163655dda95a/small.jpg</picture_url>
          <person_id>anithagollamudi</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1a36f697-fa4d-4d98-93b9-4d8a1c906e4f</slot_id>
      <event_id>b3bfaad5-f792-4abe-beec-b2c3543839eb</event_id>
      <title>Row and Bounded Polymorphism via Disjoint Polymorphism</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>12:20</end_time>
      <description>Polymorphism and subtyping are important features in mainstream OO languages. The most common way to integrate the two is via F&amp;lt;: style bounded quantification. A closely related mechanism is row polymorphism, which provides an alternative to subtyping, while still enabling many of the same applications. Yet another approach is to have type systems with intersection types and polymorphism. A recent addition to this design space are calculi with disjoint intersection types and disjoint polymorphism. With all these alternatives it is natural to wonder how they are related. 
This paper provides an answer to this question. We show that disjoint polymorphism can recover forms of both row polymorphism and bounded polymorphism, while retaining key desirable properties, such as type-safety and decidability. Furthermore, we identify the extra power of disjoint polymorphism which enables additional features that cannot be easily encoded in calculi with row polymorphism or bounded quantification alone. Ultimately we expect that our work is useful to inform language designers about the expressive power of those common features, and to simplify implementations and metatheory of feature-rich languages with polymorphism and subtyping.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ningning</first_name>
          <last_name>Xie</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://xnning.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ningningxie/99787204-daa9-484a-bea5-4b2b88551687/small.jpg</picture_url>
          <person_id>ningningxie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xuan</first_name>
          <last_name>Bi</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <person_id>xuanbi1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>30550858-93a6-4f1f-8b67-199ad7187016</slot_id>
      <event_id>fca401c6-2be9-4344-9688-7495c67214c0</event_id>
      <title>Value Partitioning: A Lightweight Approach to Relational Static Analysis for JavaScript</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>12:00</end_time>
      <description>In static analysis of modern JavaScript libraries, relational analysis at key locations is critical to provide sound and useful results. Prior work addresses this challenge by the use of various forms of trace partitioning and syntactic patterns, which is fragile and does not scale well, or by incorporating complex backwards analysis. 
In this paper, we propose a new lightweight variant of trace partitioning named value partitioning that refines individual abstract values instead of entire abstract states. We describe how this approach can effectively capture important relational properties involving dynamic property accesses, functions with free variables, and predicate functions. 
We extend an existing JavaScript analyzer with value partitioning and demonstrate experimentally that it is a simple, precise, and efficient alternative to the existing approaches for analyzing widely used JavaScript libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Benjamin Barslev</first_name>
          <last_name>Nielsen</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/benjaminbarslevnielsen/7c6acacc-eb83-4ad2-8f27-d9a7ce64e58e/small.jpg</picture_url>
          <person_id>benjaminbarslevnielsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anders</first_name>
          <last_name>Møller</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
          <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
          <person_id>andersmoller</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3ca76479-5347-4043-be29-5b14131bc209</slot_id>
      <event_id>a6b2d038-de0e-4dba-afec-21ca56a42e47</event_id>
      <title>Sound regular corecursion in coFJ</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>11:40</end_time>
      <description>The aim of the paper is to provide solid foundations for a programming paradigm natively supporting the creation and manipulation of cyclic data structures. To this end, we describe coFJ, a Java-like calculus where objects can be \emph{infinite} and methods are equipped with a \emph{codefinition} (an alternative body). We provide an abstract semantics of the calculus based on the framework of \emph{inference systems with corules}. In coFJ with this semantics, FJ recursive methods on finite objects can be extended to infinite objects as well, and behave as desired by the programmer, by specifying a codefinition. In the meantime, we describe an operational semantics which can be directly implemented in a programming language, and prove the soundness of such semantics with respect to the abstract one.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Davide</first_name>
          <last_name>Ancona</last_name>
          <affiliation>DIBRIS, University of Genova, Italy</affiliation>
          <bio>Davide Ancona (PhD in Computer Science, University of Pisa, 1998) is Associate Professor at the University of Genova. His main research interests include type systems, object-oriented programming, coinduction methods for programming languages, modules and components, software reuse and maintenance, multi-agent systems, and behavioral types. He is author of more than 70 publications. He is the secretary of the executive board of AITO, Association Internationale pour les Technologies Objets (since Jan 2013, previously Vice-President since Jan 2012), and member of the editorial board of the ACM/SIGAPP Applied Computing Review (ACR), Scientific Programming (Hindawi), and Open Computer Science. He has been guest editor of special issues of Science of Computer Programming and Journal of Object Technology. In 2009 he received, together with G. Lagorio, the best paper prize at ECOOP. He has participated to several national and European projects and has been PC member of several workshops and conferences: WOOD’04, Bytecode 2008, ESOP 2008, DLS 2009, 2010 and 2013, FOOL 2010, RP 2011 and 2012, ECOOP 2013 and 2014, POPL 2015 (ERC), OOPSLA 2016 (ERC), TASE 2016, FTfJP 2016. He has been involved in the organization of several scientific events: organizing chair of ECOOP 2009, program co-chair of FTfJP06 and of OOPS special track at SAC from 2004 through 2017, co-chair of CILC 2015 and VORTEX 2016.</bio>
          <homepage_url>http://www.disi.unige.it/person/AnconaD/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davideancona/50b3fc2f-1782-4ca1-91a5-6718f42ba51b/small.jpg</picture_url>
          <person_id>davideancona</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pietro</first_name>
          <last_name>Barbieri</last_name>
          <affiliation>Università di Genova</affiliation>
          <bio>undefined</bio>
          <person_id>pietrobarbieri</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Dagnino</last_name>
          <affiliation>DIBRIS, University of Genova, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.dibris.unige.it/en/dagnino-francesco</homepage_url>
          <person_id>francescodagnino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Elena</first_name>
          <last_name>Zucca</last_name>
          <affiliation>University of Genova</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.disi.unige.it/person/ZuccaE/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elenazucca/31be5390-fc85-4134-90af-718c3b50c4a3/small.jpg</picture_url>
          <person_id>elenazucca</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a80a8a53-b755-469d-b4cb-a1b4fe2eab6a</slot_id>
      <event_id>51bcdb71-4f23-4307-a4b8-8565ca1fb7ab</event_id>
      <title>Flow-Sensitive Type-Based Heap Cloning</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>11:20</end_time>
      <description>Flow-sensitive pointer analysis promises more precise results than its flow-insensitive counterpart by respecting program control-flow. However, existing heap abstractions for C/C++ flow-sensitive pointer analysis model the heap by creating one heap object per memory allocation. Two runtime heap objects which originate from the same allocation site are imprecisely modeled using one abstract object, which makes them share the same imprecise points-to sets and thus reduces the benefit of analysing heap objects flow-sensitively. On the other hand, equipping flow-sensitive analysis with context-sensitivity where an abstract heap object is created (cloned) per calling context can yield a more precise heap modeling for flow-sensitive analysis, but at the cost of uncontrollable analysis overhead when analysing larger programs. 
This paper presents TypeClone, a new type-based heap model for flow-sensitive analysis. Our key insight is to differentiate concrete heap objects lazily using the type information at their use sites (e.g., accessed via pointer dereferencing) within the program control-flow. The novelty of TypeClone lies in its lazy heap cloning: an untyped abstract heap object created at an allocation site is killed and replaced with a new (cloned) object uniquely identified by the type information at its use site for flow-sensitive points-to propagation. This yields more precise points-to relations for each program point through well-typed objects where necessary. Thus, heap cloning can be performed within a flow-sensitive analysis without the need for context-sensitivity. Moreover, we extend TypeClone to support new kinds of strong updates for heap objects to filter out imprecise points-to relations at object use sites for programs conforming to the strict aliasing rules based on the standard C/C++ specification. Our method is neither strictly superior nor inferior to context-sensitive heap cloning, but rather, represents a new dimension that achieves a sweet spot between precision and efficiency. Our experimental results also confirm that TypeClone is more precise than flow-sensitive pointer analysis by increasing the percentage of no-alias queries by 12% on average.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohamad</first_name>
          <last_name>Barbar</last_name>
          <affiliation>University of Technology, Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>mohamadbarbar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yulei</first_name>
          <last_name>Sui</last_name>
          <affiliation>University of Technology Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuleisui.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yuleisui/e6ce6e88-3cd8-4595-9c61-a8da6f7319f6/small.jpg</picture_url>
          <person_id>yuleisui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Shiping</first_name>
          <last_name>Chen</last_name>
          <affiliation>Data61 at CSIRO, Australia / UNSW, Australia</affiliation>
          <bio>Dr. Shiping Chen is a principal research scientist in CSIRO Data61. He also holds an conjoint A/Professor title with the University of New Suouth Wales (UNSW) and the University of Sydney through teaching and supervising PhD students. He has been working on distributed systems for over 20 years with focus on performance and security. He has published 150+ research papers in these research areas. He is actively involved in computing research community through publications, journal editorship and conference TPC services, including WWW, EDOC, ICSOC and IEEE ICWS/SCC/CLOUD. His current research interests include application security, blockchain and service-oriented trusted collaboration. He is a senior member of the IEEE.</bio>
          <homepage_url>https://www.cse.unsw.edu.au/~z9195738/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shipingchen/820fa36a-2dfb-43c7-996f-98306efc746b/small.jpg</picture_url>
          <person_id>shipingchen</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>eaaab73d-9570-4cf1-a622-32cdf2fa157b</subevent_id>
    <title>SAS: 6</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>b048de65-2444-4346-958b-ec6e2ea8706e</slot_id>
      <title>Session: SAS - 6</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>09:00</start_time>
      <end_time>10:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Mihaela</first_name>
          <last_name>Sighireanu</last_name>
          <affiliation>IRIF, Université Paris Diderot</affiliation>
          <bio>I’m associate professor, more precisely “Maitre de conferences with HDR” at University of Paris and member of the verification team in the research institute IRIF. I’ve obtained my PhD from University of Grenoble under the supervision of Hubert Garavel. I’ve previously worked at Verimag during my Master thesis and at INRIA during my postdoc .</bio>
          <homepage_url>https://www.irif.fr/~sighirea</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mihaelasighireanu/8a15d1c3-bf93-4e81-98bb-e903aa08b0d2/small.jpg</picture_url>
          <person_id>mihaelasighireanu</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>811a300d-9918-4516-848b-83dad9f38e6d</slot_id>
      <event_id>187c6e5a-f0c2-4d97-b61b-97cf948fa0e3</event_id>
      <title>Termination of Polynomial Loops</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>10:00</end_time>
      <description>We consider the termination problem for triangular weakly non-linear loops (twn-loops) over some ring S like Z, Q, or R. Essentially, the guard of such a loop is an arbitrary Boolean formula over (possibly non-linear) polynomial inequations, and the body is a single assignment (x1,…,xd)⟵(c1⋅x1+p1,…,cd⋅xd+pd) where each xi is a variable, ci∈S, and each pi is a (possibly non-linear) polynomial over S and the variables xi+1,…,xd. We present a reduction from the question of termination to the existential fragment of the first-order theory of S and R. For loops over R, our reduction entails decidability of termination. For loops over Z and Q, it proves semi-decidability of non-termination. Furthermore, we present a transformation to convert certain non-twn-loops into twn-form. Then the original loop terminates iff the transformed loop terminates over a specific subset of R, which can also be checked via our reduction. This transformation also allows us to prove tight complexity bounds for the termination problem for two important classes of loops which can always be transformed into twn-loops.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Florian</first_name>
          <last_name>Frohn</last_name>
          <affiliation>Max Planck Institute for Informatics</affiliation>
          <bio>undefined</bio>
          <person_id>florianfrohn</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marcel</first_name>
          <last_name>Hark</last_name>
          <affiliation>RWTH Aachen University, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/marcelhark/5357ec40-8b32-4698-8252-6c0d8b96f75e/small.jpg</picture_url>
          <person_id>marcelhark</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jürgen</first_name>
          <last_name>Giesl</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://verify.rwth-aachen.de/giesl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jurgengiesl/b1a15529-1129-4608-9104-be1d58d0e129/small.jpg</picture_url>
          <person_id>jurgengiesl</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d9aa46d6-ff33-40fc-89c4-3c292af007e0</slot_id>
      <event_id>fa77e119-6a7c-478d-a301-745160397e38</event_id>
      <title>Polynomial Invariants for Affine Programs</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>09:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>James</first_name>
          <last_name>Worrell</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ox.ac.uk/people/james.worrell/home.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jamesworrell/6504b62e-546c-401b-ba8d-2749ee9c9308/small.jpg</picture_url>
          <person_id>jamesworrell</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5d15614c-7cb1-4fce-81a2-7d7dccbba6f2</subevent_id>
    <title>SAS: 4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>afc5939d-da85-433a-8453-ebbead43e756</slot_id>
      <title>Session: SAS - 4</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Shigeru</first_name>
          <last_name>Chiba</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.csg.ci.i.u-tokyo.ac.jp/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shigeruchiba/b57db719-4160-4e39-9f41-ef3facc9e449/small.jpg</picture_url>
          <person_id>shigeruchiba</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Caterina</first_name>
          <last_name>Urban</last_name>
          <affiliation>École normale supérieure</affiliation>
          <bio>undefined</bio>
          <person_id>caterinaurban</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2c9a5e27-bc34-4cf2-b4e5-27e566f654ae</slot_id>
      <event_id>60869a0f-9da8-4a93-9b8e-4d4adbc8ef13</event_id>
      <title>Memory-Efficient Fixpoint Computation</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>03:20</end_time>
      <description>Practical adoption of static analysis often requires trading precision for performance. This paper focuses on improving the memory efficiency of abstract interpretation without sacrificing precision or time efficiency. Computationally, abstract interpretation reduces the problem of inferring program invariants to computing a fixpoint of a set of equations. This paper presents a method to minimize the memory footprint in Bourdoncle’s iteration strategy, a widely-used technique for fixpoint computation. Our technique is agnostic to the abstract domain used. We prove that our technique is optimal (i.e., it results in minimum memory footprint) for Bourdoncle’s iteration strategy while computing the same result. We evaluate the efficacy of our technique by implementing it in a tool called MIKOS, which extends the state-of-the-art abstract interpreter IKOS. When verifying user-provided assertions, MIKOS shows a decrease in peak-memory usage to 4.07% (24.57x) on average compared to IKOS. When performing interprocedural buffer-overflow analysis, MIKOS shows a decrease in peak-memory usage to 43.7% (2.29x) on average compared to IKOS.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sung</first_name>
          <last_name>Kook Kim</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>sungkookkim</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Arnaud J.</first_name>
          <last_name>Venet</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>arnaudjvenet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aditya V.</first_name>
          <last_name>Thakur</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://thakur.cs.ucdavis.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adityavthakur/89eb0287-7273-4261-b8a5-47ccfc8799b0/small.jpg</picture_url>
          <person_id>adityavthakur</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6c2e5501-13d0-42c4-8796-57a411c6fa21</slot_id>
      <event_id>ce3e05fe-bed4-4c6e-8f2f-3ec96e59bf13</event_id>
      <title>Dynamic Pattern Matching with Python</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>03:40</end_time>
      <description>Pattern matching allows programs both to extract specific information from complex data types, as well as to branch on the structure of data and thus apply specialized actions to different forms of data. Originally designed for strongly typed functional languages with algebraic data types, pattern matching has since been adapted for object-oriented and even dynamic languages. This paper discusses how pattern matching can be included in the dynamically typed language \emph{Python} in line with existing features that support extracting values from sequential data structures.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Kohn</last_name>
          <affiliation>University of Cambridge, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://tobiaskohn.ch/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tobiaskohn/de1722d1-b49c-4534-9f14-52a007daabf7/small.jpg</picture_url>
          <person_id>tobiaskohn</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guido</first_name>
          <last_name>van Rossum</last_name>
          <affiliation>Python Software Foundation</affiliation>
          <bio>undefined</bio>
          <person_id>guidovanrossum</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gary Brandt</first_name>
          <last_name>Bucher, II</last_name>
          <affiliation>Research Affiliates, LLC</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://brandtbucher.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/garybrandtbucherii/4d2da008-7dca-4c6f-805b-65214288ada8/small.jpg</picture_url>
          <person_id>garybrandtbucherii</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>undefined</first_name>
          <last_name>Talin</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>talin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Levkivskyi</last_name>
          <affiliation>Dropbox Ireland</affiliation>
          <bio>undefined</bio>
          <person_id>ivanlevkivskyi</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d6cf4501-816d-4640-b1cb-d57ee4d6d475</slot_id>
      <event_id>b5f8101e-f7bf-45b0-98cf-165cd7531f05</event_id>
      <title>Sound, Heuristic Type Annotation Inference for Ruby</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>04:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>04:20</end_time>
      <description>Many researchers have explored retrofitting static type systems to dynamic languages. This raises the question of how to add type annotations to code that was previously untyped. One obvious solution is type inference. However, in complex type systems, in particular those with structural types, type inference typically produces most general types that are large, hard to understand, and unnatural for programmers. To solve this problem, we introduce InferDL, a novel Ruby type inference system that infers sound and useful type annotations by incorporating heuristics that guess types. For example, we might heuristically guess that a parameter whose name ends in ``count'' is an integer. InferDL works by first running standard type inference and then applying heuristics to any positions for which standard type inference produces overly-general types. Heuristic guesses are added as constraints to the type inference problem to ensure they are consistent with the rest of the program and other heuristic guesses; inconsistent guesses are discarded. We formalized InferDL in a core type and constraint language. We implemented InferDL on top of RDL, an existing Ruby type checker. To evaluate InferDL, we applied it to four Ruby on Rails apps that had been previously type checked with RDL, and hence had type annotations. We found that, when using heuristics, InferDL inferred 22% more types that were as or more precise than the previous annotations, compared to standard type inference without heuristics. We also found one new type error. We further evaluated InferDL by applying it to six additional apps, finding five additional type errors. Thus, we believe InferDL represents a promising approach for inferring type annotations in dynamic languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Milod</first_name>
          <last_name>Kazerounian</last_name>
          <affiliation>University of Maryland, College Park</affiliation>
          <bio>undefined</bio>
          <person_id>milodkazerounian1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Brianna M.</first_name>
          <last_name>Ren</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
          <person_id>briannamren</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jeffrey S.</first_name>
          <last_name>Foster</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.tufts.edu/~jfoster/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeffreysfoster/b22ce952-32b0-48bd-be56-12fd87bf3469/small.jpg</picture_url>
          <person_id>jeffreysfoster</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f1c964b9-9190-4a42-9d05-b112a3996fc2</slot_id>
      <event_id>5e5d5e27-4f5e-4ec9-be96-5f1f0a5bfe96</event_id>
      <title>Simple and Efficient Computation of Minimal Weak Control Closure</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>04:00</end_time>
      <description>Control dependency is a fundamental concept in many pro- gram analyses, transformation, parallelization, and compiler optimiza- tion techniques. An overwhelming number of definitions of control depen- dency relations are found in the literature that capture various kinds of program control flow structures. Weak and strong control closure (WCC and SCC) relations capture nontermination insensitive and sensitive con- trol dependencies and subsume all previously defined control dependency relations. In this paper, we have shown that static dependency-based pro- gram slicing requires the repeated computation of WCC and SCC. The state-of-the-art WCC algorithm provided by Danicic et al. has the cubic worst-case complexity in terms of the size of the control flow graph and is a major obstacle to be used in static program slicing. We have provided a simple yet efficient method to compute the minimal WCC which has the quadratic worst-case complexity and proved the correctness of our algorithms. We implemented ours and the state-of-the-art algorithms in the Clang/LLVM compiler framework and run experiments on a num- ber of SPEC CPU 2017 benchmarks. Our method performs a maximum of 23.8 times and on average 10.6 times faster than the state-of-the-art method. The performance curves of our WCC algorithm for practical applications are closer to the NlogN curve in the microsecond scale. Ev- idently, we improve the practical performance of WCC computation by an order of magnitude.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abu Naser</first_name>
          <last_name>Masud</last_name>
          <affiliation>Malardalen University</affiliation>
          <bio>undefined</bio>
          <person_id>abunasermasud</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>376c14b7-ab5a-41a2-bd9a-a678372cef80</subevent_id>
    <title>SAS: 5</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>edd33d48-1172-40c3-8148-7c61294c737d</slot_id>
      <title>Session: SAS - 5</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Xavier</first_name>
          <last_name>Rival</last_name>
          <affiliation>INRIA/CNRS/ENS Paris</affiliation>
          <bio>Xavier Rival is a Senior Research Scientist (Directeur de Recherche) at INRIA Paris. His research interest focus on abstract interpretation and software verification by static analysis. He is mainly working on symbolic abstractions (trace partitionning abstraction, shape analysis, separation logic and memory abstract domains). He has been involved in the design, implementation and transfer of the Astrée analyser, a static analyser able to verify safety properties on industrial size safety critical softwares. He is currently the PI of the MemCAD ERC Starting Grant, aiming at the design of a library of abstract domains to describe memory states containing a wide range of complex data structures. He is also the Head of the ANTIQUE INRIA group, located at ENS Paris, and Professeur Chargé de Cours at Ecole Polytechnique.</bio>
          <homepage_url>http://www.di.ens.fr/~rival/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xavierrival/036511d0-47a1-4db2-97df-0bf5da1a2c8d/small.jpg</picture_url>
          <person_id>xavierrival</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Sukyoung</first_name>
          <last_name>Ryu</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>sukyoungryu1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5f46fb26-3a63-4ae7-a578-99dfdd0dbf3f</slot_id>
      <event_id>890ea906-b119-4828-8f45-d132f9c38082</event_id>
      <title>Abstract Neural Networks</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>05:20</end_time>
      <description>Deep Neural Networks (DNNs) are rapidly being applied to safety-critical domains such as drone and airplane control, motivating techniques for verifying the safety of their behavior. Unfortunately, DNN verification is NP-hard, with current algorithms slowing exponentially with the number of nodes in the DNN. This paper introduces the notion of Abstract Neural Networks (ANNs), which can be used to soundly overapproximate DNNs while using fewer nodes. An ANN is like a DNN except weight matrices are replaced by values in a given abstract domain. We present a framework parameterized by the abstract domain and activation functions used in the DNN that can be used to construct a corresponding ANN. We present necessary and sufficient conditions on the DNN activation functions for the constructed ANN to soundly over-approximate the given DNN. Prior work on DNN abstraction was restricted to the interval domain and ReLU activation function. Our framework can be instantiated with other abstract domains such as octagons and polyhedra, as well as other activation functions such as Leaky ReLU, Sigmoid, and Hyperbolic Tangent.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Sotoudeh</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://masot.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthewsotoudeh/32b819f5-05ef-4b0a-8a19-d59eed661278/small.jpg</picture_url>
          <person_id>matthewsotoudeh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aditya V.</first_name>
          <last_name>Thakur</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://thakur.cs.ucdavis.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adityavthakur/89eb0287-7273-4261-b8a5-47ccfc8799b0/small.jpg</picture_url>
          <person_id>adityavthakur</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>96624ab6-7b23-44d2-9f90-6c913772f35a</slot_id>
      <event_id>5360324a-7234-4b20-95d8-80639f65ad7a</event_id>
      <title>Probabilistic Lipschitz Analysis of Neural Networks</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>05:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>06:00</end_time>
      <description>We are interested in algorithmically proving the robustness of neural networks. Notions of robustness have been discussed in the literature; we are interested in probabilistic notions of robustness that assume it feasible to construct a statistical model of the process generating the inputs of a neural network. We find this a reasonable assumption given the rapid advances in algorithms for learning generative models of data. A neural network f is then defined to be probabilistically robust if, for a randomly generated pair of inputs, f is likely to demonstrate k-Lipschitzness, i.e., the distance between the outputs computed by $f$ is upper-bounded by the k-th multiple of the distance between the pair of inputs. We name this property, probabilistic Lipschitzness. 
We model generative models and neural networks, together, as programs in a simple, first-order, imperative, probabilistic programming language, pcat. Inspired by a large body of existing literature, we define a denotational semantics for this language. Then we develop a sound local Lipschitzness analysis for cat, a non-probabilistic sublanguage of pcat. This analysis can compute an upper bound of the ``Lipschitzness'' of a neural network in a bounded region of the input set. We next present a provably correct algorithm, PROLIP, that analyzes the behavior of a neural network in a user-specified box-shaped input region and computes - (i) lower bounds on the probabilistic mass of such a region with respect to the generative model, (ii) upper bounds on the Lipschitz constant of the neural network in this region, with the help of the local Lipschitzness analysis. Finally, we present a sketch of a proof-search algorithm that uses PROLIP as a primitive for finding proofs of probabilistic Lipschitzness. We implement the PROLIP algorithm and empirically evaluate the computational complexity of PROLIP.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ravi</first_name>
          <last_name>Mangal</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cc.gatech.edu/~rmangal3/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ravimangal/a3129793-a42b-47f4-8195-79800685503e/small.jpg</picture_url>
          <person_id>ravimangal</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kartik</first_name>
          <last_name>Sarangmath</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>kartiksarangmath</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aditya</first_name>
          <last_name>Nori</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>adityanori</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Alessandro</first_name>
          <last_name>Orso</last_name>
          <affiliation>Georgia Tech</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cc.gatech.edu/~orso/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alessandroorso/5f7dffa8-54ca-4f1e-84f0-1f1a9affbf55/small.jpg</picture_url>
          <person_id>alessandroorso</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>aee87c67-5a0c-4016-8f75-9be6ef04b1ae</slot_id>
      <event_id>179704f8-cb35-4d44-8ef9-ea437c436204</event_id>
      <title>Amalgamating Different JIT Compilations in a Meta-tracing JIT Compiler Framework</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>05:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>05:40</end_time>
      <description>Most virtual machines employ just-in-time (JIT) compilers to achieve high-performance. Trace-based compilation and method-based compilation are two major compilation strategies in JIT compilers. In general, the former excels in compiling programs with more in-depth method calls and more dynamic branches, while the latter is suitable for a wide range of programs. Some previous studies have suggested that each strategy has its advantages and disadvantages, and there is no clear winner. 
In this paper, we present a new approach, namely, the meta-hybrid JIT compilation strategy. It combines trace-based and method-based compilations to utilize the advantages of both strategies. Moreover, it is realized as a meta JIT compiler framework; thus, we can generate a VM with a hybrid JIT compiler that can apply different program parts by merely writing an interpreter with our framework. 
We chose to extend a meta-tracing JIT compiler and supported the two compilations on it. As a prototype, we implemented a simple meta-tracing JIT compiler framework called BacCaml based on the MinCaml compiler by following RPython’s architecture. 
We evaluated its performance by creating a small functional programming language with BacCaml and running microbenchmark programs. Furthermore, we performed a synthetic experiment to confirm that there are programs that run faster by hybrid compilation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yusuke</first_name>
          <last_name>Izawa</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://3tty0n.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yusukeizawa/2d1131a1-4abb-4ade-9761-e3d2648bd9f5/small.jpg</picture_url>
          <person_id>yusukeizawa</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hidehiko</first_name>
          <last_name>Masuhara</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>Hidehiko Masuhara is a Professor of Mathematical and Computing Science, Tokyo Institute of Technology since April 2013. He received his B.S., M.S., and Ph.D. in Computer Science from Department of Information Science, University of Tokyo in 1992, 1994, and 1999, respectively, and served as an assistant professor, lecturer, and associate professor at Graphics and Computer Science, Graduate School of Arts and Sciences, University of Tokyo from 1995 until 2013.</bio>
          <homepage_url>http://prg.is.titech.ac.jp/people/masuhara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hidehikomasuhara/3ea94269-6fb5-4c6d-8d6f-0435717377d6/small.jpg</picture_url>
          <person_id>hidehikomasuhara</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>edab5d5e-1266-4297-80cb-335754c7bef6</slot_id>
      <event_id>5013f5f6-0c92-406c-b516-126cc1c9f16c</event_id>
      <title>Pricing Python Parallelism: A Dynamic Language Cost Model for Heterogeneous Platforms</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>06:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>06:20</end_time>
      <description>Execution times may be reduced by offloading parallel loop nests to a GPU. Auto-parallelizing compilers are common for static languages, often using a cost model to determine when the GPU execution speed will outweigh the offload overheads. Nowadays scientific software is increasingly written in dynamic languages and would benefit from compute accelerators. The ALPyNA framework analyses moderately complex Python loop nests and automatically JIT compiles code for heterogeneous CPU and GPU architectures. 
We present the first analytical cost model for auto-parallelizing loop nests in a dynamic language on heterogeneous architectures. Predicting execution time in a language like Python is extremely challenging, since aspects like the element types, size of the iteration space, and amenability to parallelization can only be determined at runtime. Hence the cost model must be both staged, to combine compile and run-time information, and lightweight to minimize runtime overhead. GPU execution time prediction must account for factors like data transfer, block-structured execution, and starvation. 
We show that a comparatively simple, staged analytical model can accurately determine during execution when it is profitable to offload a loop nest. We evaluate our model on three heterogeneous platforms across 360 experiments with 12 loop-intensive Python benchmark programs. The results show small misprediction intervals and a mean slowdown of just 13.6%, relative to the optimal (oracular) offload strategy.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dejice</first_name>
          <last_name>Jacob</last_name>
          <affiliation>University of Glasgow, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~jacobd</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/dejicejacob/3f7c1cd4-c004-439f-a953-1389a8b68578/small.jpg</picture_url>
          <person_id>dejicejacob</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Phil</first_name>
          <last_name>Trinder</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~trinder/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philtrinder/fa2ffb07-cddf-4a8d-a52a-ca1aaad1273b/small.jpg</picture_url>
          <person_id>philtrinder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Singer</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~jsinger</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeremysinger/14db1542-37ba-4e0e-b338-e3a952991f1a/small.jpg</picture_url>
          <person_id>jeremysinger</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>aebfc60d-dc95-4034-a752-a7a52f07ecf9</subevent_id>
    <title>SAS: 8</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>798ae7a2-c991-4cc4-916e-57e8d7df8a17</slot_id>
      <title>Session: SAS - 8</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Tim</first_name>
          <last_name>Felgentreff</last_name>
          <affiliation>Oracle Labs, Potsdam</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/timfelgentreff/1cdb8c05-2513-4508-ab46-dcae9a44d4c4/small.jpg</picture_url>
          <person_id>timfelgentreff</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Samir</first_name>
          <last_name>Genaim</last_name>
          <affiliation> Universidad Complutense de Madrid</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://samir.loopkiller.com</homepage_url>
          <person_id>samirgenaim</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>46008787-c9af-4d90-bef1-d4283eb6a52f</slot_id>
      <event_id>43e38930-e679-4381-b5e9-f606f58d5550</event_id>
      <title>Formal framework for reasoning about the precision of dynamic analysis</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>13:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mila</first_name>
          <last_name>Dalla Preda</last_name>
          <affiliation>University of Verona, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://profs.sci.univr.it/~dallapre</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/miladallapreda/bfe198ed-1dee-40dd-a639-ad6951f36888/small.jpg</picture_url>
          <person_id>miladallapreda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roberto</first_name>
          <last_name>Giacobazzi</last_name>
          <affiliation>University of Verona and IMDEA Software Institute</affiliation>
          <bio>Roberto Giacobazzi received the Laurea degree in Computer Science in 1988 from the University of Pisa, and in 1993 he received the Ph.D. in Computer Science from the same university, with a Ph.D. thesis on Semantic aspects of logic program analysis, under the supervision of Prof. Giorgio Levi. From 1993 to 1995 he had a Post Doctoral Research position at Laboratoire d’Informatique (LIX), Ecole Polytechnique (Paris) in the equipe Cousot. From 1995 to 1998 he was (tenured) Assistant Professor in Computer Science at the University of Pisa. From May 2000 until now he is Full Professor in Computer Science at the University of Verona. The research interests of Roberto Giacobazzi include abstract interpretation, static program analysis, semantics of programming languages, program verification, abstract model-checking, program transformation and optimization, digital asset protection, code obfuscation, malware detection, software watermarking, computability and lattice theory. He has been Program Chair of SAS, VMCAI, of workshops in programming languages and language based security, and General Chair of ACM POPL2013. From 2006 to 2012 he has been Dean of the College of Science of the University of Verona. He works at the University of Verona and at IMDEA Software Institute.</bio>
          <homepage_url>http://profs.sci.univr.it/~giaco/index.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/robertogiacobazzi/3a292abe-6f69-4d5d-bfa3-305417b39cba/small.jpg</picture_url>
          <person_id>robertogiacobazzi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Niccolò</first_name>
          <last_name>Marastoni</last_name>
          <affiliation>University of Verona</affiliation>
          <bio>undefined</bio>
          <person_id>niccolomarastoni</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>65ca0aac-d1e0-4410-8b79-8634eafb21c4</slot_id>
      <event_id>3faff150-5135-4eb3-affb-a5bfe3c3fe17</event_id>
      <title>Framework-Aware Debugging with Stack Tailoring</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>14:20</end_time>
      <description>Debugging applications that execute within a framework is not always easy: the call-stack offered to developers is often a mix-up of stack frames that belong to different frameworks, introducing an unnecessary noise that prevents developers from focusing on the debugging task. Moreover, relevant application code is not always available in the call-stack because it may have already returned, or is available in another thread. In such cases, manually gathering all relevant information from these different sources is not only cumbersome but also costly. 
In this paper we introduce Sarto, a call-stack instrumentation layer that allows developers to tailor the stack to make debugging framework-aware. The goal is to improve the quality and amount information present in the call-stack to reduce debugging time without impacting the execution time. Sarto proposes a set of six stack operations that combined hide irrelevant information, introduce missing information, and relate dispersed debugging sources before this is fed to the debugger. 
We validate Sarto by applying it to four application cases using inherently different frameworks: unit testing, web server, remote promises and big data processing. We showcase our experiences in using Sarto in the different frameworks, and perform some performance benchmarks to demonstrate that Sarto does not generate noticeable overhead when instrumenting a call-stack. We also show that our solution reduces by half the amount of data stored to debug similar exceptions happening in a parallel setup.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matteo</first_name>
          <last_name>Marra</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>I am a pre-doctoral researcher at the Vrije Universiteit Brussel (Belgium). After completing my bachelor studies in Italy (Università degli studi di Bologna), I moved to Brussels for a master at the Vrije Universiteit Brussel, in the Software Languages Lab, and decided to start a PhD under the guide of prof. Elisa Gonzalez Boix. I also cooperate with the RMoD research group at INRIA Lille Nord-Europe. 
My research focuses on debugging concurrent and parallel applications, particularly Big Data (or data intensive) applications.</bio>
          <homepage_url>https://soft.vub.ac.be/~mmarra</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matteomarra/71e5312b-940b-4349-afaf-fa0a934b2c49/small.jpg</picture_url>
          <person_id>matteomarra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guillermo</first_name>
          <last_name>Polito</last_name>
          <affiliation>Univ. Lille, CNRS, Centrale Lille, Inria, UMR 9189 - CRIStAL - Centre de Recherche en Informatique Signal et Automatique de Lille</affiliation>
          <bio>Guille Polito is research engineer at the CRIStAL laboratory in the university of Lille, working in tight relation with the RMoD team. Guille’s main research interests are programming language development, programming tools, modular systems, and maintenance of large software systems. 
He currently works on techniques to develop modular systems and languages, and new development tools. Guille works in the development of the open source Pharo programming language and environment since 2010, and he is a member of its technical board since 2018.</bio>
          <homepage_url>https://guillep.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guillermopolito/fb027991-a37d-4375-8c71-1858ce478695/small.jpg</picture_url>
          <person_id>guillermopolito</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Elisa</first_name>
          <last_name>Gonzalez Boix</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~egonzale</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elisagonzalezboix/8e8a61c4-366e-49b5-a861-7dfbc98ee129/small.jpg</picture_url>
          <person_id>elisagonzalezboix</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>eb80fe7a-f17d-45c0-8660-63205463d67a</slot_id>
      <event_id>4fd50d6f-63a1-4bda-a578-b90810c55019</event_id>
      <title>Farkas-Based Tree Interpolation</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>13:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sepideh</first_name>
          <last_name>Asadi</last_name>
          <affiliation>PhD Student</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.inf.usi.ch/phd/asadi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sepidehasadi/68b2e971-e6c1-495a-be27-6eeedea8173c/small.jpg</picture_url>
          <person_id>sepidehasadi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin</first_name>
          <last_name>Blicha</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>martinblicha</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Antti</first_name>
          <last_name>Hyvärinen</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>anttihyvarinen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Grigory</first_name>
          <last_name>Fedyukovich</last_name>
          <affiliation>Florida State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.fsu.edu/~grigory</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/grigoryfedyukovich/902a9cea-9078-42f4-9fb4-19a433865738/small.jpg</picture_url>
          <person_id>grigoryfedyukovich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Natasha</first_name>
          <last_name>Sharygina</last_name>
          <affiliation>USI Lugano, Switzerland</affiliation>
          <bio>Natasha Sharygina is a Full Professor of Computer Science at the University of Lugano, Switzerland. Prof. Sharygina received a Ph.D. degree from the University of Texas at Austin, USA in 2002. Her professional experience includes a visiting professor position at Imperial college, London, UK in 2018, a research faculty position at Carnegie Mellon University, SEI in 2002-2005 and consulting at Bell Labs, Lucent Technologies at the Computing Sciences Research in 2000-2001. Prof. Sharygina directs the USI Formal Verification and Security group whose research deals with improving the program development process through formal methods of specification and verification. Prof. Sharygina´s interests lie in software and hardware verification, temporal logics, model checking, SAT/SMT methods, and concurrent and distributed computing. Prof. Sharygina´s current focus is on applying automated formal methods to problems in computer security, electronic design automation, and program analysis. Prof. Sharygina is the recipient of various awards among which are the ACM recognition of service award and CMU Technical Excellence awards. Prof. Sharygina´s research has been funded by multiple grants from the Swiss National Foundation, EU Research and Innovation programs, EU cooperation in science and technology projects, Hasler Foundation and TASSO career awards. Prof. Sharygina has authored more than 150 research papers in areas of formal verification, and system design. She served on program committees of various major conferences in the field of computer-aided verification (e.g., CAV, TACAS, FMCAD, SPIN), given keynote and invited presentations, and co-chaired highly competitive international conferences and symposia such as FMCAD 2010 and CAV 2013.</bio>
          <homepage_url>https://www.inf.usi.ch/faculty/sharygina/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/natashasharygina/9f9a75af-6af0-4d73-ab0c-c440c28bdb5f/small.jpg</picture_url>
          <person_id>natashasharygina</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8070343f-e9f1-42f0-b94a-20fbd02c6d0e</subevent_id>
    <title>SAS: 1</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/18</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>d4212569-60b3-4c6a-912c-db565d53e08c</slot_id>
      <title>Session: SAS - 1</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>07:00</start_time>
      <end_time>08:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Cousot</last_name>
          <affiliation>New York University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/patrickcousot/42f5b16b-b574-4d75-a3b1-902508060f2a/small.jpg</picture_url>
          <person_id>patrickcousot</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2bad46cf-da0e-4a38-affd-cdc6d07704ba</slot_id>
      <event_id>ae38a637-3b97-4277-a496-2c1f2d2c6a6b</event_id>
      <title>Cost Analysis of Smart Contracts via Parametric Resource Analysis</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>07:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Hermenegildo</last_name>
          <affiliation>IMDEA Software Institute and T.U. of Madrid</affiliation>
          <bio>Manuel Hermenegildo is Distinguished Professor at (and was the Founding Director of) the IMDEA Software Institute. He is also full Prof. of Computer Science at the Tech. U. of Madrid, UPM. Previously he held an Endowed Chair in Information Science and Technology at the U. of New Mexico. He was also project leader at the MCC research center and Adjunct Associate Prof. at the CS Department of the U. of Texas, both in Austin, Texas. See his home page for more information. 
Research interests: Energy-Aware Computing, Resource / non-functional property analysis, verification, and control; Global Program Analysis, Optimization, Verification, Debugging; Abstract Interpretation; Partial Evaluation; Parallelism and Parallelizing Compilers; Constraint/Logic/Functional Programming Theory and Implementation, Abstract Machines; Automatic Documentation Tools, Execution Visualization; Sequential and Parallel Computer Architecture.</bio>
          <homepage_url>http://cliplab.org/herme</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelhermengildo/9ad5b1a1-5b09-4700-a372-66f4683bb674/small.jpg</picture_url>
          <person_id>manuelhermengildo</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ca939b92-d7ad-4a8d-af82-0766061ad965</slot_id>
      <event_id>96776028-772c-4c12-bdda-eb5721127c2c</event_id>
      <title>A Library Modeling Language for the Static Analysis of C Programs</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>07:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>08:00</end_time>
      <description>We present a specification language aiming at soundly modeling unavailable functions in a static analyzer for C by abstract interpretation. It takes inspiration from Behavioral Interface Specification Languages popular in deductive verification, notably Frama-C’s ACSL, as we annotate function prototypes with pre and post-conditions expressed concisely in a first-order logic, but with key differences. Firstly, the specification aims at replacing a function implementation in a safety analysis, not verifying its functional correctness. Secondly, we do not rely on theorem provers; instead, specifications are interpreted at function calls by our abstract interpreter. We implemented the language into Mopsa, a static analyzer designed to easily reuse abstract domains across widely different languages (such as C and Python). We show how its design helped us support a logic-based language with minimal effort. Notably, it was sufficient to add only a handful transfer functions (including very selective support for quantifiers) to achieve a sound and precise analysis. We modeled a large part of the GNU C library and C execution environment in our language, including the manipulation of unbounded strings, file descriptors, and programs with an unbounded number of symbolic command-line parameters, which allows verifying programs in a realistic setting. We report on the analysis of C programs from the Juliet benchmarks and Coreutils.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abdelraouf</first_name>
          <last_name>Ouadjaout</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~ouadjaout/</homepage_url>
          <person_id>abdelraoufouadjaout</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Miné</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~mine/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/antoinemine/77e18473-3b05-4bec-8b27-3e073a24fb34/small.jpg</picture_url>
          <person_id>antoinemine</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e7e78624-0128-48c6-9995-52dbadf83238</subevent_id>
    <title>SAS: 2</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/18</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>d04d25bd-9163-4e4a-aed0-fd381eea73ed</slot_id>
      <title>Session: SAS - 2</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Flatt</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>Matthew Flatt is a professor in the School of Computing at the University of Utah, where he works on extensible programming languages, runtime systems, and applications of functional programming. He is one of the developers of the Racket programming language. He received his PhD from Rice University in 1999.</bio>
          <homepage_url>http://www.cs.utah.edu/~mflatt/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthewflatt/b4995a2a-f1be-406b-ac9b-fcd5984c1c31/small.jpg</picture_url>
          <person_id>matthewflatt</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Pichardie</last_name>
          <affiliation>Univ Rennes, ENS Rennes, IRISA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.irisa.fr/celtique/pichardie/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidpichardie/b0f30e9b-c1d3-4e4f-9923-4cf150989f86/small.jpg</picture_url>
          <person_id>davidpichardie</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2b30c6b3-ab33-4d2a-a456-1b42d2d22811</slot_id>
      <event_id>a314d207-12a7-4384-9f2a-43bf0cacd948</event_id>
      <title>Static Resource Analysis at Scale</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>11:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Ezgi</first_name>
          <last_name>Çiçek</last_name>
          <affiliation>Facebook London</affiliation>
          <bio>I have obtained my PhD in Programming Languages at MPI-SWS (Max Planck Institute for Software Systems, Saarbrücken, Germany) and Saarland University in January 2018. I was advised by Deepak Garg. I am currently a Software Engineer at Facebook’s Static Analysis team, Infer. Nowadays, I am working on a static analysis tool for detecting performance regressions at diff time.</bio>
          <homepage_url>https://ezgicicek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ezgicicek/fd8cd7b8-388d-46de-960d-2e5912ceae85/small.jpg</picture_url>
          <person_id>ezgicicek</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9a9c5487-bf59-4b3d-8001-7775ee2700d7</slot_id>
      <event_id>9dacd93d-13cf-4a2c-9a12-ef5b3d814e72</event_id>
      <title>Croquet: A Unique Collaboration Architecture (Keynote)</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>12:20</end_time>
      <description>The next generation of our connected world calls for a low-latency, low-bandwidth, low-development-effort platform for synchronized interactions. The platform must also enforce privacy from the ground up, in particular in anticipation of an always-on Augmented Reality future. 
In traditional synchronization approaches, computations are performed on a server and results are continuously distributed to clients. Croquet moves all computation to the clients. A lightweight “reflector” server directs the clients to advance time in sync, and ensures that any external event is incorporated by all clients at exactly the same point in the computation, leading to synchronized, bit-identical state. All data is end-to-end encrypted by the clients; the server stores and distributes data, but can never peek inside. 
Croquet’s programming model separates the synchronized computation of “models” from individually computed “views”. This means the world is the same for everyone, but the display of the world can be tailored to each device and user. Models and views communicate using a publish/subscribe mechanism that routes certain events via the reflector. This model/view separation and pub/sub communication is a major departure from the previous, proxy-based Smalltalk implementation of Croquet. It retains the ability for live programming by atomically incorporating new code. 
Vanessa is the chief architect of the current JavaScript-based implementation. She will give an overview of the system, highlight challenges in designing the API, and explore the far-reaching implications of the shift from server to client.</description>
      <persons>
        <person>
          <role>Presenter</role>
          <sort_key>1</sort_key>
          <first_name>Vanessa</first_name>
          <last_name>Freudenberg</last_name>
          <affiliation>Croquet Corp</affiliation>
          <bio>Vanessa is a co-founder of Croquet Corp and the principal engineer of the current Teatime client/server architecture underlying Croquet. She has been developing interactive systems for more than 20 years with a focus on live, self-supporting systems (including Squeak Etoys, Scratch, Lively, Smalltalk VMs).</bio>
          <homepage_url>https://www.croquet.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vanessafreudenberg/846610a3-d712-4599-95cb-b259a0d51d2b/small.jpg</picture_url>
          <person_id>vanessafreudenberg</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>406657d0-5f8b-4a94-8172-d17fc3bf2b2d</subevent_id>
    <title>SAS: 5</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/18</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>f08b7def-94a1-416c-b258-358471b66c99</slot_id>
      <title>Session: SAS - 5</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Cousot</last_name>
          <affiliation>New York University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/patrickcousot/42f5b16b-b574-4d75-a3b1-902508060f2a/small.jpg</picture_url>
          <person_id>patrickcousot</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Sukyoung</first_name>
          <last_name>Ryu</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>sukyoungryu1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1b0c8169-e5f5-4301-af7b-4d1acc1464b0</slot_id>
      <event_id>5013f5f6-0c92-406c-b516-126cc1c9f16c</event_id>
      <title>Pricing Python Parallelism: A Dynamic Language Cost Model for Heterogeneous Platforms</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>18:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>18:20</end_time>
      <description>Execution times may be reduced by offloading parallel loop nests to a GPU. Auto-parallelizing compilers are common for static languages, often using a cost model to determine when the GPU execution speed will outweigh the offload overheads. Nowadays scientific software is increasingly written in dynamic languages and would benefit from compute accelerators. The ALPyNA framework analyses moderately complex Python loop nests and automatically JIT compiles code for heterogeneous CPU and GPU architectures. 
We present the first analytical cost model for auto-parallelizing loop nests in a dynamic language on heterogeneous architectures. Predicting execution time in a language like Python is extremely challenging, since aspects like the element types, size of the iteration space, and amenability to parallelization can only be determined at runtime. Hence the cost model must be both staged, to combine compile and run-time information, and lightweight to minimize runtime overhead. GPU execution time prediction must account for factors like data transfer, block-structured execution, and starvation. 
We show that a comparatively simple, staged analytical model can accurately determine during execution when it is profitable to offload a loop nest. We evaluate our model on three heterogeneous platforms across 360 experiments with 12 loop-intensive Python benchmark programs. The results show small misprediction intervals and a mean slowdown of just 13.6%, relative to the optimal (oracular) offload strategy.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dejice</first_name>
          <last_name>Jacob</last_name>
          <affiliation>University of Glasgow, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~jacobd</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/dejicejacob/3f7c1cd4-c004-439f-a953-1389a8b68578/small.jpg</picture_url>
          <person_id>dejicejacob</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Phil</first_name>
          <last_name>Trinder</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~trinder/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philtrinder/fa2ffb07-cddf-4a8d-a52a-ca1aaad1273b/small.jpg</picture_url>
          <person_id>philtrinder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Singer</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~jsinger</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeremysinger/14db1542-37ba-4e0e-b338-e3a952991f1a/small.jpg</picture_url>
          <person_id>jeremysinger</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3bf82d53-7ac3-4551-a63a-7fa1666ee629</slot_id>
      <event_id>890ea906-b119-4828-8f45-d132f9c38082</event_id>
      <title>Abstract Neural Networks</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>17:20</end_time>
      <description>Deep Neural Networks (DNNs) are rapidly being applied to safety-critical domains such as drone and airplane control, motivating techniques for verifying the safety of their behavior. Unfortunately, DNN verification is NP-hard, with current algorithms slowing exponentially with the number of nodes in the DNN. This paper introduces the notion of Abstract Neural Networks (ANNs), which can be used to soundly overapproximate DNNs while using fewer nodes. An ANN is like a DNN except weight matrices are replaced by values in a given abstract domain. We present a framework parameterized by the abstract domain and activation functions used in the DNN that can be used to construct a corresponding ANN. We present necessary and sufficient conditions on the DNN activation functions for the constructed ANN to soundly over-approximate the given DNN. Prior work on DNN abstraction was restricted to the interval domain and ReLU activation function. Our framework can be instantiated with other abstract domains such as octagons and polyhedra, as well as other activation functions such as Leaky ReLU, Sigmoid, and Hyperbolic Tangent.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Sotoudeh</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://masot.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthewsotoudeh/32b819f5-05ef-4b0a-8a19-d59eed661278/small.jpg</picture_url>
          <person_id>matthewsotoudeh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aditya V.</first_name>
          <last_name>Thakur</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://thakur.cs.ucdavis.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adityavthakur/89eb0287-7273-4261-b8a5-47ccfc8799b0/small.jpg</picture_url>
          <person_id>adityavthakur</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>dbdc6a65-7df8-4ce3-9a5f-d947e28a4a75</slot_id>
      <event_id>179704f8-cb35-4d44-8ef9-ea437c436204</event_id>
      <title>Amalgamating Different JIT Compilations in a Meta-tracing JIT Compiler Framework</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>17:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>17:40</end_time>
      <description>Most virtual machines employ just-in-time (JIT) compilers to achieve high-performance. Trace-based compilation and method-based compilation are two major compilation strategies in JIT compilers. In general, the former excels in compiling programs with more in-depth method calls and more dynamic branches, while the latter is suitable for a wide range of programs. Some previous studies have suggested that each strategy has its advantages and disadvantages, and there is no clear winner. 
In this paper, we present a new approach, namely, the meta-hybrid JIT compilation strategy. It combines trace-based and method-based compilations to utilize the advantages of both strategies. Moreover, it is realized as a meta JIT compiler framework; thus, we can generate a VM with a hybrid JIT compiler that can apply different program parts by merely writing an interpreter with our framework. 
We chose to extend a meta-tracing JIT compiler and supported the two compilations on it. As a prototype, we implemented a simple meta-tracing JIT compiler framework called BacCaml based on the MinCaml compiler by following RPython’s architecture. 
We evaluated its performance by creating a small functional programming language with BacCaml and running microbenchmark programs. Furthermore, we performed a synthetic experiment to confirm that there are programs that run faster by hybrid compilation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yusuke</first_name>
          <last_name>Izawa</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://3tty0n.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yusukeizawa/2d1131a1-4abb-4ade-9761-e3d2648bd9f5/small.jpg</picture_url>
          <person_id>yusukeizawa</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hidehiko</first_name>
          <last_name>Masuhara</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>Hidehiko Masuhara is a Professor of Mathematical and Computing Science, Tokyo Institute of Technology since April 2013. He received his B.S., M.S., and Ph.D. in Computer Science from Department of Information Science, University of Tokyo in 1992, 1994, and 1999, respectively, and served as an assistant professor, lecturer, and associate professor at Graphics and Computer Science, Graduate School of Arts and Sciences, University of Tokyo from 1995 until 2013.</bio>
          <homepage_url>http://prg.is.titech.ac.jp/people/masuhara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hidehikomasuhara/3ea94269-6fb5-4c6d-8d6f-0435717377d6/small.jpg</picture_url>
          <person_id>hidehikomasuhara</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fcfa6794-c3c5-4a25-92f8-6a7eb65ca070</slot_id>
      <event_id>5360324a-7234-4b20-95d8-80639f65ad7a</event_id>
      <title>Probabilistic Lipschitz Analysis of Neural Networks</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>17:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>18:00</end_time>
      <description>We are interested in algorithmically proving the robustness of neural networks. Notions of robustness have been discussed in the literature; we are interested in probabilistic notions of robustness that assume it feasible to construct a statistical model of the process generating the inputs of a neural network. We find this a reasonable assumption given the rapid advances in algorithms for learning generative models of data. A neural network f is then defined to be probabilistically robust if, for a randomly generated pair of inputs, f is likely to demonstrate k-Lipschitzness, i.e., the distance between the outputs computed by $f$ is upper-bounded by the k-th multiple of the distance between the pair of inputs. We name this property, probabilistic Lipschitzness. 
We model generative models and neural networks, together, as programs in a simple, first-order, imperative, probabilistic programming language, pcat. Inspired by a large body of existing literature, we define a denotational semantics for this language. Then we develop a sound local Lipschitzness analysis for cat, a non-probabilistic sublanguage of pcat. This analysis can compute an upper bound of the ``Lipschitzness'' of a neural network in a bounded region of the input set. We next present a provably correct algorithm, PROLIP, that analyzes the behavior of a neural network in a user-specified box-shaped input region and computes - (i) lower bounds on the probabilistic mass of such a region with respect to the generative model, (ii) upper bounds on the Lipschitz constant of the neural network in this region, with the help of the local Lipschitzness analysis. Finally, we present a sketch of a proof-search algorithm that uses PROLIP as a primitive for finding proofs of probabilistic Lipschitzness. We implement the PROLIP algorithm and empirically evaluate the computational complexity of PROLIP.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ravi</first_name>
          <last_name>Mangal</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cc.gatech.edu/~rmangal3/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ravimangal/a3129793-a42b-47f4-8195-79800685503e/small.jpg</picture_url>
          <person_id>ravimangal</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kartik</first_name>
          <last_name>Sarangmath</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>kartiksarangmath</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aditya</first_name>
          <last_name>Nori</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>adityanori</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Alessandro</first_name>
          <last_name>Orso</last_name>
          <affiliation>Georgia Tech</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cc.gatech.edu/~orso/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alessandroorso/5f7dffa8-54ca-4f1e-84f0-1f1a9affbf55/small.jpg</picture_url>
          <person_id>alessandroorso</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5b0a3b73-4050-45fe-afd4-829fdfd9f123</subevent_id>
    <title>SAS: 7</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>489b1b55-2802-4675-ad3e-196e0cc611a7</slot_id>
      <title>Session: SAS - 7</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Tim</first_name>
          <last_name>Felgentreff</last_name>
          <affiliation>Oracle Labs, Potsdam</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/timfelgentreff/1cdb8c05-2513-4508-ab46-dcae9a44d4c4/small.jpg</picture_url>
          <person_id>timfelgentreff</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Kedar</first_name>
          <last_name>Namjoshi</last_name>
          <affiliation>Nokia Bell Labs</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kedar-namjoshi.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/kedarnamjoshi/1a827d58-b3c1-42d8-a822-1cdd6c72bc74/small.jpg</picture_url>
          <person_id>kedarnamjoshi</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>344d4621-55c6-4de3-a424-16f77e015089</slot_id>
      <event_id>e3e14325-c529-4426-a059-6ef122bc4c43</event_id>
      <title>Stratified Guarded First-order Transition Systems</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>12:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christian</first_name>
          <last_name>Müller</last_name>
          <affiliation>Technical University of Munich</affiliation>
          <bio>undefined</bio>
          <person_id>christianmuller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Helmut</first_name>
          <last_name>Seidl</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www2.in.tum.de/~seidl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/helmutseidl/2dcd593b-82c2-48ee-b042-87ebd49b4379/small.jpg</picture_url>
          <person_id>helmutseidl</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6a987258-4ef2-489c-bdf3-ac4ae32d38c3</slot_id>
      <event_id>d282d18e-5f62-43fb-b68c-eb3bf99afa68</event_id>
      <title>Sampling Optimized Code for Type Feedback</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>12:20</end_time>
      <description>To efficiently execute dynamically typed languages, many language implementations have adopted a two-tier architecture. The first tier aims for low-latency startup times and collects dynamic profiles, such as the dynamic types of variables. The second tier provides high-throughput using an optimizing compiler that specializes code to the recorded type information. If the program behavior changes to the point that not previously seen types occur in specialized code, that specialized code becomes invalid, it is deoptimized, and control is transferred back to the first tier execution engine which will start specializing anew. However, if the program behavior becomes more specific, for instance, if a polymorphic variable becomes monomorphic, nothing changes. Once the program is running optimized code, there are no means to notice that an opportunity for optimization has been missed. 
We propose to employ a sampling-based profiler to monitor native code without any instrumentation. The absence of instrumentation means that when the profiler is not active, no overhead is incurred. We present an implementation is in the context of the \v{R} just-in-time, optimizing compiler for the R language. Based on the sampled profiles, we are able to detect when the native code produced by \v{R} is specialized for stale type feedback and recompile it to more type-specific code. We show that sampling adds an overhead of less than 3% in most cases and up to 9% in few cases and that it reliably detects stale type feedback within milliseconds.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Flückiger</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.o1o.ch</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/olivierfluckiger/6051271d-0eac-48f3-b931-bff878bbce61/small.jpg</picture_url>
          <person_id>olivierfluckiger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Wälchli</last_name>
          <affiliation>University of Bern</affiliation>
          <bio>undefined</bio>
          <person_id>andreaswalchli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sebastián</first_name>
          <last_name>Krynski</last_name>
          <affiliation>Czech Technical University, National University of Quilmes</affiliation>
          <bio>undefined</bio>
          <person_id>sebastiankrynski</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University, USA / Czech Technical University, Czechia</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ccb940ec-6584-4e84-9690-fc6ebce19a17</slot_id>
      <event_id>76914a82-f0e1-4d78-8093-7ea5ce50bb37</event_id>
      <title>DelayRepay: Delayed Execution for Kernel Fusion in Python</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>11:40</end_time>
      <description>Python is a popular, dynamic language for data science and scientific computing. To ensure efficiency, significant numerical libraries are implemented in static native languages. However, performance suffers when switching between native and non-native code, especially if data has to be converted between native arrays and Python data structures. As GPU accelerators are increasingly used, this problem becomes particularly acute. Data and control has to be repeatedly transferred between the accelerator and the host. 
In this paper, we present DelayRepay, a delayed execution framework for numeric Python programs. It avoids excessive switching and data transfer by using lazy evaluation and kernel fusion. Using DelayRepay, operations on NumPy arrays are executed lazily, allowing multiple calls to accelerator kernels to be fused together dynamically. DelayRepay is available as a drop-in replacement for existing Python libraries. This approach enables significant performance improvement over the state-of-the-art and is invisible to the application programmer. We show that our approach provides a maximum $377\times$ speedup over NumPy - a 409% increase over the state of the art.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John Magnus</first_name>
          <last_name>Morton</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>johnmagnusmorton</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kuba</first_name>
          <last_name>Kaszyk</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>kubakaszyk</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Lu</first_name>
          <last_name>Li</last_name>
          <affiliation>Linköping University</affiliation>
          <bio>undefined</bio>
          <person_id>luli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jiawen</first_name>
          <last_name>Sun</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>jiawensun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Christophe</first_name>
          <last_name>Dubach</last_name>
          <affiliation>McGill University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/cdubach/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/christophedubach/dc7b0040-a3ef-46dd-b4f3-0f0ea3b2b026/small.jpg</picture_url>
          <person_id>christophedubach</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Michel</first_name>
          <last_name>Steuwer</last_name>
          <affiliation>The University of Edinburgh</affiliation>
          <bio>I am a lecturer (assistant professor) in compilers and runtime systems in the School of Informatics at the University of Edinburgh in Scotland. I am a member of the Compiler and Architecture Design Group (CArD), the Institute for Computing Systems Architecture (ICSA), and a visiting member of staff at the School of Computing Science at the University of Glasgow. 
Before joining the faculty in Edinburgh I was a lecturer in the School of Computing Science at the University of Glasgow. Prior to that, I was a postdoctoral researcher at the School of Informatics at the University of Edinburgh. I received my PhD from the University of Münster in Germany. 
I am interested in all aspects of parallel programming. Particular research interests of mine include performance portability, structured parallel programming, heterogeneous and GPU computing, and novel compilation techniques for high-level languages.</bio>
          <homepage_url>http://michel.steuwer.info/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michelsteuwer/5a465be6-d235-472c-8ace-4894a70bb742/small.jpg</picture_url>
          <person_id>michelsteuwer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Murray</first_name>
          <last_name>Cole</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <person_id>murraycole</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Michael</first_name>
          <last_name>O'Boyle</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>michaeloboyle</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ed5fd028-b2c5-432f-8023-330cd4bda01b</slot_id>
      <event_id>932e180e-dfa8-48ee-bea1-99cedf469770</event_id>
      <title>Interprocedural Shape Analysis Using Separation Logic-based Transformer Summaries</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>11:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hugo</first_name>
          <last_name>Illous</last_name>
          <affiliation>CEA &amp; INRIA / ENS Paris</affiliation>
          <bio>undefined</bio>
          <person_id>hugoillous</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthieu</first_name>
          <last_name>Lemerre</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>matthieulemerre</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xavier</first_name>
          <last_name>Rival</last_name>
          <affiliation>INRIA/CNRS/ENS Paris</affiliation>
          <bio>Xavier Rival is a Senior Research Scientist (Directeur de Recherche) at INRIA Paris. His research interest focus on abstract interpretation and software verification by static analysis. He is mainly working on symbolic abstractions (trace partitionning abstraction, shape analysis, separation logic and memory abstract domains). He has been involved in the design, implementation and transfer of the Astrée analyser, a static analyser able to verify safety properties on industrial size safety critical softwares. He is currently the PI of the MemCAD ERC Starting Grant, aiming at the design of a library of abstract domains to describe memory states containing a wide range of complex data structures. He is also the Head of the ANTIQUE INRIA group, located at ENS Paris, and Professeur Chargé de Cours at Ecole Polytechnique.</bio>
          <homepage_url>http://www.di.ens.fr/~rival/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xavierrival/036511d0-47a1-4db2-97df-0bf5da1a2c8d/small.jpg</picture_url>
          <person_id>xavierrival</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0ef7cbf0-f06f-45b9-9a9b-b9f38270ce9a</subevent_id>
    <title>SAS: 8</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/20</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>87ddc621-e199-4058-9b18-4f86ab08813f</slot_id>
      <title>Session: SAS - 8</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Helmut</first_name>
          <last_name>Seidl</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www2.in.tum.de/~seidl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/helmutseidl/2dcd593b-82c2-48ee-b042-87ebd49b4379/small.jpg</picture_url>
          <person_id>helmutseidl</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>005f57fd-94b4-4d26-a09e-e928a5c2ecbc</slot_id>
      <event_id>43e38930-e679-4381-b5e9-f606f58d5550</event_id>
      <title>Formal framework for reasoning about the precision of dynamic analysis</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>01:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mila</first_name>
          <last_name>Dalla Preda</last_name>
          <affiliation>University of Verona, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://profs.sci.univr.it/~dallapre</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/miladallapreda/bfe198ed-1dee-40dd-a639-ad6951f36888/small.jpg</picture_url>
          <person_id>miladallapreda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roberto</first_name>
          <last_name>Giacobazzi</last_name>
          <affiliation>University of Verona and IMDEA Software Institute</affiliation>
          <bio>Roberto Giacobazzi received the Laurea degree in Computer Science in 1988 from the University of Pisa, and in 1993 he received the Ph.D. in Computer Science from the same university, with a Ph.D. thesis on Semantic aspects of logic program analysis, under the supervision of Prof. Giorgio Levi. From 1993 to 1995 he had a Post Doctoral Research position at Laboratoire d’Informatique (LIX), Ecole Polytechnique (Paris) in the equipe Cousot. From 1995 to 1998 he was (tenured) Assistant Professor in Computer Science at the University of Pisa. From May 2000 until now he is Full Professor in Computer Science at the University of Verona. The research interests of Roberto Giacobazzi include abstract interpretation, static program analysis, semantics of programming languages, program verification, abstract model-checking, program transformation and optimization, digital asset protection, code obfuscation, malware detection, software watermarking, computability and lattice theory. He has been Program Chair of SAS, VMCAI, of workshops in programming languages and language based security, and General Chair of ACM POPL2013. From 2006 to 2012 he has been Dean of the College of Science of the University of Verona. He works at the University of Verona and at IMDEA Software Institute.</bio>
          <homepage_url>http://profs.sci.univr.it/~giaco/index.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/robertogiacobazzi/3a292abe-6f69-4d5d-bfa3-305417b39cba/small.jpg</picture_url>
          <person_id>robertogiacobazzi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Niccolò</first_name>
          <last_name>Marastoni</last_name>
          <affiliation>University of Verona</affiliation>
          <bio>undefined</bio>
          <person_id>niccolomarastoni</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4d7b415f-b0f8-4d98-95d2-57a5ab51e9bb</slot_id>
      <event_id>3faff150-5135-4eb3-affb-a5bfe3c3fe17</event_id>
      <title>Framework-Aware Debugging with Stack Tailoring</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>02:20</end_time>
      <description>Debugging applications that execute within a framework is not always easy: the call-stack offered to developers is often a mix-up of stack frames that belong to different frameworks, introducing an unnecessary noise that prevents developers from focusing on the debugging task. Moreover, relevant application code is not always available in the call-stack because it may have already returned, or is available in another thread. In such cases, manually gathering all relevant information from these different sources is not only cumbersome but also costly. 
In this paper we introduce Sarto, a call-stack instrumentation layer that allows developers to tailor the stack to make debugging framework-aware. The goal is to improve the quality and amount information present in the call-stack to reduce debugging time without impacting the execution time. Sarto proposes a set of six stack operations that combined hide irrelevant information, introduce missing information, and relate dispersed debugging sources before this is fed to the debugger. 
We validate Sarto by applying it to four application cases using inherently different frameworks: unit testing, web server, remote promises and big data processing. We showcase our experiences in using Sarto in the different frameworks, and perform some performance benchmarks to demonstrate that Sarto does not generate noticeable overhead when instrumenting a call-stack. We also show that our solution reduces by half the amount of data stored to debug similar exceptions happening in a parallel setup.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matteo</first_name>
          <last_name>Marra</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>I am a pre-doctoral researcher at the Vrije Universiteit Brussel (Belgium). After completing my bachelor studies in Italy (Università degli studi di Bologna), I moved to Brussels for a master at the Vrije Universiteit Brussel, in the Software Languages Lab, and decided to start a PhD under the guide of prof. Elisa Gonzalez Boix. I also cooperate with the RMoD research group at INRIA Lille Nord-Europe. 
My research focuses on debugging concurrent and parallel applications, particularly Big Data (or data intensive) applications.</bio>
          <homepage_url>https://soft.vub.ac.be/~mmarra</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matteomarra/71e5312b-940b-4349-afaf-fa0a934b2c49/small.jpg</picture_url>
          <person_id>matteomarra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guillermo</first_name>
          <last_name>Polito</last_name>
          <affiliation>Univ. Lille, CNRS, Centrale Lille, Inria, UMR 9189 - CRIStAL - Centre de Recherche en Informatique Signal et Automatique de Lille</affiliation>
          <bio>Guille Polito is research engineer at the CRIStAL laboratory in the university of Lille, working in tight relation with the RMoD team. Guille’s main research interests are programming language development, programming tools, modular systems, and maintenance of large software systems. 
He currently works on techniques to develop modular systems and languages, and new development tools. Guille works in the development of the open source Pharo programming language and environment since 2010, and he is a member of its technical board since 2018.</bio>
          <homepage_url>https://guillep.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guillermopolito/fb027991-a37d-4375-8c71-1858ce478695/small.jpg</picture_url>
          <person_id>guillermopolito</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Elisa</first_name>
          <last_name>Gonzalez Boix</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~egonzale</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elisagonzalezboix/8e8a61c4-366e-49b5-a861-7dfbc98ee129/small.jpg</picture_url>
          <person_id>elisagonzalezboix</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>98c89d91-3a9c-4b65-ae75-d270c6128833</slot_id>
      <event_id>4fd50d6f-63a1-4bda-a578-b90810c55019</event_id>
      <title>Farkas-Based Tree Interpolation</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>01:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sepideh</first_name>
          <last_name>Asadi</last_name>
          <affiliation>PhD Student</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.inf.usi.ch/phd/asadi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sepidehasadi/68b2e971-e6c1-495a-be27-6eeedea8173c/small.jpg</picture_url>
          <person_id>sepidehasadi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin</first_name>
          <last_name>Blicha</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>martinblicha</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Antti</first_name>
          <last_name>Hyvärinen</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>anttihyvarinen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Grigory</first_name>
          <last_name>Fedyukovich</last_name>
          <affiliation>Florida State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.fsu.edu/~grigory</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/grigoryfedyukovich/902a9cea-9078-42f4-9fb4-19a433865738/small.jpg</picture_url>
          <person_id>grigoryfedyukovich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Natasha</first_name>
          <last_name>Sharygina</last_name>
          <affiliation>USI Lugano, Switzerland</affiliation>
          <bio>Natasha Sharygina is a Full Professor of Computer Science at the University of Lugano, Switzerland. Prof. Sharygina received a Ph.D. degree from the University of Texas at Austin, USA in 2002. Her professional experience includes a visiting professor position at Imperial college, London, UK in 2018, a research faculty position at Carnegie Mellon University, SEI in 2002-2005 and consulting at Bell Labs, Lucent Technologies at the Computing Sciences Research in 2000-2001. Prof. Sharygina directs the USI Formal Verification and Security group whose research deals with improving the program development process through formal methods of specification and verification. Prof. Sharygina´s interests lie in software and hardware verification, temporal logics, model checking, SAT/SMT methods, and concurrent and distributed computing. Prof. Sharygina´s current focus is on applying automated formal methods to problems in computer security, electronic design automation, and program analysis. Prof. Sharygina is the recipient of various awards among which are the ACM recognition of service award and CMU Technical Excellence awards. Prof. Sharygina´s research has been funded by multiple grants from the Swiss National Foundation, EU Research and Innovation programs, EU cooperation in science and technology projects, Hasler Foundation and TASSO career awards. Prof. Sharygina has authored more than 150 research papers in areas of formal verification, and system design. She served on program committees of various major conferences in the field of computer-aided verification (e.g., CAV, TACAS, FMCAD, SPIN), given keynote and invited presentations, and co-chaired highly competitive international conferences and symposia such as FMCAD 2010 and CAV 2013.</bio>
          <homepage_url>https://www.inf.usi.ch/faculty/sharygina/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/natashasharygina/9f9a75af-6af0-4d73-ab0c-c440c28bdb5f/small.jpg</picture_url>
          <person_id>natashasharygina</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ced79737-c6d5-4061-a938-8ca960644a52</subevent_id>
    <title>SAS: 1</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/18</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>3f8e8aff-c9cd-49b5-b5a8-168af79d0f09</slot_id>
      <title>Session: SAS - 1</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>19:00</start_time>
      <end_time>20:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Bor-Yuh Evan</first_name>
          <last_name>Chang</last_name>
          <affiliation>University of Colorado Boulder &amp; Amazon</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.colorado.edu/~bec/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/boryuhevanchang/0cbe7e94-aaf8-458b-9670-3892350bc209/small.jpg</picture_url>
          <person_id>boryuhevanchang</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c022ecf0-309b-49a6-860a-fa41b7479b8e</slot_id>
      <event_id>96776028-772c-4c12-bdda-eb5721127c2c</event_id>
      <title>A Library Modeling Language for the Static Analysis of C Programs</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>19:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>20:00</end_time>
      <description>We present a specification language aiming at soundly modeling unavailable functions in a static analyzer for C by abstract interpretation. It takes inspiration from Behavioral Interface Specification Languages popular in deductive verification, notably Frama-C’s ACSL, as we annotate function prototypes with pre and post-conditions expressed concisely in a first-order logic, but with key differences. Firstly, the specification aims at replacing a function implementation in a safety analysis, not verifying its functional correctness. Secondly, we do not rely on theorem provers; instead, specifications are interpreted at function calls by our abstract interpreter. We implemented the language into Mopsa, a static analyzer designed to easily reuse abstract domains across widely different languages (such as C and Python). We show how its design helped us support a logic-based language with minimal effort. Notably, it was sufficient to add only a handful transfer functions (including very selective support for quantifiers) to achieve a sound and precise analysis. We modeled a large part of the GNU C library and C execution environment in our language, including the manipulation of unbounded strings, file descriptors, and programs with an unbounded number of symbolic command-line parameters, which allows verifying programs in a realistic setting. We report on the analysis of C programs from the Juliet benchmarks and Coreutils.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abdelraouf</first_name>
          <last_name>Ouadjaout</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~ouadjaout/</homepage_url>
          <person_id>abdelraoufouadjaout</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Miné</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~mine/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/antoinemine/77e18473-3b05-4bec-8b27-3e073a24fb34/small.jpg</picture_url>
          <person_id>antoinemine</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ecba2904-73db-4b85-966d-5c9a3adf8ec5</slot_id>
      <event_id>ae38a637-3b97-4277-a496-2c1f2d2c6a6b</event_id>
      <title>Cost Analysis of Smart Contracts via Parametric Resource Analysis</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>19:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Hermenegildo</last_name>
          <affiliation>IMDEA Software Institute and T.U. of Madrid</affiliation>
          <bio>Manuel Hermenegildo is Distinguished Professor at (and was the Founding Director of) the IMDEA Software Institute. He is also full Prof. of Computer Science at the Tech. U. of Madrid, UPM. Previously he held an Endowed Chair in Information Science and Technology at the U. of New Mexico. He was also project leader at the MCC research center and Adjunct Associate Prof. at the CS Department of the U. of Texas, both in Austin, Texas. See his home page for more information. 
Research interests: Energy-Aware Computing, Resource / non-functional property analysis, verification, and control; Global Program Analysis, Optimization, Verification, Debugging; Abstract Interpretation; Partial Evaluation; Parallelism and Parallelizing Compilers; Constraint/Logic/Functional Programming Theory and Implementation, Abstract Machines; Automatic Documentation Tools, Execution Visualization; Sequential and Parallel Computer Architecture.</bio>
          <homepage_url>http://cliplab.org/herme</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelhermengildo/9ad5b1a1-5b09-4700-a372-66f4683bb674/small.jpg</picture_url>
          <person_id>manuelhermengildo</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0843b270-3f27-4a54-ba5e-7c1449cc209e</subevent_id>
    <title>SAS: 9</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/20</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>01c81f7c-64ed-49e2-9ba3-aa2916017efa</slot_id>
      <title>Session: SAS - 9</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Jerome</first_name>
          <last_name>Feret</last_name>
          <affiliation>INRIA Paris</affiliation>
          <bio>Jérôme Feret defended a PhD at the computer science laboratory of École normale superieure in 2005 working with Patrick Cousot on the static analysis of networks with dynamical interaction topologies. In 2007-2008, he did a postdoc at Harvard Medical School working with Walter Fontana on model reduction for intracellular signaling pathways. In 2008, he got a junior researcher position (CR2, then CR1 since 2011) at INRIA working in the Abstraction (now Antique) team at the computer science laboratory of École normale supérieure. 
Since 2001, he has been participating to the design of ASTRE. Since 2006, he is applying abstract interpretation theory for simplifying the combinatorial complexity of models of intracellular signaling pathways.</bio>
          <homepage_url>http://www.di.ens.fr/~feret/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeromeferet/ce9b355f-7001-4837-8b2f-f21caf0d4daf/small.jpg</picture_url>
          <person_id>jeromeferet</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>69d30a54-a0c6-4cd5-a489-888238b136c8</slot_id>
      <event_id>b673ae70-f50a-4531-b748-2fe1a22e890b</event_id>
      <title>Counterexample- and Simulation-Guided Floating-Point Loop Invariant Synthesis</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>03:20</end_time>
      <description>We present an automated procedure for synthesizing sound inductive invariants for floating-point numerical loops. Our procedure generates invariants of the form of a convex polynomial inequality that tightly bounds the values of loop variables. Such invariants are a prerequisite for reasoning about the safety and roundoff errors of floating-point programs. 
Unlike previous approaches that rely on policy iteration, linear algebra or semi-definite programming, we propose a heuristic procedure based on simulation and counterexample-guided refinement. We observe that this combination is remarkably effective and general and can handle both linear and nonlinear loop bodies, nondeterministic values as well as conditional statements. Our evaluation shows that our approach can efficiently synthesize loop invariants for existing benchmarks from literature, but that it is also able to find invariants for nonlinear loops that today’s tools cannot handle.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anastasiia</first_name>
          <last_name>Izycheva</last_name>
          <affiliation>Technical University of Munich</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/anastasiiaizycheva/049b4a5f-65b4-44c8-bc62-ba47c866094f/small.jpg</picture_url>
          <person_id>anastasiiaizycheva</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eva</first_name>
          <last_name>Darulova</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mpi-sws.org/~eva/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/evadarulova/0d98744b-ec94-4a27-b1c0-0d728d54bdb7/small.jpg</picture_url>
          <person_id>evadarulova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Helmut</first_name>
          <last_name>Seidl</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www2.in.tum.de/~seidl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/helmutseidl/2dcd593b-82c2-48ee-b042-87ebd49b4379/small.jpg</picture_url>
          <person_id>helmutseidl</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fa844ea3-09f0-4771-b77b-efdd50b3d260</slot_id>
      <event_id>826b72b5-8d2a-4c83-b0c8-2893d66b8ea5</event_id>
      <title>Predicate Abstraction and CEGAR for nuHFL(Z) Validity Checking</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>04:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Iwayama</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <person_id>naokiiwayama</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.kb.is.s.u-tokyo.ac.jp/~koba/</homepage_url>
          <person_id>naokikobayashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ryota</first_name>
          <last_name>Suzuki</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>ryotasuzuki</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Takeshi</first_name>
          <last_name>Tsukada</last_name>
          <affiliation>Chiba University, Japan</affiliation>
          <bio>undefined</bio>
          <person_id>takeshitsukada</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>92d46c4f-ce8c-4c02-a7dd-a0be0d570172</subevent_id>
    <title>SAS: 4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/18</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>6182b3f7-1cf7-4834-a423-f63788fc56ab</slot_id>
      <title>Session: SAS - 4</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Miné</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~mine/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/antoinemine/77e18473-3b05-4bec-8b27-3e073a24fb34/small.jpg</picture_url>
          <person_id>antoinemine</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Jeremy G.</first_name>
          <last_name>Siek</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>Jeremy Siek is a Professor at Indiana University Bloomington. Jeremy’s areas of research include programming language design, type systems, mechanized theorem proving using proof assistants, and optimizing compilers. Jeremy’s Ph.D. thesis explored foundations for constrained templates, aka the “concepts” proposal for C++. Prior to that, Jeremy developed the Boost Graph Library, a C++ generic library for graph algorithms and data structures. Jeremy post-doc’d at Rice University where he developed the idea of gradual typing: a type system that integrates both dynamic and static typing in the same programming language. Jeremy is currently working on several open questions regarding gradual typing. Is the polymorphic blame calculus really parametric? How should gradual typing be combined with other features such as dependent types? What is the formal criteria for gradually typed languages? Is it possible to create a high-performance implementation of a gradually-typed languages? In 2009 Jeremy received the NSF CAREER award to fund his project: “Bridging the Gap Between Prototyping and Production”. In 2010 and again in 2015, Jeremy was awarded a Distinguished Visiting Fellowship from the Scottish Informatics &amp;amp; Computer Science Alliance.</bio>
          <homepage_url>http://homes.soic.indiana.edu/jsiek/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeremysiek/4365edf9-715f-46e0-8867-4ea5fb6341ad/small.jpg</picture_url>
          <person_id>jeremysiek</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>214d03e9-fa36-4b7c-ac05-44089ceeceb4</slot_id>
      <event_id>ce3e05fe-bed4-4c6e-8f2f-3ec96e59bf13</event_id>
      <title>Dynamic Pattern Matching with Python</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>15:40</end_time>
      <description>Pattern matching allows programs both to extract specific information from complex data types, as well as to branch on the structure of data and thus apply specialized actions to different forms of data. Originally designed for strongly typed functional languages with algebraic data types, pattern matching has since been adapted for object-oriented and even dynamic languages. This paper discusses how pattern matching can be included in the dynamically typed language \emph{Python} in line with existing features that support extracting values from sequential data structures.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Kohn</last_name>
          <affiliation>University of Cambridge, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://tobiaskohn.ch/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tobiaskohn/de1722d1-b49c-4534-9f14-52a007daabf7/small.jpg</picture_url>
          <person_id>tobiaskohn</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guido</first_name>
          <last_name>van Rossum</last_name>
          <affiliation>Python Software Foundation</affiliation>
          <bio>undefined</bio>
          <person_id>guidovanrossum</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gary Brandt</first_name>
          <last_name>Bucher, II</last_name>
          <affiliation>Research Affiliates, LLC</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://brandtbucher.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/garybrandtbucherii/4d2da008-7dca-4c6f-805b-65214288ada8/small.jpg</picture_url>
          <person_id>garybrandtbucherii</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>undefined</first_name>
          <last_name>Talin</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>talin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Levkivskyi</last_name>
          <affiliation>Dropbox Ireland</affiliation>
          <bio>undefined</bio>
          <person_id>ivanlevkivskyi</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>88394186-cbb7-43fb-b7e9-773c79c6ce07</slot_id>
      <event_id>b5f8101e-f7bf-45b0-98cf-165cd7531f05</event_id>
      <title>Sound, Heuristic Type Annotation Inference for Ruby</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>16:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>16:20</end_time>
      <description>Many researchers have explored retrofitting static type systems to dynamic languages. This raises the question of how to add type annotations to code that was previously untyped. One obvious solution is type inference. However, in complex type systems, in particular those with structural types, type inference typically produces most general types that are large, hard to understand, and unnatural for programmers. To solve this problem, we introduce InferDL, a novel Ruby type inference system that infers sound and useful type annotations by incorporating heuristics that guess types. For example, we might heuristically guess that a parameter whose name ends in ``count'' is an integer. InferDL works by first running standard type inference and then applying heuristics to any positions for which standard type inference produces overly-general types. Heuristic guesses are added as constraints to the type inference problem to ensure they are consistent with the rest of the program and other heuristic guesses; inconsistent guesses are discarded. We formalized InferDL in a core type and constraint language. We implemented InferDL on top of RDL, an existing Ruby type checker. To evaluate InferDL, we applied it to four Ruby on Rails apps that had been previously type checked with RDL, and hence had type annotations. We found that, when using heuristics, InferDL inferred 22% more types that were as or more precise than the previous annotations, compared to standard type inference without heuristics. We also found one new type error. We further evaluated InferDL by applying it to six additional apps, finding five additional type errors. Thus, we believe InferDL represents a promising approach for inferring type annotations in dynamic languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Milod</first_name>
          <last_name>Kazerounian</last_name>
          <affiliation>University of Maryland, College Park</affiliation>
          <bio>undefined</bio>
          <person_id>milodkazerounian1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Brianna M.</first_name>
          <last_name>Ren</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
          <person_id>briannamren</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jeffrey S.</first_name>
          <last_name>Foster</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.tufts.edu/~jfoster/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeffreysfoster/b22ce952-32b0-48bd-be56-12fd87bf3469/small.jpg</picture_url>
          <person_id>jeffreysfoster</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>db8d3a86-8581-4930-87d3-b8b949fd82ad</slot_id>
      <event_id>5e5d5e27-4f5e-4ec9-be96-5f1f0a5bfe96</event_id>
      <title>Simple and Efficient Computation of Minimal Weak Control Closure</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>16:00</end_time>
      <description>Control dependency is a fundamental concept in many pro- gram analyses, transformation, parallelization, and compiler optimiza- tion techniques. An overwhelming number of definitions of control depen- dency relations are found in the literature that capture various kinds of program control flow structures. Weak and strong control closure (WCC and SCC) relations capture nontermination insensitive and sensitive con- trol dependencies and subsume all previously defined control dependency relations. In this paper, we have shown that static dependency-based pro- gram slicing requires the repeated computation of WCC and SCC. The state-of-the-art WCC algorithm provided by Danicic et al. has the cubic worst-case complexity in terms of the size of the control flow graph and is a major obstacle to be used in static program slicing. We have provided a simple yet efficient method to compute the minimal WCC which has the quadratic worst-case complexity and proved the correctness of our algorithms. We implemented ours and the state-of-the-art algorithms in the Clang/LLVM compiler framework and run experiments on a num- ber of SPEC CPU 2017 benchmarks. Our method performs a maximum of 23.8 times and on average 10.6 times faster than the state-of-the-art method. The performance curves of our WCC algorithm for practical applications are closer to the NlogN curve in the microsecond scale. Ev- idently, we improve the practical performance of WCC computation by an order of magnitude.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abu Naser</first_name>
          <last_name>Masud</last_name>
          <affiliation>Malardalen University</affiliation>
          <bio>undefined</bio>
          <person_id>abunasermasud</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ea0555f9-6f56-4516-86fc-ab280024219c</slot_id>
      <event_id>60869a0f-9da8-4a93-9b8e-4d4adbc8ef13</event_id>
      <title>Memory-Efficient Fixpoint Computation</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>15:20</end_time>
      <description>Practical adoption of static analysis often requires trading precision for performance. This paper focuses on improving the memory efficiency of abstract interpretation without sacrificing precision or time efficiency. Computationally, abstract interpretation reduces the problem of inferring program invariants to computing a fixpoint of a set of equations. This paper presents a method to minimize the memory footprint in Bourdoncle’s iteration strategy, a widely-used technique for fixpoint computation. Our technique is agnostic to the abstract domain used. We prove that our technique is optimal (i.e., it results in minimum memory footprint) for Bourdoncle’s iteration strategy while computing the same result. We evaluate the efficacy of our technique by implementing it in a tool called MIKOS, which extends the state-of-the-art abstract interpreter IKOS. When verifying user-provided assertions, MIKOS shows a decrease in peak-memory usage to 4.07% (24.57x) on average compared to IKOS. When performing interprocedural buffer-overflow analysis, MIKOS shows a decrease in peak-memory usage to 43.7% (2.29x) on average compared to IKOS.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sung</first_name>
          <last_name>Kook Kim</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>sungkookkim</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Arnaud J.</first_name>
          <last_name>Venet</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>arnaudjvenet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aditya V.</first_name>
          <last_name>Thakur</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://thakur.cs.ucdavis.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adityavthakur/89eb0287-7273-4261-b8a5-47ccfc8799b0/small.jpg</picture_url>
          <person_id>adityavthakur</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ceb1318a-f724-444a-b7cd-32491a8a5ce8</subevent_id>
    <title>SAS: 3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>2404923b-a6a6-4b98-9f20-85e94d0fba3c</slot_id>
      <title>Session: SAS - 3</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Homer</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ecs.vuw.ac.nz/~mwh</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelhomer/16fc38e2-021c-4b11-8ea6-752cf9b2c0a9/small.jpg</picture_url>
          <person_id>michaelhomer</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Ranzato</last_name>
          <affiliation>University of Padova</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.math.unipd.it/~ranzato/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/francescoranzato/319b8e10-9d08-4060-889f-c55067c7ffed/small.jpg</picture_url>
          <person_id>francescoranzato</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>170cd952-feec-43f0-afe6-2ce7adf3fbb3</slot_id>
      <event_id>3935655d-f3ff-4f44-8de9-a461cc25e8d1</event_id>
      <title>Python 3 Types in the Wild: A Tale of Two Type Systems</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>01:40</end_time>
      <description>Python 3 is a highly dynamic language, but it has introduced a syntax for expressing types with PEP484. This paper explores how developers use these type annotations, the type system semantics provided by type checking and inference tools, and the performance of these tools. We evaluate the types and tools on a corpus of public GitHub repositories. We review MyPy and PyType, two canonical static type checking and inference tools, and their distinct approaches to type analysis. We then address three research questions: (i) How often and in what ways do developers use Python 3 types? (ii) Which type errors do developers make? (iii) How do type errors from different tools compare? 
Surprisingly, when developers use static types, the code rarely type-checks with either of the tools. MyPy and PyType exhibit false positives, due to their static nature, but also flag many useful errors in our corpus. Lastly, MyPy and PyType embody two distinct type systems, flagging different errors in many cases. Understanding the usage of Python types can help guide tool-builders and researchers. Understanding the performance of popular tools can help increase the adoption of static types and tools by practitioners, ultimately leading to more correct and more robust Python code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ingkarat</first_name>
          <last_name>Rak-amnouykit</last_name>
          <affiliation>Rensselaer Polytechnic Institute</affiliation>
          <bio>undefined</bio>
          <person_id>ingkaratrakamnouykit</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>McCrevan</last_name>
          <affiliation>Rensselaer Polytechnic Institute</affiliation>
          <bio>undefined</bio>
          <person_id>danielmccrevan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ana</first_name>
          <last_name>Milanova</last_name>
          <affiliation>Rensselaer Polytechnic Institute, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.rpi.edu/~milanova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anamilanova/4fa9038c-d0e6-44ca-b1b7-2420329714f4/small.jpg</picture_url>
          <person_id>anamilanova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Martin</first_name>
          <last_name>Hirzel</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hirzels.com/martin/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/martinhirzel/8ffffeeb-b25c-4f90-b2e3-4949c2871a2a/small.jpg</picture_url>
          <person_id>martinhirzel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Julian</first_name>
          <last_name>Dolby</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-dolby</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juliandolby/092667c4-6e51-4476-8ef0-58b41ce9014d/small.jpg</picture_url>
          <person_id>juliandolby</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>327f8696-c675-40b0-b105-65b5c4663a54</slot_id>
      <event_id>d008d8aa-e072-4ded-bb28-92df9b4a75ab</event_id>
      <title>On Multi-Language Abstraction: Towards a Static Analysis of Multi-Language Programs</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>02:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Samuele</first_name>
          <last_name>Buro</last_name>
          <affiliation>Università degli Studi di Verona</affiliation>
          <bio>undefined</bio>
          <person_id>samueleburo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roy</first_name>
          <last_name>Crole</last_name>
          <affiliation>University of Leicester</affiliation>
          <bio>undefined</bio>
          <person_id>roycrole</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Isabella</first_name>
          <last_name>Mastroeni</last_name>
          <affiliation>University of Verona, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://profs.scienze.univr.it/mastroeni/Welcome.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/isabellamastroeni/35102ab8-17d3-49b9-8ae0-f3990cb799b5/small.jpg</picture_url>
          <person_id>isabellamastroeni</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>522632c8-9aef-4df9-a493-dc19ed15e0dd</slot_id>
      <event_id>e665af34-4eeb-4601-96fd-e5aa138a4c64</event_id>
      <title>Wasm/k: Delimited Continuations for WebAssembly</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>02:20</end_time>
      <description>WebAssembly is designed to be an alternative to JavaScript that is a safe, portable, and efficient compilation target for a variety of languages. The performance of high-level languages depends not only on the underlying performance of WebAssembly, but also on the quality of the generated WebAssembly code. In this paper, we identify several features of high-level languages that current approaches can only compile to WebAssembly by generating complex and inefficient code. We argue that these problems could be addressed if WebAssembly natively supported first-class continuations. We then present Wasm/k, which extends WebAssembly with delimited continuations. Wasm/k introduces no new value types, and thus does not require significant changes to the WebAssembly type system (validation). Wasm/k is safe, even in the presence of foreign function calls (e.g., to and from JavaScript). Finally, Wasm/k is amenable to efficient implementation: we implement Wasm/k as a local change to Wasmtime, an existing WebAssembly JIT. We evaluate Wasm/k by implementing C/k, which adds delimited continuations to C/C++. C/k uses Emscripten and its implementation serves as a case study on how to use Wasm/k in a compiler that targets WebAssembly. We present several case studies using C/k, and show that on implementing green threads, it can outperform the state-of-the-art approach Asyncify with an 18% improvement in performance and a 30% improvement in code size.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Donald</first_name>
          <last_name>Pinckney</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Currently, I’m a computer science PhD student at Northeastern Univeristy, where I study programming languages and software engineering. However, I’m relatively new to Massachusetts, as I grew up for most of my life in California. For my undergraduate degree, I completed a double major in math and computer science at UC Davis. Meanwhile, I interned in industry for 3 summers, primarily at Apple, where I worked on the AppKit user interface library for macOS. After interning in industry I decided to pursue a PhD in computer science, and specifically programming languages, so I can work to drive the field forward in creating correct, safe, and secure software more easily.</bio>
          <homepage_url>https://donaldpinckney.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/donaldpinckney/90179ee6-31e2-4b13-8a6b-dddb6a1ec706/small.jpg</picture_url>
          <person_id>donaldpinckney</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Guha</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://khoury.northeastern.edu/~arjunguha</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjunguha/284e0782-ec24-4ad9-b6a4-b6a1d0e2fe9a/small.jpg</picture_url>
          <person_id>arjunguha</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yuriy</first_name>
          <last_name>Brun</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>My research is in software engineering. I am interested in improving our ability to build systems that are smart, and self-adapt to their environment. I am particularly interested in ensuring fairness in software systems. Watch a video describing my latest work on software fairness testing here: http://tinyurl.com/FairnessVideo</bio>
          <homepage_url>http://people.cs.umass.edu/~brun/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yuriybrun/15eff225-fb71-4b2c-9925-a0d731136238/small.jpg</picture_url>
          <person_id>yuriybrun</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>904d8b77-4ab4-4047-80cf-5a5963930872</slot_id>
      <event_id>74b4eec7-f45e-46a4-915c-a2812474e966</event_id>
      <title>Exact and Linear-Time Gas-Cost Analysis</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>01:20</end_time>
      <description>Blockchains support execution of smart contracts: programs encoding complex transactions between distrusting parties. Due to their distributed nature, blockchains rely on third-party miners to execute and validate transactions. Miners are compensated by charging users with gas based on the execution cost of the transaction. To compute the exact gas cost, blockchains track gas cost dynamically creating its own overhead. This paper presents a static exact gas-cost analysis technique that can be employed to eliminate dynamic gas tracking. This approach presents further benefits such as providing miners with a trusted gas bound that can be verified in linear time, and eliminating out-of-gas exceptions. To handle recursion and unbounded computation, we propose a novel amortization technique that stores gas inside data structures. We have implemented our analysis technique in a tool called GasBoX that takes a contract as input and infers the gas cost of its functions automatically. We have evaluated GasBoX on 13 standard smart contracts borrowed from real-world blockchain projects. Our soundness theorem proves that the gas bound inferred by GasBoX exactly matches the gas cost at runtime and no dynamic gas tracking is necessary.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ankush</first_name>
          <last_name>Das</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Ankush Das is a final year PhD student at Carnegie Mellon University. He is advised by Prof. Jan Hoffmann. He is broadly interested in programming languages with a specific focus on resource analysis, session types and language design for smart contracts on the blockchain. He is the lead designer and developer of Nomos, a domain-specific language for implementing smart contracts based on resource-aware session types. In the past, he has worked jointly with Prof. Frank Pfenning and his advisor on designing resource-aware session types for parallel complexity analysis of concurrent programs implemented in a programming language called Rast. Before joining CMU, he worked as a Research Fellow at Microsoft Research, India with Akash Lal where he developed an efficient method to perform precise alias analysis for C and C++ programs for Windows driver modules to automatically infer safe null pointer dereferences. He completed his undergraduate at IIT Bombay, India in 2014 where he worked with Prof. Supratik Chakraborty and Prof. Akshay S on deciding termination of linear loop programs.</bio>
          <homepage_url>https://www.cs.cmu.edu/~ankushd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ankushdas/25c652a4-c4da-4eac-8520-4fa23d996157/small.jpg</picture_url>
          <person_id>ankushdas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shaz</first_name>
          <last_name>Qadeer</last_name>
          <affiliation>Novi, USA</affiliation>
          <bio>Shaz Qadeer has worked at Facebook, Microsoft, HP, and Compaq. He has studied at the University of California at Berkeley and the Indian Institute of Technology at Kanpur.</bio>
          <homepage_url>https://scholar.google.com/citations?user=EqIVfYcAAAAJ&amp;hl=en</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shazqadeer1/f224e8bb-da8c-4512-b63b-d56831c9f712/small.jpg</picture_url>
          <person_id>shazqadeer1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>06d37bf3-a470-4e21-ba9c-af4808dd90e0</subevent_id>
    <title>SAS: 6</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>0705e3f8-5266-487a-bcc8-31d43b56c1a9</slot_id>
      <title>Session: SAS - 6</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>21:00</start_time>
      <end_time>22:00</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c430fb59-1e22-415a-a722-80f85be2ef23</slot_id>
      <event_id>fa77e119-6a7c-478d-a301-745160397e38</event_id>
      <title>Polynomial Invariants for Affine Programs</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>21:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>James</first_name>
          <last_name>Worrell</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ox.ac.uk/people/james.worrell/home.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jamesworrell/6504b62e-546c-401b-ba8d-2749ee9c9308/small.jpg</picture_url>
          <person_id>jamesworrell</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ea24a961-4a75-45d9-86c4-ef7b41349bf4</slot_id>
      <event_id>187c6e5a-f0c2-4d97-b61b-97cf948fa0e3</event_id>
      <title>Termination of Polynomial Loops</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>21:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>22:00</end_time>
      <description>We consider the termination problem for triangular weakly non-linear loops (twn-loops) over some ring S like Z, Q, or R. Essentially, the guard of such a loop is an arbitrary Boolean formula over (possibly non-linear) polynomial inequations, and the body is a single assignment (x1,…,xd)⟵(c1⋅x1+p1,…,cd⋅xd+pd) where each xi is a variable, ci∈S, and each pi is a (possibly non-linear) polynomial over S and the variables xi+1,…,xd. We present a reduction from the question of termination to the existential fragment of the first-order theory of S and R. For loops over R, our reduction entails decidability of termination. For loops over Z and Q, it proves semi-decidability of non-termination. Furthermore, we present a transformation to convert certain non-twn-loops into twn-form. Then the original loop terminates iff the transformed loop terminates over a specific subset of R, which can also be checked via our reduction. This transformation also allows us to prove tight complexity bounds for the termination problem for two important classes of loops which can always be transformed into twn-loops.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Florian</first_name>
          <last_name>Frohn</last_name>
          <affiliation>Max Planck Institute for Informatics</affiliation>
          <bio>undefined</bio>
          <person_id>florianfrohn</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marcel</first_name>
          <last_name>Hark</last_name>
          <affiliation>RWTH Aachen University, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/marcelhark/5357ec40-8b32-4698-8252-6c0d8b96f75e/small.jpg</picture_url>
          <person_id>marcelhark</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jürgen</first_name>
          <last_name>Giesl</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://verify.rwth-aachen.de/giesl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jurgengiesl/b1a15529-1129-4608-9104-be1d58d0e129/small.jpg</picture_url>
          <person_id>jurgengiesl</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6c62b8ba-9d6d-41ef-bf60-1c8af7a133c3</subevent_id>
    <title>SAS: 10</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>fe43ff36-ac9b-48a0-87b5-f464a0724deb</slot_id>
      <title>Session: SAS - 10</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Pichardie</last_name>
          <affiliation>Univ Rennes, ENS Rennes, IRISA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.irisa.fr/celtique/pichardie/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidpichardie/b0f30e9b-c1d3-4e4f-9923-4cf150989f86/small.jpg</picture_url>
          <person_id>davidpichardie</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>876958c4-fa98-474c-9723-27b17d8c0931</slot_id>
      <event_id>887f15df-4810-48ff-86b1-91907513cccf</event_id>
      <title>Static analysis for privacy-preserving artificial intelligence</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>17:20</end_time>
      <description>In this talk, I will present the static analysis component of the open source Arcs Project, which is an ecosystem for building privacy-preserving AI applications . Specifically, I will talk about how we use static analysis to ensure that data is only used in approved ways in an AI application. First, I will introduce the Arcs programming model, the type system, and a policy specification language. Then, I will talk about how we use abstract interpretation and the guarantees provided by the type system to ensure that the application only uses data as outlined by the data-usage policy.</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Gogul</first_name>
          <last_name>Balakrishnan</last_name>
          <affiliation>Google</affiliation>
          <bio>I am a staff engineer at Google, where I work on using formal methods for privacy preserving AI. Until recently, I was working as part of the exciting Swift for TensorFlow project. Previously, I led a team that develops static analysis tools to improve the security of Android Apps. Before that I was an engineer at Facebook, and a research staff member in the Systems Analysis and Verification (SAV) group at NEC Laboratories America, Inc. I got my Ph.D in from the University of Wisconsin-Madison.</bio>
          <homepage_url>http://pages.cs.wisc.edu/~bgogul/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gogulbalakrishnan/7e9d2712-94c4-4da1-8fdb-a6203f61414d/small.jpg</picture_url>
          <person_id>gogulbalakrishnan</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b52c17f9-95a7-44df-a670-3c3109c47088</subevent_id>
    <title>SAS: 7</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>1cbf45c2-1f1b-4229-9213-fd2e7e187277</slot_id>
      <title>Session: SAS - 7</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Mihaela</first_name>
          <last_name>Sighireanu</last_name>
          <affiliation>IRIF, Université Paris Diderot</affiliation>
          <bio>I’m associate professor, more precisely “Maitre de conferences with HDR” at University of Paris and member of the verification team in the research institute IRIF. I’ve obtained my PhD from University of Grenoble under the supervision of Hubert Garavel. I’ve previously worked at Verimag during my Master thesis and at INRIA during my postdoc .</bio>
          <homepage_url>https://www.irif.fr/~sighirea</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mihaelasighireanu/8a15d1c3-bf93-4e81-98bb-e903aa08b0d2/small.jpg</picture_url>
          <person_id>mihaelasighireanu</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>653d4359-4ce0-4d5c-8eee-f3d400bd008a</slot_id>
      <event_id>76914a82-f0e1-4d78-8093-7ea5ce50bb37</event_id>
      <title>DelayRepay: Delayed Execution for Kernel Fusion in Python</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>23:40</end_time>
      <description>Python is a popular, dynamic language for data science and scientific computing. To ensure efficiency, significant numerical libraries are implemented in static native languages. However, performance suffers when switching between native and non-native code, especially if data has to be converted between native arrays and Python data structures. As GPU accelerators are increasingly used, this problem becomes particularly acute. Data and control has to be repeatedly transferred between the accelerator and the host. 
In this paper, we present DelayRepay, a delayed execution framework for numeric Python programs. It avoids excessive switching and data transfer by using lazy evaluation and kernel fusion. Using DelayRepay, operations on NumPy arrays are executed lazily, allowing multiple calls to accelerator kernels to be fused together dynamically. DelayRepay is available as a drop-in replacement for existing Python libraries. This approach enables significant performance improvement over the state-of-the-art and is invisible to the application programmer. We show that our approach provides a maximum $377\times$ speedup over NumPy - a 409% increase over the state of the art.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John Magnus</first_name>
          <last_name>Morton</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>johnmagnusmorton</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kuba</first_name>
          <last_name>Kaszyk</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>kubakaszyk</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Lu</first_name>
          <last_name>Li</last_name>
          <affiliation>Linköping University</affiliation>
          <bio>undefined</bio>
          <person_id>luli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jiawen</first_name>
          <last_name>Sun</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>jiawensun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Christophe</first_name>
          <last_name>Dubach</last_name>
          <affiliation>McGill University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/cdubach/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/christophedubach/dc7b0040-a3ef-46dd-b4f3-0f0ea3b2b026/small.jpg</picture_url>
          <person_id>christophedubach</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Michel</first_name>
          <last_name>Steuwer</last_name>
          <affiliation>The University of Edinburgh</affiliation>
          <bio>I am a lecturer (assistant professor) in compilers and runtime systems in the School of Informatics at the University of Edinburgh in Scotland. I am a member of the Compiler and Architecture Design Group (CArD), the Institute for Computing Systems Architecture (ICSA), and a visiting member of staff at the School of Computing Science at the University of Glasgow. 
Before joining the faculty in Edinburgh I was a lecturer in the School of Computing Science at the University of Glasgow. Prior to that, I was a postdoctoral researcher at the School of Informatics at the University of Edinburgh. I received my PhD from the University of Münster in Germany. 
I am interested in all aspects of parallel programming. Particular research interests of mine include performance portability, structured parallel programming, heterogeneous and GPU computing, and novel compilation techniques for high-level languages.</bio>
          <homepage_url>http://michel.steuwer.info/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michelsteuwer/5a465be6-d235-472c-8ace-4894a70bb742/small.jpg</picture_url>
          <person_id>michelsteuwer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Murray</first_name>
          <last_name>Cole</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <person_id>murraycole</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Michael</first_name>
          <last_name>O'Boyle</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>michaeloboyle</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b801108b-784f-46cd-9f41-63e427054a50</slot_id>
      <event_id>d282d18e-5f62-43fb-b68c-eb3bf99afa68</event_id>
      <title>Sampling Optimized Code for Type Feedback</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>00:20</end_time>
      <description>To efficiently execute dynamically typed languages, many language implementations have adopted a two-tier architecture. The first tier aims for low-latency startup times and collects dynamic profiles, such as the dynamic types of variables. The second tier provides high-throughput using an optimizing compiler that specializes code to the recorded type information. If the program behavior changes to the point that not previously seen types occur in specialized code, that specialized code becomes invalid, it is deoptimized, and control is transferred back to the first tier execution engine which will start specializing anew. However, if the program behavior becomes more specific, for instance, if a polymorphic variable becomes monomorphic, nothing changes. Once the program is running optimized code, there are no means to notice that an opportunity for optimization has been missed. 
We propose to employ a sampling-based profiler to monitor native code without any instrumentation. The absence of instrumentation means that when the profiler is not active, no overhead is incurred. We present an implementation is in the context of the \v{R} just-in-time, optimizing compiler for the R language. Based on the sampled profiles, we are able to detect when the native code produced by \v{R} is specialized for stale type feedback and recompile it to more type-specific code. We show that sampling adds an overhead of less than 3% in most cases and up to 9% in few cases and that it reliably detects stale type feedback within milliseconds.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Flückiger</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.o1o.ch</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/olivierfluckiger/6051271d-0eac-48f3-b931-bff878bbce61/small.jpg</picture_url>
          <person_id>olivierfluckiger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Wälchli</last_name>
          <affiliation>University of Bern</affiliation>
          <bio>undefined</bio>
          <person_id>andreaswalchli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sebastián</first_name>
          <last_name>Krynski</last_name>
          <affiliation>Czech Technical University, National University of Quilmes</affiliation>
          <bio>undefined</bio>
          <person_id>sebastiankrynski</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University, USA / Czech Technical University, Czechia</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bc979c2a-78e6-443b-91ac-835e82a1389a</slot_id>
      <event_id>932e180e-dfa8-48ee-bea1-99cedf469770</event_id>
      <title>Interprocedural Shape Analysis Using Separation Logic-based Transformer Summaries</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>23:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hugo</first_name>
          <last_name>Illous</last_name>
          <affiliation>CEA &amp; INRIA / ENS Paris</affiliation>
          <bio>undefined</bio>
          <person_id>hugoillous</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthieu</first_name>
          <last_name>Lemerre</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>matthieulemerre</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xavier</first_name>
          <last_name>Rival</last_name>
          <affiliation>INRIA/CNRS/ENS Paris</affiliation>
          <bio>Xavier Rival is a Senior Research Scientist (Directeur de Recherche) at INRIA Paris. His research interest focus on abstract interpretation and software verification by static analysis. He is mainly working on symbolic abstractions (trace partitionning abstraction, shape analysis, separation logic and memory abstract domains). He has been involved in the design, implementation and transfer of the Astrée analyser, a static analyser able to verify safety properties on industrial size safety critical softwares. He is currently the PI of the MemCAD ERC Starting Grant, aiming at the design of a library of abstract domains to describe memory states containing a wide range of complex data structures. He is also the Head of the ANTIQUE INRIA group, located at ENS Paris, and Professeur Chargé de Cours at Ecole Polytechnique.</bio>
          <homepage_url>http://www.di.ens.fr/~rival/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xavierrival/036511d0-47a1-4db2-97df-0bf5da1a2c8d/small.jpg</picture_url>
          <person_id>xavierrival</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f365cc3d-f750-4d4b-994e-d360451b267d</slot_id>
      <event_id>e3e14325-c529-4426-a059-6ef122bc4c43</event_id>
      <title>Stratified Guarded First-order Transition Systems</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>00:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christian</first_name>
          <last_name>Müller</last_name>
          <affiliation>Technical University of Munich</affiliation>
          <bio>undefined</bio>
          <person_id>christianmuller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Helmut</first_name>
          <last_name>Seidl</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www2.in.tum.de/~seidl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/helmutseidl/2dcd593b-82c2-48ee-b042-87ebd49b4379/small.jpg</picture_url>
          <person_id>helmutseidl</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>43f8b378-d451-4237-9fe9-5740fb84771b</subevent_id>
    <title>SAS: 9</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>c5fa98ba-95b9-4437-83ef-f1352225a175</slot_id>
      <title>Session: SAS - 9</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Kwangkeun</first_name>
          <last_name>Yi</last_name>
          <affiliation>Seoul National University, South Korea</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://kwangkeunyi.snu.ac.kr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/kwangkeunyi/cf1603f7-9a87-4f8c-8403-50164aaf72b5/small.jpg</picture_url>
          <person_id>kwangkeunyi</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4f51e173-f461-401b-a06c-01ec8b6001c5</slot_id>
      <event_id>826b72b5-8d2a-4c83-b0c8-2893d66b8ea5</event_id>
      <title>Predicate Abstraction and CEGAR for nuHFL(Z) Validity Checking</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>16:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Iwayama</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <person_id>naokiiwayama</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.kb.is.s.u-tokyo.ac.jp/~koba/</homepage_url>
          <person_id>naokikobayashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ryota</first_name>
          <last_name>Suzuki</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>ryotasuzuki</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Takeshi</first_name>
          <last_name>Tsukada</last_name>
          <affiliation>Chiba University, Japan</affiliation>
          <bio>undefined</bio>
          <person_id>takeshitsukada</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c646040b-ec16-4689-ae43-e3983579f60e</slot_id>
      <event_id>b673ae70-f50a-4531-b748-2fe1a22e890b</event_id>
      <title>Counterexample- and Simulation-Guided Floating-Point Loop Invariant Synthesis</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/19</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>15:20</end_time>
      <description>We present an automated procedure for synthesizing sound inductive invariants for floating-point numerical loops. Our procedure generates invariants of the form of a convex polynomial inequality that tightly bounds the values of loop variables. Such invariants are a prerequisite for reasoning about the safety and roundoff errors of floating-point programs. 
Unlike previous approaches that rely on policy iteration, linear algebra or semi-definite programming, we propose a heuristic procedure based on simulation and counterexample-guided refinement. We observe that this combination is remarkably effective and general and can handle both linear and nonlinear loop bodies, nondeterministic values as well as conditional statements. Our evaluation shows that our approach can efficiently synthesize loop invariants for existing benchmarks from literature, but that it is also able to find invariants for nonlinear loops that today’s tools cannot handle.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anastasiia</first_name>
          <last_name>Izycheva</last_name>
          <affiliation>Technical University of Munich</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/anastasiiaizycheva/049b4a5f-65b4-44c8-bc62-ba47c866094f/small.jpg</picture_url>
          <person_id>anastasiiaizycheva</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eva</first_name>
          <last_name>Darulova</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mpi-sws.org/~eva/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/evadarulova/0d98744b-ec94-4a27-b1c0-0d728d54bdb7/small.jpg</picture_url>
          <person_id>evadarulova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Helmut</first_name>
          <last_name>Seidl</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www2.in.tum.de/~seidl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/helmutseidl/2dcd593b-82c2-48ee-b042-87ebd49b4379/small.jpg</picture_url>
          <person_id>helmutseidl</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>edf310d8-458d-473b-b249-35fb424f8188</subevent_id>
    <title>SAS: 2</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/18</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>dbd3b557-c3f4-42fd-8da1-e7e905444d10</slot_id>
      <title>Session: SAS - 2</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Flatt</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>Matthew Flatt is a professor in the School of Computing at the University of Utah, where he works on extensible programming languages, runtime systems, and applications of functional programming. He is one of the developers of the Racket programming language. He received his PhD from Rice University in 1999.</bio>
          <homepage_url>http://www.cs.utah.edu/~mflatt/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthewflatt/b4995a2a-f1be-406b-ac9b-fcd5984c1c31/small.jpg</picture_url>
          <person_id>matthewflatt</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Mihaela</first_name>
          <last_name>Sighireanu</last_name>
          <affiliation>IRIF, Université Paris Diderot</affiliation>
          <bio>I’m associate professor, more precisely “Maitre de conferences with HDR” at University of Paris and member of the verification team in the research institute IRIF. I’ve obtained my PhD from University of Grenoble under the supervision of Hubert Garavel. I’ve previously worked at Verimag during my Master thesis and at INRIA during my postdoc .</bio>
          <homepage_url>https://www.irif.fr/~sighirea</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mihaelasighireanu/8a15d1c3-bf93-4e81-98bb-e903aa08b0d2/small.jpg</picture_url>
          <person_id>mihaelasighireanu</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6b367a68-fe3c-4faa-b0ee-87ed44c40832</slot_id>
      <event_id>9dacd93d-13cf-4a2c-9a12-ef5b3d814e72</event_id>
      <title>Croquet: A Unique Collaboration Architecture (Keynote)</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>00:20</end_time>
      <description>The next generation of our connected world calls for a low-latency, low-bandwidth, low-development-effort platform for synchronized interactions. The platform must also enforce privacy from the ground up, in particular in anticipation of an always-on Augmented Reality future. 
In traditional synchronization approaches, computations are performed on a server and results are continuously distributed to clients. Croquet moves all computation to the clients. A lightweight “reflector” server directs the clients to advance time in sync, and ensures that any external event is incorporated by all clients at exactly the same point in the computation, leading to synchronized, bit-identical state. All data is end-to-end encrypted by the clients; the server stores and distributes data, but can never peek inside. 
Croquet’s programming model separates the synchronized computation of “models” from individually computed “views”. This means the world is the same for everyone, but the display of the world can be tailored to each device and user. Models and views communicate using a publish/subscribe mechanism that routes certain events via the reflector. This model/view separation and pub/sub communication is a major departure from the previous, proxy-based Smalltalk implementation of Croquet. It retains the ability for live programming by atomically incorporating new code. 
Vanessa is the chief architect of the current JavaScript-based implementation. She will give an overview of the system, highlight challenges in designing the API, and explore the far-reaching implications of the shift from server to client.</description>
      <persons>
        <person>
          <role>Presenter</role>
          <sort_key>1</sort_key>
          <first_name>Vanessa</first_name>
          <last_name>Freudenberg</last_name>
          <affiliation>Croquet Corp</affiliation>
          <bio>Vanessa is a co-founder of Croquet Corp and the principal engineer of the current Teatime client/server architecture underlying Croquet. She has been developing interactive systems for more than 20 years with a focus on live, self-supporting systems (including Squeak Etoys, Scratch, Lively, Smalltalk VMs).</bio>
          <homepage_url>https://www.croquet.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vanessafreudenberg/846610a3-d712-4599-95cb-b259a0d51d2b/small.jpg</picture_url>
          <person_id>vanessafreudenberg</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fed3a4c3-3a03-4162-8820-29f699121c48</slot_id>
      <event_id>a314d207-12a7-4384-9f2a-43bf0cacd948</event_id>
      <title>Static Resource Analysis at Scale</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>23:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Ezgi</first_name>
          <last_name>Çiçek</last_name>
          <affiliation>Facebook London</affiliation>
          <bio>I have obtained my PhD in Programming Languages at MPI-SWS (Max Planck Institute for Software Systems, Saarbrücken, Germany) and Saarland University in January 2018. I was advised by Deepak Garg. I am currently a Software Engineer at Facebook’s Static Analysis team, Infer. Nowadays, I am working on a static analysis tool for detecting performance regressions at diff time.</bio>
          <homepage_url>https://ezgicicek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ezgicicek/fd8cd7b8-388d-46de-960d-2e5912ceae85/small.jpg</picture_url>
          <person_id>ezgicicek</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6b29ee13-1e63-41cd-87b7-c76b3a95625d</subevent_id>
    <title>SAS: 10</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/20</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>a9f44810-f840-4aaf-b908-958b95d27bed</slot_id>
      <title>Session: SAS - 10</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Mihaela</first_name>
          <last_name>Sighireanu</last_name>
          <affiliation>IRIF, Université Paris Diderot</affiliation>
          <bio>I’m associate professor, more precisely “Maitre de conferences with HDR” at University of Paris and member of the verification team in the research institute IRIF. I’ve obtained my PhD from University of Grenoble under the supervision of Hubert Garavel. I’ve previously worked at Verimag during my Master thesis and at INRIA during my postdoc .</bio>
          <homepage_url>https://www.irif.fr/~sighirea</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mihaelasighireanu/8a15d1c3-bf93-4e81-98bb-e903aa08b0d2/small.jpg</picture_url>
          <person_id>mihaelasighireanu</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ade687ad-8ef5-4fdd-b7eb-67e1b2215b28</slot_id>
      <event_id>887f15df-4810-48ff-86b1-91907513cccf</event_id>
      <title>Static analysis for privacy-preserving artificial intelligence</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>05:20</end_time>
      <description>In this talk, I will present the static analysis component of the open source Arcs Project, which is an ecosystem for building privacy-preserving AI applications . Specifically, I will talk about how we use static analysis to ensure that data is only used in approved ways in an AI application. First, I will introduce the Arcs programming model, the type system, and a policy specification language. Then, I will talk about how we use abstract interpretation and the guarantees provided by the type system to ensure that the application only uses data as outlined by the data-usage policy.</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Gogul</first_name>
          <last_name>Balakrishnan</last_name>
          <affiliation>Google</affiliation>
          <bio>I am a staff engineer at Google, where I work on using formal methods for privacy preserving AI. Until recently, I was working as part of the exciting Swift for TensorFlow project. Previously, I led a team that develops static analysis tools to improve the security of Android Apps. Before that I was an engineer at Facebook, and a research staff member in the Systems Analysis and Verification (SAV) group at NEC Laboratories America, Inc. I got my Ph.D in from the University of Wisconsin-Madison.</bio>
          <homepage_url>http://pages.cs.wisc.edu/~bgogul/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gogulbalakrishnan/7e9d2712-94c4-4da1-8fdb-a6203f61414d/small.jpg</picture_url>
          <person_id>gogulbalakrishnan</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0ab8aedf-90c3-4695-b4c5-34e5523bb10b</subevent_id>
    <title>SAS: 3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/18</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>adf975c2-8c9f-4c33-9ae1-9b9554e0a8b4</slot_id>
      <title>Session: SAS - 3</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Cousot</last_name>
          <affiliation>New York University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/patrickcousot/42f5b16b-b574-4d75-a3b1-902508060f2a/small.jpg</picture_url>
          <person_id>patrickcousot</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Homer</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ecs.vuw.ac.nz/~mwh</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelhomer/16fc38e2-021c-4b11-8ea6-752cf9b2c0a9/small.jpg</picture_url>
          <person_id>michaelhomer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>458a30b3-7c5e-4b97-87ec-78c2083c8739</slot_id>
      <event_id>d008d8aa-e072-4ded-bb28-92df9b4a75ab</event_id>
      <title>On Multi-Language Abstraction: Towards a Static Analysis of Multi-Language Programs</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>14:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Samuele</first_name>
          <last_name>Buro</last_name>
          <affiliation>Università degli Studi di Verona</affiliation>
          <bio>undefined</bio>
          <person_id>samueleburo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roy</first_name>
          <last_name>Crole</last_name>
          <affiliation>University of Leicester</affiliation>
          <bio>undefined</bio>
          <person_id>roycrole</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Isabella</first_name>
          <last_name>Mastroeni</last_name>
          <affiliation>University of Verona, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://profs.scienze.univr.it/mastroeni/Welcome.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/isabellamastroeni/35102ab8-17d3-49b9-8ae0-f3990cb799b5/small.jpg</picture_url>
          <person_id>isabellamastroeni</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6fa596e8-6e99-46f1-8874-1d865d1fa222</slot_id>
      <event_id>74b4eec7-f45e-46a4-915c-a2812474e966</event_id>
      <title>Exact and Linear-Time Gas-Cost Analysis</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>13:20</end_time>
      <description>Blockchains support execution of smart contracts: programs encoding complex transactions between distrusting parties. Due to their distributed nature, blockchains rely on third-party miners to execute and validate transactions. Miners are compensated by charging users with gas based on the execution cost of the transaction. To compute the exact gas cost, blockchains track gas cost dynamically creating its own overhead. This paper presents a static exact gas-cost analysis technique that can be employed to eliminate dynamic gas tracking. This approach presents further benefits such as providing miners with a trusted gas bound that can be verified in linear time, and eliminating out-of-gas exceptions. To handle recursion and unbounded computation, we propose a novel amortization technique that stores gas inside data structures. We have implemented our analysis technique in a tool called GasBoX that takes a contract as input and infers the gas cost of its functions automatically. We have evaluated GasBoX on 13 standard smart contracts borrowed from real-world blockchain projects. Our soundness theorem proves that the gas bound inferred by GasBoX exactly matches the gas cost at runtime and no dynamic gas tracking is necessary.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ankush</first_name>
          <last_name>Das</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Ankush Das is a final year PhD student at Carnegie Mellon University. He is advised by Prof. Jan Hoffmann. He is broadly interested in programming languages with a specific focus on resource analysis, session types and language design for smart contracts on the blockchain. He is the lead designer and developer of Nomos, a domain-specific language for implementing smart contracts based on resource-aware session types. In the past, he has worked jointly with Prof. Frank Pfenning and his advisor on designing resource-aware session types for parallel complexity analysis of concurrent programs implemented in a programming language called Rast. Before joining CMU, he worked as a Research Fellow at Microsoft Research, India with Akash Lal where he developed an efficient method to perform precise alias analysis for C and C++ programs for Windows driver modules to automatically infer safe null pointer dereferences. He completed his undergraduate at IIT Bombay, India in 2014 where he worked with Prof. Supratik Chakraborty and Prof. Akshay S on deciding termination of linear loop programs.</bio>
          <homepage_url>https://www.cs.cmu.edu/~ankushd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ankushdas/25c652a4-c4da-4eac-8520-4fa23d996157/small.jpg</picture_url>
          <person_id>ankushdas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shaz</first_name>
          <last_name>Qadeer</last_name>
          <affiliation>Novi, USA</affiliation>
          <bio>Shaz Qadeer has worked at Facebook, Microsoft, HP, and Compaq. He has studied at the University of California at Berkeley and the Indian Institute of Technology at Kanpur.</bio>
          <homepage_url>https://scholar.google.com/citations?user=EqIVfYcAAAAJ&amp;hl=en</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shazqadeer1/f224e8bb-da8c-4512-b63b-d56831c9f712/small.jpg</picture_url>
          <person_id>shazqadeer1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bd126cb0-6dda-4c11-ad4e-e1dd2976c290</slot_id>
      <event_id>3935655d-f3ff-4f44-8de9-a461cc25e8d1</event_id>
      <title>Python 3 Types in the Wild: A Tale of Two Type Systems</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>13:40</end_time>
      <description>Python 3 is a highly dynamic language, but it has introduced a syntax for expressing types with PEP484. This paper explores how developers use these type annotations, the type system semantics provided by type checking and inference tools, and the performance of these tools. We evaluate the types and tools on a corpus of public GitHub repositories. We review MyPy and PyType, two canonical static type checking and inference tools, and their distinct approaches to type analysis. We then address three research questions: (i) How often and in what ways do developers use Python 3 types? (ii) Which type errors do developers make? (iii) How do type errors from different tools compare? 
Surprisingly, when developers use static types, the code rarely type-checks with either of the tools. MyPy and PyType exhibit false positives, due to their static nature, but also flag many useful errors in our corpus. Lastly, MyPy and PyType embody two distinct type systems, flagging different errors in many cases. Understanding the usage of Python types can help guide tool-builders and researchers. Understanding the performance of popular tools can help increase the adoption of static types and tools by practitioners, ultimately leading to more correct and more robust Python code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ingkarat</first_name>
          <last_name>Rak-amnouykit</last_name>
          <affiliation>Rensselaer Polytechnic Institute</affiliation>
          <bio>undefined</bio>
          <person_id>ingkaratrakamnouykit</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>McCrevan</last_name>
          <affiliation>Rensselaer Polytechnic Institute</affiliation>
          <bio>undefined</bio>
          <person_id>danielmccrevan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ana</first_name>
          <last_name>Milanova</last_name>
          <affiliation>Rensselaer Polytechnic Institute, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.rpi.edu/~milanova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anamilanova/4fa9038c-d0e6-44ca-b1b7-2420329714f4/small.jpg</picture_url>
          <person_id>anamilanova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Martin</first_name>
          <last_name>Hirzel</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hirzels.com/martin/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/martinhirzel/8ffffeeb-b25c-4f90-b2e3-4949c2871a2a/small.jpg</picture_url>
          <person_id>martinhirzel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Julian</first_name>
          <last_name>Dolby</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-dolby</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juliandolby/092667c4-6e51-4476-8ef0-58b41ce9014d/small.jpg</picture_url>
          <person_id>juliandolby</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fc834762-aa54-42f7-b01d-b6f7a7b304fc</slot_id>
      <event_id>e665af34-4eeb-4601-96fd-e5aa138a4c64</event_id>
      <title>Wasm/k: Delimited Continuations for WebAssembly</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>14:20</end_time>
      <description>WebAssembly is designed to be an alternative to JavaScript that is a safe, portable, and efficient compilation target for a variety of languages. The performance of high-level languages depends not only on the underlying performance of WebAssembly, but also on the quality of the generated WebAssembly code. In this paper, we identify several features of high-level languages that current approaches can only compile to WebAssembly by generating complex and inefficient code. We argue that these problems could be addressed if WebAssembly natively supported first-class continuations. We then present Wasm/k, which extends WebAssembly with delimited continuations. Wasm/k introduces no new value types, and thus does not require significant changes to the WebAssembly type system (validation). Wasm/k is safe, even in the presence of foreign function calls (e.g., to and from JavaScript). Finally, Wasm/k is amenable to efficient implementation: we implement Wasm/k as a local change to Wasmtime, an existing WebAssembly JIT. We evaluate Wasm/k by implementing C/k, which adds delimited continuations to C/C++. C/k uses Emscripten and its implementation serves as a case study on how to use Wasm/k in a compiler that targets WebAssembly. We present several case studies using C/k, and show that on implementing green threads, it can outperform the state-of-the-art approach Asyncify with an 18% improvement in performance and a 30% improvement in code size.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Donald</first_name>
          <last_name>Pinckney</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Currently, I’m a computer science PhD student at Northeastern Univeristy, where I study programming languages and software engineering. However, I’m relatively new to Massachusetts, as I grew up for most of my life in California. For my undergraduate degree, I completed a double major in math and computer science at UC Davis. Meanwhile, I interned in industry for 3 summers, primarily at Apple, where I worked on the AppKit user interface library for macOS. After interning in industry I decided to pursue a PhD in computer science, and specifically programming languages, so I can work to drive the field forward in creating correct, safe, and secure software more easily.</bio>
          <homepage_url>https://donaldpinckney.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/donaldpinckney/90179ee6-31e2-4b13-8a6b-dddb6a1ec706/small.jpg</picture_url>
          <person_id>donaldpinckney</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Guha</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://khoury.northeastern.edu/~arjunguha</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjunguha/284e0782-ec24-4ad9-b6a4-b6a1d0e2fe9a/small.jpg</picture_url>
          <person_id>arjunguha</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yuriy</first_name>
          <last_name>Brun</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>My research is in software engineering. I am interested in improving our ability to build systems that are smart, and self-adapt to their environment. I am particularly interested in ensuring fairness in software systems. Watch a video describing my latest work on software fairness testing here: http://tinyurl.com/FairnessVideo</bio>
          <homepage_url>http://people.cs.umass.edu/~brun/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yuriybrun/15eff225-fb71-4b2c-9925-a0d731136238/small.jpg</picture_url>
          <person_id>yuriybrun</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a69d48a6-0cf3-4308-a04e-93f73af48d7d</subevent_id>
    <title>SPLASH REBASE: 9</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>8f57c2d3-ab83-48fa-8b92-2816ffb64ccc</slot_id>
      <title>Session: SPLASH REBASE - 9</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>15:00</start_time>
      <end_time>15:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0c7c6168-61e9-40ba-b602-36af3dca504e</slot_id>
      <event_id>d0422a7b-b071-4c38-901b-e817df74486e</event_id>
      <title>Non-local compiler transformations in the presence of dynamic dispatch</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>15:40</end_time>
      <description>Non-local, semantic compiler transformations such as Automatic Differentiation and certain Bayesian Inference algorithms pose particular challenges for dynamic dispatch systems, where non-local information may not necessarily be computable at compile time. In this talk, I will describe how we approach these problems in Julia while retaining performance scalability all the way from completely dynamic information situations to the semi-static case. Along the way, I will introduce optical constructions, a recent result from Category Theory that provides a useful guide when choosing abstractions for this class of transformations. 
The discussion following this talk will be moderated by Simon Peyton Jones.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Keno</first_name>
          <last_name>Fischer</last_name>
          <affiliation>Julia Computing</affiliation>
          <bio>Keno Fischer is a core developer of the Julia programming language and co-founder and CTO at Julia Computing. Keno has been working on Julia for most of the past 8 years, contributing major parts of the compiler, REPL and binary package management infrastructure, as well as the Julia Machine Learning stack. In his research, Keno likes to push the boundaries of possibilities for programming systems, from exascale computation to practical systems for homomorphic encryption. Keno holds an AM degree in Physics from Harvard University and was recognized by Forbes as one of their “30 under 30”.</bio>
          <homepage_url>https://github.com/Keno</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/kenofischer/b110c2b1-0ad1-4469-8459-5f667861d8ea/small.jpg</picture_url>
          <person_id>kenofischer</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8421eb0c-28c9-4d01-82f5-876f9fc7b5a5</subevent_id>
    <title>SPLASH REBASE: 26</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>60400f54-1c96-46ca-831f-9097e37ab7b0</slot_id>
      <title>Session: SPLASH REBASE - 26</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/20</date>
      <start_time>07:00</start_time>
      <end_time>07:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9cbd97a6-a957-43c2-887f-b13d1b9d17f3</slot_id>
      <event_id>59a73831-882e-4229-b00a-9f8b357d17b3</event_id>
      <title>PL and HCI: Better Together</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/20</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>07:40</end_time>
      <description>Programming Languages (PL), Human-Computer Interaction (HCI), and Software Engineering (SE) have a key overlapping interest: getting computers to do what we want. Each field has a different balance of methods and beneficiaries, from novice programmers to professional programmers. This talk will highlight the overlaps between HCI and PL, a powerful but under-explored pairing with much mutual benefit. HCI is concerned with creating new ways of interacting with computers and using computers to enhance human-to-human interaction, as well as studying how existing systems impact individuals and society. PL is concerned with the theory, design, and implementation of programming languages, program analyses, and program transformations. I will highlight several existing systems that demonstrate how PL and HCI are better together, as well as dispel common misconceptions and lay out some promising future research directions. 
The discussion and AMA following this talk will be moderated by Amy Ko.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Elena</first_name>
          <last_name>Glassman</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>Elena Glassman is a the Stanley A. Marks and William H. Marks Assistant Professor at the Radcliffe Institute and a professor of computer science at the Harvard Paulson School of Engineering and Applied Sciences specializing in human-computer interaction. She designs, builds and evaluates systems for comprehending and interacting with intelligent systems and population-level structure in large code and data corpora. Prior to joining Harvard as an assistant professor, Glassman earned BS, MEng and PhD degrees from MIT EECS and served as a postdoctoral scholar at the University of California, Berkeley EECS department and Berkeley Institute for Design.</bio>
          <homepage_url>http://glassmanlab.seas.harvard.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elenaglassman/4951972c-4212-4bfb-9e7a-bdaefbf84466/small.jpg</picture_url>
          <person_id>elenaglassman</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3599907a-19ab-403d-8bfd-f893298ed9ed</subevent_id>
    <title>SPLASH REBASE: 20</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>9259d6c8-7044-4f36-909a-b0456839430e</slot_id>
      <title>Session: SPLASH REBASE - 20</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/19</date>
      <start_time>05:00</start_time>
      <end_time>05:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9bfe5752-2b1f-4abf-8e92-4258c1edfceb</slot_id>
      <event_id>4b457c84-3b99-44ca-afaa-f1811e462b6e</event_id>
      <title>Tales from the Frontlines: Startup War Stories</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/19</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>05:40</end_time>
      <description>Can one build the Hotspot VM, the Azul GC and the H20 big data engine without getting into the occasional battle and making a mistake or two? This talk distill the lessons of success and wrings wisdom out of failures over three decades in the industy. 
The discussion and AMA following this talk will be moderated by Doug Lea.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cliff</first_name>
          <last_name>Click</last_name>
          <affiliation>Self</affiliation>
          <bio>Cliff Click was the CTO and Co-Founder of H2O, makers of H2O, the open source math and machine learning engine for Big Data. Cliff wrote his first compiler when he was 15 (Pascal to TRS Z-80!), although Cliff’s most famous compiler is the HotSpot Server Compiler (the Sea of Nodes IR). Cliff helped Azul Systems build an 864 core pure-Java mainframe that keeps GC pauses on 500Gb heaps to under 10ms, and worked on all aspects of that JVM. Before that he worked on HotSpot at Sun Microsystems, and was at least partially responsible for bringing Java into the mainstream. Cliff is invited to speak regularly at industry and academic conferences and has published many papers about HotSpot technology. He holds a PhD in Computer Science from Rice University and about 20 patents.</bio>
          <homepage_url>http://cliffc.org/blog/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cliffclick/73d11404-ae6e-4004-80e3-b75f7f40656b/small.jpg</picture_url>
          <person_id>cliffclick</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4056e5e5-b63a-4214-855e-0ecb3e3f036e</subevent_id>
    <title>SPLASH REBASE: 23</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>36c4cfb1-2744-4b82-8315-ecbcec27ea32</slot_id>
      <title>Session: SPLASH REBASE - 23</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/19</date>
      <start_time>13:00</start_time>
      <end_time>13:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3f72c1b4-7266-42ce-86df-c4eb3a1d87cf</slot_id>
      <event_id>be69fb05-2d8f-41eb-9a0b-aa5c1cb43a59</event_id>
      <title>JAX: accelerated machine learning research via composable function transformations in Python</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/19</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>13:40</end_time>
      <description>JAX is a system for high-performance machine learning research and numerical computing. It offers the familiarity of Python+NumPy together with hardware acceleration, and it enables the definition and composition of user-wielded function transformations useful for machine learning programs. These transformations include automatic differentiation, automatic batching, end-to-end compilation (via XLA), parallelizing over multiple accelerators, and more. Composing these transformations is the key to JAX’s power and simplicity. 
JAX had its initial open-source release in December 2018 (https://github.com/google/jax). It’s used by researchers for a wide range of advanced applications, from studying training dynamics of neural networks, to probabilistic programming, to scientific applications in physics and biology. 
This talk will be moderated by Todd Mytkowicz.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Johnson</last_name>
          <affiliation>Google Brain</affiliation>
          <bio>Matt Johnson is a research scientist at Google Brain interested in software systems powering machine learning research. When moonlighting as a machine learning researcher, he works on composing graphical models with neural networks, automatically recognizing and exploiting conjugacy structure, and model-based reinforcement learning from pixels. Matt was a postdoc with Ryan Adams at the Harvard Intelligent Probabilistic Systems Group and Bob Datta in the Datta Lab at the Harvard Medical School. His Ph.D. is from MIT in EECS, where he worked with Alan Willsky on Bayesian time series models and scalable inference. He was an undergrad at UC Berkeley (Go Bears!).</bio>
          <homepage_url>https://people.csail.mit.edu/mattjj/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthewjohnson/c8772aa1-ea44-4d16-a4a1-bf5aafd05f76/small.jpg</picture_url>
          <person_id>matthewjohnson</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>454040ec-b762-40dd-952a-37dcd52ed332</subevent_id>
    <title>SPLASH REBASE: 19</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>2a2a28ad-4287-4066-92af-b5c9facd9bd3</slot_id>
      <title>Session: SPLASH REBASE - 19</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>15:00</start_time>
      <end_time>15:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>74cb04d6-7167-4a52-83e8-f2e4a62ceafe</slot_id>
      <event_id>f3ec9a74-d5ee-4008-9430-ff52af55c713</event_id>
      <title>Speculation in Smart Contracts</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>15:40</end_time>
      <description>A smart contract is a script that controls the transfer of electronic assets within a distributed ledger. Existing smart contract architectures suffer from a bottleneck problem: contract calls place arbitrary user code right in the ledger’s critical path, so relatively complex contract executions delay processing for all transactions, especially simple payments and transfers that could otherwise be cleared quickly. This talk describes an alternative smart contract architecture that executes user code speculatively off the blockchain’s critical path. A secure committee validates and votes on each such computation, certifying the computation’s preconditions and its effects, and forwarding the certified results to a different committee controlling the blockchain. The paper focuses on the authors’ experience integrating this smart contract architecture with an existing commercial blockchain and an existing language virtual machine. 
The discussion and AMA following this talk will be moderated by Yannis Smaragdakis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Maurice</first_name>
          <last_name>Herlihy</last_name>
          <affiliation>Brown University</affiliation>
          <bio>Maurice Herlihy has an A.B. in Mathematics from Harvard University, and a Ph.D. in Computer Science from M.I.T. He has served on the faculty of Carnegie Mellon University and the staff of DEC Cambridge Research Lab. He is the recipient of the 2003 Dijkstra Prize in Distributed Computing, the 2004 Gödel Prize in theoretical computer science, the 2008 ISCA influential paper award, the 2012 Edsger W. Dijkstra Prize, and the 2013 Wallace McDowell award. He received a 2012 Fulbright Distinguished Chair in the Natural Sciences and Engineering Lecturing Fellowship, and he is fellow of the ACM, a fellow of the National Academy of Inventors, the National Academy of Engineering, and the National Academy of Arts and Sciences.</bio>
          <homepage_url>http://cs.brown.edu/~mph/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mauriceherlihy/475dd54e-d8ee-47c6-9eb8-d0ebae4914e2/small.jpg</picture_url>
          <person_id>mauriceherlihy</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>903afa25-efd4-4497-b599-a89a25303820</subevent_id>
    <title>SPLASH REBASE: 21</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>ba5ab9e6-64b0-4a9e-bcf2-8e6d30b3b99e</slot_id>
      <title>Session: SPLASH REBASE - 21</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/19</date>
      <start_time>21:00</start_time>
      <end_time>21:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5862dee6-d917-4e7a-84d2-d77a6778c0cc</slot_id>
      <event_id>03ce757b-14f2-4cff-96de-d52eb26aa2bf</event_id>
      <title>Relational Reasoning in Object-based Programs</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/19</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>21:40</end_time>
      <description>Relational properties arise in many settings: relating two versions of a program that use different data representations, noninterference properties for security, conditional equivalence in program transformations, etc. How might one reason about such relational properties? The talk reports on current investigations of a logic based on novel syntax that weaves together product programs to express alignment of control flow points at which relational formulas are asserted. Correctness judgments feature hypotheses with relational specifications, discharged by a rule for the linking of procedure implementations. The logic supports reasoning about program-pairs containing both similar and dissimilar control and data structures. Reasoning about dynamically allocated objects is supported by a frame rule based on frame conditions amenable to SMT provers. 
The discussion following this talk will be moderated by Yu David Liu.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anindya</first_name>
          <last_name>Banerjee</last_name>
          <affiliation>National Science Foundation</affiliation>
          <bio>Anindya is a Program Director at the National Science Foundation in the CISE Directorate in the Division of Computing and Communication Foundations (CCF) where he focuses on the issues of Software and Hardware Foundations; Exploiting Parallelism for Scalability; Cyber-physical Systems; Research Experience for Undergraduates; CISE Research Initiation Initiatives. Banerjee’s research interests span software security, software verification, probabilistic programming, semantics and logics of programs, abstract interpretation, program analysis and program transformation. He received his Ph.D. from Kansas State University, USA, in 1995. After his Ph.D., Anindya was a postdoctoral researcher, first in the Labaratoire d’Informatique (LIX) of Ecole Polytechnique, Paris and subsequently at the University of Aarhus. He joined the IMDEA Software Institute in February 2009 as Full Professor. Immediately prior to this position, Anindya was Full Professor of Computing and Information Sciences at Kansas State University, USA. He was an Academic Visitor in the Advanced Programming Tools group, IBM T. J. Watson Research Center in 2007 and a Visiting Researcher in the Programming Languages and Methodology group at Microsoft Research in 2007–2008. He was a recipient of the Career Award of the US National Science Foundation in 2001.</bio>
          <homepage_url>https://www.nsf.gov/staff/staff_bio.jsp?lan=abanerje&amp;org=NSF&amp;from_org=NSF</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anindyabanerjee1/fe921757-de11-449b-9c37-f3c7d07db1bb/small.jpg</picture_url>
          <person_id>anindyabanerjee1</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3f750f4b-e824-4bec-a997-4dd047dab920</subevent_id>
    <title>SPLASH REBASE: 15</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>f793901a-c978-4a44-880d-09df7d5d7603</slot_id>
      <title>Session: SPLASH REBASE - 15</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>05:00</start_time>
      <end_time>05:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>03d26fcb-26c5-4ec2-8e77-017d3fd1744f</slot_id>
      <event_id>a89b8a71-8095-4032-a94a-5405a58da74b</event_id>
      <title>Technology Today: A Paucity of Integrity and Imagination</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>05:40</end_time>
      <description>Judging by the experiences of Robert Grimm and a close confidante, both academe and industry have long given up even trying to conduct their business in an ethical fashion. In this talk, the author will detail some of the most egregious instances of deeply unethical if not outright criminal behavior across their career, will argue that they are representative of elites acting in a deeply irresponsible and self-serving manner, causally tie that misbehavior to the rise of nativist nationalism across the western world, and contrast it all against the civilization-ending threat of climate change. This talk sounds the alarm as much as it identifies our last best hope for survival. It’s up to us! 
The discussion and AMA following this talk will be moderated by Emery Berger.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Grimm</last_name>
          <affiliation>Self</affiliation>
          <bio>Robert worked at Facebook. He was also Vice President in the Technology Division of Goldman Sachs, where he worked on the company’s risk and trading platform. Robert was an Associate Professor of Computer Science at New York University, researching how to leverage programming language technologies to make complex systems easier to build, maintain and extend. He received a Ph.D. in Computer Science from the University of Washington at Seattle in 2002. His honors include the Best Paper award at the 6th ACM International Conference on Distributed Event-Based Systems, a Junior Fellowship at NYU’s Center for Teaching Excellence, and an NSF CAREER award.</bio>
          <homepage_url>http://cs.nyu.edu/rgrimm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/robertgrimm/00645048-2d05-48ed-ae6f-50c441f41179/small.jpg</picture_url>
          <person_id>robertgrimm</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>dd25ec73-3a78-442d-b5e8-fb590b6001a3</subevent_id>
    <title>SPLASH REBASE: 8</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>4d50c27e-b42e-4626-b3c9-58a68c5dfc43</slot_id>
      <title>Session: SPLASH REBASE - 8</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>13:00</start_time>
      <end_time>13:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3278d263-db91-4af5-8b79-47cae9bb0c1d</slot_id>
      <event_id>9909752f-2f85-4ed3-abab-a13ebbc9e912</event_id>
      <title>Herding Nulls in Dart</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>13:40</end_time>
      <description>The programming language Dart is about to introduce sound null safety, which involves a bundle of language mechanisms associated with null as a typing property. This talk presents these mechanisms, including nullable types, late variables, type promotion, null shorting, and the handling of programs with both legacy and null safe libraries. 
The discussion and AMA following this talk will be moderated by Joe Pamer and Erik Meijer. No recording will be available.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Erik</first_name>
          <last_name>Ernst</last_name>
          <affiliation>Google LLC</affiliation>
          <bio>Erik Ernst is a member of the Dart language team at Google, maintaining the language specification. He has been an associate professor at Aarhus University. He has published research on virtual classes, establishing that they can be statically safe. He introduced family polymorphism, which is foundational for path dependent types, and he contributed to the introduction of generics is Java.</bio>
          <homepage_url>https://scholar.google.com/citations?user=L-i5BHcAAAAJ&amp;hl=en</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/erikernst/dbb8033d-763a-4571-90ef-c750ed5f597b/small.jpg</picture_url>
          <person_id>erikernst</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>002a72fd-18fc-455b-a274-493ff380afd1</subevent_id>
    <title>SPLASH REBASE: 10</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>8346649c-a00c-4f27-8366-d393c579411b</slot_id>
      <title>Session: SPLASH REBASE - 10</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>17:00</start_time>
      <end_time>17:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7ee3f126-2b71-485b-9a7c-5819aa046a40</slot_id>
      <event_id>dbb6bee0-b4d0-48fe-aa57-9d19010b0d78</event_id>
      <title>Lies we tell ourselves about developer infrastructure</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>17:40</end_time>
      <description>Over the past decade “developer infrastructure” teams have become an increasingly common presence in industry. Focused on serving the unique needs of an organization’s engineers, their responsibilities can be as modest as build script support or as ambitious as developing new general-purpose programming languages. As a practitioner they can be a wonderful place to work; a perfect environment to apply state of the art techniques to real world problems and invest in new ideas, all while keeping a tight feedback loop with a potentially massive user base. But with great power comes great responsibility, and the potential for waste is real. 
How many build systems, UI frameworks, code review tools, and bespoke IDEs have been developed in industry because of “unique needs”? Of those, how many actually improved the state of the art or eventually provided a return on their investment? Why does conventional wisdom — or common sense — so seldom apply when we choose to pursue these sorts of projects? (Why is it so often easier to get funding to develop a new programming language than it is to make critical improvements to an aging but essential piece of infrastructure?) The truth is that we often build new developer tools not because they’re necessary, but because personally meaningful, easy to rationalize, and fun. 
While fun is great – I’m a big fan of it – we have a professional obligation to be honest about our intentions, use resources responsibly, and go into our work with open eyes. In this talk I aim to call out the most common sources of irrational exuberance when it comes to developer infrastructure, and the lies I’ve been told (or told others) to justify certain classes of projects. Where appropriate I’ll provide cautionary tales from my last two decades working in the field (names will be changed to protect the innocent), sensible alternatives for those wiser than I was, and advice for those foolhardy enough to try and build that better wheel. (Because I guarantee you – whatever mistake you’re thinking of making, I’ve either made it myself or know someone who did.) 
The discussion and AMA following this talks will be moderated by Keith Adams.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joe</first_name>
          <last_name>Pamer</last_name>
          <affiliation>Facebook</affiliation>
          <bio>Joe Pamer is an Engineering Director at Instagram, where he serves as their Head of Infrastructure, Feed, and ML. Before joining Facebook to help lead their programming language efforts, he was instrumental in the design and development of the F#, TypeScript, and Swift programming languages, and has contributed to many other major developer technologies ranging from .NET to VS Code to Clang. He currently resides in Brooklyn, New York.</bio>
          <homepage_url>http://noteven.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joepamer/8638da18-a5b0-4543-9d00-fd4b97be5d14/small.jpg</picture_url>
          <person_id>joepamer</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>161ff398-399e-40a5-9c63-a94c4c893d45</subevent_id>
    <title>SPLASH REBASE: 3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>b9a5158f-2c8a-4133-a05c-04f394f77fa6</slot_id>
      <title>Session: SPLASH REBASE - 3</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/15</date>
      <start_time>13:00</start_time>
      <end_time>13:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>41259158-4892-4ad0-aa15-4ed22d968069</slot_id>
      <event_id>bc103573-47f7-44f0-b8e7-b629c50d6e17</event_id>
      <title>Probabilistic Programming: The What, Why and How</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/15</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>13:40</end_time>
      <description>f(x) = y, but y = 5. What’s the probability that x =1? Probabilistic programming is the idea of describing probabilistic models as programs, to then automatically infer how our beliefs about model parameters change given observed data. In recent years, probabilistic programming languages (such as Stan) have demonstrated the power of this approach by becoming the underlying tool behind numerous projects in social science, biology, genetics, astrophysics, and engineering. But why haven’t such languages been more widely adopted yet? In this talk, Maria will talk about the nuts and bolts of probabilistic programming languages, addressing the challenges behind making these languages general-purpose, automatic, and efficient. 
This talk and the following AMA will be moderated by Andrew Gordon.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Maria I.</first_name>
          <last_name>Gorinova</last_name>
          <affiliation>The University of Edinburgh</affiliation>
          <bio>Maria is a Data Science PhD student at the University of Edinburgh, where she works on improving the expressivity and efficiency of probabilistic programming languages. In particular, she is interested in applying program-analysis techniques to existing probabilistic languages, such as Stan, and she is also part of Stan’s development team. Previously, Maria worked as a Research Assistant in the Graphics and Interaction Group at the University of Cambridge, where she also received her BA, developing an interactive development environment for probabilistic programming for her final year project.</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/s1207807/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mariaigorinova/d9555ab1-6d7e-4631-bcc7-2f6ed701a677/small.jpg</picture_url>
          <person_id>mariaigorinova</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>dc63f7ab-7a83-4698-bdd1-6eb84997c21b</subevent_id>
    <title>SPLASH REBASE: 32</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>9f79ede8-f660-47db-8e52-6d261c5fd47b</slot_id>
      <title>Session: SPLASH REBASE - 32</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>03:00</start_time>
      <end_time>03:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9b6c3eb8-295c-4590-9efb-7929aa1fdac0</slot_id>
      <event_id>05a740f8-7a2d-42bb-a92d-7cfa31345b5f</event_id>
      <title>Gillian: a Multi-language Platform for Compositional Symbolic Analysis</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>03:40</end_time>
      <description>This talk will give a general introduction to Gillian, a multi-language platform for symbolic program analysis being developed by my team at Imperial College London. Gillian currently supports three types of analysis: whole-program symbolic testing; full verification based on separation logic; and automatic compositional testing based on bi-abduction. It uses a core symbolic execution engine, with strong mathematical foundations, that unifies bug catching and verification. To instantiate Gillian to a new target language (TL), the tool developer must provide: a compiler from the TL to GIL, an intermediate representation which is parametric on the TL memory model: that is, on the set of basic actions capturing the ways in which TL programs fundamentally interact with their memories; an OCaml implementation of the TL memory model using the basic actions; proofs of simple lemmas for the TL basic actions, if interested in correctness guarantees. So far, we have instantiated Gillian to JavaScript and C. These instantiations have been used to: find bugs in the real-world data-structure libraries Buckets.js and Collections-C; find bugs and prove bounded correctness results for a real-world jQuery-like library, cash; and verify the deserialisation function of the AWS Encryption SDK messaging system. 
The discussion and AMA following this talk will be moderated by Jan Vitek.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Philippa</first_name>
          <last_name>Gardner</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Philippa Gardner is a professor in the Department of Computing at Imperial College London and and has a UKRI Established Fellowship from 2018–2023. Her current research focusses on program verification: in particular, reasoning about Web programs (JavaScript and DOM); and reasoning about concurrent programs. She completed her PhD thesis, supervised by Professor Gordon Plotkin FRS at Edinburgh in 1992 and held five years of fellowships at Edinburgh. She moved to Cambridge in 1998 on an EPSRC Advanced Fellowship, hosted by Professor Robin Milner FRS. She obtained a lectureship at Imperial in 2001, and became professor in 2009. She held a Microsoft Research Cambridge/Royal Academy of Engineering Senior Fellowship from 2005 to 2010 at Imperial. Philippa directs the Research Institute on Verified Trustworthy Software Systems (VeTSS), funded by EPSRC, from 2017 to 2022. She chaired the BCS awards committee, 2013-2018, which decides the Lovelace medal (senior) and Roger Needham award (mid-career) for computer science and engineering.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~pg</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippagardner/8031e77a-ebbb-4963-a5de-94895edd7f71/small.jpg</picture_url>
          <person_id>philippagardner</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c68c3682-381a-4ee4-87bd-2206e1496d56</subevent_id>
    <title>SPLASH REBASE: 2</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>fbe47638-7c05-47d3-8c24-b577e51b24d3</slot_id>
      <title>Session: SPLASH REBASE - 2</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/15</date>
      <start_time>11:00</start_time>
      <end_time>11:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>33f0896c-ff56-4cde-91f7-36f88a3d9c8a</slot_id>
      <event_id>4e833098-9571-41d8-9ce8-db793ded3069</event_id>
      <title>Back to the Future! A History of UIs through Trends and Mass Culture</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/15</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>11:40</end_time>
      <description>Digital interfaces have changed a lot since the good old days of CERN’s first webpage. UI design has evolved in a very unpredictable way, generating new trends year after year always based on the needs and expectations of users. Also, in popular culture, we can find more and more user interfaces: TV shows, movies, comics and video clips are full of digital systems and it is very interesting to see how the media industry perceives the “shape” of technology and how it is used. From the colorful (and pixelated) iframe-based websites in the 90s to the minimalist and pretentious interfaces of 2020, we will take a journey through the trends, patterns and perception of mass culture of user interfaces, trying to understand how and why. they evolved in this way. Furthermore, we will try to understand why hackers in TV shows are able to break into the FBI’s servers by simply clicking a button.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paola</first_name>
          <last_name>Bisogno</last_name>
          <affiliation>Casavo</affiliation>
          <bio>Paola is an italian digital product designer with more than 15 years of experience. She started as a web master in the early 00s, building web 1.0 sites. After years in digital agencies, she switched to focus on user experience and interface design. She now works as UX/UI Designer at Casavo, one of the most innovative italian proptech startups. She worries about usability, design patterns, engineering design process, heuristic evaluation, information architecture and cognitive design. She is on the jury of the international design and development awards CSS Design Awards.</bio>
          <homepage_url>https://www.paobi.it/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/paolabisogno/494b3b99-2e72-47b6-b372-df5227bd8469/small.jpg</picture_url>
          <person_id>paolabisogno</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f0c8344c-714d-480a-8e2c-737e5f38e36a</subevent_id>
    <title>SPLASH REBASE: 6</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>00790be9-15d8-4b9d-a10e-bb9c47e4023a</slot_id>
      <title>Session: SPLASH REBASE - 6</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>19:00</start_time>
      <end_time>19:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>03f7b8c9-8b79-4f72-a281-5c08478f1144</slot_id>
      <event_id>f62da32e-6fe2-4aae-a89f-747447ef4bac</event_id>
      <title>Reliable Stack Traces, the Reality of Myth</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>19:40</end_time>
      <description>Debug information is a hidden and obscure component of our computing infrastructure obviously used by debuggers, but also playing a key role in program analysis tools, and, most surprisingly, in the runtime of programming languages. For instance C++ leverages DWARF stack unwind tables to implement exceptions! Alas, generating debug information adds significant burden to compilers, and the debug info itself can be pervaded by subtle bugs, making the whole infrastructure unreliable. Additionally, interpreting the debug tables is a bottleneck. My talk focuses on the DWARF unwind table, that enables stack unwinding in absence of frame-pointer information. I show two techniques to perform validation and synthesis of unwinding tables, and their implementation for x86_64. Our validator has proven effective for compiler and inline assembly testing, while the synthesis tool can generate unwind tables for arbitrary binaries lacking debug information. Additionally, I will report on a technique to precompile unwind tables into native x86_64 code, which we have implemented and integrated into libunwind, resulting in a 25x DWARF-based unwind speedup. 
The discussion and AMA following the talk will be moderated by Christoph Kirsch and Robert Grimm.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Zappa Nardelli</last_name>
          <affiliation>Facebook</affiliation>
          <bio>My work is at boundaries between programming languages, system programming, and computer architectures, with the overall goal of producing systems which are better-understood, more robust, and more secure.</bio>
          <homepage_url>https://fzn.fr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/francescozappanardelli/e7d164ff-66ed-4309-b99f-60e2f77f7b02/small.jpg</picture_url>
          <person_id>francescozappanardelli</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5017f4a5-0a5a-44bf-8c6c-d89617ab12fb</subevent_id>
    <title>SPLASH REBASE: 4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>aef61d76-ca26-44a4-9a87-17632ac3fa8a</slot_id>
      <title>Session: SPLASH REBASE - 4</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/15</date>
      <start_time>15:00</start_time>
      <end_time>15:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>429f2790-02ed-402d-8178-9bb423efdef7</slot_id>
      <event_id>9ca583dd-05ba-44fc-b913-6a78719ea4e0</event_id>
      <title>A Ray of Hope: Array Programming for the 21st Century</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/15</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>15:40</end_time>
      <description>The ideas of APL and its successors, the array programming languages, were two generations ahead of their time.&amp;nbsp; These languages are based on the notion that everything is a tensor, and all operations are rank-polymorphic: they extend automatically to tensors of any rank. These ideas are perfectly suited to an era of machine learning, large scale data, GPUs and other accelerators. Building on recent academic research, we are building ShapeRank, a new statically typed, purely functional language for industrial use, that extends rank-polymorphism to streams. We’ll introduce the key ideas and show how they are realized in ShapeRank.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gilad</first_name>
          <last_name>Bracha</last_name>
          <affiliation>F5 Networks</affiliation>
          <bio>Gilad Bracha is the creator of the Newspeak programming language and a well known researcher in the area of object-oriented programming languages. He was awarded the senior Dahl-Nygaard prize in 2017. Previously, he has worked at Google, as a VP at SAP Labs in Palo Alto, a Distinguished Engineer at Cadence, and a Computational Theologist and Distinguished Engineer at Sun. He has authored or co-authored several books including the Java Language and Virtual Machine Specifications, and the Dart Programming Language. Prior to joining Sun, he worked on Strongtalk, the Animorphic Smalltalk System. He received his B.Sc in Mathematics and Computer Science from Ben Gurion University in Israel and a Ph.D. in Computer Science from the University of Utah.</bio>
          <homepage_url>https://bracha.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/giladbracha/66fe962c-9388-4df3-aaaa-677a8e2e64df/small.jpg</picture_url>
          <person_id>giladbracha</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c41d960f-8617-4f16-be0f-1e11b2718e49</subevent_id>
    <title>SPLASH REBASE: 18</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>0b305cf8-c0d2-46ba-83dd-34bbd3b0efc6</slot_id>
      <title>Session: SPLASH REBASE - 18</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>13:00</start_time>
      <end_time>13:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bb3f37ff-0a0f-4b29-b0b7-1878de6d707a</slot_id>
      <event_id>a1270bf8-34d0-477b-b540-3c525ff165fa</event_id>
      <title>Inside Every Calculus Is A Little Algebra Waiting To Get Out</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>13:40</end_time>
      <description>Because of deep learning, there has been a surge in interest in automatic differentiation, especially from the functional programming community. As a result there are many recent papers that look at AD from a Category Theory perspective. However, Category Theorists have already been looking at differentiation and calculus in general since the late 60’s in the context of Synthetic Differential Geometry, but it seems that this work is largely ignored by those interested in AD. In this talk, we will provide a gentle introduction to the ideas of SDG, by relating them to dual numbers, and show how it provides a simple and purely algebraic approach to (automatic) differentiation. 
The discussion and AMA following this talk will be moderated by Mitch Wand.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Erik</first_name>
          <last_name>Meijer</last_name>
          <affiliation>Facebook</affiliation>
          <bio>Erik Meijer has been trying to bridge the ridge between theory and practice for most of his career. He is perhaps best known for his work on, amongst others, Haskell, C#, Visual Basic, and Dart programming languages, as well as for his contributions to LINQ and the Reactive Framework (Rx). Most recently he is on a quest to make uncertainty a first-class citizen in mainstream programming languages.</bio>
          <homepage_url>https://twitter.com/headinthebox</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/erikmeijer/caccbe57-ed32-4b35-966a-886c97f93d47/small.jpg</picture_url>
          <person_id>erikmeijer</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>93c368ec-1d51-4c6c-9aef-b5193f764c4f</subevent_id>
    <title>SPLASH REBASE: 26</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>51f85b91-645a-42de-bc21-a7104037535e</slot_id>
      <title>Session: SPLASH REBASE - 26</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/20</date>
      <start_time>19:00</start_time>
      <end_time>19:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>61bf489a-8364-4ddd-90b0-69d3f1d6bd5b</slot_id>
      <event_id>59a73831-882e-4229-b00a-9f8b357d17b3</event_id>
      <title>PL and HCI: Better Together</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/20</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>19:40</end_time>
      <description>Programming Languages (PL), Human-Computer Interaction (HCI), and Software Engineering (SE) have a key overlapping interest: getting computers to do what we want. Each field has a different balance of methods and beneficiaries, from novice programmers to professional programmers. This talk will highlight the overlaps between HCI and PL, a powerful but under-explored pairing with much mutual benefit. HCI is concerned with creating new ways of interacting with computers and using computers to enhance human-to-human interaction, as well as studying how existing systems impact individuals and society. PL is concerned with the theory, design, and implementation of programming languages, program analyses, and program transformations. I will highlight several existing systems that demonstrate how PL and HCI are better together, as well as dispel common misconceptions and lay out some promising future research directions. 
The discussion and AMA following this talk will be moderated by Amy Ko.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Elena</first_name>
          <last_name>Glassman</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>Elena Glassman is a the Stanley A. Marks and William H. Marks Assistant Professor at the Radcliffe Institute and a professor of computer science at the Harvard Paulson School of Engineering and Applied Sciences specializing in human-computer interaction. She designs, builds and evaluates systems for comprehending and interacting with intelligent systems and population-level structure in large code and data corpora. Prior to joining Harvard as an assistant professor, Glassman earned BS, MEng and PhD degrees from MIT EECS and served as a postdoctoral scholar at the University of California, Berkeley EECS department and Berkeley Institute for Design.</bio>
          <homepage_url>http://glassmanlab.seas.harvard.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elenaglassman/4951972c-4212-4bfb-9e7a-bdaefbf84466/small.jpg</picture_url>
          <person_id>elenaglassman</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>56be88cd-f1c8-4d33-914a-2c5d0ebe5d74</subevent_id>
    <title>SPLASH REBASE: 3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>d596dcec-4825-4ac5-bb7c-7caa20d5fa50</slot_id>
      <title>Session: SPLASH REBASE - 3</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/15</date>
      <start_time>23:00</start_time>
      <end_time>23:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>979f5f3c-351e-482f-aff4-31199d685adf</slot_id>
      <event_id>bc103573-47f7-44f0-b8e7-b629c50d6e17</event_id>
      <title>Probabilistic Programming: The What, Why and How</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/15</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>23:40</end_time>
      <description>f(x) = y, but y = 5. What’s the probability that x =1? Probabilistic programming is the idea of describing probabilistic models as programs, to then automatically infer how our beliefs about model parameters change given observed data. In recent years, probabilistic programming languages (such as Stan) have demonstrated the power of this approach by becoming the underlying tool behind numerous projects in social science, biology, genetics, astrophysics, and engineering. But why haven’t such languages been more widely adopted yet? In this talk, Maria will talk about the nuts and bolts of probabilistic programming languages, addressing the challenges behind making these languages general-purpose, automatic, and efficient. 
This talk and the following AMA will be moderated by Andrew Gordon.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Maria I.</first_name>
          <last_name>Gorinova</last_name>
          <affiliation>The University of Edinburgh</affiliation>
          <bio>Maria is a Data Science PhD student at the University of Edinburgh, where she works on improving the expressivity and efficiency of probabilistic programming languages. In particular, she is interested in applying program-analysis techniques to existing probabilistic languages, such as Stan, and she is also part of Stan’s development team. Previously, Maria worked as a Research Assistant in the Graphics and Interaction Group at the University of Cambridge, where she also received her BA, developing an interactive development environment for probabilistic programming for her final year project.</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/s1207807/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mariaigorinova/d9555ab1-6d7e-4631-bcc7-2f6ed701a677/small.jpg</picture_url>
          <person_id>mariaigorinova</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7aaf739f-ff37-4155-b059-e151a06c2a00</subevent_id>
    <title>SPLASH REBASE: 19</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>aec850b8-8994-4871-aa4a-7939bc0a1a23</slot_id>
      <title>Session: SPLASH REBASE - 19</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/19</date>
      <start_time>03:00</start_time>
      <end_time>03:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a540c1d4-1a16-4ff6-aab2-6e6bd8cbb59c</slot_id>
      <event_id>f3ec9a74-d5ee-4008-9430-ff52af55c713</event_id>
      <title>Speculation in Smart Contracts</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/19</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>03:40</end_time>
      <description>A smart contract is a script that controls the transfer of electronic assets within a distributed ledger. Existing smart contract architectures suffer from a bottleneck problem: contract calls place arbitrary user code right in the ledger’s critical path, so relatively complex contract executions delay processing for all transactions, especially simple payments and transfers that could otherwise be cleared quickly. This talk describes an alternative smart contract architecture that executes user code speculatively off the blockchain’s critical path. A secure committee validates and votes on each such computation, certifying the computation’s preconditions and its effects, and forwarding the certified results to a different committee controlling the blockchain. The paper focuses on the authors’ experience integrating this smart contract architecture with an existing commercial blockchain and an existing language virtual machine. 
The discussion and AMA following this talk will be moderated by Yannis Smaragdakis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Maurice</first_name>
          <last_name>Herlihy</last_name>
          <affiliation>Brown University</affiliation>
          <bio>Maurice Herlihy has an A.B. in Mathematics from Harvard University, and a Ph.D. in Computer Science from M.I.T. He has served on the faculty of Carnegie Mellon University and the staff of DEC Cambridge Research Lab. He is the recipient of the 2003 Dijkstra Prize in Distributed Computing, the 2004 Gödel Prize in theoretical computer science, the 2008 ISCA influential paper award, the 2012 Edsger W. Dijkstra Prize, and the 2013 Wallace McDowell award. He received a 2012 Fulbright Distinguished Chair in the Natural Sciences and Engineering Lecturing Fellowship, and he is fellow of the ACM, a fellow of the National Academy of Inventors, the National Academy of Engineering, and the National Academy of Arts and Sciences.</bio>
          <homepage_url>http://cs.brown.edu/~mph/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mauriceherlihy/475dd54e-d8ee-47c6-9eb8-d0ebae4914e2/small.jpg</picture_url>
          <person_id>mauriceherlihy</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fe58d1e2-729e-4beb-839b-ccca5b5054bc</subevent_id>
    <title>SPLASH REBASE: 28</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>b6757c7a-01ed-42dd-9be2-4d9eacac2130</slot_id>
      <title>Session: SPLASH REBASE - 28</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/20</date>
      <start_time>09:00</start_time>
      <end_time>09:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>efcd09df-7247-4f2e-8db9-4d588f54da75</slot_id>
      <event_id>fbb11428-c9f3-4c7b-8395-2c4f79d8f397</event_id>
      <title>Performance Really Matters</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/20</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>09:40</end_time>
      <description>Performance clearly matters to users. For example, the most common software update on the AppStore is “Bug fixes and performance enhancements.” Now that Moore’s Law has ended, programmers have to work hard to get high performance for their applications. But why is performance hard to deliver? I will first explain why current approaches to evaluating and optimizing performance don’t work. I’ll show how complicated performance has become on modern systems, and how compiler optimizations have essentially run out of steam. Next, I’ll introduce two radically new performance profilers that guide programmers directly to the code they need to change to improve application performance. The first is Coz, a new “causal profiler” for C/C++/Rust that lets programmers optimize for throughput or latency, and which pinpoints and accurately predicts the impact of optimizations via what we call “virtual speedup” experiments. Coz’s approach unlocks previously unknown optimization opportunities. Guided by Coz, we improved the performance of applications by as much as 68%; in most cases, this involved modifying less than 10 lines of code and took under half an hour (without any prior understanding of the programs!). Coz now ships as part of standard Linux distros. The second is Scalene, a “scripting-language aware” profiler for Python. Scalene runs orders of magnitude faster than other profilers while delivering far more detailed information – information that’s especially valuable to Python programmers. Via a combination of sampling, inference, and disassembly of byte-codes, Scalene efficiently and precisely attributes execution time and memory usage to Python, which developers can optimize, or library code, which they cannot. Its novel sampling memory allocator efficiently reports line-level memory consumption and trends with low overhead, helping developers reduce footprints and identify leaks. Finally, Scalene reports a new metric, copy volume, that helps developers root out insidious copying costs across the Python/library boundary, which can drastically degrade performance. Scalene is available on PyPi. 
The discussion and AMA following this talk will be moderated by Ben Zorn.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Emery</first_name>
          <last_name>Berger</last_name>
          <affiliation>University of Massachusetts at Amherst, USA</affiliation>
          <bio>Emery is a Professor at the University of Massachusetts Amherst. He researches languages, runtime systems, and operating systems, with a particular focus on systems that transparently improve reliability, security, and performance. Emery and friends have created Hoard, the first scalable memory manager (malloc), on which the Mac OS X memory manager is based; DieHard, an error-avoiding memory manager that directly influenced the design of the Windows 7 Fault-Tolerant Heap; DieHarder, a secure memory manager that was an inspiration for hardening changes made to the Windows 8 heap; the Coz profiler, which ships with modern Linux distros; and more. He was named an ACM Fellow in 2019.</bio>
          <homepage_url>http://www.emeryberger.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/emeryberger/6187feeb-700c-48d5-aceb-6d7b87490a7a/small.jpg</picture_url>
          <person_id>emeryberger</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>373f228d-2693-4fa0-83bd-95c0f93aa51d</subevent_id>
    <title>SPLASH REBASE: 14</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>eaad0ba2-b12b-4703-80e8-1ee2d60931c4</slot_id>
      <title>Session: SPLASH REBASE - 14</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/17</date>
      <start_time>15:00</start_time>
      <end_time>15:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8e805bc5-89e8-4da6-ace7-cdf24ae2ea5d</slot_id>
      <event_id>3915f558-1e15-450f-b38f-222ffd9da8ca</event_id>
      <title>Quantitative Types in Idris 2</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/17</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>15:40</end_time>
      <description>Dependent types allow us to express precisely what a function is intended to do. Recent work on Quantitative Type Theory (QTT) extends dependent type systems with linearity, also allowing precision in expressing when a function can run. This is promising, because it suggests the ability to design and reason about resource usage protocols, such as we might find in distributed and concurrent programming, where the state of a communication channel changes throughout program execution. Up to now, however, there has not been a full-scale programming language with which to experiment with these ideas. Idris 2 is a new version of the dependently typed language Idris, with a new core language based on QTT, supporting linear and dependent types. In this talk I will show the benfits of QTT in Idris 2, in particular how it improves interactive program development by reducing the search space for type-driven program synthesis; and, how resource tracking in the type system leads to type-safe concurrent programming with session types. 
The discussion and AMA following this talk will be moderated by Phil Wadler.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Edwin</first_name>
          <last_name>Brady</last_name>
          <affiliation>University of St. Andrews</affiliation>
          <bio>I am a Lecturer in Computer Science at the University of St Andrews, interested in type theory, dependently typed functional programming, compilers and metaprogramming. I am currently working on a new implementation of Idris, a dependently typed functional programming language. When I’m not doing that, you might find me playing Go (I’m about 2 kyu), walking up a hill, watching a game of cricket, or waiting for a delayed train. I’m afraid I also perpetrated the Whitespace programming language.</bio>
          <homepage_url>https://eb.host.cs.st-andrews.ac.uk</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/edwinbrady/cbff36d2-7476-402e-bc2c-e84d1ceb0ab5/small.jpg</picture_url>
          <person_id>edwinbrady</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>59951e75-9819-4b3c-be3b-d4db99ccbdd5</subevent_id>
    <title>SPLASH REBASE: 12</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>bee2c3f9-aad9-40dc-ba1d-4532742b84ff</slot_id>
      <title>Session: SPLASH REBASE - 12</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/19</date>
      <start_time>01:00</start_time>
      <end_time>01:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>56094898-54bf-4e11-ad85-f6dd88cbde18</slot_id>
      <event_id>903e6b1f-a35a-40b8-a306-8d3a5bde3b5e</event_id>
      <title>Towards the tower of Babel: a Polyglot Language VM in Java</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/19</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>01:40</end_time>
      <description>Meet the GraalVM, a technology you can use to build composable high-performance language implementations and tools. Most production-level virtual machines duplicate their target language’s semantics in the interpreter, in the compiler, and in the runtime system. This violates DRY and is hell on the maintainers as the target evolves. In contrast, Truffle lets you define languages by simply writing their interpreter. That interpreter can be seamlessly combined with interpreters of different languages in a single just-in-time compilation unit. By treating the host language as just another language, you can reuse embeddings across languages. A language agnostic instrumentation mechanism enables us to build tools that attach cross-cutting concerns to applications with zero overhead. 
The discussion following this talk will be moderated by Eelco Visser.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christian</first_name>
          <last_name>Humer</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>Christian Humer is a researcher at Oracle Labs in Zurich, working on the GraalVM project. He develops the Truffle framework which aims to make all programming languages fast, composable and embeddable. His research interests include virtual machines, partial evaluation, and domain-specific languages. He is the main author of Truffle DSL, a domain-specific language to simplify the development of Truffle interpreters.</bio>
          <homepage_url>https://labs.oracle.com/pls/apex/f?p=LABS:bio:0:2137</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/christianhumer/7a395af3-35b6-4728-81d5-bf478224f957/small.jpg</picture_url>
          <person_id>christianhumer</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>52a13995-d6c0-47f8-93fd-3145c3655568</subevent_id>
    <title>SPLASH REBASE: 16</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>109b4cfe-94cb-457b-8237-6650026b2d30</slot_id>
      <title>Session: SPLASH REBASE - 16</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>19:00</start_time>
      <end_time>19:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e3960dcd-d0ed-400e-a526-01408aa8fee8</slot_id>
      <event_id>f8bcf094-fae6-48e2-b07b-243759ea945b</event_id>
      <title>Miniaturize All States!</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>19:40</end_time>
      <description>Like science, software is in reproducibility crisis. All too often, “steps to reproduce” in bug reports don’t work or are too long and complicated. They shouldn’t be necessary to begin with. Fleets of servers suffer from constant “configuration drift”, making any incremental change to their state hazardous. Will an upgrade that worked yesterday work today? Will it work for you if it worked for me? We’re never quite sure. Lack of reproducibility hinders sharing, from lab reports to bug reports to build instructions to software packages to cloud infrastructure. The solution: miniaturizing the inputs to your lab experiment and to your build bots, the state of your laptop and of your resources in the cloud, using precise, shareable, composable declarative specifications. 
The talk is moderated by Artem Pelenitsyn.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mathieu</first_name>
          <last_name>Boespflug</last_name>
          <affiliation>Tweag I/O</affiliation>
          <bio>Mathieu is the CEO of Tweag I/O, an independent industrial lab helping startups and research groups within the enterprise boldly ship high-risk, high-reward digital products. He was involved in European initiatives for exascale storage, worked on build systems, programming language interop and compilers. In a previous life, Mathieu was a researcher in formal methods and programming language design. He has a PhD from École Polytechnique.</bio>
          <homepage_url>https://www.linkedin.com/in/mboes</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mathieuboespflug/d01c0846-8cf1-41ab-bbbd-2aa6beba122b/small.jpg</picture_url>
          <person_id>mathieuboespflug</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c8596b01-f09c-4d8a-a808-33e4aec7a9ce</subevent_id>
    <title>SPLASH REBASE: 1</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>8f336250-1be9-4a38-8ade-e09b33509d4d</slot_id>
      <title>Session: SPLASH REBASE - 1</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/15</date>
      <start_time>09:00</start_time>
      <end_time>09:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ecb7cd03-7f6e-4d8f-aa14-b1c2e9482686</slot_id>
      <event_id>910bd8ae-8e1b-40c6-af3c-b39c2bf4431b</event_id>
      <title>Move Semantics for Nim</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/15</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:40</end_time>
      <description>This talk explains Nim’s move semantics and their connection to reference counting, how Nim’s model differs from C++/Rust and why move semantics can offer superior performance. It is explained how to leverage this technology to make multi-threading safer. Nim with deterministic memory management never has been easier.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Rumpf</last_name>
          <affiliation>Freelancer</affiliation>
          <bio>Andreas is the designer of the Nim programming language, which he develops full-time with a team of developers and the help of an enthusiastic open source community. He has programmed in various languages over the years (including quite obscure ones) without being satisfied with any of them. Andreas holds a degree in Computer Science which he obtained from University of Kaiserslautern.</bio>
          <homepage_url>https://nim-lang.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andreasrumpf/4b595ba1-d534-4051-8273-b37195473412/small.jpg</picture_url>
          <person_id>andreasrumpf</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ad76bb85-804d-41e3-b37c-06e468f0dd88</subevent_id>
    <title>SPLASH REBASE: 17</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>412dd819-e73a-4bac-8adf-052a27a1e119</slot_id>
      <title>Session: SPLASH REBASE - 17</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>11:00</start_time>
      <end_time>11:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b4f41074-bcd2-4b11-b0ac-dd29a3757ff0</slot_id>
      <event_id>737532d5-e146-4b76-8463-400864a7a121</event_id>
      <title>Paradigms Without Progress: Kuhnian Reflections on Programming Practice</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>11:40</end_time>
      <description>Borrowing from Thomas Kuhn’s definition of a paradigm, Robert Floyd introduced the notion of a programming paradigm in his 1978 Turing Award acceptance speech. Ever since, this idea has infected the software world, becoming an organizing principle for jobs, conferences, and research. But further than that, it has become a ground for interminable debate and disagreement. In order to help us understand this unfortunate situation, we will explore Thomas Kuhn’s notion of a paradigm. Kuhn’s paradigm is much richer than our ordinary everyday understanding; it is not merely a way of approaching problems, but is itself the system in which problems are made intelligible. We will discover the ways in which paradigm is apt for discussing the activities of the software world, and the ways in which our usage of the word deviates from its history. We will then explore these insights showing how they might apply in specific circumstances not typically considered. Finally, we will talk about philosophy’s place in computer science’s practice and possible avenues for further exploration. 
What you will learn 
We will not focus on the substance of debate between the various partisans of programming paradigms (object oriented, functional, and imperative being the most popular). Nor will we try to bridge the gap, finding some synthesis to make all parties agree. Instead we will explore the philosophy of science background that gave rise to these ideas. Focusing primarily on Thomas Kuhn, we will explore the notion of a paradigm and the ways in which paradigms are created, maintained, and discarded. Next we will evalute the ways in which our usage of paradigm aligns with Kuhn’s. We will consider the ways in which this alignment impacts these programming paradigms debates and further consider Kuhn’s notion of incommensurability. Can we borrow insights from the history of science to better understand our own practices? Can find a compelling reason for why these interminable debates seem to plague the software world at large? Next, we will consider ways in which our usage of paradigm diverge from that of Kuhn and consider other areas of software practice where Kuhn’s ideas may apply more directly. Finally we will consider philosophy’s impact on programming. Setting aside the ever popular discussions around Artificial Intelligence, we will begin by exploring how philosophy shaped foundational elements of computer science. We will explore under appreciated applications, especially those insights from Turing Award winner Peter Naur. Finally, we will look at areas where further insights may be gained in the future. 
The discussion following this talk will be moderated by Robert Biddle.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jimmy</first_name>
          <last_name>Miller</last_name>
          <affiliation>Adzerk</affiliation>
          <bio>Jimmy is a Senior Software Engineer at Adzerk where he uses Clojure to build data transformation and analysis systems. In his spare time he enjoys exploring programming language theory, reading analytic philosophy, and writing code that no one will ever use.</bio>
          <homepage_url>https://jimmyhmiller.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jimmymiller/820df0a6-b4ae-4b50-90b7-9a7ac0965e99/small.jpg</picture_url>
          <person_id>jimmymiller</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2d6d8215-54be-45b3-8067-13a15a3ead79</subevent_id>
    <title>SPLASH REBASE: 29</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>7c7df92e-d291-4409-b483-b59ac71e4b3d</slot_id>
      <title>Session: SPLASH REBASE - 29</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/20</date>
      <start_time>11:00</start_time>
      <end_time>11:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>502c7df7-70a4-4fc6-8c07-d55826005cc9</slot_id>
      <event_id>0b5c7264-a9ac-43c5-b25b-baff765650af</event_id>
      <title>Co-Design for High-Performance Computing Software Systems</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/20</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>11:40</end_time>
      <description>High-performance computing (HPC) systems are designed for pursuing extreme-scale parallelism and computational power to accelerate various computational-expensive applications in scientific computing. HPC software stack is deep and wide, mainly due to the complex computational requirements from various domain-specific algorithms and the diverse capacities provided by the underlying hardware architecture. For instance, domain-specific language or multi-layer runtime library is a common approach for developers to decouple the complex scientific algorithms from parallel programming (i.e., deep). To fully utilize different hardware components, different parallel programming models and runtime subsystems often coexist in an application software stack such as the popular MPI + “X” programming model (i.e., wide). Although abstraction allows developers and researchers to isolate innovations for different software components, experiences have indicated that co-design is the key strategy to achieve exascale computing and beyond. Co-design across the deep and wide HPC software stack is a very challenging task. However, the potential performance gain can be significant. In this talk, I will share the experiences and insights from several projects that explored the co-design approach across applications and parallel runtime subsystems. 
The discussion following this talk will be moderated by Mary Hall.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Min</first_name>
          <last_name>Si</last_name>
          <affiliation>Argonne National Laboratory</affiliation>
          <bio>Dr. Min Si is an Assistant Computer Scientist at Argonne National Laboratory working with the Programming Models and Runtime Systems group. Min’s research interests include communication runtime in high-performance computing and parallel programming models. Min was previously an Enrico Fermi Postdoctoral Scholar of Argonne National Laboratory. She received the Ph.D. degree in computer science from the University of Tokyo. Her doctoral dissertation focused on the optimization of high performance message passing communication on massively parallel multi-/many-core architectures. Min is the recipient of the 2018 IEEE-CS Technical Consortium on High Performance Computing (TCHPC) Early Career Researchers Award for Excellence in High Performance Computing, and won the Karsten Schwan Best Paper Award at HPDC 2018.</bio>
          <homepage_url>https://www.mcs.anl.gov/~minsi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/minsi/b566ccd5-1498-4770-923d-94635bfad191/small.jpg</picture_url>
          <person_id>minsi</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>281f401d-a0c3-4a33-950b-e4a70729429d</subevent_id>
    <title>SPLASH REBASE: 25</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>4cca2560-a0d7-465e-bd72-1d42fa0175e8</slot_id>
      <title>Session: SPLASH REBASE - 25</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/20</date>
      <start_time>05:00</start_time>
      <end_time>05:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>92c6aa5e-2cde-4f4c-94ba-c2ca72048f65</slot_id>
      <event_id>eb49d071-bd76-4216-8ac6-0fc3cf3a7f99</event_id>
      <title>Enterprise-scale static analysis: A Pinpoint experience</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/20</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>05:40</end_time>
      <description>Despite years of research and practice, modern static analysis techniques still cannot detect oldest and extremely well understood software bugs such as the Heartbleed, one of the most “spectacular” security flaws of the recent decade. A remedy, as what we have attempted through the successful commercialization of the Pinpoint platform (PLDI 18), is to make static program analysis aware of the basic characteristics of the modern enterprise-scale software system. The talk focuses on discussing these characteristics and how Pinpoint addresses them pragmatically as well as its future directions. Pinpoint is a LLVM-based cross-language static analysis platform and deployed in major Chinese tech companies such as Tencent, Baidu, Huawei, and Alibaba. 
The discussion following this talk will be moderated by Shan Lu.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Charles</first_name>
          <last_name>Zhang</last_name>
          <affiliation>The Hong Kong University of Science and Technology</affiliation>
          <bio>My general research interest centers around the use of both static and dynamic programming analysis techniques for making complex software systems more secure and reliable. I’m an Associate Professor and director of the Cybersecurity Lab at HKUST. My research received an ICSE and a PLDI distinguished paper award, as well as the ACM SIGSOFT Doctoral Dissertation Award, and IBM PhD fellowships. I co-founded and served as the chairman of Sourcebrella Inc, a static analysis tool vendor.</bio>
          <homepage_url>http://www.cse.ust.hk/~charlesz</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/charleszhang/059321fa-d896-44bf-b4a8-02ec597c0b3b/small.jpg</picture_url>
          <person_id>charleszhang</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2c1ad239-8a92-4038-bc1b-5adae9f50edf</subevent_id>
    <title>SPLASH REBASE: 30</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>ba185812-5f2b-46ae-a4bb-2960aaf2d9a1</slot_id>
      <title>Session: SPLASH REBASE - 30</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/20</date>
      <start_time>13:00</start_time>
      <end_time>13:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a5428976-4028-4b07-b6c6-0adf43015ae2</slot_id>
      <event_id>31254170-da2a-4537-8030-95b74ed3df9d</event_id>
      <title>Variant analysis</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/20</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>13:40</end_time>
      <description>In security, ‘variant analysis’ is the process of searching for variants of known vulnerabilities. This used to be done with grep and painstaking manual code audits, but it can be automated with a powerful semantic query language like CodeQL. The idea of such a query language had been around in academic research for a long time, but we had to create a startup named Semmle to make CodeQL reality. Semmle was acquired by GitHub in September 2019. I’ll show with a few in-depth examples how security researchers have used the CodeQL product to find and fix many vulnerabilities in popular open source projects. I’ll also discuss why the focus on variant analysis was a critical step in making Semmle a successful startup company. Finally, I’ll explain why the experience of creating Semmle and CodeQL convinced me that blue skies research goes fastest with user needs driving the research agenda. 
The discussion and AMA following this talk will be moderated by Satish Chandra.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Oege</first_name>
          <last_name>de Moor</last_name>
          <affiliation>Semmle</affiliation>
          <bio>Oege de Moor is the CEO and Founder of Semmle. Semmle’s mission is to secure the software that runs the world. From 1994 to 2014, Oege was a professor of computer science at the University of Oxford, where he did research in programming languages and tools. Semmle’s products are used by Microsoft, Google, NASA, NASDAQ, Credit Suisse, Dell, and many other leading software organisations. It has offices in Oxford, Copenhagen, Valencia, New York, San Francisco and Seattle. The technology at Semmle is a fun combination of deep theory (if you like lattice theory, you’ll like our engine), good engineering (making it work on some of the largest code bases on the planet) and cool applications (like the 0-days we report in open source). Semmle is always on the look-out for new team members.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/oegedemoor/8ea496f6-779b-47b3-9df9-6e7d2ad698eb/small.jpg</picture_url>
          <person_id>oegedemoor</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a89dc9b7-acdc-4e1d-87b7-9450bf78cd2c</subevent_id>
    <title>SPLASH REBASE: 5</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>3dbfb017-faee-42b7-b263-d9b21c2ccd00</slot_id>
      <title>Session: SPLASH REBASE - 5</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/15</date>
      <start_time>17:00</start_time>
      <end_time>17:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>be1ae549-530d-4547-b581-525cf4ffa505</slot_id>
      <event_id>04f10f98-8485-40ec-8ac4-3c6c4925b7b5</event_id>
      <title>APIs are Illness and Cure: The Software Heterogeneity Problem in Web Programming</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/15</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>17:40</end_time>
      <description>It is easier than ever before to build complex web applications. But developer tooling for understanding, testing, and maintaining these systems has not caught up. Something I heard over and over again when starting Akita was that developers could log, measure, monitor, but they have a hard time understanding what was really going on with their software systems. A major challenge comes from the fact that modern web applications run across many heterogenous components, often communicating via remote procedure calls. Current software analysis methods do not work here, as network calls across heterogeneous components subvert language-level modelings. And using network tools alone do not yield the full picture. The result is that developers end up piecing the whole story together through reading code, logs, and documentation. At Akita, we observe that network-based application programming interfaces (APIs) are both a root cause of what we call the Software Heterogeneity Problem—and also the key to the solution. The proliferation of APIs for both internal and external use, with the rise of service-oriented architectures and the growth of the API economy, have made it easy to quickly build applications that are amalgams of cross-service network calls. At the same time, there is consolidation around a handful of interface definition languages for web APIs. This makes it possible for us to address the Software Heterogeneity problem by applying programming languages techniques at the API layer. In this talk, I will introduce the Software Heterogeneity Problem, show how we at Akita are solving this problem at the API layer, and outline API-level PL problems we can solve as a community. 
The discussion and AMA for this talk will be moderated by Satish Chandra.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jean</first_name>
          <last_name>Yang</last_name>
          <affiliation>Akita Software</affiliation>
          <bio>Hi there. I’m Jean. I started Akita because I wanted to build practical, principled tooling for modern software systems. I’ve spent my career in pursuit of better software tools. I grew up programming—and it felt like magic that a kid like me could just conjure software. In college, I fell in love with programming tools: helping people make magic faster felt like pretty much the coolest thing a person could do. This was why I got my PhD in programming languages, at MIT. After that, I was a tenure-track professor at Carnegie Mellon University. The whole time I was in research, I wanted to build tools that could majorly help practicing software developers. Early in my PhD, I got obsessed with two problems around this that I couldn’t solve using application-level techniques. First, the legacy software problem: you can’t just easily port most code to a fancy new language or type system. And even if you could, you run into the second problem: the heterogeneity of software systems. Modern software is an ecosystem, with your data stores, data streams, services, and third-party APIs. This is how I became obsessed with APIs: APIs let you encapsulate any code written in any language—and you can apply language design principles, just one zoom level up. This is why, while at CMU, I started doing research about APIs. This takes us to Spring 2018. Cambridge Analytica happened. GDPR was just about to come out. I realized that we were entering into a new era of software, where people were realizing that not having visibility or control over your software can hold you back in a major way. I called everyone on my LinkedIn who would talk to me and asked them about their tooling needs. When I realized there were big and interesting problems I was uniquely positioned to solve with my API tooling ideas, I just couldn’t miss out on the action. I took leave from CMU, sold my furniture, and drove across the country to the Bay Area to start Akita.</bio>
          <homepage_url>http://jeanyang.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeanyang/be7879c9-e0d3-4a7c-af5c-7aec4693cc67/small.jpg</picture_url>
          <person_id>jeanyang</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>90c2ac04-3fb6-4d05-8cae-b62804efb6b6</subevent_id>
    <title>SPLASH REBASE: 25</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>c0524c08-96bf-4fe6-a5c4-502795e0ac12</slot_id>
      <title>Session: SPLASH REBASE - 25</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/19</date>
      <start_time>17:00</start_time>
      <end_time>17:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ba880232-4415-45c8-8e0b-52b094937484</slot_id>
      <event_id>eb49d071-bd76-4216-8ac6-0fc3cf3a7f99</event_id>
      <title>Enterprise-scale static analysis: A Pinpoint experience</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/19</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>17:40</end_time>
      <description>Despite years of research and practice, modern static analysis techniques still cannot detect oldest and extremely well understood software bugs such as the Heartbleed, one of the most “spectacular” security flaws of the recent decade. A remedy, as what we have attempted through the successful commercialization of the Pinpoint platform (PLDI 18), is to make static program analysis aware of the basic characteristics of the modern enterprise-scale software system. The talk focuses on discussing these characteristics and how Pinpoint addresses them pragmatically as well as its future directions. Pinpoint is a LLVM-based cross-language static analysis platform and deployed in major Chinese tech companies such as Tencent, Baidu, Huawei, and Alibaba. 
The discussion following this talk will be moderated by Shan Lu.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Charles</first_name>
          <last_name>Zhang</last_name>
          <affiliation>The Hong Kong University of Science and Technology</affiliation>
          <bio>My general research interest centers around the use of both static and dynamic programming analysis techniques for making complex software systems more secure and reliable. I’m an Associate Professor and director of the Cybersecurity Lab at HKUST. My research received an ICSE and a PLDI distinguished paper award, as well as the ACM SIGSOFT Doctoral Dissertation Award, and IBM PhD fellowships. I co-founded and served as the chairman of Sourcebrella Inc, a static analysis tool vendor.</bio>
          <homepage_url>http://www.cse.ust.hk/~charlesz</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/charleszhang/059321fa-d896-44bf-b4a8-02ec597c0b3b/small.jpg</picture_url>
          <person_id>charleszhang</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d1ceef15-ea86-41b7-97f9-09c711066091</subevent_id>
    <title>SPLASH REBASE: 22</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>9af27c73-2e24-48d6-9854-0b20099029bf</slot_id>
      <title>Session: SPLASH REBASE - 22</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/19</date>
      <start_time>11:00</start_time>
      <end_time>11:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0e7001b7-a203-4748-b093-803bd69d06ec</slot_id>
      <event_id>dc0729ca-9f38-4990-9628-8170b60af78e</event_id>
      <title>Intermittent Computer Systems on Earth and in Space</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/19</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>11:40</end_time>
      <description>Intermittent computing is an emerging computational model that allows software to operate reliably on devices that harvest energy from their environment. Energy-harvesting frees devices from the need for batteries, battery replacements, tethered power, and regular maintenance, enabling deployment to far remote installations, such as in civil infrastructure and outer space. This does not come for free: power failures impede progress and can leave a system’s memory and execution state inconsistent. Unpredictable future energy availability, and the difficulty of precisely characterizing device power consumption makes building a reliable intermittent system a challenge. I describe our experience with intermittent computing. I describe our recent efforts to mathematically formalize the behavior of intermittent software execution, and lessons learned from these formal modeling efforts. I discuss concrete incarnations of our intermittent and energy-harvesting computing results: a terrestrial, long-range batteryless camera system with the ability to do on-device machine learning and transmit over 10km distances with no batteries and two tiny, intermittent computing nanosatellites that sense, compute on sensor data, and communicate with Earth. 
The discussion following this talk will be moderated by Mike Bond.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Brandon</first_name>
          <last_name>Lucia</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Brandon is a Professor at Carnegie Mellon University working on hardware and software computer systems to answer the question: “How capable can a computing system be, given physical restrictions on its form factor, input power, energy storage, or other resource constraints?” His research has been recognized with 8 best paper awards, the 2019 IEEE TCCA Young Computer Architect Award and the 2015 Bell Labs Prize.</bio>
          <homepage_url>http://brandonlucia.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brandonlucia/e10fc900-d74f-44e7-a793-5e2f21a7dd0b/small.jpg</picture_url>
          <person_id>brandonlucia</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1dc261ca-c682-49ea-84cc-b9826da542b6</subevent_id>
    <title>SPLASH REBASE: 6</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>122b6c78-dd81-4895-ba8b-21e372c50dc0</slot_id>
      <title>Session: SPLASH REBASE - 6</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>07:00</start_time>
      <end_time>07:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e3d053d8-a95e-4ecb-ba59-385525e014d7</slot_id>
      <event_id>f62da32e-6fe2-4aae-a89f-747447ef4bac</event_id>
      <title>Reliable Stack Traces, the Reality of Myth</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>07:40</end_time>
      <description>Debug information is a hidden and obscure component of our computing infrastructure obviously used by debuggers, but also playing a key role in program analysis tools, and, most surprisingly, in the runtime of programming languages. For instance C++ leverages DWARF stack unwind tables to implement exceptions! Alas, generating debug information adds significant burden to compilers, and the debug info itself can be pervaded by subtle bugs, making the whole infrastructure unreliable. Additionally, interpreting the debug tables is a bottleneck. My talk focuses on the DWARF unwind table, that enables stack unwinding in absence of frame-pointer information. I show two techniques to perform validation and synthesis of unwinding tables, and their implementation for x86_64. Our validator has proven effective for compiler and inline assembly testing, while the synthesis tool can generate unwind tables for arbitrary binaries lacking debug information. Additionally, I will report on a technique to precompile unwind tables into native x86_64 code, which we have implemented and integrated into libunwind, resulting in a 25x DWARF-based unwind speedup. 
The discussion and AMA following the talk will be moderated by Christoph Kirsch and Robert Grimm.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Zappa Nardelli</last_name>
          <affiliation>Facebook</affiliation>
          <bio>My work is at boundaries between programming languages, system programming, and computer architectures, with the overall goal of producing systems which are better-understood, more robust, and more secure.</bio>
          <homepage_url>https://fzn.fr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/francescozappanardelli/e7d164ff-66ed-4309-b99f-60e2f77f7b02/small.jpg</picture_url>
          <person_id>francescozappanardelli</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>93ab618f-38c3-41ec-84da-e489b559bd0e</subevent_id>
    <title>SPLASH REBASE: 4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>d2c44eaf-3742-4249-b404-2a1094d2869b</slot_id>
      <title>Session: SPLASH REBASE - 4</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>01:00</start_time>
      <end_time>01:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>28f00528-e62f-45d5-9f30-893405c4b3bd</slot_id>
      <event_id>9ca583dd-05ba-44fc-b913-6a78719ea4e0</event_id>
      <title>A Ray of Hope: Array Programming for the 21st Century</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>01:40</end_time>
      <description>The ideas of APL and its successors, the array programming languages, were two generations ahead of their time.&amp;nbsp; These languages are based on the notion that everything is a tensor, and all operations are rank-polymorphic: they extend automatically to tensors of any rank. These ideas are perfectly suited to an era of machine learning, large scale data, GPUs and other accelerators. Building on recent academic research, we are building ShapeRank, a new statically typed, purely functional language for industrial use, that extends rank-polymorphism to streams. We’ll introduce the key ideas and show how they are realized in ShapeRank.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gilad</first_name>
          <last_name>Bracha</last_name>
          <affiliation>F5 Networks</affiliation>
          <bio>Gilad Bracha is the creator of the Newspeak programming language and a well known researcher in the area of object-oriented programming languages. He was awarded the senior Dahl-Nygaard prize in 2017. Previously, he has worked at Google, as a VP at SAP Labs in Palo Alto, a Distinguished Engineer at Cadence, and a Computational Theologist and Distinguished Engineer at Sun. He has authored or co-authored several books including the Java Language and Virtual Machine Specifications, and the Dart Programming Language. Prior to joining Sun, he worked on Strongtalk, the Animorphic Smalltalk System. He received his B.Sc in Mathematics and Computer Science from Ben Gurion University in Israel and a Ph.D. in Computer Science from the University of Utah.</bio>
          <homepage_url>https://bracha.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/giladbracha/66fe962c-9388-4df3-aaaa-677a8e2e64df/small.jpg</picture_url>
          <person_id>giladbracha</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>03a8bcb6-ef58-4382-b484-d92d9776fb4e</subevent_id>
    <title>SPLASH REBASE: 13</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>49709cee-89ce-42e9-8a7c-0f6a83a15158</slot_id>
      <title>Session: SPLASH REBASE - 13</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/17</date>
      <start_time>13:00</start_time>
      <end_time>13:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>93ca958a-5ffd-4242-8785-dd91bf50965d</slot_id>
      <event_id>e076a4e6-6258-4908-8dc8-3802e89a0f59</event_id>
      <title>Developing the Wolfram Language Compiler</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/17</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:40</end_time>
      <description>The Wolfram Language is a high level computation language used in many technical, scientific, engineering, mathematical, and computing fields. It is widely used in practice and, in particular, it is the foundation of Wolfram Mathematica and Wolfram Alpha. This talk describes the Wolfram Language Compiler; a long term project for compilation of Wolfram programs. The talk will show how clever use of parametric types, code specialization, and optimization techniques allow compilation of Wolfram Language programs to achieve performance that rivals hand-tuned C code. It will show how the compiler enables features for scientific computation (such as automatic differentiation) and how it provides a key new implementation layer for future development of the language. It will also show how the type system allows disambiguating and optimizing function calls despite seemingly ambiguous input. Finally, it will demonstrate how the Wolfram compiler is used to target specialized output such as WebAssembly) or accelerators (e.g. CUDA or FPGAs). 
The discussion following this talk will be moderated by Tomas Kalibera.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tom</first_name>
          <last_name>Wickham-Jones</last_name>
          <affiliation>Wolfram Research, Inc.</affiliation>
          <bio>Tom Wickham-Jones has worked for Wolfram Research on the implementation of Mathematica since 1990. He is currently the Director of Kernel Technology. He has worked on many details of the Mathematica programming language, as well as other areas such as graphics. In addition he is the architect of webMathematica and Wolfram Workbench. In 1992 he published the book Mathematica Graphics: Techniques and Applications. His most recent work has focused on the Mathematica compiler and parallel computation.</bio>
          <homepage_url>https://www.linkedin.com/in/tom-wickham-jones-a452777</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomwickhamjones/21c29c5a-05a7-4519-9853-7f0b38511ed9/small.jpg</picture_url>
          <person_id>tomwickhamjones</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bf227431-8525-4654-aaf7-60679c07b2aa</subevent_id>
    <title>SPLASH REBASE: 20</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>8fb8a3a7-1528-4ea6-bb6d-24bc4fd988cf</slot_id>
      <title>Session: SPLASH REBASE - 20</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>17:00</start_time>
      <end_time>17:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7d8eee74-943d-4ee4-a6b9-beccd5ddbe6f</slot_id>
      <event_id>4b457c84-3b99-44ca-afaa-f1811e462b6e</event_id>
      <title>Tales from the Frontlines: Startup War Stories</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>17:40</end_time>
      <description>Can one build the Hotspot VM, the Azul GC and the H20 big data engine without getting into the occasional battle and making a mistake or two? This talk distill the lessons of success and wrings wisdom out of failures over three decades in the industy. 
The discussion and AMA following this talk will be moderated by Doug Lea.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cliff</first_name>
          <last_name>Click</last_name>
          <affiliation>Self</affiliation>
          <bio>Cliff Click was the CTO and Co-Founder of H2O, makers of H2O, the open source math and machine learning engine for Big Data. Cliff wrote his first compiler when he was 15 (Pascal to TRS Z-80!), although Cliff’s most famous compiler is the HotSpot Server Compiler (the Sea of Nodes IR). Cliff helped Azul Systems build an 864 core pure-Java mainframe that keeps GC pauses on 500Gb heaps to under 10ms, and worked on all aspects of that JVM. Before that he worked on HotSpot at Sun Microsystems, and was at least partially responsible for bringing Java into the mainstream. Cliff is invited to speak regularly at industry and academic conferences and has published many papers about HotSpot technology. He holds a PhD in Computer Science from Rice University and about 20 patents.</bio>
          <homepage_url>http://cliffc.org/blog/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cliffclick/73d11404-ae6e-4004-80e3-b75f7f40656b/small.jpg</picture_url>
          <person_id>cliffclick</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>70e64597-f8bb-4aed-81f0-f1873647ca1f</subevent_id>
    <title>SPLASH REBASE: 13</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>2cddbd0f-cf81-4749-8a48-7745a8c8bb85</slot_id>
      <title>Session: SPLASH REBASE - 13</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>01:00</start_time>
      <end_time>01:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>77fc7582-3b07-4b4d-a619-bc4e24bcb44e</slot_id>
      <event_id>e076a4e6-6258-4908-8dc8-3802e89a0f59</event_id>
      <title>Developing the Wolfram Language Compiler</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:40</end_time>
      <description>The Wolfram Language is a high level computation language used in many technical, scientific, engineering, mathematical, and computing fields. It is widely used in practice and, in particular, it is the foundation of Wolfram Mathematica and Wolfram Alpha. This talk describes the Wolfram Language Compiler; a long term project for compilation of Wolfram programs. The talk will show how clever use of parametric types, code specialization, and optimization techniques allow compilation of Wolfram Language programs to achieve performance that rivals hand-tuned C code. It will show how the compiler enables features for scientific computation (such as automatic differentiation) and how it provides a key new implementation layer for future development of the language. It will also show how the type system allows disambiguating and optimizing function calls despite seemingly ambiguous input. Finally, it will demonstrate how the Wolfram compiler is used to target specialized output such as WebAssembly) or accelerators (e.g. CUDA or FPGAs). 
The discussion following this talk will be moderated by Tomas Kalibera.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tom</first_name>
          <last_name>Wickham-Jones</last_name>
          <affiliation>Wolfram Research, Inc.</affiliation>
          <bio>Tom Wickham-Jones has worked for Wolfram Research on the implementation of Mathematica since 1990. He is currently the Director of Kernel Technology. He has worked on many details of the Mathematica programming language, as well as other areas such as graphics. In addition he is the architect of webMathematica and Wolfram Workbench. In 1992 he published the book Mathematica Graphics: Techniques and Applications. His most recent work has focused on the Mathematica compiler and parallel computation.</bio>
          <homepage_url>https://www.linkedin.com/in/tom-wickham-jones-a452777</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomwickhamjones/21c29c5a-05a7-4519-9853-7f0b38511ed9/small.jpg</picture_url>
          <person_id>tomwickhamjones</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>947127c4-e78b-4f98-8e17-ddbbbf3f519c</subevent_id>
    <title>SPLASH REBASE: 8</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>5d5f1c1a-c3c6-4880-9020-d803accbd389</slot_id>
      <title>Session: SPLASH REBASE - 8</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>23:00</start_time>
      <end_time>23:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e2d50cc1-354c-4541-b1d6-9d002b364a9c</slot_id>
      <event_id>9909752f-2f85-4ed3-abab-a13ebbc9e912</event_id>
      <title>Herding Nulls in Dart</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:40</end_time>
      <description>The programming language Dart is about to introduce sound null safety, which involves a bundle of language mechanisms associated with null as a typing property. This talk presents these mechanisms, including nullable types, late variables, type promotion, null shorting, and the handling of programs with both legacy and null safe libraries. 
The discussion and AMA following this talk will be moderated by Joe Pamer and Erik Meijer. No recording will be available.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Erik</first_name>
          <last_name>Ernst</last_name>
          <affiliation>Google LLC</affiliation>
          <bio>Erik Ernst is a member of the Dart language team at Google, maintaining the language specification. He has been an associate professor at Aarhus University. He has published research on virtual classes, establishing that they can be statically safe. He introduced family polymorphism, which is foundational for path dependent types, and he contributed to the introduction of generics is Java.</bio>
          <homepage_url>https://scholar.google.com/citations?user=L-i5BHcAAAAJ&amp;hl=en</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/erikernst/dbb8033d-763a-4571-90ef-c750ed5f597b/small.jpg</picture_url>
          <person_id>erikernst</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3c18ec84-815a-4d1c-ad30-8c482dda958b</subevent_id>
    <title>SPLASH REBASE: 16</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>2434986c-0885-4bed-9226-566ed4d284d9</slot_id>
      <title>Session: SPLASH REBASE - 16</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>07:00</start_time>
      <end_time>07:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5a6177c9-0085-44f8-ae73-ef07867b86db</slot_id>
      <event_id>f8bcf094-fae6-48e2-b07b-243759ea945b</event_id>
      <title>Miniaturize All States!</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>07:40</end_time>
      <description>Like science, software is in reproducibility crisis. All too often, “steps to reproduce” in bug reports don’t work or are too long and complicated. They shouldn’t be necessary to begin with. Fleets of servers suffer from constant “configuration drift”, making any incremental change to their state hazardous. Will an upgrade that worked yesterday work today? Will it work for you if it worked for me? We’re never quite sure. Lack of reproducibility hinders sharing, from lab reports to bug reports to build instructions to software packages to cloud infrastructure. The solution: miniaturizing the inputs to your lab experiment and to your build bots, the state of your laptop and of your resources in the cloud, using precise, shareable, composable declarative specifications. 
The talk is moderated by Artem Pelenitsyn.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mathieu</first_name>
          <last_name>Boespflug</last_name>
          <affiliation>Tweag I/O</affiliation>
          <bio>Mathieu is the CEO of Tweag I/O, an independent industrial lab helping startups and research groups within the enterprise boldly ship high-risk, high-reward digital products. He was involved in European initiatives for exascale storage, worked on build systems, programming language interop and compilers. In a previous life, Mathieu was a researcher in formal methods and programming language design. He has a PhD from École Polytechnique.</bio>
          <homepage_url>https://www.linkedin.com/in/mboes</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mathieuboespflug/d01c0846-8cf1-41ab-bbbd-2aa6beba122b/small.jpg</picture_url>
          <person_id>mathieuboespflug</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>38269062-ab8c-4df0-b4e6-8f810e5e72e0</subevent_id>
    <title>SPLASH REBASE: 24</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>7dc201fd-9d71-40d2-8297-65f44bc68e41</slot_id>
      <title>Session: SPLASH REBASE - 24</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/19</date>
      <start_time>15:00</start_time>
      <end_time>15:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>63e997e3-d18e-44eb-bff7-9b9d20dcd2c4</slot_id>
      <event_id>e57184bb-0544-49be-bf26-5c1369670c39</event_id>
      <title>On the Future of Flight Software</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/19</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>15:40</end_time>
      <description>In recent years, mishaps in commercial aviation have been predominantly due to software; meanwhile software continues to grow more complex. Combining this with the on-going trend toward converting aviation hardware and mechanical systems to software, and the popular claim that aircraft are already more than half software, it is clear that the future of flight software faces a formidable challenge. The FAA provides regulations through documents such as DO-333, but little guidance as to how to achieve them. In short: for software to be certified to fly, the chance of a safety-critical failure must be less than one in a billion. So how do we do that? Particularly how do we achieve a sustainable, scalable schema for future avionics? We will overview the difficulties that face fabricating formidable flight software, break out the challenges facing future flight software, and pose possibilities for boldly going where no software has gone before. 
The discussion following this talk will be moderated by Luke Ziarek.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kristin</first_name>
          <last_name>Yvonne Rozier</last_name>
          <affiliation>Iowa State University</affiliation>
          <bio>NSF CAREER Award winner and recipient of the Inaugural Initiative-Inspiration-Impact Award from Women in Aerospace, Kristin Yvonne Rozier joined the faculty of the Aerospace Engineering and CS in Fall, 2016. Previous to that she spent 14 years as a Research Scientist at NASA. She contributed research to the Aeroacoustics, and Safety-Critial Avionics groups and to the Robust Software Engineering, and Discovery and Systems Health groups in the Intelligent Systems Division. Most recently, Rozier was a primary contributing researcher to the Next Generation Air Transportation System (NextGen) Air Traffic Management project of the Airspace Systems Program at NASA. She also served as Principal Investigator of an ARMD Seedling project advancing System and Safety Health Management for Unmanned Aerial Systems (UAS).</bio>
          <homepage_url>https://www.aere.iastate.edu/kyrozier/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/kristinyvonnerozier/6da96576-6d4d-492d-8631-0d8ef350b15a/small.jpg</picture_url>
          <person_id>kristinyvonnerozier</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9ae02012-545e-42d5-a4b2-7021174609a9</subevent_id>
    <title>SPLASH REBASE: 5</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>d0a525a0-27df-429c-a06b-58925cb6f79e</slot_id>
      <title>Session: SPLASH REBASE - 5</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>05:00</start_time>
      <end_time>05:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>97cb1ee1-7e4e-4fba-9bd6-306c8705ac98</slot_id>
      <event_id>04f10f98-8485-40ec-8ac4-3c6c4925b7b5</event_id>
      <title>APIs are Illness and Cure: The Software Heterogeneity Problem in Web Programming</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>05:40</end_time>
      <description>It is easier than ever before to build complex web applications. But developer tooling for understanding, testing, and maintaining these systems has not caught up. Something I heard over and over again when starting Akita was that developers could log, measure, monitor, but they have a hard time understanding what was really going on with their software systems. A major challenge comes from the fact that modern web applications run across many heterogenous components, often communicating via remote procedure calls. Current software analysis methods do not work here, as network calls across heterogeneous components subvert language-level modelings. And using network tools alone do not yield the full picture. The result is that developers end up piecing the whole story together through reading code, logs, and documentation. At Akita, we observe that network-based application programming interfaces (APIs) are both a root cause of what we call the Software Heterogeneity Problem—and also the key to the solution. The proliferation of APIs for both internal and external use, with the rise of service-oriented architectures and the growth of the API economy, have made it easy to quickly build applications that are amalgams of cross-service network calls. At the same time, there is consolidation around a handful of interface definition languages for web APIs. This makes it possible for us to address the Software Heterogeneity problem by applying programming languages techniques at the API layer. In this talk, I will introduce the Software Heterogeneity Problem, show how we at Akita are solving this problem at the API layer, and outline API-level PL problems we can solve as a community. 
The discussion and AMA for this talk will be moderated by Satish Chandra.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jean</first_name>
          <last_name>Yang</last_name>
          <affiliation>Akita Software</affiliation>
          <bio>Hi there. I’m Jean. I started Akita because I wanted to build practical, principled tooling for modern software systems. I’ve spent my career in pursuit of better software tools. I grew up programming—and it felt like magic that a kid like me could just conjure software. In college, I fell in love with programming tools: helping people make magic faster felt like pretty much the coolest thing a person could do. This was why I got my PhD in programming languages, at MIT. After that, I was a tenure-track professor at Carnegie Mellon University. The whole time I was in research, I wanted to build tools that could majorly help practicing software developers. Early in my PhD, I got obsessed with two problems around this that I couldn’t solve using application-level techniques. First, the legacy software problem: you can’t just easily port most code to a fancy new language or type system. And even if you could, you run into the second problem: the heterogeneity of software systems. Modern software is an ecosystem, with your data stores, data streams, services, and third-party APIs. This is how I became obsessed with APIs: APIs let you encapsulate any code written in any language—and you can apply language design principles, just one zoom level up. This is why, while at CMU, I started doing research about APIs. This takes us to Spring 2018. Cambridge Analytica happened. GDPR was just about to come out. I realized that we were entering into a new era of software, where people were realizing that not having visibility or control over your software can hold you back in a major way. I called everyone on my LinkedIn who would talk to me and asked them about their tooling needs. When I realized there were big and interesting problems I was uniquely positioned to solve with my API tooling ideas, I just couldn’t miss out on the action. I took leave from CMU, sold my furniture, and drove across the country to the Bay Area to start Akita.</bio>
          <homepage_url>http://jeanyang.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeanyang/be7879c9-e0d3-4a7c-af5c-7aec4693cc67/small.jpg</picture_url>
          <person_id>jeanyang</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>116bc97c-46c4-4f50-b1dc-1a0831a2cf9f</subevent_id>
    <title>SPLASH REBASE: 30</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>84089aec-329e-44fd-a394-106178a52849</slot_id>
      <title>Session: SPLASH REBASE - 30</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/21</date>
      <start_time>01:00</start_time>
      <end_time>01:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>250d32d2-3d46-4748-978b-2881bf0456d0</slot_id>
      <event_id>31254170-da2a-4537-8030-95b74ed3df9d</event_id>
      <title>Variant analysis</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/21</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>01:40</end_time>
      <description>In security, ‘variant analysis’ is the process of searching for variants of known vulnerabilities. This used to be done with grep and painstaking manual code audits, but it can be automated with a powerful semantic query language like CodeQL. The idea of such a query language had been around in academic research for a long time, but we had to create a startup named Semmle to make CodeQL reality. Semmle was acquired by GitHub in September 2019. I’ll show with a few in-depth examples how security researchers have used the CodeQL product to find and fix many vulnerabilities in popular open source projects. I’ll also discuss why the focus on variant analysis was a critical step in making Semmle a successful startup company. Finally, I’ll explain why the experience of creating Semmle and CodeQL convinced me that blue skies research goes fastest with user needs driving the research agenda. 
The discussion and AMA following this talk will be moderated by Satish Chandra.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Oege</first_name>
          <last_name>de Moor</last_name>
          <affiliation>Semmle</affiliation>
          <bio>Oege de Moor is the CEO and Founder of Semmle. Semmle’s mission is to secure the software that runs the world. From 1994 to 2014, Oege was a professor of computer science at the University of Oxford, where he did research in programming languages and tools. Semmle’s products are used by Microsoft, Google, NASA, NASDAQ, Credit Suisse, Dell, and many other leading software organisations. It has offices in Oxford, Copenhagen, Valencia, New York, San Francisco and Seattle. The technology at Semmle is a fun combination of deep theory (if you like lattice theory, you’ll like our engine), good engineering (making it work on some of the largest code bases on the planet) and cool applications (like the 0-days we report in open source). Semmle is always on the look-out for new team members.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/oegedemoor/8ea496f6-779b-47b3-9df9-6e7d2ad698eb/small.jpg</picture_url>
          <person_id>oegedemoor</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>43842c92-31f5-4b22-a784-0585fa02ba6c</subevent_id>
    <title>SPLASH REBASE: 7</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>9f0394cd-6e98-4725-ac58-a965963268dc</slot_id>
      <title>Session: SPLASH REBASE - 7</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>11:00</start_time>
      <end_time>11:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b0991f43-b304-41b2-9c49-c4133ce6a055</slot_id>
      <event_id>0afb2ceb-8556-4b8b-a17f-1c5eb0d00ffc</event_id>
      <title>Paparazzi, an open source UAV for research</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/16</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:40</end_time>
      <description>Unmanned Aerial Systems have rapidly reached the maturity allowing them to be used in many civil applications. Open-source communities and research laboratories have played an important role to this breakthrough in aviation history. I will present the Paparazzi UAV system, a research oriented fully open-source hardware and software project dedicated to mini and micro drones. Through its rich history of collaborations, I will show how our laboratory and our community have been able to contribute to various HMI innovations, rich flight plan concepts, novel aerodynamic designs, efficient and robust control algorithms and many multi-disciplinary applications spreading the usage of drones in various scientific fields. This has been made possible by seeking the right balance between innovations, experimental needs, real world operations and more fundamental contributions. Finally, I will point to some of the future challenges for light UAV systems. 
The discussion following this talk will be moderated by Yu David Liu.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gautier</first_name>
          <last_name>Hattenberger</last_name>
          <affiliation>ENAC</affiliation>
          <bio>Gautier Hattenberger is an assistant-professor at the French Civil Aviation University (ENAC) in Toulouse, France. As a member of the UAV Research Program, he is working on flight dynamics and control of micro-UAVs, modeling and simulation, architecture of embedded systems, trajectory planing and formation flight. Most of his work is based on the Open-Source UAV system “Paparazzi”, for which he is now one of the head developer. He graduate from the French national engineering school of aeronautical construction in 2004 and received his Ph.D Degree at the Robotic department of the Laboratory for Analysis and Architecture of Systems (LAAS-CNRS, Toulouse), for his work on formation flight control and planing of UAVs in 2008.</bio>
          <homepage_url>http://optim.recherche.enac.fr/?staff-member=gautier-hattenberger</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gautierhattenberger/a799856f-c948-40c1-8ee2-aab746ddb41b/small.jpg</picture_url>
          <person_id>gautierhattenberger</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>53307b8a-e386-451c-aff4-3189ce645d7f</subevent_id>
    <title>SPLASH REBASE: 29</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>0ef8812d-80ad-4365-8610-24721a7e5fa3</slot_id>
      <title>Session: SPLASH REBASE - 29</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/20</date>
      <start_time>23:00</start_time>
      <end_time>23:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>71b041b3-84fa-47fe-aecc-32716b5df0a1</slot_id>
      <event_id>0b5c7264-a9ac-43c5-b25b-baff765650af</event_id>
      <title>Co-Design for High-Performance Computing Software Systems</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/20</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>23:40</end_time>
      <description>High-performance computing (HPC) systems are designed for pursuing extreme-scale parallelism and computational power to accelerate various computational-expensive applications in scientific computing. HPC software stack is deep and wide, mainly due to the complex computational requirements from various domain-specific algorithms and the diverse capacities provided by the underlying hardware architecture. For instance, domain-specific language or multi-layer runtime library is a common approach for developers to decouple the complex scientific algorithms from parallel programming (i.e., deep). To fully utilize different hardware components, different parallel programming models and runtime subsystems often coexist in an application software stack such as the popular MPI + “X” programming model (i.e., wide). Although abstraction allows developers and researchers to isolate innovations for different software components, experiences have indicated that co-design is the key strategy to achieve exascale computing and beyond. Co-design across the deep and wide HPC software stack is a very challenging task. However, the potential performance gain can be significant. In this talk, I will share the experiences and insights from several projects that explored the co-design approach across applications and parallel runtime subsystems. 
The discussion following this talk will be moderated by Mary Hall.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Min</first_name>
          <last_name>Si</last_name>
          <affiliation>Argonne National Laboratory</affiliation>
          <bio>Dr. Min Si is an Assistant Computer Scientist at Argonne National Laboratory working with the Programming Models and Runtime Systems group. Min’s research interests include communication runtime in high-performance computing and parallel programming models. Min was previously an Enrico Fermi Postdoctoral Scholar of Argonne National Laboratory. She received the Ph.D. degree in computer science from the University of Tokyo. Her doctoral dissertation focused on the optimization of high performance message passing communication on massively parallel multi-/many-core architectures. Min is the recipient of the 2018 IEEE-CS Technical Consortium on High Performance Computing (TCHPC) Early Career Researchers Award for Excellence in High Performance Computing, and won the Karsten Schwan Best Paper Award at HPDC 2018.</bio>
          <homepage_url>https://www.mcs.anl.gov/~minsi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/minsi/b566ccd5-1498-4770-923d-94635bfad191/small.jpg</picture_url>
          <person_id>minsi</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ba3a9726-6d5d-4832-8f7d-bee00b86b655</subevent_id>
    <title>SPLASH REBASE: 28</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>82bd82b7-a303-4e7d-a681-dfa99ac2c134</slot_id>
      <title>Session: SPLASH REBASE - 28</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/20</date>
      <start_time>21:00</start_time>
      <end_time>21:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>89f41788-cb17-48ed-a6cf-3c08a0a92cc9</slot_id>
      <event_id>fbb11428-c9f3-4c7b-8395-2c4f79d8f397</event_id>
      <title>Performance Really Matters</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/20</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>21:40</end_time>
      <description>Performance clearly matters to users. For example, the most common software update on the AppStore is “Bug fixes and performance enhancements.” Now that Moore’s Law has ended, programmers have to work hard to get high performance for their applications. But why is performance hard to deliver? I will first explain why current approaches to evaluating and optimizing performance don’t work. I’ll show how complicated performance has become on modern systems, and how compiler optimizations have essentially run out of steam. Next, I’ll introduce two radically new performance profilers that guide programmers directly to the code they need to change to improve application performance. The first is Coz, a new “causal profiler” for C/C++/Rust that lets programmers optimize for throughput or latency, and which pinpoints and accurately predicts the impact of optimizations via what we call “virtual speedup” experiments. Coz’s approach unlocks previously unknown optimization opportunities. Guided by Coz, we improved the performance of applications by as much as 68%; in most cases, this involved modifying less than 10 lines of code and took under half an hour (without any prior understanding of the programs!). Coz now ships as part of standard Linux distros. The second is Scalene, a “scripting-language aware” profiler for Python. Scalene runs orders of magnitude faster than other profilers while delivering far more detailed information – information that’s especially valuable to Python programmers. Via a combination of sampling, inference, and disassembly of byte-codes, Scalene efficiently and precisely attributes execution time and memory usage to Python, which developers can optimize, or library code, which they cannot. Its novel sampling memory allocator efficiently reports line-level memory consumption and trends with low overhead, helping developers reduce footprints and identify leaks. Finally, Scalene reports a new metric, copy volume, that helps developers root out insidious copying costs across the Python/library boundary, which can drastically degrade performance. Scalene is available on PyPi. 
The discussion and AMA following this talk will be moderated by Ben Zorn.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Emery</first_name>
          <last_name>Berger</last_name>
          <affiliation>University of Massachusetts at Amherst, USA</affiliation>
          <bio>Emery is a Professor at the University of Massachusetts Amherst. He researches languages, runtime systems, and operating systems, with a particular focus on systems that transparently improve reliability, security, and performance. Emery and friends have created Hoard, the first scalable memory manager (malloc), on which the Mac OS X memory manager is based; DieHard, an error-avoiding memory manager that directly influenced the design of the Windows 7 Fault-Tolerant Heap; DieHarder, a secure memory manager that was an inspiration for hardening changes made to the Windows 8 heap; the Coz profiler, which ships with modern Linux distros; and more. He was named an ACM Fellow in 2019.</bio>
          <homepage_url>http://www.emeryberger.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/emeryberger/6187feeb-700c-48d5-aceb-6d7b87490a7a/small.jpg</picture_url>
          <person_id>emeryberger</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4af05212-0b1b-4429-bbc2-cde006ae8737</subevent_id>
    <title>SPLASH REBASE: 14</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>52d12bf1-0f87-4777-8b38-1a6231c44ae4</slot_id>
      <title>Session: SPLASH REBASE - 14</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>03:00</start_time>
      <end_time>03:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>861395e1-afd3-4128-b852-f0b7accdb497</slot_id>
      <event_id>3915f558-1e15-450f-b38f-222ffd9da8ca</event_id>
      <title>Quantitative Types in Idris 2</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/18</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>03:40</end_time>
      <description>Dependent types allow us to express precisely what a function is intended to do. Recent work on Quantitative Type Theory (QTT) extends dependent type systems with linearity, also allowing precision in expressing when a function can run. This is promising, because it suggests the ability to design and reason about resource usage protocols, such as we might find in distributed and concurrent programming, where the state of a communication channel changes throughout program execution. Up to now, however, there has not been a full-scale programming language with which to experiment with these ideas. Idris 2 is a new version of the dependently typed language Idris, with a new core language based on QTT, supporting linear and dependent types. In this talk I will show the benfits of QTT in Idris 2, in particular how it improves interactive program development by reducing the search space for type-driven program synthesis; and, how resource tracking in the type system leads to type-safe concurrent programming with session types. 
The discussion and AMA following this talk will be moderated by Phil Wadler.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Edwin</first_name>
          <last_name>Brady</last_name>
          <affiliation>University of St. Andrews</affiliation>
          <bio>I am a Lecturer in Computer Science at the University of St Andrews, interested in type theory, dependently typed functional programming, compilers and metaprogramming. I am currently working on a new implementation of Idris, a dependently typed functional programming language. When I’m not doing that, you might find me playing Go (I’m about 2 kyu), walking up a hill, watching a game of cricket, or waiting for a delayed train. I’m afraid I also perpetrated the Whitespace programming language.</bio>
          <homepage_url>https://eb.host.cs.st-andrews.ac.uk</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/edwinbrady/cbff36d2-7476-402e-bc2c-e84d1ceb0ab5/small.jpg</picture_url>
          <person_id>edwinbrady</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e3067d06-12d4-4ae6-b906-efed9f3c4195</subevent_id>
    <title>SPLASH REBASE: 21</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>83385d5f-17e1-4a99-984a-be58fff06b57</slot_id>
      <title>Session: SPLASH REBASE - 21</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/19</date>
      <start_time>09:00</start_time>
      <end_time>09:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>53904de7-0dae-46cb-9a64-205c7d3008d1</slot_id>
      <event_id>03ce757b-14f2-4cff-96de-d52eb26aa2bf</event_id>
      <title>Relational Reasoning in Object-based Programs</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/19</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>09:40</end_time>
      <description>Relational properties arise in many settings: relating two versions of a program that use different data representations, noninterference properties for security, conditional equivalence in program transformations, etc. How might one reason about such relational properties? The talk reports on current investigations of a logic based on novel syntax that weaves together product programs to express alignment of control flow points at which relational formulas are asserted. Correctness judgments feature hypotheses with relational specifications, discharged by a rule for the linking of procedure implementations. The logic supports reasoning about program-pairs containing both similar and dissimilar control and data structures. Reasoning about dynamically allocated objects is supported by a frame rule based on frame conditions amenable to SMT provers. 
The discussion following this talk will be moderated by Yu David Liu.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anindya</first_name>
          <last_name>Banerjee</last_name>
          <affiliation>National Science Foundation</affiliation>
          <bio>Anindya is a Program Director at the National Science Foundation in the CISE Directorate in the Division of Computing and Communication Foundations (CCF) where he focuses on the issues of Software and Hardware Foundations; Exploiting Parallelism for Scalability; Cyber-physical Systems; Research Experience for Undergraduates; CISE Research Initiation Initiatives. Banerjee’s research interests span software security, software verification, probabilistic programming, semantics and logics of programs, abstract interpretation, program analysis and program transformation. He received his Ph.D. from Kansas State University, USA, in 1995. After his Ph.D., Anindya was a postdoctoral researcher, first in the Labaratoire d’Informatique (LIX) of Ecole Polytechnique, Paris and subsequently at the University of Aarhus. He joined the IMDEA Software Institute in February 2009 as Full Professor. Immediately prior to this position, Anindya was Full Professor of Computing and Information Sciences at Kansas State University, USA. He was an Academic Visitor in the Advanced Programming Tools group, IBM T. J. Watson Research Center in 2007 and a Visiting Researcher in the Programming Languages and Methodology group at Microsoft Research in 2007–2008. He was a recipient of the Career Award of the US National Science Foundation in 2001.</bio>
          <homepage_url>https://www.nsf.gov/staff/staff_bio.jsp?lan=abanerje&amp;org=NSF&amp;from_org=NSF</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anindyabanerjee1/fe921757-de11-449b-9c37-f3c7d07db1bb/small.jpg</picture_url>
          <person_id>anindyabanerjee1</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b9dc3a0b-551b-4ad4-bc33-c5e5d4625713</subevent_id>
    <title>SPLASH REBASE: 32</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>9d303976-60f2-4f3d-a8b1-44facb9b81ef</slot_id>
      <title>Session: SPLASH REBASE - 32</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/17</date>
      <start_time>09:00</start_time>
      <end_time>09:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fb68692e-7ad7-48ba-b8e2-65d191e99ddc</slot_id>
      <event_id>05a740f8-7a2d-42bb-a92d-7cfa31345b5f</event_id>
      <title>Gillian: a Multi-language Platform for Compositional Symbolic Analysis</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/17</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>09:40</end_time>
      <description>This talk will give a general introduction to Gillian, a multi-language platform for symbolic program analysis being developed by my team at Imperial College London. Gillian currently supports three types of analysis: whole-program symbolic testing; full verification based on separation logic; and automatic compositional testing based on bi-abduction. It uses a core symbolic execution engine, with strong mathematical foundations, that unifies bug catching and verification. To instantiate Gillian to a new target language (TL), the tool developer must provide: a compiler from the TL to GIL, an intermediate representation which is parametric on the TL memory model: that is, on the set of basic actions capturing the ways in which TL programs fundamentally interact with their memories; an OCaml implementation of the TL memory model using the basic actions; proofs of simple lemmas for the TL basic actions, if interested in correctness guarantees. So far, we have instantiated Gillian to JavaScript and C. These instantiations have been used to: find bugs in the real-world data-structure libraries Buckets.js and Collections-C; find bugs and prove bounded correctness results for a real-world jQuery-like library, cash; and verify the deserialisation function of the AWS Encryption SDK messaging system. 
The discussion and AMA following this talk will be moderated by Jan Vitek.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Philippa</first_name>
          <last_name>Gardner</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Philippa Gardner is a professor in the Department of Computing at Imperial College London and and has a UKRI Established Fellowship from 2018–2023. Her current research focusses on program verification: in particular, reasoning about Web programs (JavaScript and DOM); and reasoning about concurrent programs. She completed her PhD thesis, supervised by Professor Gordon Plotkin FRS at Edinburgh in 1992 and held five years of fellowships at Edinburgh. She moved to Cambridge in 1998 on an EPSRC Advanced Fellowship, hosted by Professor Robin Milner FRS. She obtained a lectureship at Imperial in 2001, and became professor in 2009. She held a Microsoft Research Cambridge/Royal Academy of Engineering Senior Fellowship from 2005 to 2010 at Imperial. Philippa directs the Research Institute on Verified Trustworthy Software Systems (VeTSS), funded by EPSRC, from 2017 to 2022. She chaired the BCS awards committee, 2013-2018, which decides the Lovelace medal (senior) and Roger Needham award (mid-career) for computer science and engineering.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~pg</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippagardner/8031e77a-ebbb-4963-a5de-94895edd7f71/small.jpg</picture_url>
          <person_id>philippagardner</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1a6a85dc-cbe9-4cfc-bf10-d97922d1a7fa</subevent_id>
    <title>SPLASH REBASE: 15</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>09c7411a-4b9d-442f-8eef-8df59f5df8c6</slot_id>
      <title>Session: SPLASH REBASE - 15</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/17</date>
      <start_time>17:00</start_time>
      <end_time>17:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8ff28324-f1b8-4efa-a9f0-50e60f9aacd8</slot_id>
      <event_id>a89b8a71-8095-4032-a94a-5405a58da74b</event_id>
      <title>Technology Today: A Paucity of Integrity and Imagination</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/17</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>17:40</end_time>
      <description>Judging by the experiences of Robert Grimm and a close confidante, both academe and industry have long given up even trying to conduct their business in an ethical fashion. In this talk, the author will detail some of the most egregious instances of deeply unethical if not outright criminal behavior across their career, will argue that they are representative of elites acting in a deeply irresponsible and self-serving manner, causally tie that misbehavior to the rise of nativist nationalism across the western world, and contrast it all against the civilization-ending threat of climate change. This talk sounds the alarm as much as it identifies our last best hope for survival. It’s up to us! 
The discussion and AMA following this talk will be moderated by Emery Berger.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Grimm</last_name>
          <affiliation>Self</affiliation>
          <bio>Robert worked at Facebook. He was also Vice President in the Technology Division of Goldman Sachs, where he worked on the company’s risk and trading platform. Robert was an Associate Professor of Computer Science at New York University, researching how to leverage programming language technologies to make complex systems easier to build, maintain and extend. He received a Ph.D. in Computer Science from the University of Washington at Seattle in 2002. His honors include the Best Paper award at the 6th ACM International Conference on Distributed Event-Based Systems, a Junior Fellowship at NYU’s Center for Teaching Excellence, and an NSF CAREER award.</bio>
          <homepage_url>http://cs.nyu.edu/rgrimm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/robertgrimm/00645048-2d05-48ed-ae6f-50c441f41179/small.jpg</picture_url>
          <person_id>robertgrimm</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c4bf39eb-5f9e-4a2b-b1fd-c8f227be2c77</subevent_id>
    <title>SPLASH REBASE: 27</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>b7d63c88-e065-4d2a-aab9-724cb1ffccf5</slot_id>
      <title>Session: SPLASH REBASE - 27</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/20</date>
      <start_time>15:00</start_time>
      <end_time>15:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>60c509ae-28a8-4828-81f1-6a58bcb3ee82</slot_id>
      <event_id>039345f2-202a-48a0-a868-2c9d3ff80808</event_id>
      <title>The impact of differentiable programming: how ∂P is enabling new science in Julia</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/20</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>15:40</end_time>
      <description>Fully incorporating differentiable programming (∂P) into the Julia language has enabled composability between modern machine learning techniques and existing high performance computing (HPC) modeling and simulation without sacrificing expressivity. Most notably, this has meant that small neural networks can be embedded within larger models whose other behaviors are fully understood and can be concretely represented. Smaller neural networks, in turn, are easier to train and interpret. It has also enabled complex computations to be embedded within cost functions for fast and robust reinforcement learning. In this talk, we’ll walk through several concrete examples and demonstrate how the combination of ∂P with Julia’s generic programming has enabled powerful and expressive new models. 
The discussion and AMA following this talk will be moderated by Ras Bodik.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matt</first_name>
          <last_name>Bauman</last_name>
          <affiliation>Julia Computing</affiliation>
          <bio>Matt Bauman is a Senior Research Scientist at JuliaComputing’s Chicago outpost, where he spends lots of time working on arrays and broadcasting. He’s been contributing to both the core language and multiple packages since 2014. At his previous position as a Data Science Fellow at the University of Chicago’s Center for Data Science and Public Policy, he longed for dot-broadcasting in Python while working with local governments to use data science for social good. He recently defended his PhD dissertation in Bioengineering from the University of Pittsburgh, focusing on neural prosthetics.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/mattbauman/d7111f63-4de2-423b-904f-d652ac16868b/small.jpg</picture_url>
          <person_id>mattbauman</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>153834eb-a2fc-4b23-a4f3-57ae520d4a13</subevent_id>
    <title>SPLASH REBASE: 12</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>ce72e07e-df22-45bc-8fcf-ec9f7023be11</slot_id>
      <title>Session: SPLASH REBASE - 12</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/17</date>
      <start_time>11:00</start_time>
      <end_time>11:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2d307b18-0cd6-42fe-ae3c-f2a6de427eb2</slot_id>
      <event_id>903e6b1f-a35a-40b8-a306-8d3a5bde3b5e</event_id>
      <title>Towards the tower of Babel: a Polyglot Language VM in Java</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/17</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>11:40</end_time>
      <description>Meet the GraalVM, a technology you can use to build composable high-performance language implementations and tools. Most production-level virtual machines duplicate their target language’s semantics in the interpreter, in the compiler, and in the runtime system. This violates DRY and is hell on the maintainers as the target evolves. In contrast, Truffle lets you define languages by simply writing their interpreter. That interpreter can be seamlessly combined with interpreters of different languages in a single just-in-time compilation unit. By treating the host language as just another language, you can reuse embeddings across languages. A language agnostic instrumentation mechanism enables us to build tools that attach cross-cutting concerns to applications with zero overhead. 
The discussion following this talk will be moderated by Eelco Visser.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christian</first_name>
          <last_name>Humer</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>Christian Humer is a researcher at Oracle Labs in Zurich, working on the GraalVM project. He develops the Truffle framework which aims to make all programming languages fast, composable and embeddable. His research interests include virtual machines, partial evaluation, and domain-specific languages. He is the main author of Truffle DSL, a domain-specific language to simplify the development of Truffle interpreters.</bio>
          <homepage_url>https://labs.oracle.com/pls/apex/f?p=LABS:bio:0:2137</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/christianhumer/7a395af3-35b6-4728-81d5-bf478224f957/small.jpg</picture_url>
          <person_id>christianhumer</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a041f42b-d6a8-40f1-88df-97d3d02e7dc4</subevent_id>
    <title>SPLASH REBASE: 10</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>d8cd57ba-feb7-4d82-aa4a-26664e3a89ad</slot_id>
      <title>Session: SPLASH REBASE - 10</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/17</date>
      <start_time>01:00</start_time>
      <end_time>01:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0a38cc43-23e5-4f4e-bdbf-659d90b9474f</slot_id>
      <event_id>dbb6bee0-b4d0-48fe-aa57-9d19010b0d78</event_id>
      <title>Lies we tell ourselves about developer infrastructure</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/17</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>01:40</end_time>
      <description>Over the past decade “developer infrastructure” teams have become an increasingly common presence in industry. Focused on serving the unique needs of an organization’s engineers, their responsibilities can be as modest as build script support or as ambitious as developing new general-purpose programming languages. As a practitioner they can be a wonderful place to work; a perfect environment to apply state of the art techniques to real world problems and invest in new ideas, all while keeping a tight feedback loop with a potentially massive user base. But with great power comes great responsibility, and the potential for waste is real. 
How many build systems, UI frameworks, code review tools, and bespoke IDEs have been developed in industry because of “unique needs”? Of those, how many actually improved the state of the art or eventually provided a return on their investment? Why does conventional wisdom — or common sense — so seldom apply when we choose to pursue these sorts of projects? (Why is it so often easier to get funding to develop a new programming language than it is to make critical improvements to an aging but essential piece of infrastructure?) The truth is that we often build new developer tools not because they’re necessary, but because personally meaningful, easy to rationalize, and fun. 
While fun is great – I’m a big fan of it – we have a professional obligation to be honest about our intentions, use resources responsibly, and go into our work with open eyes. In this talk I aim to call out the most common sources of irrational exuberance when it comes to developer infrastructure, and the lies I’ve been told (or told others) to justify certain classes of projects. Where appropriate I’ll provide cautionary tales from my last two decades working in the field (names will be changed to protect the innocent), sensible alternatives for those wiser than I was, and advice for those foolhardy enough to try and build that better wheel. (Because I guarantee you – whatever mistake you’re thinking of making, I’ve either made it myself or know someone who did.) 
The discussion and AMA following this talks will be moderated by Keith Adams.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joe</first_name>
          <last_name>Pamer</last_name>
          <affiliation>Facebook</affiliation>
          <bio>Joe Pamer is an Engineering Director at Instagram, where he serves as their Head of Infrastructure, Feed, and ML. Before joining Facebook to help lead their programming language efforts, he was instrumental in the design and development of the F#, TypeScript, and Swift programming languages, and has contributed to many other major developer technologies ranging from .NET to VS Code to Clang. He currently resides in Brooklyn, New York.</bio>
          <homepage_url>http://noteven.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joepamer/8638da18-a5b0-4543-9d00-fd4b97be5d14/small.jpg</picture_url>
          <person_id>joepamer</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e3c29b86-3865-4ef3-a1f5-af5fc31c02c7</subevent_id>
    <title>SPLASH REBASE: 31</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-II</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>0e493c88-6dbb-48b6-9a92-a11f08139fa9</slot_id>
      <title>Session: SPLASH REBASE - 31</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/17</date>
      <start_time>03:00</start_time>
      <end_time>03:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cc52047b-5367-46fe-bd2b-95a81618a34f</slot_id>
      <event_id>8875d96d-01cb-41f7-bb72-48ddc6799c32</event_id>
      <title>SQLancer: Automatically Finding Bugs in Databases</title>
      <room>Online | SPLASH-II</room>
      <date>2020/11/17</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>03:40</end_time>
      <description>Abstract: This talk presents our work on automatic testing of Database Management Systems (DBMS), part of which we found over 400 bugs in widely-used DBMS such as SQLite, MySQL, and PostgreSQL. While crash bugs in DBMS can be detected via fuzzers such as AFL, we aim to detect correctness bugs, which cause a DBMS to produce an incorrect result set for a given query. These bugs are more difficult to detect, since it is unclear how an effective test oracle could be created that could judge whether a given result set is correct. We designed three practical approaches for finding correctness bugs that we implemented as a tool called SQLancer. Besides providing a general overview of the bug-finding techniques, we will also present a number of interesting and surprising bugs that we found in the DBMS that we tested. 
The discussion following this talk will be moderated by Amir Shaikhha.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Rigger</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>Manuel Rigger is a postdoctoral researcher in the Advanced Software Technologies (AST) Lab at ETH Zurich, mentored by Zhendong Su. He is working on programming language implementation, software reliability, and systems. He completed his PhD at Johannes Kepler University Linz, mentored by Hanspeter Mössenböck, and is known for his work on Sulong to support the safe execution of LLVM-based languages.</bio>
          <homepage_url>http://www.manuelrigger.at/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelrigger/47e268e9-158c-471f-a7e9-442216c54550/small.jpg</picture_url>
          <person_id>manuelrigger</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>91a18757-b55d-46f5-b239-0d0057a37cf1</subevent_id>
    <title>SPLASH OOPSLA: F-1A</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>571f5e92-e578-4333-862b-f279686713f1</slot_id>
      <title>Session: SPLASH OOPSLA - F-1A</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>19:00</start_time>
      <end_time>20:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Tongping</first_name>
          <last_name>Liu</last_name>
          <affiliation>University of Massachusetts at Amherst, USA</affiliation>
          <bio>undefined</bio>
          <person_id>tongpingliu1</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Azalea</first_name>
          <last_name>Raad</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.SoundAndComplete.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/azalearaad/180ee602-475f-483f-a01b-ea187c9e8ac1/small.jpg</picture_url>
          <person_id>azalearaad</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5c9fc485-bcd7-42ce-8fb4-e9b92f3a73b1</slot_id>
      <event_id>a96ad696-c68c-417e-8be4-411ad8b965f2</event_id>
      <title>Pomsets with Preconditions: A Simple Model of Relaxed Memory</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>19:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>19:40</end_time>
      <description>Relaxed memory models must simultaneously achieve efficient implementability and thread-compositional reasoning. Is that why they have become so complicated? We argue that the answer is no: It is possible to achieve these goals by combining an idea from the 60s (preconditions) with an idea from the 80s (pomsets), at least for X64 and ARMv8. We show that the resulting model (1) supports compositional reasoning for temporal safety properties, (2) supports all expected sequential compiler optimizations, (3) satisfies the DRF-SC criterion, and (4) compiles to X64 and ARMv8 microprocessors without requiring extra fences on relaxed accesses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Radha</first_name>
          <last_name>Jagadeesan</last_name>
          <affiliation>DePaul University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>radhajagadeesan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alan</first_name>
          <last_name>Jeffrey</last_name>
          <affiliation>Mozilla Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://asaj.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alanjeffrey1/85292841-a6a7-416c-8808-fc36002bf1bd/small.jpg</picture_url>
          <person_id>alanjeffrey1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>James</first_name>
          <last_name>Riely</last_name>
          <affiliation>DePaul University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/jamesriely/3e1c46e0-9695-4c0f-aa5e-63f6577a3720/small.jpg</picture_url>
          <person_id>jamesriely</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8b2a08cd-ca41-431a-803b-69518cbf9d28</slot_id>
      <event_id>3f5436ba-b7cb-4e49-a7d9-a11c2a16b38a</event_id>
      <title>StreamQL: A Query Language for Processing Streaming Time Series</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>19:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>20:00</end_time>
      <description>Real-time data analysis applications increasingly rely on complex streaming computations over time-series data. We propose StreamQL, a language that facilitates the high-level specification of complex analyses over streaming time series. StreamQL is designed as an algebra of stream transformations and provides a collection of combinators for composing them. It integrates three language-based approaches for data stream processing: relational queries, dataflow composition, and temporal formalisms. The relational constructs are useful for specifying simple transformations, aggregations, and the partitioning of data into key-based groups or windows. The dataflow abstractions enable the modular description of a computation as a pipeline of stages or, more generally, as a directed graph of independent tasks. Finally, temporal constructs can be used to specify complex temporal patterns and time-varying computations. These constructs can be composed freely to describe complex streaming computations. We provide a formal denotational semantics for StreamQL using a class of monotone functions over streams. We have implemented StreamQL as a lightweight Java library, which we use to experimentally evaluate our approach. The experiments show that the throughput of our implementation is competitive compared to state-of-the-art streaming engines such as RxJava and Reactor.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lingkun</first_name>
          <last_name>Kong</last_name>
          <affiliation>Rice University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>lingkunkong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Mamouras</last_name>
          <affiliation>Rice University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>konstantinosmamouras1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c67941a0-e58c-4e2f-88d1-66f9d735420b</slot_id>
      <event_id>3b3961c4-c2ea-4595-931e-44ad2b54fd4e</event_id>
      <title>Foundations of Empirical Memory Consistency Testing</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>20:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>20:20</end_time>
      <description>Modern memory consistency models are complex, and it is difficult to reason about the relaxed behaviors that current systems allow. Programming languages, such as C and OpenCL, offer a memory model interface that developers can use to safely write concurrent applications. This abstraction provides functional portability across any platform that implements the interface, regardless of differences in the underlying systems. This powerful abstraction hinges on the ability of the system to correctly implement the interface. Many techniques for memory consistency model validation use empirical testing, which has been effective at uncovering undocumented behaviors and even finding bugs in trusted compilation schemes. Memory model testing consists of small concurrent unit tests called ``litmus tests''. In these tests, certain observations, \emph{including potential bugs}, are exceedingly rare, as they may only be triggered by precise interleaving of system steps in a complex processor, which is probabilistic in nature. Thus, each test must be run many times in order to provide a high level of confidence in its coverage. 
In this work, we rigorously investigate empirical memory model testing. In particular, we propose methodologies for navigating complex stressing routines and analyzing large numbers of testing observations. Using these insights, we can more efficiently tune stressing parameters, which can lead to higher confidence results at a faster rate. We emphasize the need for such approaches by performing a meta-study of prior work, which reveals results with low reproducibility and inefficient use of testing time. 
Our investigation is presented alongside empirical data. We believe that OpenCL targeting GPUs is a pragmatic choice in this domain as there exists a variety of different platforms to test, from large HPC servers to power-efficient edge devices. The tests presented in the work span 3 GPUs from 3 different vendors. We show that our methodologies are applicable across the GPUs, despite significant variances in the results. Concretely, our results show: lossless speedups of more than $5\times$ in tuning using data peeking; a definition of portable stressing parameters which loses only 12% efficiency when generalized across our domain; a priority order of litmus tests for tuning. We stress test a conformance test suite for the OpenCL 2.0 memory model and discover a bug in Intel's compiler. Our methods are evaluated on the other two GPUs using mutation testing. We end with recommendations for official memory model conformance tests.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jake</first_name>
          <last_name>Kirkham</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>jakekirkham</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Sorensen</last_name>
          <affiliation>University of California at Santa Cruz, USA</affiliation>
          <bio>I am a Post Doc researcher at Princeton University working in Margaret Martonosi’s group. My research interests are in concurrency: programming, modeling, testing, and architecture. In particular, I am interested in exploring new heterogeneous architectures and how programming models can enable development of secure and efficient applications. 
I received my PhD from the Multicore Programming Group at Imperial College London supervised by Alastair Donaldson. Previously, I worked with Ganesh Gopalakrishnan and Zvonimir Rakamaric at University of Utah.</bio>
          <homepage_url>https://www.cs.princeton.edu/~ts20/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tylersorensen1/e6c9c5cc-65e1-4a42-87c2-5e4a7d347b0d/small.jpg</picture_url>
          <person_id>tylersorensen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Esin</first_name>
          <last_name>Tureci</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>esintureci</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Margaret</first_name>
          <last_name>Martonosi</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>margaretrmartonosi</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e860f5a5-928e-433d-ab7a-638506192b70</slot_id>
      <event_id>3cd8b177-a095-4aa3-b2fb-63a917807035</event_id>
      <title>DiffStream: Differential Output Testing for Stream Processing Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>19:20</end_time>
      <description>High performance architectures for processing distributed data streams, such as Flink, Spark Streaming, and Storm, are increasingly deployed in emerging data-driven computing systems. Exploiting the parallelism afforded by such platforms, while preserving the semantics of the desired computation, is prone to errors, and motivates the development of tools for specification, testing, and verification. We focus on the problem of differential output testing for distributed stream processing systems, that is, checking whether two implementations produce equivalent output streams in response to a given input stream. The notion of equivalence allows reordering of logically independent data items, and the main technical contribution of the paper is an optimal online algorithm for checking this equivalence. Our testing framework is implemented as a library called DiffStream in Flink. We present four case studies to illustrate how our framework can be used to (1) correctly identify bugs in a set of benchmark MapReduce programs, (2) facilitate the development of difficult-to-parallelize high performance applications, and (3) monitor an application for a long period of time with minimal performance overhead.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Kallas</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://angelhof.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/konstantinoskallas/58e65111-bc8d-4f20-9522-b677a026f0c4/small.jpg</picture_url>
          <person_id>konstantinoskallas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Filip</first_name>
          <last_name>Niksic</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://fniksic.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/filipniksic/22f726ab-2c20-4f80-b6d4-32a9530437d5/small.jpg</picture_url>
          <person_id>filipniksic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Caleb</first_name>
          <last_name>Stanford</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cis.upenn.edu/~castan/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/calebstanford/ecc7c13b-42ab-49e9-a867-dd26542ae449/small.jpg</picture_url>
          <person_id>calebstanford</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rajeev</first_name>
          <last_name>Alur</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cis.upenn.edu/~alur/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rajeevalur/3b3a4dca-8d4b-4db9-9986-376b2352a264/small.jpg</picture_url>
          <person_id>rajeevalur</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a410c6d7-161d-4300-b942-b133c01d790e</subevent_id>
    <title>SPLASH OOPSLA: T-2</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>3c03fc1d-7062-4f36-88b9-b0b8fff66ab7</slot_id>
      <title>Session: SPLASH OOPSLA - T-2</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Karim</first_name>
          <last_name>Ali</last_name>
          <affiliation>University of Alberta</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://karimali.ca</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/karimali/460ecc0b-764d-462b-a93e-66a3270d72ef/small.jpg</picture_url>
          <person_id>karimali</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Aritra</first_name>
          <last_name>Sengupta</last_name>
          <affiliation>Amazon Web Services, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://web.cse.ohio-state.edu/~sengupta.25/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aritrasengupta/e0902a88-5806-49ae-b278-4f6dd9e62f54/small.jpg</picture_url>
          <person_id>aritrasengupta</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>45cdfcd9-8587-4709-91bb-b078aabbe0f8</slot_id>
      <event_id>b5281650-dcac-4963-b682-1fed545a5e0a</event_id>
      <title>WATCHER: In-Situ Failure Diagnosis</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>10:20</end_time>
      <description>Diagnosing software failures is important but notoriously challenging. Existing work either requires extensive manual effort, imposing a serious privacy concern (for in-production systems), or cannot report sufficient information for bug fixes. This paper presents a novel diagnosis system, named WATCHER, that can pinpoint root causes of program failures within the failing process ("in-situ"), eliminating the privacy concern. It combines identical record-and-replay, binary analysis, dynamic analysis, and hardware support together to perform the diagnosis without human involvement. It further proposes two optimizations to reduce the diagnosis time and diagnose failures with control flow hijacks. WATCHER can be easily deployed, without requiring custom hardware or operating system, program modification, or recompilation. We evaluate WATCHER with 24 program failures in real-world deployed software, including large-scale applications, such as Memcached, SQLite, and OpenJPEG. Experimental results show that WATCHER can accurately identify the root causes in only a few seconds.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hongyu</first_name>
          <last_name>Liu</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://liuhycs.github.io/</homepage_url>
          <person_id>hongyuliu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Silvestro</last_name>
          <affiliation>University of Texas at San Antonio, USA</affiliation>
          <bio>undefined</bio>
          <person_id>samsilvestro</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xiangyu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/xyzhang/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xiangyuzhang/57d4d88e-c02e-41fc-836c-0e22cdf6b3b8/small.jpg</picture_url>
          <person_id>xiangyuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jian</first_name>
          <last_name>Huang</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jianh.web.engr.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jianhuang/f6e25055-585a-40e2-89ae-b28280a62eab/small.jpg</picture_url>
          <person_id>jianhuang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Tongping</first_name>
          <last_name>Liu</last_name>
          <affiliation>University of Massachusetts at Amherst, USA</affiliation>
          <bio>undefined</bio>
          <person_id>tongpingliu1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9e2419ac-e94e-4e63-aa71-945dab2eae16</slot_id>
      <event_id>93f41bfd-9988-4002-8de8-22ce8bf00c55</event_id>
      <title>A Large-Scale Longitudinal Study of Flaky Tests</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>09:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>09:40</end_time>
      <description>Flaky tests are tests that can non-deterministically pass or fail for the same code version. These tests undermine regression testing efficiency, because developers cannot easily identify whether a test fails due to their recent changes or due to flakiness. Ideally, one would detect flaky tests right when flakiness is introduced, so that developers can then immediately remove the flakiness. Some software organizations, e.g., Mozilla and Netflix, run some tools—detectors—to detect flaky tests as soon as possible. However, detecting flaky tests is costly due to their inherent non-determinism, so even state-of-the-art detectors are often impractical to be used on all tests for each project change. To combat the high cost of applying detectors, these organizations typically run a detector solely on newly added or directly modified tests, i.e., not on unmodified tests or when other changes occur (including changes to the test suite, the code under test, and library dependencies). However, it is unclear how many flaky tests can be detected or missed by applying detectors in only these limited circumstances. 
To better understand this problem, we conduct a large-scale longitudinal study of flaky tests to determine when flaky tests become flaky and what changes cause them to become flaky. We apply two state-of-theart detectors to 55 Java projects, identifying a total of 245 flaky tests that can be compiled and run in the code version where each test was added. We find that 75% of flaky tests (184 out of 245) are flaky when added, indicating substantial potential value for developers to run detectors specifically on newly added tests. However, running detectors solely on newly added tests would still miss detecting 25% of flaky tests. The percentage of flaky tests that can be detected does increase to 85% when detectors are run on newly added or directly modified tests. The remaining 15% of flaky tests become flaky due to other changes and can be detected only when detectors are always applied to all tests. Our study is the first to empirically evaluate when tests become flaky and to recommend guidelines for applying detectors in the future.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wing</first_name>
          <last_name>Lam</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://winglam2.web.engr.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/winglam/4052f462-6ac0-4252-8c59-92a77a7c33dc/small.jpg</picture_url>
          <person_id>winglam</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stefan</first_name>
          <last_name>Winter</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>I am a postdoctoral researcher at TU Darmstadt in Germany, from where I previously obtained a Ph.D. in computer science. My research interests span a variety of topics related to the design and analysis of dependable software systems from operating system design to system-level test efficiency.</bio>
          <homepage_url>http://www.stefan-winter.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stefanwinter/b2ba53f2-c875-4cd6-b938-2152649c47bb/small.jpg</picture_url>
          <person_id>stefanwinter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anjiang</first_name>
          <last_name>Wei</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/anjiangwei/680e5627-484e-433a-be11-7fcc497f7075/small.jpg</picture_url>
          <person_id>anjiangwei</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tao</first_name>
          <last_name>Xie</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://taoxiease.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/taoxie/14ae8022-1dd6-4455-a54f-157c86bc406d/small.jpg</picture_url>
          <person_id>taoxie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Darko</first_name>
          <last_name>Marinov</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>Please see my website</bio>
          <homepage_url>http://mir.cs.illinois.edu/marinov</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/darkomarinov/715fd20e-8e93-48b7-8f26-4e80ed2aeab5/small.jpg</picture_url>
          <person_id>darkomarinov</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Bell</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>Jon is an Assistant Professor directing research in Software Engineering and Software Systems at Northeastern University. His research makes it easier for developers to create reliable and secure software by improving software testing and program analysis. Jon’s work on accelerating software testing has been recognized with an ACM SIGSOFT Distinguished Paper Award (ICSE ’14 – Unit Test Virtualization with VMVM), and was the basis for an industrial collaboration with Electric Cloud. His program analysis research has resulted in several widely adopted runtime systems for the JVM, including the Phosphor taint tracking system (OOPSLA ’14) and CROCHET checkpoint/rollback tool (ECOOP ’18). His research has been funded by the NSA and the NSF, and he is the recipient of the NSF CAREER award. At George Mason, Jon taught courses in distributed systems, web development, and program analysis. His teaching at GMU has been recognized with a departmental award. Jon serves on a variety of program committees and was recently co-chair of the PLDI 2020 Artifact Evaluation Committee. As part of his efforts to broaden the participation of underrepresented groups in computing, Jon co-organizes the PL/SE mentoring workshop at SPLASH (in 2017, 2018, 2019 and 2020).</bio>
          <homepage_url>http://jonbell.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanbell/1ef3641d-0ed6-4021-aab6-b13b53962e3d/small.jpg</picture_url>
          <person_id>jonathanbell</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b9480495-eb6b-42e6-a413-b3fc3416ef06</slot_id>
      <event_id>bf240e74-90f0-407b-8552-d2d71c9c86e4</event_id>
      <title>Handling Bidirectional Control Flow</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>10:00</end_time>
      <description>Pressed by the difficulty of writing asynchronous, event-driven code, mainstream languages have recently been building in support for a variety of advanced control-flow features. Meanwhile, experimental language designs have suggested effect handlers as a unifying solution to programmer-defined control effects, subsuming exceptions, generators, and async–await. However, despite these trends, complex control flow—in particular, control flow that exhibits a bidirectional pattern—remains challenging to manage. 
We introduce bidirectional algebraic effects, a new programming abstraction that supports bidirectional control transfer in a more natural way. Handlers of bidirectional effects can raise further effects to transfer control back to the site where the initiating effect was raised, and can use themselves to handle their own effects. We present applications of this expressive power, which falls out naturally as we push toward the unification of effectful programming with object-oriented programming. We pin down the mechanism and the unification formally using a core language that makes generalizations to effect operations and effect handlers. 
The usual propagation semantics of control effects such as exceptions conflicts with modular reasoning in the presence of effect polymorphism—it breaks parametricity. Bidirectionality exacerbates the problem. Hence, we set out to show the core language, which builds on the existing tunneling semantics for algebraic effects, is not only type-safe (no effects go unhandled), but also abstraction-safe (no effects are accidentally handled). We devise a step-indexed logical-relations model, and construct its parametricity and soundness proofs. These core results are fully mechanized in Coq. While a full-featured compiler is left to future work, experiments show that as a first-class language feature, bidirectional handlers can be implemented efficiently.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yizhou</first_name>
          <last_name>Zhang</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.uwaterloo.ca/~yizhou</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yizhouzhang/0629b9fd-c9c0-44e9-ac08-6760a0b35950/small.jpg</picture_url>
          <person_id>yizhouzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guido</first_name>
          <last_name>Salvaneschi</last_name>
          <affiliation>University of St. Gallen, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.guidosalvaneschi.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guidosalvaneschi/6f1373d5-57c6-4d68-b6c3-c0a679ee24ed/small.jpg</picture_url>
          <person_id>guidosalvaneschi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Myers</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>Andrew Myers is a Professor in the Department of Computer Science at Cornell University in Ithaca, NY. His research interests include programming languages, computer security, and distributed and persistent programming systems. Myers is an ACM Fellow. He has received awards for papers appearing in POPL’99, SOSP’01, SOSP’07, CIDR’13, PLDI’13, and PLDI’15. Myers is currently the Editor-in-Chief for ACM Transactions on Programming Languages and Systems (TOPLAS). He has also served as program chair or co-chair for a few conferences: ACM POPL 2018, ACM CCS 2016, POST 2014, IEEE CSF 2010, and IEEE S&amp;amp;P 2009.</bio>
          <homepage_url>http://www.cs.cornell.edu/andru</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andrewmyers/88baadd2-5ed8-4687-b205-3cbbe8b1a848/small.jpg</picture_url>
          <person_id>andrewmyers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c9735190-c1fa-4e0c-b296-47c7cc98905a</slot_id>
      <event_id>5d1aeb28-75c6-4924-8e7a-5cbbe33cfacd</event_id>
      <title>Formulog: Datalog for SMT-Based Static Analysis</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>09:20</end_time>
      <description>Satisfiability modulo theories (SMT) solving has become a critical part of many static analyses, including symbolic execution, refinement type checking, and model checking. We propose Formulog, a domain-specific language that makes it possible to write a range of SMT-based static analyses in a way that is both close to their formal specifications and amenable to high-level optimizations and efficient evaluation. 
Formulog extends the logic programming language Datalog with a first-order functional language and mechanisms for representing and reasoning about SMT formulas; a novel type system supports the construction of expressive formulas, while ensuring that neither normal evaluation nor SMT solving goes wrong. Our case studies demonstrate that a range of SMT-based analyses can naturally and concisely be encoded in Formulog, and that — thanks to this encoding — high-level Datalog-style optimizations can be automatically and advantageously applied to these analyses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Bembenek</last_name>
          <affiliation>Harvard University, USA</affiliation>
          <bio>Aaron Bembenek is currently a computer science PhD candidate at Harvard University working under Stephen Chong. He previously earned an undergraduate degree in classics from Princeton University.</bio>
          <homepage_url>http://people.seas.harvard.edu/~bembenek/index.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aaronbembenek/def526d3-8049-43ee-a891-2437ec903da6/small.jpg</picture_url>
          <person_id>aaronbembenek</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Greenberg</last_name>
          <affiliation>Pomona College, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.pomona.edu/~michael/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
          <person_id>michaelgreenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chong</last_name>
          <affiliation>Harvard University, USA</affiliation>
          <bio>Stephen Chong is a Gordon McKay Professor of Computer Science in the Harvard John A. Paulson School of Engineering and Applied Sciences. Steve’s research focuses on programming languages, information security, and the intersection of these two areas. He is the recipient of an NSF CAREER award, an AFOSR Young Investigator award, and a Sloan Research Fellowship. He received a PhD from Cornell University, and a bachelor’s degree from Victoria University of Wellington, New Zealand.</bio>
          <homepage_url>https://people.seas.harvard.edu/~chong/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stephenchong/91e43651-bcd6-40dc-b231-4c92711b0e95/small.jpg</picture_url>
          <person_id>stephenchong</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f3674f64-bf0e-4d31-a6d3-e09729aa3fd1</subevent_id>
    <title>SPLASH OOPSLA: F-3A</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>9eb9161d-a683-4e79-b88d-7fc9afd686e1</slot_id>
      <title>Session: SPLASH OOPSLA - F-3A</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Stefan</first_name>
          <last_name>Marr</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://stefan-marr.de/research/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stefanmarr/0917eab8-ec51-465f-9ff6-1295826fd91e/small.jpg</picture_url>
          <person_id>stefanmarr</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Reuben</first_name>
          <last_name>Rowe</last_name>
          <affiliation>University College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www0.cs.ucl.ac.uk/staff/r.rowe/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/reubenrowe/88fe0ddc-2847-4a93-8fe2-6e9aa9c8a1ff/small.jpg</picture_url>
          <person_id>reubenrowe</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a2255de5-3c79-480a-994b-d06c21da7d27</slot_id>
      <event_id>8d09d351-1484-4e6f-a97b-31fc3a8589f5</event_id>
      <title>Fixpoints for the Masses: Programming with First-Class Datalog Constraints</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>11:40</end_time>
      <description>Datalog is a declarative logic programming language that has been used in a variety of applications, including big-data analytics, language processing, networking and distributed systems, and program analysis. 
In this paper, we propose first-class Datalog constraints as a mechanism to construct, compose, and solve Datalog programs at run time. The benefits are twofold: We gain the full power of a functional programming language to operate on Datalog constraints-as-values, while simultaneously we can use Datalog where it really shines: to declaratively express and solve fixpoint problems. 
We present an extension of the lambda calculus with first-class Datalog constraints, including its semantics and a type system with row polymorphism based on Hindley-Milner. We prove soundness of the type system and implement it as an extension of the Flix programming language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b93b8a6c-c3cf-46a5-ac5b-8eb9bb0cef93</slot_id>
      <event_id>50c0fcb1-ef71-4df6-9d10-ebeddb89add2</event_id>
      <title>Polymorphic Types and Effects with Boolean Unification</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>12:20</end_time>
      <description>We present a simple, practical, and expressive type and effect system based on Boolean constraints. The effect system extends the Hindley-Milner type system, supports parametric polymorphism, and preserves principal types modulo Boolean equivalence. We show how to support type inference by extending Algorithm W with Boolean unification based on the successive variable elimination algorithm. 
We implement the type and effect system in the Flix programming language. We perform an in-depth evaluation on the impact of Boolean unification on type inference time and end-to-end compilation time. While the computational complexity of Boolean unification is NP-hard, the experimental results demonstrate that it works well in practice. We find that the impact on type inference time is on average a 1.4x slowdown and the overall impact on end-to-end compilation time is a 1.1x slowdown.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jaco</first_name>
          <last_name>van de Pol</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>Jaco van de Pol started his research in Utrecht on rewrite systems, in particular termination of higher-order rewrite systems. At CWI Amsterdam, he published several papers on theorem proving and model checking for concurrent systems in process algebra and contributed to the µCRL toolset. In Twente, he started a new research line on parallel model checking algorithms. This resulted in the LTSmin toolset for high-performance model checking. He worked on applications in embedded systems, safety &amp;amp; security and systems biology. He published ~25 journal papers, ~100 conference papers, and edited ~10 volumes. Publications at Google Scholar and DBLP. 
Affiliations: 
 
 MSc Utrecht University (supervisor Hans Zantema) 
 PhD Utrecht University (supervisor Jan Bergstra) 
 Research Assistant LMU Mathematisches Institute Munich (with Helmut Schwichtenberg) 
 Postdoc Technical University of Eindhoven (with Jozef Hooman) 
 Senior Researcher CWI (1999-2007) 
 Associate Professor Technical University of Eindhoven (2004-2007, 20%) 
 Professor Formal Methods and Tools at University of Twente (2007-2018; from Nov 2018 10%) 
 Professor Computer Science at Aarhus University (from Nov 2018) 
</bio>
          <homepage_url>http://fmt.cs.utwente.nl/~vdpol/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jacovandepol/b053e08d-fe52-46a9-b4cd-b863ea6c9c07/small.jpg</picture_url>
          <person_id>jacovandepol</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d28157cf-5ad0-4a67-bb9e-28f6c987ee42</slot_id>
      <event_id>c3da127b-d137-44d6-888b-a9da4ddc54a5</event_id>
      <title>Verifying and Improving Halide’s Term Rewriting System with Program Synthesis</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>12:00</end_time>
      <description>Halide is a domain-specific language for high-performance image processing and tensor computations, widely adopted in industry. Internally, the Halide compiler relies on a term rewriting system to prove properties of code required for efficient and correct compilation. This rewrite system is a collection of handwritten transformation rules that incrementally rewrite expressions into simpler forms; the system requires high performance in both time and memory usage to keep compile times low, while operating over the undecidable theory of integers. In this work, we apply formal techniques to prove the correctness of existing rewrite rules and provide a guarantee of termination. Then, we build an automatic program synthesis system in order to craft new, provably correct rules from failure cases where the compiler was unable to prove properties. We identify and fix 4 incorrect rules as well as 8 rules which could give rise to infinite rewriting loops. We demonstrate that the synthesizer can produce better rules than hand-authored ones in five bug fixes, and describe four cases in which it has served as an assistant to a human compiler engineer. We further show that it can proactively improve weaknesses in the compiler by synthesizing a large number of rules without human supervision and showing that the enhanced ruleset lowers peak memory usage of compiled code without appreciably increasing compilation times.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julie L.</first_name>
          <last_name>Newcomb</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jn80842.github.io/</homepage_url>
          <person_id>julielnewcomb</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Adams</last_name>
          <affiliation>Adobe, n.n.</affiliation>
          <bio>undefined</bio>
          <person_id>andrewadams</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Steven</first_name>
          <last_name>Johnson</last_name>
          <affiliation>Google, n.n.</affiliation>
          <bio>undefined</bio>
          <person_id>stevenjohnson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rastislav</first_name>
          <last_name>Bodik</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://homes.cs.washington.edu/~bodik</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rastislavbodik/ae16ae8e-9d00-41c4-9067-0c37da65dde7/small.jpg</picture_url>
          <person_id>rastislavbodik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Shoaib</first_name>
          <last_name>Kamil</last_name>
          <affiliation>Adobe, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shoaibkamil/2bc60aee-bda5-437e-9e74-e00f5a55c9ef/small.jpg</picture_url>
          <person_id>shoaibkamil</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d98c66e7-6e79-4f7a-8aec-6664eed59998</slot_id>
      <event_id>8cf8faa8-1f32-4ec8-b6ba-b5a6fc13efef</event_id>
      <title>Contextual Dispatch for Function Specialization</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>11:20</end_time>
      <description>In order to generate efficient code, dynamic language compilers often need information, such as dynamic types, not readily available in the program source. Leveraging a mixture of static and dynamic information, these compilers speculate on the missing information. Within one compilation unit, they specialize the generated code to the previously observed behaviors, betting that past is prologue. When speculation fails, the execution must jump back to unoptimized code. In this paper, we propose an approach to further the specialization, by disentangling classes of behaviors into separate optimization units. With contextual dispatch, functions are versioned and each version is compiled under different assumptions. When a function is invoked, the implementation dispatches to a version optimized under assumptions matching the dynamic context of the call. As a proof-of-concept, we describe a compiler for the R language which uses this approach. Our implementation is, on average, $1.7\times$ faster than the GNU R reference implementation. We evaluate contextual dispatch on a set of benchmarks and measure additional speedup, on top of traditional speculation with deoptimization techniques. In this setting contextual dispatch improves the performance of 18 out of 46 programs in our benchmark suite.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Flückiger</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.o1o.ch</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/olivierfluckiger/6051271d-0eac-48f3-b931-bff878bbce61/small.jpg</picture_url>
          <person_id>olivierfluckiger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guido</first_name>
          <last_name>Chari</last_name>
          <affiliation>Asapp, Argentina</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://charig.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guidochari/a0147ecd-ef4f-404e-ba4a-ffa5894e8830/small.jpg</picture_url>
          <person_id>guidochari</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ming-Ho</first_name>
          <last_name>Yee</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>I’m currently a Ph.D. student in computer science at Northeastern University in Boston, Massachusetts. I work on programming language design and implementation with Jan Vitek.</bio>
          <homepage_url>http://mhyee.com</homepage_url>
          <person_id>minghoyee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jan</first_name>
          <last_name>Jecmen</last_name>
          <affiliation>Czech Technical University, Czechia</affiliation>
          <bio>undefined</bio>
          <person_id>janjecmen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jakob</first_name>
          <last_name>Hain</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.linkedin.com/in/jakobeha/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jakobhain/d10d3ad5-e905-4e33-93d6-7d1545e3ab22/small.jpg</picture_url>
          <person_id>jakobhain</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University, USA / Czech Technical University, Czechia</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c05beda1-42bb-407b-9385-4c90690279fe</subevent_id>
    <title>SPLASH OOPSLA: F-1A</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>15a60fd9-d319-4f35-a13d-c68fd92a4ee5</slot_id>
      <title>Session: SPLASH OOPSLA - F-1A</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>07:00</start_time>
      <end_time>08:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Diomidis</first_name>
          <last_name>Spinellis</last_name>
          <affiliation>Athens University of Economics and Business, Greece</affiliation>
          <bio>Diomidis Spinellis is Professor of Software Engineering, Head of the Department of Management Science and Technology, and director of the Business Analytics Laboratory (BALab), at the Athens University of Economics and Business, Greece. His research interests include software engineering, IT security, and computing systems. He has written two award-winning, widely-translated books: Code Reading and Code Quality: The Open Source Perspective. In 2016 he published the book Effective Debugging: 66 Specific Ways to Debug Software and Systems. Dr. Spinellis has also published more than 300 technical papers in journals and refereed conference proceedings, which have received more than 8000 citations. He served for a decade as a member of the IEEE Software editorial board, authoring the regular “Tools of the Trade” column and for four years at the magazine’s Editor in Chief. He has contributed code that ships with Apple’s macOS and BSD Unix and is the developer of CScout, UMLGraph, dgsh, and other open-source software packages, libraries, and tools. He holds an MEng in Software Engineering and a PhD in Computer Science, both from Imperial College London. Dr. Spinellis has served as an elected member of the IEEE Computer Society Board of Governors (2013–2015), and is a senior member of the ACM and the IEEE.</bio>
          <homepage_url>https://www.dmst.aueb.gr/dds</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/diomidisspinellis/a7f21db5-04c0-4282-85ab-614b4394c90a/small.jpg</picture_url>
          <person_id>diomidisspinellis</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>John</first_name>
          <last_name>Wickerson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Lecturer in the Department of Electrical and Electronic Engineering at Imperial College London.</bio>
          <homepage_url>http://johnwickerson.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnwickerson/e74d4ce8-1ae7-4f7a-a53d-0aa35c361396/small.jpg</picture_url>
          <person_id>johnwickerson</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1ecef038-5bcc-47bb-92df-f8152b344088</slot_id>
      <event_id>3f5436ba-b7cb-4e49-a7d9-a11c2a16b38a</event_id>
      <title>StreamQL: A Query Language for Processing Streaming Time Series</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>07:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>08:00</end_time>
      <description>Real-time data analysis applications increasingly rely on complex streaming computations over time-series data. We propose StreamQL, a language that facilitates the high-level specification of complex analyses over streaming time series. StreamQL is designed as an algebra of stream transformations and provides a collection of combinators for composing them. It integrates three language-based approaches for data stream processing: relational queries, dataflow composition, and temporal formalisms. The relational constructs are useful for specifying simple transformations, aggregations, and the partitioning of data into key-based groups or windows. The dataflow abstractions enable the modular description of a computation as a pipeline of stages or, more generally, as a directed graph of independent tasks. Finally, temporal constructs can be used to specify complex temporal patterns and time-varying computations. These constructs can be composed freely to describe complex streaming computations. We provide a formal denotational semantics for StreamQL using a class of monotone functions over streams. We have implemented StreamQL as a lightweight Java library, which we use to experimentally evaluate our approach. The experiments show that the throughput of our implementation is competitive compared to state-of-the-art streaming engines such as RxJava and Reactor.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lingkun</first_name>
          <last_name>Kong</last_name>
          <affiliation>Rice University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>lingkunkong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Mamouras</last_name>
          <affiliation>Rice University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>konstantinosmamouras1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6e600620-4d73-4be4-84e0-45ca66c3d6e8</slot_id>
      <event_id>3cd8b177-a095-4aa3-b2fb-63a917807035</event_id>
      <title>DiffStream: Differential Output Testing for Stream Processing Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>07:20</end_time>
      <description>High performance architectures for processing distributed data streams, such as Flink, Spark Streaming, and Storm, are increasingly deployed in emerging data-driven computing systems. Exploiting the parallelism afforded by such platforms, while preserving the semantics of the desired computation, is prone to errors, and motivates the development of tools for specification, testing, and verification. We focus on the problem of differential output testing for distributed stream processing systems, that is, checking whether two implementations produce equivalent output streams in response to a given input stream. The notion of equivalence allows reordering of logically independent data items, and the main technical contribution of the paper is an optimal online algorithm for checking this equivalence. Our testing framework is implemented as a library called DiffStream in Flink. We present four case studies to illustrate how our framework can be used to (1) correctly identify bugs in a set of benchmark MapReduce programs, (2) facilitate the development of difficult-to-parallelize high performance applications, and (3) monitor an application for a long period of time with minimal performance overhead.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Kallas</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://angelhof.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/konstantinoskallas/58e65111-bc8d-4f20-9522-b677a026f0c4/small.jpg</picture_url>
          <person_id>konstantinoskallas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Filip</first_name>
          <last_name>Niksic</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://fniksic.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/filipniksic/22f726ab-2c20-4f80-b6d4-32a9530437d5/small.jpg</picture_url>
          <person_id>filipniksic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Caleb</first_name>
          <last_name>Stanford</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cis.upenn.edu/~castan/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/calebstanford/ecc7c13b-42ab-49e9-a867-dd26542ae449/small.jpg</picture_url>
          <person_id>calebstanford</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rajeev</first_name>
          <last_name>Alur</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cis.upenn.edu/~alur/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rajeevalur/3b3a4dca-8d4b-4db9-9986-376b2352a264/small.jpg</picture_url>
          <person_id>rajeevalur</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bc78856b-9b95-49a3-8375-3c133752e25b</slot_id>
      <event_id>a96ad696-c68c-417e-8be4-411ad8b965f2</event_id>
      <title>Pomsets with Preconditions: A Simple Model of Relaxed Memory</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>07:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>07:40</end_time>
      <description>Relaxed memory models must simultaneously achieve efficient implementability and thread-compositional reasoning. Is that why they have become so complicated? We argue that the answer is no: It is possible to achieve these goals by combining an idea from the 60s (preconditions) with an idea from the 80s (pomsets), at least for X64 and ARMv8. We show that the resulting model (1) supports compositional reasoning for temporal safety properties, (2) supports all expected sequential compiler optimizations, (3) satisfies the DRF-SC criterion, and (4) compiles to X64 and ARMv8 microprocessors without requiring extra fences on relaxed accesses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Radha</first_name>
          <last_name>Jagadeesan</last_name>
          <affiliation>DePaul University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>radhajagadeesan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alan</first_name>
          <last_name>Jeffrey</last_name>
          <affiliation>Mozilla Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://asaj.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alanjeffrey1/85292841-a6a7-416c-8808-fc36002bf1bd/small.jpg</picture_url>
          <person_id>alanjeffrey1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>James</first_name>
          <last_name>Riely</last_name>
          <affiliation>DePaul University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/jamesriely/3e1c46e0-9695-4c0f-aa5e-63f6577a3720/small.jpg</picture_url>
          <person_id>jamesriely</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fe527ff7-74a1-40c3-bac3-a053d323a48a</slot_id>
      <event_id>3b3961c4-c2ea-4595-931e-44ad2b54fd4e</event_id>
      <title>Foundations of Empirical Memory Consistency Testing</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>08:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>08:20</end_time>
      <description>Modern memory consistency models are complex, and it is difficult to reason about the relaxed behaviors that current systems allow. Programming languages, such as C and OpenCL, offer a memory model interface that developers can use to safely write concurrent applications. This abstraction provides functional portability across any platform that implements the interface, regardless of differences in the underlying systems. This powerful abstraction hinges on the ability of the system to correctly implement the interface. Many techniques for memory consistency model validation use empirical testing, which has been effective at uncovering undocumented behaviors and even finding bugs in trusted compilation schemes. Memory model testing consists of small concurrent unit tests called ``litmus tests''. In these tests, certain observations, \emph{including potential bugs}, are exceedingly rare, as they may only be triggered by precise interleaving of system steps in a complex processor, which is probabilistic in nature. Thus, each test must be run many times in order to provide a high level of confidence in its coverage. 
In this work, we rigorously investigate empirical memory model testing. In particular, we propose methodologies for navigating complex stressing routines and analyzing large numbers of testing observations. Using these insights, we can more efficiently tune stressing parameters, which can lead to higher confidence results at a faster rate. We emphasize the need for such approaches by performing a meta-study of prior work, which reveals results with low reproducibility and inefficient use of testing time. 
Our investigation is presented alongside empirical data. We believe that OpenCL targeting GPUs is a pragmatic choice in this domain as there exists a variety of different platforms to test, from large HPC servers to power-efficient edge devices. The tests presented in the work span 3 GPUs from 3 different vendors. We show that our methodologies are applicable across the GPUs, despite significant variances in the results. Concretely, our results show: lossless speedups of more than $5\times$ in tuning using data peeking; a definition of portable stressing parameters which loses only 12% efficiency when generalized across our domain; a priority order of litmus tests for tuning. We stress test a conformance test suite for the OpenCL 2.0 memory model and discover a bug in Intel's compiler. Our methods are evaluated on the other two GPUs using mutation testing. We end with recommendations for official memory model conformance tests.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jake</first_name>
          <last_name>Kirkham</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>jakekirkham</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Sorensen</last_name>
          <affiliation>University of California at Santa Cruz, USA</affiliation>
          <bio>I am a Post Doc researcher at Princeton University working in Margaret Martonosi’s group. My research interests are in concurrency: programming, modeling, testing, and architecture. In particular, I am interested in exploring new heterogeneous architectures and how programming models can enable development of secure and efficient applications. 
I received my PhD from the Multicore Programming Group at Imperial College London supervised by Alastair Donaldson. Previously, I worked with Ganesh Gopalakrishnan and Zvonimir Rakamaric at University of Utah.</bio>
          <homepage_url>https://www.cs.princeton.edu/~ts20/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tylersorensen1/e6c9c5cc-65e1-4a42-87c2-5e4a7d347b0d/small.jpg</picture_url>
          <person_id>tylersorensen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Esin</first_name>
          <last_name>Tureci</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>esintureci</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Margaret</first_name>
          <last_name>Martonosi</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>margaretrmartonosi</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f9c51d4a-8558-4abc-9e12-86c7e7a65d1e</subevent_id>
    <title>SPLASH OOPSLA: F-1B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>8eb16d17-df94-44cd-8880-cead41740b89</slot_id>
      <title>Session: SPLASH OOPSLA - F-1B</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>07:00</start_time>
      <end_time>08:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>486d83a8-eb92-46b5-9232-8119282a2a2f</slot_id>
      <event_id>fd3d1690-7023-4d0a-a100-6ba2b8f4497c</event_id>
      <title>Incremental Predicate Analysis for Regression Verification</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>07:20</end_time>
      <description>Software products are evolving during their life cycles. Ideally, every revision need be formally verified to ensure software quality. Yet repeated formal verification requires significant computing resources. Verifying each and every revision can be very challenging. It is desirable to ameliorate regression verification for practical purposes. In this paper, we regard predicate analysis as a process of assertion annotation. Assertion annotations can be used as a certificate for the verification results. It is thus a waste of resources to throw them away after each verification. We propose to reuse the previously-yielded assertion annotation in regression verification. A light-weight impact-analysis technique is proposed to analyze the reusability of assertions. A novel assertion strengthening technique is furthermore developed to improve reusability of annotation. With these techniques, we present an incremental predicate analysis technique for regression verification. Correctness of our incremental technique is formally proved. We performed comprehensive experiments on revisions of Linux kernel device drivers. Our technique outperforms the state-of-the-art program verification tool CPAchecker by getting 2.8x speedup in total time and solving additional 393 tasks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Qianshan</first_name>
          <last_name>Yu</last_name>
          <affiliation>Tsinghua University, China</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/qianshanyu/5ab95d6b-de0b-48ef-8655-f7b92c2938c8/small.jpg</picture_url>
          <person_id>qianshanyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fei</first_name>
          <last_name>He</last_name>
          <affiliation>Tsinghua University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://feihe.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/feihe/8546030e-3821-4cb3-8f33-23a258579461/small.jpg</picture_url>
          <person_id>feihe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bow-Yaw</first_name>
          <last_name>Wang</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <person_id>bowyawwang1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8764b9cf-d445-41c7-8614-52e58863d2f2</slot_id>
      <event_id>256ca32c-494b-45db-903d-d2bbabbfbd1b</event_id>
      <title>Guiding Dynamic Programing via Structural Probability for Accelerating Programming by Example</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>08:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>08:20</end_time>
      <description>Programming by example (PBE) is an important subproblem of program synthesis, and PBE techniques have been applied to many domains. Though many techniques for accelerating PBE systems have been explored, the scalability remains one of the main challenges: There is still a gap between the performances of state-of-the-art synthesizers and the industrial requirement. To further speed up solving PBE tasks, in this paper, we propose a novel PBE framework MaxFlash. MaxFlash uses a model based on structural probability, named topdown prediction models, to guide a search based on dynamic programming, such that the search will focus on subproblems that form probable programs, and avoid improbable programs. Our evaluation shows that MaxFlash achieves $\times 4.107- \times 2080$ speed-ups against state-of-the-art solvers on $244$ real-world tasks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ruyi</first_name>
          <last_name>Ji</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <person_id>ruyiji</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yican</first_name>
          <last_name>Sun</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <person_id>yicansun1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yingfei</first_name>
          <last_name>Xiong</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>Associate Professor</bio>
          <homepage_url>http://sei.pku.edu.cn/~xiongyf04/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yingfeixiong/18fb7368-4f14-462a-b038-9990eebb7a9c/small.jpg</picture_url>
          <person_id>yingfeixiong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhenjiang</first_name>
          <last_name>Hu</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sei.pku.edu.cn/~hu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhenjianghu/5d426480-5589-46be-b4f6-f98cf2acc80e/small.jpg</picture_url>
          <person_id>zhenjianghu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>95340fd6-11b2-4bc9-9d54-4dcaf8ed02c0</slot_id>
      <event_id>8068ce72-3e63-4d39-8209-298d9b3bc05d</event_id>
      <title>Learning Graph-Based Heuristics for Pointer Analysis without Handcrafting Application-Specific Features</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>07:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>07:40</end_time>
      <description>We present Graphick, a new technique for automatically learning graph-based heuristics for pointer analysis. Striking a balance between precision and scalability of pointer analysis requires designing good analysis heuristics. For example, because applying context sensitivity to all methods in a real-world program is impractical, pointer analysis typically uses a heuristic to employ context sensitivity only when it is necessary. Past research has shown that exploiting the program's graph structure is a promising way of developing cost-effective analysis heuristics, promoting the recent trend of ``graph-based heuristics'' that work on the graph representations of programs obtained from a pre-analysis. Although promising, manually developing such heuristics remains challenging, requiring a great deal of expertise and laborious effort. In this paper, we aim to reduce this burden by learning graph-based heuristics automatically, in particular without hand-crafted application-specific features. To do so, we present a feature language to describe graph structures and an algorithm for learning analysis heuristics within the language. We implemented Graphick on top of Doop and used it to learn graph-based heuristics for object sensitivity and heap abstraction. The evaluation results show that our approach is general and can generate high-quality heuristics. For both instances, the learned heuristics are as competitive as the existing state-of-the-art heuristics designed manually by analysis experts.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Minseok</first_name>
          <last_name>Jeon</last_name>
          <affiliation>Korea University, South Korea</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://prl.korea.ac.kr/~minseok/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/minseokjeon/69505413-080b-41a8-8714-56f24d788995/small.jpg</picture_url>
          <person_id>minseokjeon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Myungho</first_name>
          <last_name>Lee</last_name>
          <affiliation>Korea University, South Korea</affiliation>
          <bio>undefined</bio>
          <person_id>myungholee1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hakjoo</first_name>
          <last_name>Oh</last_name>
          <affiliation>Korea University, South Korea</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://prl.korea.ac.kr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hakjoooh/d607b778-78f3-41c4-84d9-4693c8923bc3/small.jpg</picture_url>
          <person_id>hakjoooh</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e0f191b8-395b-4979-9075-4064321d914a</slot_id>
      <event_id>29356edb-fec4-4b97-9278-0bf447a06e5d</event_id>
      <title>TacTok: Semantics-Aware Proof Synthesis</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>07:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>08:00</end_time>
      <description>Formally verifying software correctness is a highly manual process. However, because verification proof scripts often share structure, it is possible to learn from existing proof scripts to fully automate some formal verification. The goal of this paper is to improve proof script synthesis and enable fully automating more verification. Interactive theorem provers, such as the Coq proof assistant, allow programmers to write partial proof scripts, observe the semantics of the proof state thus far, and then attempt more progress. Knowing the proof state semantics is a significant aid. Recent research has shown that the proof state can help predict the next step. In this paper, we present TacTok, the first technique that attempts to fully automate proof script synthesis by modeling proof scripts using both the partial proof script written thus far and the semantics of the proof state. Thus, TacTok more completely models the information the programmer has access to when writing proof scripts manually. We evaluate TacTok on a benchmark of 26 software projects in Coq, consisting of over 10 thousand theorems. We compare our approach to five tools. Two prior techniques, CoqHammer, the state-of-the-art proof synthesis technique, and ASTactic, a proof script synthesis technique that models proof state. And three new proof script synthesis technique we create ourselves, SeqOnly, which models only the partial proof script and the initial theorem being proven, and WeightedRandom and WeightedGreedy, which use metaheuristic search biased by frequencies of proof tactics in existing, successful proof scripts. We find that TacTok outperforms WeightedRandom and WeightedGreedy, and is complementary to CoqHammer and ASTactic: for 24 out of the 26 projects, TacTok can synthesize proof scripts for some theorems the prior tools cannot. Together with TacTok, 11.5% more theorems can be proven automatically than by CoqHammer alone, and 20.0% than by ASTactic alone. Compared to a combination of CoqHammer and ASTactic, TacTok can prove an additional 3.6% more theorems, proving 115 theorems no tool could previously prove. Overall, our experiments provide evidence that partial proof script and proof state semantics, together, provide useful information for proof script modeling, and that metaheuristic search is a promising direction for proof script synthesis. TacTok is open-source and we make public all our data and a replication package of our experiments.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Emily</first_name>
          <last_name>First</last_name>
          <affiliation>University of Massachusetts at Amherst, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/emilyfirst/76db7ede-1a2f-4b56-9974-9bb109e78ed1/small.jpg</picture_url>
          <person_id>emilyfirst</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yuriy</first_name>
          <last_name>Brun</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>My research is in software engineering. I am interested in improving our ability to build systems that are smart, and self-adapt to their environment. I am particularly interested in ensuring fairness in software systems. Watch a video describing my latest work on software fairness testing here: http://tinyurl.com/FairnessVideo</bio>
          <homepage_url>http://people.cs.umass.edu/~brun/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yuriybrun/15eff225-fb71-4b2c-9925-a0d731136238/small.jpg</picture_url>
          <person_id>yuriybrun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Guha</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://khoury.northeastern.edu/~arjunguha</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjunguha/284e0782-ec24-4ad9-b6a4-b6a1d0e2fe9a/small.jpg</picture_url>
          <person_id>arjunguha</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f733e01f-19f7-4133-8aa0-744ab5bd0d3d</subevent_id>
    <title>SPLASH OOPSLA: T-6A</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>8bc51aba-3a23-456d-adc5-cd974e579a63</slot_id>
      <title>Session: SPLASH OOPSLA - T-6A</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Pradel</last_name>
          <affiliation>University of Stuttgart, Germany</affiliation>
          <bio>Michael Pradel is a full professor at University of Stuttgart, which he joined after a PhD at ETH Zurich, a post-doc at UC Berkeley, an assistant professorship at TU Darmstadt, and a sabbatical at Facebook. His research interests span software engineering, programming languages, security, and machine learning, with a focus on tools and techniques for building reliable, efficient, and secure software. In particular, he is interested in dynamic program analysis, test generation, concurrency, performance profiling, JavaScript-based web applications, and machine learning-based program analysis.</bio>
          <homepage_url>http://software-lab.org/people/Michael_Pradel.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelpradel/06ef7ed7-0982-404f-8261-5188acacd15f/small.jpg</picture_url>
          <person_id>michaelpradel</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Kallas</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://angelhof.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/konstantinoskallas/58e65111-bc8d-4f20-9522-b677a026f0c4/small.jpg</picture_url>
          <person_id>konstantinoskallas</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>89363f6e-b4c3-404a-a330-c5fe5219d97c</slot_id>
      <event_id>bebba2c1-25ac-4031-96fd-49f091a06a15</event_id>
      <title>Flow2Vec: Value-Flow-Based Precise Code Embedding</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>05:20</end_time>
      <description>Code embedding, as an emerging paradigm for source code analysis, has attracted much attention over the past few years. It aims to represent code semantics through distributed vector representations, which can be used to support a variety of program analysis tasks (e.g., code summarization and semantic labeling). However, existing code embedding approaches are intraprocedural, alias-unaware and ignoring the asymmetric transitivity of directed graphs abstracted from source code, thus they are still ineffective in preserving the structural information of code. 
This paper presents Flow2Vec, a new code embedding approach that precisely preserves interprocedural program dependence (a.k.a value-flows). By approximating the high-order proximity, i.e., the asymmetric transitivity of value-flows, Flow2Vec embeds control-flows and alias-aware data-flows of a program in a low-dimensional vector space. Our value-flow embedding is formulated as matrix multiplication to preserve context-sensitive transitivity through CFL reachability by filtering out infeasible value-flow paths. We have evaluated Flow2Vec using 32 popular open-source projects. Results from our experiments show that Flow2Vec successfully boosts the performance of two recent code embedding approaches codevec and codeseq for two client applications, i.e., code classification and code summarization. For code classification, Flow2Vec improves codevec with an average increase of 21.2%, 20.1% and 20.7% in precision, recall and F1, respectively. For code summarization, Flow2Vec outperforms codeseq by an average of 13.2%, 18.8% and 16.0% in precision, recall and F1, respectively.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yulei</first_name>
          <last_name>Sui</last_name>
          <affiliation>University of Technology Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuleisui.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yuleisui/e6ce6e88-3cd8-4595-9c61-a8da6f7319f6/small.jpg</picture_url>
          <person_id>yuleisui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xiao</first_name>
          <last_name>Cheng</last_name>
          <affiliation>Beijing University of Posts and Telecommunications, China</affiliation>
          <bio>undefined</bio>
          <person_id>xiaocheng</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Guanqin</first_name>
          <last_name>Zhang</last_name>
          <affiliation>University of Technology Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <person_id>guanqinzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Haoyu</first_name>
          <last_name>Wang</last_name>
          <affiliation>Beijing University of Posts and Telecommunications, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://howiepku.github.io/</homepage_url>
          <person_id>haoyuwang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9f8c659e-a171-4008-bac6-44de49d1c157</slot_id>
      <event_id>a1340467-2468-4939-918c-5b03056c26fd</event_id>
      <title>FlowCFL: Generalized Type-Based Reachability Analysis: Graph Reduction and Equivalence of CFL-Based and Type-Based Reachability</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>05:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>05:40</end_time>
      <description>Reachability analysis is a fundamental program analysis with a wide variety of applications. We present FlowCFL, a type-based reachability analysis that accounts for mutable heap data. The underlying semantics of FlowCFL is Context-Free-Language (CFL)-reachability. 
We make three contributions. First, we define a dynamic semantics that captures the notion of flow commonly used in reachability analysis. Second, we establish correctness of CFL-reachability over graphs with inverse edges (inverse edges are necessary for the handling of mutable heap data). Our approach combines CFL-reachability with reference immutability to avoid the addition of certain inverse edges, which results in graph reduction and precision improvement. The key contribution of our work is the formal account of correctness, which extends to the case when inverse edges are removed. Third, we present a type-based reachability analysis and establish equivalence between a certain CFL-reachability analysis and the type-based analysis, thus proving correctness of the type-based analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ana</first_name>
          <last_name>Milanova</last_name>
          <affiliation>Rensselaer Polytechnic Institute, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.rpi.edu/~milanova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anamilanova/4fa9038c-d0e6-44ca-b1b7-2420329714f4/small.jpg</picture_url>
          <person_id>anamilanova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b04f8cc5-d164-479b-a241-0b1904991fec</slot_id>
      <event_id>970b6051-9a69-4c86-97a5-c53ea48536a0</event_id>
      <title>Hidden Inheritance: An Inline Caching Design for TypeScript Performance</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>05:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>06:00</end_time>
      <description>TypeScript is a dynamically typed language widely used to develop large-scale applications nowadays. These applications are usually designed with complex class or interface hierarchies and have highly polymorphic behaviors. These object-oriented (OO) features will lead to inefficient inline caches (ICs) or trigger deoptimizations, which impact the performance of TypeScript applications. 
To address this problem, we introduce an inline caching design called hidden inheritance (HI). The basic idea of HI is to cache the static information of class or interface hierarchies into hidden classes, which are leveraged to generate efficient inline caches for improving the performance of OO-style TypeScript programs. The HI design is implemented in a TypeScript engine STSC (Static TypeScript Compiler) including a static compiler and a runtime system. STSC statically generates hidden classes and enhanced inline caches, which are applied to generate specialized machine code via ahead-of-time compilation (AOTC) or just-in-time compilation (JITC). To evaluate the efficiency of this technique, we implement STSC on a state-of-the-art JavaScript virtual machine V8 and demonstrate its performance improvements on industrial benchmarks and applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zhefeng</first_name>
          <last_name>Wu</last_name>
          <affiliation>Alibaba Group, China</affiliation>
          <bio>undefined</bio>
          <person_id>zhefengwu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zhe</first_name>
          <last_name>Sun</last_name>
          <affiliation>Alibaba Group, China</affiliation>
          <bio>undefined</bio>
          <person_id>zhesun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kai</first_name>
          <last_name>Gong</last_name>
          <affiliation>Alibaba Group, China</affiliation>
          <bio>undefined</bio>
          <person_id>kaigong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>lingyun</first_name>
          <last_name>Chen</last_name>
          <affiliation>Alibaba Group, China</affiliation>
          <bio>undefined</bio>
          <person_id>lingyunchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Bin</first_name>
          <last_name>Liao</last_name>
          <affiliation>Alibaba Group, China</affiliation>
          <bio>undefined</bio>
          <person_id>binliao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Yihua</first_name>
          <last_name>Jin</last_name>
          <affiliation>Alibaba Group, China</affiliation>
          <bio>undefined</bio>
          <person_id>yihuajin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b4fd46b0-dafe-4490-a041-e38b18c2b15d</slot_id>
      <event_id>71956917-c601-44ae-8f7c-0e7327f4fa45</event_id>
      <title>Gradual Verification of Recursive Heap Data Structures</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>06:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>06:20</end_time>
      <description>Current static verification techniques do not provide good support for incrementality, making it difficult for developers to focus on specifying and verifying the properties and components that are most important. Dynamic verification approaches support incrementality, but cannot provide static guarantees. To bridge this gap, prior work proposed gradual verification, which supports incrementality by allowing every assertion to be complete, partial, or omitted, and provides sound verification that smoothly scales from dynamic to static checking. The prior approach to gradual verification, however, was limited to programs without recursive data structures. This paper extends gradual verification to programs that manipulate recursive, mutable data structures on the heap. We address several technical challenges, such as semantically connecting iso- and equi-recursive interpretations of abstract predicates, and supporting gradual verification of heap ownership. This work thus lays the foundation for future tools that work on realistic programs and support verification within an engineering process in which cost-benefit trade-offs can be made.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jenna</first_name>
          <last_name>Wise</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jlwise/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jennawise/614a00d0-d8ab-4b2f-8ec7-96abcb5c3d5b/small.jpg</picture_url>
          <person_id>jennawise</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Johannes</first_name>
          <last_name>Bader</last_name>
          <affiliation>Jane Street</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.johannes-bader.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johannesbader/0b7e635c-fba7-4113-a53d-4451edd44ca5/small.jpg</picture_url>
          <person_id>johannesbader</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Cameron</first_name>
          <last_name>Wong</last_name>
          <affiliation>Jane Street</affiliation>
          <bio>Wannabe type theorist.</bio>
          <homepage_url>https://camdar.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cameronwong/1e4412d3-e79b-4f6a-8465-6b756986e1d0/small.jpg</picture_url>
          <person_id>cameronwong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile, Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
          <person_id>etanter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Sunshine</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jssunshi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joshuasunshine/474067e5-86e8-476c-9622-5c89be145f4b/small.jpg</picture_url>
          <person_id>joshuasunshine</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8ae9cd9f-ef33-44c5-b831-b3dc7f615daf</subevent_id>
    <title>SPLASH OOPSLA: F-5A</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>9ec5ac70-d2a5-4a25-8be9-ee949bb3ce88</slot_id>
      <title>Session: SPLASH OOPSLA - F-5A</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7b564f95-c5b6-41ca-a606-03651eb61476</slot_id>
      <event_id>d2aab79b-b621-41d8-b67d-1273235197f3</event_id>
      <title>Effects as Capabilities: Effect Handlers and Lightweight Effect Polymorphism</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>15:20</end_time>
      <description>Effect handlers have recently gained popularity amongst programming language researchers. Existing type- and effect systems for effect handlers are often complicated and potentially hinder a wide-spread adoption. 
We present the language Effekt with the goal to close the gap between research languages with effect handlers and languages for working programmers. The design of Effekt revolves around a different view of effects and effect types. Traditionally, effect types express which &amp;lt;em&amp;gt;side effects&amp;lt;/em&amp;gt; a computation might have. In Effekt, effect types express which &amp;lt;em&amp;gt;capabilities&amp;lt;/em&amp;gt; a computation requires from its context. While this new point in the design space of effect systems impedes reasoning about purity, we demonstrate that it simplifies the treatment of effect polymorphism and the related issues of effect parametricity and effect encapsulation. To guarantee effect safety, we separate functions from values and treat &amp;lt;em&amp;gt;all&amp;lt;/em&amp;gt; functions as second-class. We define the semantics of Effekt as a translation to System Xi, a calculus in explicit capability-passing style.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan Immanuel</first_name>
          <last_name>Brachthäuser</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanbrachthauser/f9c0b5dc-9b85-444f-baed-e807673f202d/small.jpg</picture_url>
          <person_id>jonathanbrachthauser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Philipp</first_name>
          <last_name>Schuster</last_name>
          <affiliation>University of Tübingen, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippschuster/b2af00d9-c827-45e0-9805-0bf508cae083/small.jpg</picture_url>
          <person_id>philippschuster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Klaus</first_name>
          <last_name>Ostermann</last_name>
          <affiliation>University of Tübingen, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ps.informatik.uni-tuebingen.de/team/ostermann/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/klausostermann/3b2188f0-6472-4a18-b97c-765414c990c8/small.jpg</picture_url>
          <person_id>klausostermann</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b351a196-6797-4855-9961-12fe7a0bb2ed</slot_id>
      <event_id>88644c6c-8c4f-495f-859b-174d3c0ad26b</event_id>
      <title>Fast Linear Programming through Transprecision Computing on Small and Sparse Data</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>15:40</end_time>
      <description>A plethora of program analysis and optimization techniques rely on linear programming at their heart. However, such techniques are often considered too slow for production use. While today’s best solvers are optimized for complex problems with thousands of dimensions, linear programming, as used in compilers, is typically applied to small and seemingly trivial problems, but to many instances in a single compilation run. As a result, compilers do not benefit from decades of research on optimizing large-scale linear programming. We design a simplex solver targeted at compilers. A novel theory of transprecision computation applied from individual elements to full data-structures provides the computational foundation. By carefully combining it with optimized representations for small and sparse matrices and specialized small-coefficient algorithms, we (1) reduce memory traffic, (2) exploit wide vectors, and (3) use low-precision arithmetic units effectively. We evaluate our work by embedding our solver into a state-of-the-art integer set library and implement one essential operation, coalescing, on top of our transprecision solver. Our evaluation shows more than an order-of-magnitude speedup on the core simplex pivot operation and a mean speedup of 3.2x (vs. GMP) and 4.6x (vs. IMath) for the optimized coalescing operation. Our results demonstrate that our optimizations exploit the wide SIMD instructions of modern microarchitectures effectively. We expect our work to provide foundations for a future integer set library that uses transprecision arithmetic to accelerate compiler analyses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Grosser</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.grosser.es</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tobiasgrosser/1ee43044-14e9-497e-a230-90f96a8da867/small.jpg</picture_url>
          <person_id>tobiasgrosser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Theodoros</first_name>
          <last_name>Theodoridis</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/theodorostheodoridis/910b8757-b907-47c7-967c-de5414cae4b3/small.jpg</picture_url>
          <person_id>theodorostheodoridis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Maximilian</first_name>
          <last_name>Falkenstein</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>maxmilianfalkenstein</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Pitchanathan</last_name>
          <affiliation>IIIT Hyderabad, India</affiliation>
          <bio>undefined</bio>
          <person_id>arjunpitchanathan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Kruse</last_name>
          <affiliation>Argonne National Laboratory, USA</affiliation>
          <bio>undefined</bio>
          <person_id>michaelkruse1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Rigger</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>Manuel Rigger is a postdoctoral researcher in the Advanced Software Technologies (AST) Lab at ETH Zurich, mentored by Zhendong Su. He is working on programming language implementation, software reliability, and systems. He completed his PhD at Johannes Kepler University Linz, mentored by Hanspeter Mössenböck, and is known for his work on Sulong to support the safe execution of LLVM-based languages.</bio>
          <homepage_url>http://www.manuelrigger.at/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelrigger/47e268e9-158c-471f-a7e9-442216c54550/small.jpg</picture_url>
          <person_id>manuelrigger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Torsten</first_name>
          <last_name>Hoefler</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>torstenhoefler1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c49b3977-bf78-4796-930d-b360d8899600</subevent_id>
    <title>SPLASH OOPSLA: M-5</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>20b051f9-879f-4a54-82ee-a7fc714c84aa</slot_id>
      <title>Session: SPLASH OOPSLA - M-5</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Leonidas</first_name>
          <last_name>Lampropoulos</last_name>
          <affiliation>University of Maryland, College Park</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://lemonidas.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/leonidaslampropoulos/0533948d-2e45-449e-b1d5-5fe451706ede/small.jpg</picture_url>
          <person_id>leonidaslampropoulos</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>07e5ef70-f028-4862-a5ed-01aef07f7d89</slot_id>
      <event_id>d3521f08-1659-438b-8e27-401ba4d8046c</event_id>
      <title>Counterexample-Guided Correlation Algorithm for Translation Validation</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>15:40</end_time>
      <description>Automatic translation validation across the unoptimized intermediate representation (IR) of the original source code and the optimized executable assembly code is a desirable capability, and has the potential to compete with existing approaches to verified compilation such as CompCert. A difficult subproblem is the automatic identification of the correlations across the transitions between the two programs' respective locations. We present a counterexample-guided algorithm to identify these correlations in a robust and scalable manner. Our algorithm has both theoretical and empirical advantages over prior work in this problem space.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shubhani</first_name>
          <last_name>Gupta</last_name>
          <affiliation>IIT Delhi, India</affiliation>
          <bio>undefined</bio>
          <person_id>shubhani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Abhishek</first_name>
          <last_name>Rose</last_name>
          <affiliation>IIT Delhi, India</affiliation>
          <bio>undefined</bio>
          <person_id>abhishekrose</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sorav</first_name>
          <last_name>Bansal</last_name>
          <affiliation>IIT Delhi, India</affiliation>
          <bio>See http://compiler.ai for recent work</bio>
          <homepage_url>http://www.cse.iitd.ac.in/~sbansal</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/soravbansal1/3bacf39b-3a07-41a7-9acd-f6b4c27d2f89/small.jpg</picture_url>
          <person_id>soravbansal1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5c141a66-1d47-472c-85dd-f713a9a20d5b</slot_id>
      <event_id>41308516-fe76-4573-a027-84e9a6af5694</event_id>
      <title>Multiparty Motion Coordination: From Choreographies to Robotics Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>16:00</end_time>
      <description>We present a programming model and typing discipline for complex multi-robot coordination programming. Our model encompasses both synchronisation through message passing and continuous-time dynamic motion primitives in physical space. We specify &amp;lt;i&amp;gt;continuous-time motion primitives&amp;lt;/i&amp;gt; in an assume-guarantee logic that ensures compatibility of motion primitives as well as collision freedom. We specify global behaviour of programs in a &amp;lt;i&amp;gt;choreographic&amp;lt;/i&amp;gt; type system that extends multiparty session types with jointly executed motion primitives, predicated refinements, as well as a &amp;lt;i&amp;gt;separating conjunction&amp;lt;/i&amp;gt; that allows reasoning about subsets of interacting robots. We describe a notion of &amp;lt;i&amp;gt;well-formedness&amp;lt;/i&amp;gt; for global types that ensures motion and communication can be correctly synchronised and provide algorithms for checking well-formedness, projecting a type, and local type checking. A well-typed program is &amp;lt;i&amp;gt;communication safe&amp;lt;/i&amp;gt;, &amp;lt;i&amp;gt;motion compatible&amp;lt;/i&amp;gt;, and &amp;lt;i&amp;gt;collision free&amp;lt;/i&amp;gt;. Our type system provides a compositional approach to ensuring these properties. 
We have implemented our model on top of the ROS framework. This allows us to program multi-robot coordination scenarios on top of commercial and custom robotics hardware platforms. We show through case studies that we can model and statically verify quite complex manoeuvres involving multiple manipulators and mobile robots—such examples are beyond the scope of previous approaches.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rupak</first_name>
          <last_name>Majumdar</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~rupak</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rupakmajumdar/3289b197-9f9a-4880-94c5-d9cf6d764bb1/small.jpg</picture_url>
          <person_id>rupakmajumdar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Damien</first_name>
          <last_name>Zufferey</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://dzufferey.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/damienzufferey/5dc321db-5cef-4f4b-bd3c-a5bbb2f11dd1/small.jpg</picture_url>
          <person_id>damienzufferey</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>71dad1ce-ad7f-45f4-95d9-6deb5c2480fd</slot_id>
      <event_id>8ec74bdb-391c-4417-a0de-3cfe60039dfb</event_id>
      <title>On the Unusual Effectiveness of Type-Aware Operator Mutations for Testing SMT Solvers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>16:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>16:20</end_time>
      <description>We propose type-aware operator mutation, a simple, but unusually effective approach for testing SMT solvers. The key idea is to mutate operators of conforming types within the seed formulas to generate well-typed mutant formulas. These mutant formulas are then used as the test cases for SMT solvers. We realized type-aware operator mutation within the OpFuzz tool and used it to stress-test Z3 and CVC4, two state-of-the-art SMT solvers. Type-aware operator mutations are unusually effective: During one year of extensive testing with OpFuzz, we reported 1092 bugs on Z3’s and CVC4’s respective GitHub issue trackers, out of which 819 unique bugs were confirmed and 685 of the confirmed bugs were fixed by the developers. The detected bugs are highly diverse — we found bugs of many different types (soundness bugs, invalid model bugs, crashes, etc.), logics and solver configurations. We have further conducted an in-depth study of the bugs found by OpFuzz. The study results show that the bugs found by OpFuzz are of high quality. Many of them affect core components of the SMT solvers’ codebases, and some required major changes for the developers to fix. Among the 819 confirmed bugs found by OpFuzz,184 were soundness bugs, the most critical bugs in SMT solvers,and 489 were in the default modes of the solvers. Notably, OpFuzz found 27 critical soundness bugs in CVC4, which has proved to be a very stable SMT solver.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dominik</first_name>
          <last_name>Winterer</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/dominikwinterer/f89f4b13-8156-4541-b618-d5128446e27f/small.jpg</picture_url>
          <person_id>dominikwinterer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chengyu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>East China Normal University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.chengyuzhang.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/chengyuzhang/eee80413-7fee-43ac-88d2-72212b8b352a/small.jpg</picture_url>
          <person_id>chengyuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b61fb79f-5c61-4f3f-bf25-c57de286980a</slot_id>
      <event_id>f94ed25c-81d9-4aad-b499-42ebb3391f9d</event_id>
      <title>CAMP: Cost-Aware Multiparty Session Protocols</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>15:20</end_time>
      <description>This paper presents CAMP, a new static performance analysis framework for message-passing concurrent and distributed systems, based on the theory of multiparty session types (MPST). Understanding the run-time performance of concurrent and distributed systems is of great importance for the identification of bottlenecks and optimisation opportunities. In the message-passing setting, these bottlenecks are generally communication overheads and synchronisation times. Despite its importance, reasoning about these intensional properties of software, such as performance, has received little attention, compared to verifying extensional properties, such as correctness. Behavioural protocol specifications based on sessions types capture not only extensional, but also intensional properties of concurrent and distributed systems. CAMP augments MPST with annotations of communication latency and local computation cost, defined as estimated execution times, that we use to extract cost equations from protocol descriptions. CAMP is also extendable to analyse asynchronous communication optimisation built on a recent advance of session type theories. We apply our tool to different existing benchmarks and use cases in the literature with a wide range of communication protocols, implemented in C, MPI-C, Scala, Go, and OCaml. Our benchmarks show that, in most of the cases, we predict an upper-bound on the real execution costs with &amp;lt; 15% error.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Castro</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <person_id>davidcastro</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4a52e381-9c16-4a27-9878-300edb61b391</subevent_id>
    <title>SPLASH OOPSLA: F-4B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>3c0ae0c3-b2e1-417c-9d69-e2d7b4da1cb0</slot_id>
      <title>Session: SPLASH OOPSLA - F-4B</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/21</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>62440e50-778a-40c5-84f4-750ac0be65fa</slot_id>
      <event_id>88401ded-3b58-4749-8aef-7b24b61ab09f</event_id>
      <title>Neural Reverse Engineering of Stripped Binaries using Augmented Control Flow Graphs</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/21</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>02:00</end_time>
      <description>We address the problem of reverse engineering of stripped executables, which contain no debug information. This is a challenging problem because of the low amount of syntactic information available in stripped executables, and the diverse assembly code patterns arising from compiler optimizations. We present a novel approach for predicting procedure names in stripped executables. Our approach combines static analysis with neural models. The main idea is to use static analysis to obtain augmented representations of call sites; encode the structure of these call sites using the control-flow graph (CFG) and finally, generate a target name while attending to these call sites. We use our representation to drive graph-based, LSTM-based and Transformer-based architectures. Our evaluation shows that our models produce predictions that are difficult and time consuming for humans, while improving on existing methods by 28% and by 100% over state-of-the-art neural textual models that do not use any static analysis. Code and data for this evaluation are available at https://github.com/tech-srl/Nero.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yaniv</first_name>
          <last_name>David</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://yanivd.cswp.cs.technion.ac.il</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yanivdavid/83ffa94a-79ef-4627-b213-9d48cfeac290/small.jpg</picture_url>
          <person_id>yanivdavid</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Uri</first_name>
          <last_name>Alon</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~urialon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/urialon/a0488e4f-5173-472b-af25-10666c27e3d4/small.jpg</picture_url>
          <person_id>urialon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>Eran Yahav is an associate professor at the Computer Science Department, Technion, Israel. Prior to that, he was a research staff member at the IBM T.J. Watson Research Center (2004-2010). He received his Ph.D. from Tel Aviv University (2005) and his B.Sc. from the Technion in 1996. His research interests include program analysis, program synthesis and program verification. Eran is a recipient of the prestigious Alon Fellowship for Outstanding Young Researchers, the Andre Deloro Career Advancement Chair in Engineering, the ERC Consolidator Grant as well as multiple best paper awards at various conferences.</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
          <person_id>eranyahav</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>66eb9fb0-cc8a-4ec4-9ba7-68efdd3b1362</slot_id>
      <event_id>ec90eddc-d967-43e8-8847-c0b006802b6a</event_id>
      <title>Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/21</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>01:40</end_time>
      <description>Lighthouse projects like CompCert, seL4, IronFleet, and DeepSpec have demonstrated that full system verification is feasible by establishing a refinement between an abstract system specification and an executable implementation. Existing approaches however impose severe restrictions on the abstract system specifications due to their limited expressiveness or versatility, or on the executable code due to their use of suboptimal code extraction or inexpressive program logics. We propose a novel methodology that combines the compositional refinement of event-based models of distributed systems with the verification of full-fledged program code using expressive separation logics, which support features of realistic programming languages like heap data structures and concurrency. Our main technical contribution is a formal framework that soundly relates event-based system models to program specifications in separation logics. This enables protocol development tools to soundly interoperate with program verifiers to establish a refinement between the model and the code. We formalized our framework, Igloo, in Isabelle/HOL. We report on three case studies, a leader election protocol, a replication protocol, and a security protocol, for which we refine formal requirements into program specifications that we implement in Java and Python and prove correct using the VeriFast and Nagini tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Sprenger</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>christophsprenger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Klenze</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>tobiasklenze</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marco</first_name>
          <last_name>Eilers</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch/people/personal/meilers-pers.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/marcoeilers/fbfa4a0a-c277-440b-af64-20c5dbf19d0c/small.jpg</picture_url>
          <person_id>marcoeilers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Felix A.</first_name>
          <last_name>Wolf</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>felixwolf2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Peter</first_name>
          <last_name>Müller</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/petermller/aeb8e276-62cb-4ad1-aa7d-96f76c0c405d/small.jpg</picture_url>
          <person_id>petermller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Martin</first_name>
          <last_name>Clochard</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>martinclochard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>David</first_name>
          <last_name>Basin</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>davidbasin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6bbadf28-dbf9-4724-9579-ab5c94f57a50</slot_id>
      <event_id>cb73d5d3-92d2-4ee8-bb13-8a1b4731e3a3</event_id>
      <title>Termination Analysis for Evolving Programs: An Incremental Approach by Reusing Certified Modules</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/21</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>02:20</end_time>
      <description>Research on program termination has a long tradition. However, most of the existing techniques target a single program only. We propose in this paper an incremental termination analysis approach by reusing certified modules across different program versions. A transformation-based procedure is further developed to increase the reusability of certified modules. The proposed approach has wide applicability, applicable to various program changes. The proposed technique, to the best of our knowledge, represents a novel attempt to the termination analysis of evolving programs. We implemented the approach on top of \textsc{Ultimate Automizer}. Experimental results show dramatic improvement of our approach over the state-of-the-art tool.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fei</first_name>
          <last_name>He</last_name>
          <affiliation>Tsinghua University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://feihe.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/feihe/8546030e-3821-4cb3-8f33-23a258579461/small.jpg</picture_url>
          <person_id>feihe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jitao</first_name>
          <last_name>Han</last_name>
          <affiliation>Tsinghua University, China</affiliation>
          <bio>undefined</bio>
          <person_id>jitaohan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e8599349-96f9-41e3-b1d9-ea4d1e31d775</slot_id>
      <event_id>607946f8-4df3-4340-83bb-3317adc76c7a</event_id>
      <title>Certified and Efficient Instruction Scheduling: Application to Interlocked VLIW Processors</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/21</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>01:20</end_time>
      <description>CompCert is a moderately optimizing C compiler with a formal, machine-checked, proof of correctness: after successful compilation, the assembly code has a behavior faithful to the source code. Previously, it only supported target instruction sets with sequential semantics, and did not attempt reordering instructions for optimization. 
We present here a CompCert backend for a VLIW core (\textit{i.e.} with explicit parallelism at the instruction level), the first CompCert backend providing scalable and efficient instruction scheduling. Furthermore, its highly modular implementation can be easily adapted to other VLIW or non-VLIW pipelined processors.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cyril</first_name>
          <last_name>Six</last_name>
          <affiliation>Kalray, France / Grenoble Alps University, France / CNRS, France / Grenoble INP, France / VERIMAG, France</affiliation>
          <bio>undefined</bio>
          <person_id>cyrilsix</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sylvain</first_name>
          <last_name>Boulmé</last_name>
          <affiliation>Grenoble Alps University, France / CNRS, France / Grenoble INP, France / VERIMAG, France</affiliation>
          <bio>undefined</bio>
          <person_id>sylvainboulme</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Monniaux</last_name>
          <affiliation>Grenoble Alps University, France / CNRS, France / Grenoble INP, France / VERIMAG, France</affiliation>
          <bio>David Monniaux obtained his PhD in 2001 in Paris under Prof Patrick Cousot; his dissertation was on the static analysis of probabilistic programs by abstract interpretation. He then joined CNRS as a junior researcher and first worked on the Astrée static analyzer, still in Paris. In 2007 he transferred to VERIMAG in Grenoble, where he works on various aspects of program verification (decision procedures, abstract interpretation…). 
He now is a senior researcher at CNRS and an adjunct professor at École polytechnique.</bio>
          <homepage_url>http://www-verimag.imag.fr/~monniaux/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidmonniaux/d285baca-8e32-4918-b3c6-c724e98fc7b3/small.jpg</picture_url>
          <person_id>davidmonniaux</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d3018d06-e44d-4590-bb68-e331660f970a</subevent_id>
    <title>SPLASH OOPSLA: F-5A</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>c351a54f-bb47-43e6-a491-9c92dccca2f4</slot_id>
      <title>Session: SPLASH OOPSLA - F-5A</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a0ea4912-1fa6-4d0f-8d8c-981c5137c765</slot_id>
      <event_id>88644c6c-8c4f-495f-859b-174d3c0ad26b</event_id>
      <title>Fast Linear Programming through Transprecision Computing on Small and Sparse Data</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>03:40</end_time>
      <description>A plethora of program analysis and optimization techniques rely on linear programming at their heart. However, such techniques are often considered too slow for production use. While today’s best solvers are optimized for complex problems with thousands of dimensions, linear programming, as used in compilers, is typically applied to small and seemingly trivial problems, but to many instances in a single compilation run. As a result, compilers do not benefit from decades of research on optimizing large-scale linear programming. We design a simplex solver targeted at compilers. A novel theory of transprecision computation applied from individual elements to full data-structures provides the computational foundation. By carefully combining it with optimized representations for small and sparse matrices and specialized small-coefficient algorithms, we (1) reduce memory traffic, (2) exploit wide vectors, and (3) use low-precision arithmetic units effectively. We evaluate our work by embedding our solver into a state-of-the-art integer set library and implement one essential operation, coalescing, on top of our transprecision solver. Our evaluation shows more than an order-of-magnitude speedup on the core simplex pivot operation and a mean speedup of 3.2x (vs. GMP) and 4.6x (vs. IMath) for the optimized coalescing operation. Our results demonstrate that our optimizations exploit the wide SIMD instructions of modern microarchitectures effectively. We expect our work to provide foundations for a future integer set library that uses transprecision arithmetic to accelerate compiler analyses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Grosser</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.grosser.es</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tobiasgrosser/1ee43044-14e9-497e-a230-90f96a8da867/small.jpg</picture_url>
          <person_id>tobiasgrosser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Theodoros</first_name>
          <last_name>Theodoridis</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/theodorostheodoridis/910b8757-b907-47c7-967c-de5414cae4b3/small.jpg</picture_url>
          <person_id>theodorostheodoridis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Maximilian</first_name>
          <last_name>Falkenstein</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>maxmilianfalkenstein</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Pitchanathan</last_name>
          <affiliation>IIIT Hyderabad, India</affiliation>
          <bio>undefined</bio>
          <person_id>arjunpitchanathan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Kruse</last_name>
          <affiliation>Argonne National Laboratory, USA</affiliation>
          <bio>undefined</bio>
          <person_id>michaelkruse1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Rigger</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>Manuel Rigger is a postdoctoral researcher in the Advanced Software Technologies (AST) Lab at ETH Zurich, mentored by Zhendong Su. He is working on programming language implementation, software reliability, and systems. He completed his PhD at Johannes Kepler University Linz, mentored by Hanspeter Mössenböck, and is known for his work on Sulong to support the safe execution of LLVM-based languages.</bio>
          <homepage_url>http://www.manuelrigger.at/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelrigger/47e268e9-158c-471f-a7e9-442216c54550/small.jpg</picture_url>
          <person_id>manuelrigger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Torsten</first_name>
          <last_name>Hoefler</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>torstenhoefler1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d544f8b9-dc4e-49bd-b59f-b8a78e23fea5</slot_id>
      <event_id>d2aab79b-b621-41d8-b67d-1273235197f3</event_id>
      <title>Effects as Capabilities: Effect Handlers and Lightweight Effect Polymorphism</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>03:20</end_time>
      <description>Effect handlers have recently gained popularity amongst programming language researchers. Existing type- and effect systems for effect handlers are often complicated and potentially hinder a wide-spread adoption. 
We present the language Effekt with the goal to close the gap between research languages with effect handlers and languages for working programmers. The design of Effekt revolves around a different view of effects and effect types. Traditionally, effect types express which &amp;lt;em&amp;gt;side effects&amp;lt;/em&amp;gt; a computation might have. In Effekt, effect types express which &amp;lt;em&amp;gt;capabilities&amp;lt;/em&amp;gt; a computation requires from its context. While this new point in the design space of effect systems impedes reasoning about purity, we demonstrate that it simplifies the treatment of effect polymorphism and the related issues of effect parametricity and effect encapsulation. To guarantee effect safety, we separate functions from values and treat &amp;lt;em&amp;gt;all&amp;lt;/em&amp;gt; functions as second-class. We define the semantics of Effekt as a translation to System Xi, a calculus in explicit capability-passing style.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan Immanuel</first_name>
          <last_name>Brachthäuser</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanbrachthauser/f9c0b5dc-9b85-444f-baed-e807673f202d/small.jpg</picture_url>
          <person_id>jonathanbrachthauser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Philipp</first_name>
          <last_name>Schuster</last_name>
          <affiliation>University of Tübingen, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippschuster/b2af00d9-c827-45e0-9805-0bf508cae083/small.jpg</picture_url>
          <person_id>philippschuster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Klaus</first_name>
          <last_name>Ostermann</last_name>
          <affiliation>University of Tübingen, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ps.informatik.uni-tuebingen.de/team/ostermann/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/klausostermann/3b2188f0-6472-4a18-b97c-765414c990c8/small.jpg</picture_url>
          <person_id>klausostermann</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d5c9f8d3-5d80-4bbe-89bd-0f6b36c261e0</subevent_id>
    <title>SPLASH OOPSLA: T-6B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>f689fbb6-cd1e-4383-8965-c9115d7c702c</slot_id>
      <title>Session: SPLASH OOPSLA - T-6B</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Sorav</first_name>
          <last_name>Bansal</last_name>
          <affiliation>IIT Delhi, India</affiliation>
          <bio>See http://compiler.ai for recent work</bio>
          <homepage_url>http://www.cse.iitd.ac.in/~sbansal</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/soravbansal1/3bacf39b-3a07-41a7-9acd-f6b4c27d2f89/small.jpg</picture_url>
          <person_id>soravbansal1</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Flückiger</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.o1o.ch</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/olivierfluckiger/6051271d-0eac-48f3-b931-bff878bbce61/small.jpg</picture_url>
          <person_id>olivierfluckiger</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4399c6ea-93e1-4b7b-833d-16c0b480a78d</slot_id>
      <event_id>d9f820f7-6c4c-4457-bbf2-f791d2e1d42d</event_id>
      <title>World Age in Julia: Optimizing Method Dispatch in the Presence of Eval</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>05:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>06:00</end_time>
      <description>Dynamic programming languages face semantic and performance challenges in the presence of features, such as eval, that can inject new code into a running program. The Julia programming language introduces the novel concept of world age to insulate optimized code from one of the most disruptive side-effects of eval: changes to the definition of an existing function. This paper provides the first formal semantics of world age in a core calculus named juliette, and shows how world age enables compiler optimizations, such as inlining, in the presence of eval. While Julia also provides programmers with the means to bypass world age, we found that this mechanism is not used extensively: a static analysis of over 4,000 registered Julia packages shows that only 4-9% of packages bypass world age. This suggests that Julia's semantics aligns with programmer expectations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julia</first_name>
          <last_name>Belyakova</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>Sep 2018 – present: PhD Student, Northeastern University, USA. Sep 2017 – Jul 2018: Researcher, Czech Technical University in Prague, Czech Republic. Jan 2017 – Jun 2017: Research Scientist, Northeastern University, USA. 2014–2016: teaching assistant/lecturer at Southern Federal University, Russia. Received MS in Computer Science from Southern Federal University, Russia in 2014.</bio>
          <homepage_url>https://julbinb.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juliabelyakova/b35236df-c22a-44f1-8048-aecfeba8ac2e/small.jpg</picture_url>
          <person_id>juliabelyakova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Chung</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/benjaminchung/30978af0-bcee-4c1e-9dd1-f2588ea14f38/small.jpg</picture_url>
          <person_id>benjaminchung</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jack</first_name>
          <last_name>Gelinas</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/jackgelinas/f0a65e20-3150-4f2b-bc96-82364dbc2f2c/small.jpg</picture_url>
          <person_id>jackgelinas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jameson</first_name>
          <last_name>Nash</last_name>
          <affiliation>Julia Computing, n.n.</affiliation>
          <bio>undefined</bio>
          <person_id>jamesonnash1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ross</first_name>
          <last_name>Tate</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cornell.edu/~ross/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rosstate/cbcbd066-943d-46a2-a301-1f4084076400/small.jpg</picture_url>
          <person_id>rosstate</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University, USA / Czech Technical University, Czechia</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4851770d-ae73-4332-b64d-273ee48544a4</slot_id>
      <event_id>c46ee935-d61f-4ade-a84a-9db9d88c737e</event_id>
      <title>Featherweight Go</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>06:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>06:20</end_time>
      <description>We describe a design for generics in Go inspired by previous work on Featherweight Java by Igarashi, Pierce, and Wadler. Whereas subtyping in Java is nominal, in Go it is structural, and whereas generics in Java are defined via erasure, in Go we use monomorphisation. Although monomorphisation is widely used, we are one of the first to formalise it. Our design also supports a solution to The Expression Problem.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Griesemer</last_name>
          <affiliation>Google, USA</affiliation>
          <bio>undefined</bio>
          <person_id>robertgriesemer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Raymond</first_name>
          <last_name>Hu</last_name>
          <affiliation>University of Hertfordshire, UK</affiliation>
          <bio>undefined</bio>
          <person_id>raymondhu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Wen</first_name>
          <last_name>Kokke</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wenkokke.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/wenkokke/756e11ff-851e-4355-865b-0b5ce896d4af/small.jpg</picture_url>
          <person_id>wenkokke</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Julien</first_name>
          <last_name>Lange</last_name>
          <affiliation>Royal Holloway University of London, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.rhul.ac.uk/~jlange</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/julienlange1/7f3ad551-a3e6-46ce-9718-954f3147736b/small.jpg</picture_url>
          <person_id>julienlange1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ian Lance</first_name>
          <last_name>Taylor</last_name>
          <affiliation>Google, n.n.</affiliation>
          <bio>undefined</bio>
          <person_id>ianlancetaylor</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Bernardo</first_name>
          <last_name>Toninho</last_name>
          <affiliation>Nova University of Lisbon, Portugal / NOVA-LINCS, Portugal</affiliation>
          <bio>I am interested in the application of language-based techniques to the development of more robust and safer concurrent and distributed systems. More specifically, I work within the realm of (substructural) type theory, such as those based on Linear Logic and Session Types, and their applications to concurrent programming. I am also interested in using type and logic-based techniques to verify concurrent programs in real languages such as Go, Rust and Scala.</bio>
          <homepage_url>http://ctp.di.fct.unl.pt/~btoninho/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/bernardotoninho/1125bc54-0549-4ee4-bf19-394d89568c34/small.jpg</picture_url>
          <person_id>bernardotoninho</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Philip</first_name>
          <last_name>Wadler</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>Philip Wadler is Professor of Theoretical Computer Science at the University of Edinburgh. He is an ACM Fellow and a Fellow of the Royal Society of Edinburgh, past chair of ACM SIGPLAN, past holder of a Royal Society-Wolfson Research Merit Fellowship, winner of the SIGPLAN Distinguished Service Award, and a winner of the POPL Most Influential Paper Award. Previously, he worked or studied at Stanford, Xerox Parc, CMU, Oxford, Chalmers, Glasgow, Bell Labs, and Avaya Labs, and visited as a guest professor in Copenhagen, Sydney, and Paris. He has an h-index of 60, with more than 20,000 citations to his work according to Google Scholar. He contributed to the designs of Haskell, Java, and XQuery, and is a co-author of Introduction to Functional Programming (Prentice Hall, 1988), XQuery from the Experts (Addison Wesley, 2004) and Generics and Collections in Java (O’Reilly, 2006). He has delivered invited talks in locations ranging from Aizu to Zurich.</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/wadler/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philipwadler/55a9683e-908b-4052-9d49-20fb795c74cf/small.jpg</picture_url>
          <person_id>philipwadler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9625bccc-0fbf-4906-90e2-e250fd0cf853</slot_id>
      <event_id>9d2e80dd-45d0-4797-be3b-2ed373dc14dd</event_id>
      <title>DynamiTe: Dynamic Termination and Non-termination Proofs</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>05:20</end_time>
      <description>There is growing interest in termination reasoning for nonlinear programs and, meanwhile, recent dynamic strategies have shown they are able to infer invariants for such challenging programs. These advances led us to hypothesize that perhaps such dynamic strategies for nonlinear invariants could be adapted to learn recurrent sets (for non-termination) and/or ranking functions (for termination). 
In this paper, we exploit dynamic analysis and draw termination and non-termination as well as static and dynamic strategies closer together in order to tackle nonlinear programs. For termination, our algorithm infers ranking functions from concrete transitive closures, and, for non-termination, the algorithm iteratively collects executions and dynamically learns conditions to refine recurrent sets. Finally, we describe an integrated algorithm that allows these algorithms to mutually inform each other, taking counterexamples from a failed validation in one endeavor and crossing both the static/dynamic and termination/non-termination lines, to create new execution samples for the other one. 
We have implemented these algorithms in a new tool called DynamiTe. For nonlinear programs, there are currently no SV-COMP termination benchmarks so we created new sets of 38 terminating and 39 non-terminating programs. Our empirical evaluation shows that we can effectively guess (and sometimes even validate) ranking functions and recurrent sets for programs with nonlinear behaviors. Furthermore, we show that counterexamples from one failed validation can be used to generate executions for a dynamic analysis of the opposite property. Although we are focused on nonlinear programs, as a point of comparison, we compare DynamiTe's performance on linear programs with that of the state-of-the-art tool, Ultimate. Although DynamiTe is an order of magnitude slower it is nonetheless somewhat competitive and sometimes finds ranking functions where Ultimate was unable to. Ultimate cannot, however, handle the nonlinear programs in our new benchmark suite.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ton Chanh</first_name>
          <last_name>Le</last_name>
          <affiliation>Stevens Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://chanhle.bitbucket.io/</homepage_url>
          <person_id>tonchanhle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Timos</first_name>
          <last_name>Antonopoulos</last_name>
          <affiliation>Yale University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>timosantonopoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Parisa</first_name>
          <last_name>Fathololumi</last_name>
          <affiliation>Stevens Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>parisafathololumi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Eric</first_name>
          <last_name>Koskinen</last_name>
          <affiliation>Stevens Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.stevens.edu/~ejk/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/erickoskinen/3413fc94-5f0f-4855-af65-da2309d2632f/small.jpg</picture_url>
          <person_id>erickoskinen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>ThanhVu</first_name>
          <last_name>Nguyen</last_name>
          <affiliation>University of Nebraska-Lincoln, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cse.unl.edu/~tnguyen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/thanhvunguyen/db337089-c863-4086-ad33-88d7dbfeb025/small.jpg</picture_url>
          <person_id>thanhvunguyen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>beea1f30-7688-4039-a2ee-3027573361d5</slot_id>
      <event_id>df17fa6a-2bc8-41ee-8c02-85f4a68c1db1</event_id>
      <title>Programming and Reasoning with Partial Observability</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/18</date>
      <start_time>05:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>05:40</end_time>
      <description>Computer programs are increasingly being deployed in partially-observable environments. A partially observable environment is an environment whose state is not completely visible to the program, but from which the program receives partial observations. Developers typically deal with partial observability by writing a state estimator that, given observations, attempts to deduce the hidden state of the environment. In safety-critical domains, to formally verify safety properties developers may write an environment model. The model captures the relationship between observations and hidden states and is used to prove the software correct. 
In this paper, we present a new methodology for writing and verifying programs in partially observable environments. We present {\em belief programming}, a programming methodology where developers write an environment model that the program runtime automatically uses to perform state estimation. A belief program dynamically updates and queries a belief state that captures the possible states the environment could be in. To enable verification, we present {\em Epistemic Hoare logic} that reasons about the possible belief states of a belief program the same way that classical Hoare logic reasons about the possible states of a program. We develop these concepts by defining a semantics and a program logic for a simple core language called BLIMP. In a case study, we show how belief programming could be used to write and verify a controller for the Mars Polar Lander in BLIMP. We present an implementation of BLIMP called CBLIMP and evaluate it to determine the feasibility of belief programming.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Atkinson</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>ericatkinson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology. 
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems. 
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ca7f4eff-20cb-4c08-92aa-4b6d08fc0358</subevent_id>
    <title>SPLASH OOPSLA: M-6</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>8df03c02-4d47-4713-a74d-efc4b0f20d55</slot_id>
      <title>Session: SPLASH OOPSLA - M-6</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Lam</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://patricklam.ca</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/patricklam/d94f6246-8d4e-4896-a263-379eb20a9b24/small.jpg</picture_url>
          <person_id>patricklam</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Mamouras</last_name>
          <affiliation>Rice University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>konstantinosmamouras1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4139843d-392e-4fdf-93eb-330fe007034e</slot_id>
      <event_id>c241afa2-8ebc-4091-ba8b-11b2acfe950d</event_id>
      <title>Can Advanced Type Systems Be Usable? An Empirical Study of Ownership, Assets, and Typestate in Obsidian</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>17:20</end_time>
      <description>Some blockchain programs (smart contracts) have included serious security vulnerabilities. Obsidian is a new typestate-oriented programming language that uses a strong type system to rule out some of these vulnerabilities. Although Obsidian was designed to promote usability to make it as easy as possible to write programs, strong type systems can cause a language to be difficult to use. In particular, ownership, typestate, and assets, which Obsidian uses to provide safety guarantees, have not seen broad adoption together in popular languages and result in significant usability challenges. We performed an empirical study with 20 participants comparing Obsidian to Solidity, which is the language most commonly used for writing smart contracts today. We observed that Obsidian participants were able to successfully complete more of the programming tasks than the Solidity participants. We also found that the Solidity participants commonly inserted asset-related bugs, which Obsidian detects at compile time.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Coblenz</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umd.edu/~mcoblenz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelcoblenz/aa74b306-529b-44d4-987f-a5e4fd6d3ca2/small.jpg</picture_url>
          <person_id>michaelcoblenz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brad</first_name>
          <last_name>Myers</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~bam/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/bradmyers/7d93ede9-5674-40e8-9ba5-f9dfab4873e1/small.jpg</picture_url>
          <person_id>bradmyers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Sunshine</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jssunshi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joshuasunshine/474067e5-86e8-476c-9622-5c89be145f4b/small.jpg</picture_url>
          <person_id>joshuasunshine</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>593f1ff2-1943-495f-96f7-4d7e0d30f24b</slot_id>
      <event_id>f6dc9ecd-0036-4c59-8d53-f697d30259d2</event_id>
      <title>Geometry Types for Graphics Programming</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>18:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>18:20</end_time>
      <description>In domains that deal with physical space and geometry, programmers need to track the coordinate systems that underpin a computation. We identify a class of geometry bugs that arise from confusing which coordinate system a vector belongs to. These bugs are not ruled out by current languages for vector-oriented computing, are difficult to check for at run time, and can generate subtly incorrect output that can be hard to test for. 
We introduce a type system and language that prevents geometry bugs by reflecting the coordinate system for each geometric object. A value's geometry type encodes its reference frame, the kind of geometric object (such as a point or a direction), and the coordinate representation (such as Cartesian or spherical coordinates). We show how these types can rule out geometrically incorrect operations, and we show how to use them to automatically generate correct-by-construction code to transform vectors between coordinate systems. We implement a language for graphics programming, Gator, that checks geometry types and compiles to OpenGL's shading language, GLSL. Using case studies, we demonstrate that Gator can raise the level of abstraction for shader programming and prevent common errors without inducing significant annotation overhead or performance cost.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dietrich</first_name>
          <last_name>Geisler</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>dietrichgeisler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Irene</first_name>
          <last_name>Yoon</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://seas.upenn.edu/~euisuny</homepage_url>
          <person_id>ireneyoon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aditi</first_name>
          <last_name>Kabra</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>aditikabra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Horace</first_name>
          <last_name>He</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>horacehe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yinnon</first_name>
          <last_name>Sanders</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>yinnonsanders</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Adrian</first_name>
          <last_name>Sampson</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://adriansampson.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adriansampson/adaa9202-3352-4410-b03a-1eb4718543d5/small.jpg</picture_url>
          <person_id>adriansampson</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9ae7128d-e138-4f37-9b64-7d397ee6f541</slot_id>
      <event_id>0cc82840-fb71-4f1f-a4cb-a199c7956974</event_id>
      <title>Scalable and Serializable Networked Multi-actor Programming</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>17:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>17:40</end_time>
      <description>A major challenge in writing applications that execute across hosts, such as distributed online services, is to reconcile (a) parallelism (i.e., allowing components to execute independently on disjoint tasks), and (b)cooperation (i.e., allowing components to work together on common tasks). A good compromise between the two is vital to scalability, a core concern in distributed networked applications. 
The actor model of computation is a widely promoted programming model for distributed applications, as actors can execute in individual threads (parallelism) across different hosts and interact via asynchronous message passing (collaboration). However, this makes it hard for programmers to reason about combinations of messages as opposed to individual messages, which is essential in many scenarios. 
This paper presents a pragmatic variant of the actor model in which messages can be grouped into units that are executed in a serializable manner, whilst still retaining a high degree of parallelism. In short, our model is based on an orchestration of actors along a directed acyclic graph that supports efficient decentralized synchronization among actors based on their actual interaction. We present the implementation of this model, based on a dynamic DAG-inducing referencing discipline, in the actor-based programming language AEON. We argue serializability and the absence of deadlocks in our model, and demonstrate its scalability and usability through extensive evaluation and case studies of wide-ranging applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>BO</first_name>
          <last_name>SANG</last_name>
          <affiliation>Purdue University, USA / Ant Group, USA</affiliation>
          <bio>undefined</bio>
          <person_id>bosang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Eugster</last_name>
          <affiliation>USI Lugano, Switzerland / TU Darmstadt, Germany / Purdue University, USA</affiliation>
          <bio>Professor Eugster’s research aims at proposing support for developing distributed systems. Particular topics of interest, in the context of distributed settings, include algorithms, middleware, and programming languages, abstractions, and methodologies. 
Professor Eugster was educated in Switzerland, and has worked for both Swiss Federal Institutes of Technology in Lausanne (EPFL) and in Zurich (ETHZ), as well as for Sun Microsystems (now Oracle) prior to joining Purdue University. He has authored over 70 refereed articles, and is a member of ACM and IEEE. Among other awards for his research and teaching, Professor Eugster has received an NSF CAREER award (2007) and Experienced Researcher fellowship by the Alexander von Humboldt foundation (2011). He is also a participant of the 2011 DARPA Computer Science Study Panel.</bio>
          <homepage_url>https://www.cs.purdue.edu/people/faculty/peugster/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/patrickeugster/bf8c955c-8902-4678-8c57-4b75cbd4f3c0/small.jpg</picture_url>
          <person_id>patrickeugster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gustavo</first_name>
          <last_name>Petri</last_name>
          <affiliation>ARM Research, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gpetri.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gustavopetri/08af6041-7317-4929-9a80-b63b5f03a5b6/small.jpg</picture_url>
          <person_id>gustavopetri</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Srivatsan</first_name>
          <last_name>Ravi</last_name>
          <affiliation>University of Southern California, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.usc.edu/srivatsr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/srivatsanravi/8ec9644c-3166-4f60-b70b-778f80ece302/small.jpg</picture_url>
          <person_id>srivatsanravi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Pierre-Louis</first_name>
          <last_name>Roman</last_name>
          <affiliation>USI Lugano, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>pierrelouisroman</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d037ea18-5d39-42e8-a13f-469097e87f5b</slot_id>
      <event_id>19e7c385-f2f5-47e8-97a6-7a2e9e7afb77</event_id>
      <title>Designing Types for R, Empirically</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>17:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>18:00</end_time>
      <description>The R programming language is widely used in a variety of domains. It was designed to favor an interactive style of programming with minimal syntactic and conceptual overhead. This design is well suited to data analysis, but a bad fit for tools such as compilers or program analyzers. In particular, R has no type annotations, and all operations are dynamically checked at run-time. The starting point for our work are the two questions: \emph{what expressive power is needed to accurately type R code?} and \emph{which type system is the R community willing to adopt?} Both questions are difficult to answer without actually experimenting with a type system. The goal of this paper is to provide data that can feed into that design process. To this end, we perform a large corpus analysis to gain insights in the degree of polymorphism exhibited by idiomatic R code and explore potential benefits that the R community could accrue from a simple type system. As a starting point, we infer type signatures for 25,215 functions from 412 packages among the most widely used open source R libraries. We then conduct an evaluation on 8,694 clients of these packages, as well as on end-user code from the Kaggle data science competition website.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexi</first_name>
          <last_name>Turcotte</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://reallytg.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexiturcotte/6881a0a0-5145-40cb-aab4-ff41754a0640/small.jpg</picture_url>
          <person_id>alexiturcotte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Filip</first_name>
          <last_name>Krikava</last_name>
          <affiliation>Czech Technical University, Czechia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fikovnik.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/filipkrikava/12cc1e57-732c-4b7e-880e-ca7b51a07d77/small.jpg</picture_url>
          <person_id>filipkrikava</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University, USA / Czech Technical University, Czechia</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>53e63f52-3e97-4d09-a82d-ede718ed81b5</subevent_id>
    <title>SPLASH OOPSLA: F-5B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>447997d6-5c33-4710-b453-bc5617f4e9f3</slot_id>
      <title>Session: SPLASH OOPSLA - F-5B</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/21</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5499046c-9114-495c-9253-671395b2ff89</slot_id>
      <event_id>3f3bef96-f531-418a-9389-fe359db5c7a1</event_id>
      <title>Rethinking Safe Consistency in Distributed Object-Oriented Programming</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/21</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>03:40</end_time>
      <description>Large scale distributed systems require to embrace the trade off between consistency and availability, accepting lower levels of consistency to guarantee higher availability. Existing programming languages are, however, agnostic to this compromise, resulting in consistency guarantees that are the same for the whole application and are implicitly adopted from the middleware or hardcoded in configuration files. In this paper, we propose to integrate availability in the design of an object-oriented language, allowing developers to specify different consistency and isolation constraints in the same application at the granularity of single objects. We investigate how availability levels interact with object structure and define a type system that preserves correct program behavior. Our evaluation shows that our solution performs efficiently and improves the design of distributed applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mirko</first_name>
          <last_name>Köhler</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>mirkokohler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nafise</first_name>
          <last_name>Eskandani Masoule</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.stg.tu-darmstadt.de/staff/nafise_eskandani</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nafiseeskandanimasoule/6eac9bf0-bfcf-4440-ba06-24fa9145cb4e/small.jpg</picture_url>
          <person_id>nafiseeskandanimasoule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pascal</first_name>
          <last_name>Weisenburger</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/pascalweisenburger/bf663f00-24ac-4d12-919b-ef1e2ff8e128/small.jpg</picture_url>
          <person_id>pascalweisenburger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Alessandro</first_name>
          <last_name>Margara</last_name>
          <affiliation>Politecnico di Milano, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://margara.faculty.polimi.it</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alessandromargara/c43a91d0-b824-4046-ab28-23a6ad3c2c3b/small.jpg</picture_url>
          <person_id>alessandromargara</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Guido</first_name>
          <last_name>Salvaneschi</last_name>
          <affiliation>University of St. Gallen, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.guidosalvaneschi.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guidosalvaneschi/6f1373d5-57c6-4d68-b6c3-c0a679ee24ed/small.jpg</picture_url>
          <person_id>guidosalvaneschi</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9860d56e-e4f0-4da0-9ee6-0ef6551eda8b</slot_id>
      <event_id>193eb222-e5b0-4ec0-88fe-28f689c66880</event_id>
      <title>Programming at the Edge of Synchrony</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/21</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>03:20</end_time>
      <description>Synchronization primitives for fault-tolerant distributed systems that ensure an effective and efficient cooperation among processes are an important challenge in the programming languages community. We present a new programming abstraction, ReSync, for implementing benign and Byzantine fault-tolerant protocols. ReSync has a new round structure that offers a simple abstraction for group communication, like it is customary in synchronous systems, but also allows messages to be received one by one, like in the asynchronous systems. This extension allows implementing network and algorithm-specific policies for the message reception, which is not possible in classic round models. 
The execution of ReSync programs is based on a new generic round switch protocol that generalizes the famous theoretical result about consensus in the presence of partial synchrony by of Dwork, Lynch, and Stockmeyer. We evaluate experimentally the performance of ReSync’s execution platform, by comparing consensus implementations in ReSync with LibPaxos3, etcd, and Bft-SMaRt, three consensus libraries tolerant to benign, resp. byzantine faults.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cezara</first_name>
          <last_name>Drăgoi</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.di.ens.fr/~cezarad/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cezaradragoi/3403e4d3-23e5-41ac-8cf7-48cc033f3d48/small.jpg</picture_url>
          <person_id>cezaradragoi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Josef</first_name>
          <last_name>Widder</last_name>
          <affiliation>Informal Systems, n.n.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://forsyte.at/widder</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/josefwidder1/44228499-3e67-4144-be7a-4bcc366c4dd7/small.jpg</picture_url>
          <person_id>josefwidder1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Damien</first_name>
          <last_name>Zufferey</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://dzufferey.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/damienzufferey/5dc321db-5cef-4f4b-bd3c-a5bbb2f11dd1/small.jpg</picture_url>
          <person_id>damienzufferey</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9de56217-3fb6-4c19-9304-0174ecbd0486</slot_id>
      <event_id>67d39e09-ddf4-4c9d-8d1b-b8dffa795e2f</event_id>
      <title>Testing Consensus Implementations using Communication Closure</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/21</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>04:00</end_time>
      <description>Large scale production distributed systems are difficult to design and test. Correctness must be ensured when processes run asynchronously, at arbitrary rates relative to each other, and in the presence of failures, e.g., process crashes or message losses. These conditions create a huge space of executions that is difficult to explore in a principled way. Current testing techniques focus on systematic or randomized exploration of all executions of an implementation while treating the implemented algorithms as black boxes. On the other hand, proofs of correctness of many of the underlying algorithms often exploit semantic properties that reduce reasoning about correctness to a subset of behaviors. For example, the \emph{communication-closure} property, used in many proofs of distributed consensus algorithms, shows that every asynchronous execution of the algorithm is equivalent to a \emph{lossy synchronous} execution, thus reducing the burden of proof to only that subset. In a lossy synchronous execution, processes execute in lock-step rounds, and messages are either received in the same round or lost forever—such executions form a small subset of all asynchronous ones. 
We formulate the \emph{communication-closure hypothesis}, which states that bugs in implementations of distributed consensus algorithms will already manifest in lossy synchronous executions and present a testing algorithm based on this hypothesis. We prioritize the search space based on a bound on the number of failures in the execution and the rate at which these failures are recovered. We show that a random testing algorithm based on sampling lossy synchronous executions can empirically find a number of bugs—including previously unknown ones—in production distributed systems such as Zookeeper, Cassandra, and Ratis, and also produce more understandable bug traces.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cezara</first_name>
          <last_name>Drăgoi</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.di.ens.fr/~cezarad/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cezaradragoi/3403e4d3-23e5-41ac-8cf7-48cc033f3d48/small.jpg</picture_url>
          <person_id>cezaradragoi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Constantin</first_name>
          <last_name>Enea</last_name>
          <affiliation>University of Paris Diderot, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~cenea/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/constantinenea/2dfe8bfe-ddfe-4012-a2e2-01cc8b953734/small.jpg</picture_url>
          <person_id>constantinenea</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Burcu</first_name>
          <last_name>Kulahcioglu Ozkan</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://burcuku.github.io/home/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/burcukulahciogluozkan/4a854b1d-126f-47f5-8935-25d6401437c4/small.jpg</picture_url>
          <person_id>burcukulahciogluozkan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rupak</first_name>
          <last_name>Majumdar</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~rupak</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rupakmajumdar/3289b197-9f9a-4880-94c5-d9cf6d764bb1/small.jpg</picture_url>
          <person_id>rupakmajumdar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Filip</first_name>
          <last_name>Niksic</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://fniksic.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/filipniksic/22f726ab-2c20-4f80-b6d4-32a9530437d5/small.jpg</picture_url>
          <person_id>filipniksic</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>483769f2-9c86-4b77-9eb3-a522d54146e7</subevent_id>
    <title>SPLASH OOPSLA: W-3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>92eec067-fc85-4306-b4c6-a5dfad021181</slot_id>
      <title>Session: SPLASH OOPSLA - W-3</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0d531532-f581-4229-b750-534b10ec36cf</slot_id>
      <event_id>a67c5220-155d-4d8b-af2a-ba2543bafbfa</event_id>
      <title>Dynamic Dispatch of Context-Sensitive Optimizations</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>00:00</end_time>
      <description>Academia has spent much effort into making context-sensitive {\em analyses} practical, with great profit. However, the implementation of context-sensitive {\em optimizations}, in contrast to analyses, is still not practical, due to code-size explosion. This growth happens because current technology requires the cloning of full paths in the Calling Context Tree. In this paper, we present a solution to this problem. We combine finite state machines and dynamic dispatching to allow fully context-sensitive specialization while cloning only functions that are effectively optimized. This technique makes it possible to apply very liberal optimizations, such as context-sensitive constant propagation, in large programs—something that could not have been easily done before. We demonstrate the viability of our idea by formalizing it in Prolog, and implementing it in LLVM. As a proof of concept, we have used our state machines to implement context-sensitive constant propagation in LLVM. The binaries produced by traditional full cloning are 2.63 times larger than the binaries that we generate with our state machines. When applied on Mozilla Firefox, our optimization increases binary size from 7.2MB to 9.2MB. Full cloning, in contrast, yields a binary of 34MB.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gabriel</first_name>
          <last_name>Poesia</last_name>
          <affiliation>Federal University of Minas Gerais, Brazil</affiliation>
          <bio>undefined</bio>
          <person_id>gabrielpoesia1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fernando Magno Quintão</first_name>
          <last_name>Pereira</last_name>
          <affiliation>Federal University of Minas Gerais, Brazil</affiliation>
          <bio>Fernando got his Ph.D at UCLA in 2008, under the supervision of Jens Palsberg. He is currently an assistant professor at the Universidade Federal de Minas Gerais, Brazil. His main research interest are in code generation, compiler optimizations and static program analyses.</bio>
          <homepage_url>http://homepages.dcc.ufmg.br/~fernando/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/fernandomagnoquintaopereira/8f86b14f-fbc3-49a4-9f4f-1a8216564d39/small.jpg</picture_url>
          <person_id>fernandomagnoquintaopereira</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>53983365-f2a1-4d90-b180-5d3efb4060cb</slot_id>
      <event_id>9b43b518-879b-4aa7-b841-9f12dc9bcf2a</event_id>
      <title>Automated Policy Synthesis for System Call Sandboxing</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>00:20</end_time>
      <description>System call whitelisting is a powerful sandboxing approach that can significantly reduce the capabilities of an attacker if an application is compromised. Given a \emph{policy} that specifies which system calls can be invoked with what arguments, a sandboxing framework terminates any execution that violates the policy. While this mechanism greatly reduces the attack surface of a system, manually constructing these policies is time-consuming and error-prone. As a result, many applications —including those that take untrusted user input— opt not to use a system call sandbox. 
Motivated by this problem, we propose a technique for automatically constructing system call whitelisting policies for a given application and policy DSL. Our method combines static code analysis and program synthesis to construct \emph{sound and precise policies} that never erroneously terminate the application, while restricting the program's system call usage as much as possible. We have implemented our approach in a tool called \textsc{Abhaya}\xspace and experimentally evaluate it 493 Linux and OpenBSD applications by automatically synthesizing {Seccomp-bpf}\xspace and \text{Pledge}\xspace policies. Our experimental results indicate that \textsc{Abhaya}\xspace can efficiently generate useful and precise sandboxes for real-world applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shankara</first_name>
          <last_name>Pailoor</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>shankarapailoor</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xinyu</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Michigan, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://web.eecs.umich.edu/~xwangsd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xinyuwang/ccbe37b1-293c-4205-8386-295e20bce0d7/small.jpg</picture_url>
          <person_id>xinyuwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hovav</first_name>
          <last_name>Shacham</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>hovavshacham</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Isil</first_name>
          <last_name>Dillig</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>Isil Dillig is an Associate Professor of Computer Science at the University of Texas at Austin where she leads the UToPiA research group. Her main research area is programming languages, with a specific emphasis on static analysis, verification, and program synthesis. The techniques developed by her group aim to make software systems more reliable, secure, and easier to build in a robust way. Dr. Dillig is a Sloan Fellow and a recipient of the NSF CAREER award. She obtained all her degrees (BS, MS, and PhD) from Stanford University.</bio>
          <homepage_url>http://www.cs.utexas.edu/~isil/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/isildillig/e4fa3855-0ae4-4638-84e3-1fe224e64e3f/small.jpg</picture_url>
          <person_id>isildillig</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b6631dc5-c143-4626-a825-26fdbc0361ba</slot_id>
      <event_id>36a05e0f-c662-4f1b-b7fa-748674279502</event_id>
      <title>Build Scripts with Perfect Dependencies</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>23:20</end_time>
      <description>Build scripts for most build systems describe the actions to run, and the dependencies between those actions - but often build scripts get those dependencies wrong. Most build scripts have both too few dependencies (leading to incorrect build outputs) and too many dependencies (leading to excessive rebuilds and reduced parallelism). Any programmer who has wondered why a small change led to excess compilation, or who resorted to a clean step, has suffered the ill effects of incorrect dependency specification. We outline a build system where dependencies are not specified, but instead captured by tracing execution. The consequence is that dependencies are always correct by construction and build scripts are easier to write. The simplest implementation of our approach would lose parallelism, but we are able to recover parallelism using speculation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sarah</first_name>
          <last_name>Spall</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>sarahspall</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Neil</first_name>
          <last_name>Mitchell</last_name>
          <affiliation>Facebook, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ndmitchell.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/neilmitchell/bcccf5bd-0c3b-4e0e-90c9-ef73780b976c/small.jpg</picture_url>
          <person_id>neilmitchell</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sam</first_name>
          <last_name>Tobin-Hochstadt</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>I am an Assistant Professor in the Department of Computer Science at Indiana University. 
Research Interests: my research focuses on the design and analysis of software and programming languages. I am particularly interested in how programs grow from prototype scripts to robust software, and how programming language design can support this process. My research concerns type systems, software contracts, modularity, and extensibility. I’m currently working with the DARPA CRASH program on Racket and with Mozilla Labs on JavaScript.</bio>
          <homepage_url>http://samth.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/samtobinhochstadt/d817e5c9-fe1c-4664-a4d1-6af45d4d4586/small.jpg</picture_url>
          <person_id>samtobinhochstadt</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bedd2c49-96cd-41c5-b30c-1efc75bb23a9</slot_id>
      <event_id>dc2c4321-bace-402b-a2d9-f08a7830e7e5</event_id>
      <title>Random Testing for C and C++ Compilers with YARPGen</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>23:40</end_time>
      <description>Compilers should not crash and they should not miscompile applications. Random testing is an effective method for finding compiler bugs that have escaped other kinds of testing. This paper presents Yet Another Random Program Generator (YARPGen), a random test-case generator for C and C++ that we used to find and report more than 220 bugs in GCC, LLVM, and the Intel® C++ Compiler. Our research contributions include a method for generating expressive programs that avoid undefined behavior without using dynamic checks, and generation policies, a mechanism for increasing diversity of generated code and for triggering more optimizations. Generation policies decrease the testing time to find hard-to-trigger compiler bugs and, for the kinds of scalar optimizations YARPGen was designed to stress-test, increase the number of times these optimizations are applied by the compiler by an average of 20% for LLVM and 40% for GCC. We also created tools for automating most of the common tasks related to compiler fuzzing; these tools are also useful for fuzzers other than ours.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vsevolod</first_name>
          <last_name>Livinskii</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
          <person_id>vsevolodlivinskii</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dmitry</first_name>
          <last_name>Babokin</last_name>
          <affiliation>Intel Corporation, USA</affiliation>
          <bio>undefined</bio>
          <person_id>dmitrybabokin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>John</first_name>
          <last_name>Regehr</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.utah.edu/~regehr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnregehr/2cb23ab0-042a-487a-a859-cbd3147a46a7/small.jpg</picture_url>
          <person_id>johnregehr</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b798486d-fefd-4104-a8fe-65a6b3fecd26</subevent_id>
    <title>SPLASH OOPSLA: M-6</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>d575a98a-4f11-49bf-a509-d9036907d7ce</slot_id>
      <title>Session: SPLASH OOPSLA - M-6</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Ifaz</first_name>
          <last_name>Kabir</last_name>
          <affiliation>University of Alberta, Canada</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/ifazkabir/991cbcab-f46c-4c5e-8b8f-c365d1b11d6b/small.jpg</picture_url>
          <person_id>ifazkabir</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4a2757ce-21d4-4403-9cac-fadeaa2c2147</slot_id>
      <event_id>f6dc9ecd-0036-4c59-8d53-f697d30259d2</event_id>
      <title>Geometry Types for Graphics Programming</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>06:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>06:20</end_time>
      <description>In domains that deal with physical space and geometry, programmers need to track the coordinate systems that underpin a computation. We identify a class of geometry bugs that arise from confusing which coordinate system a vector belongs to. These bugs are not ruled out by current languages for vector-oriented computing, are difficult to check for at run time, and can generate subtly incorrect output that can be hard to test for. 
We introduce a type system and language that prevents geometry bugs by reflecting the coordinate system for each geometric object. A value's geometry type encodes its reference frame, the kind of geometric object (such as a point or a direction), and the coordinate representation (such as Cartesian or spherical coordinates). We show how these types can rule out geometrically incorrect operations, and we show how to use them to automatically generate correct-by-construction code to transform vectors between coordinate systems. We implement a language for graphics programming, Gator, that checks geometry types and compiles to OpenGL's shading language, GLSL. Using case studies, we demonstrate that Gator can raise the level of abstraction for shader programming and prevent common errors without inducing significant annotation overhead or performance cost.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dietrich</first_name>
          <last_name>Geisler</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>dietrichgeisler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Irene</first_name>
          <last_name>Yoon</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://seas.upenn.edu/~euisuny</homepage_url>
          <person_id>ireneyoon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aditi</first_name>
          <last_name>Kabra</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>aditikabra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Horace</first_name>
          <last_name>He</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>horacehe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yinnon</first_name>
          <last_name>Sanders</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>yinnonsanders</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Adrian</first_name>
          <last_name>Sampson</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://adriansampson.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adriansampson/adaa9202-3352-4410-b03a-1eb4718543d5/small.jpg</picture_url>
          <person_id>adriansampson</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9bb76054-5af7-4891-b019-028b3dbb788f</slot_id>
      <event_id>0cc82840-fb71-4f1f-a4cb-a199c7956974</event_id>
      <title>Scalable and Serializable Networked Multi-actor Programming</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>05:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>05:40</end_time>
      <description>A major challenge in writing applications that execute across hosts, such as distributed online services, is to reconcile (a) parallelism (i.e., allowing components to execute independently on disjoint tasks), and (b)cooperation (i.e., allowing components to work together on common tasks). A good compromise between the two is vital to scalability, a core concern in distributed networked applications. 
The actor model of computation is a widely promoted programming model for distributed applications, as actors can execute in individual threads (parallelism) across different hosts and interact via asynchronous message passing (collaboration). However, this makes it hard for programmers to reason about combinations of messages as opposed to individual messages, which is essential in many scenarios. 
This paper presents a pragmatic variant of the actor model in which messages can be grouped into units that are executed in a serializable manner, whilst still retaining a high degree of parallelism. In short, our model is based on an orchestration of actors along a directed acyclic graph that supports efficient decentralized synchronization among actors based on their actual interaction. We present the implementation of this model, based on a dynamic DAG-inducing referencing discipline, in the actor-based programming language AEON. We argue serializability and the absence of deadlocks in our model, and demonstrate its scalability and usability through extensive evaluation and case studies of wide-ranging applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>BO</first_name>
          <last_name>SANG</last_name>
          <affiliation>Purdue University, USA / Ant Group, USA</affiliation>
          <bio>undefined</bio>
          <person_id>bosang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Eugster</last_name>
          <affiliation>USI Lugano, Switzerland / TU Darmstadt, Germany / Purdue University, USA</affiliation>
          <bio>Professor Eugster’s research aims at proposing support for developing distributed systems. Particular topics of interest, in the context of distributed settings, include algorithms, middleware, and programming languages, abstractions, and methodologies. 
Professor Eugster was educated in Switzerland, and has worked for both Swiss Federal Institutes of Technology in Lausanne (EPFL) and in Zurich (ETHZ), as well as for Sun Microsystems (now Oracle) prior to joining Purdue University. He has authored over 70 refereed articles, and is a member of ACM and IEEE. Among other awards for his research and teaching, Professor Eugster has received an NSF CAREER award (2007) and Experienced Researcher fellowship by the Alexander von Humboldt foundation (2011). He is also a participant of the 2011 DARPA Computer Science Study Panel.</bio>
          <homepage_url>https://www.cs.purdue.edu/people/faculty/peugster/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/patrickeugster/bf8c955c-8902-4678-8c57-4b75cbd4f3c0/small.jpg</picture_url>
          <person_id>patrickeugster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gustavo</first_name>
          <last_name>Petri</last_name>
          <affiliation>ARM Research, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gpetri.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gustavopetri/08af6041-7317-4929-9a80-b63b5f03a5b6/small.jpg</picture_url>
          <person_id>gustavopetri</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Srivatsan</first_name>
          <last_name>Ravi</last_name>
          <affiliation>University of Southern California, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.usc.edu/srivatsr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/srivatsanravi/8ec9644c-3166-4f60-b70b-778f80ece302/small.jpg</picture_url>
          <person_id>srivatsanravi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Pierre-Louis</first_name>
          <last_name>Roman</last_name>
          <affiliation>USI Lugano, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>pierrelouisroman</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a8f4982c-031e-4299-a05a-a8f0eee317d5</slot_id>
      <event_id>19e7c385-f2f5-47e8-97a6-7a2e9e7afb77</event_id>
      <title>Designing Types for R, Empirically</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>05:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>06:00</end_time>
      <description>The R programming language is widely used in a variety of domains. It was designed to favor an interactive style of programming with minimal syntactic and conceptual overhead. This design is well suited to data analysis, but a bad fit for tools such as compilers or program analyzers. In particular, R has no type annotations, and all operations are dynamically checked at run-time. The starting point for our work are the two questions: \emph{what expressive power is needed to accurately type R code?} and \emph{which type system is the R community willing to adopt?} Both questions are difficult to answer without actually experimenting with a type system. The goal of this paper is to provide data that can feed into that design process. To this end, we perform a large corpus analysis to gain insights in the degree of polymorphism exhibited by idiomatic R code and explore potential benefits that the R community could accrue from a simple type system. As a starting point, we infer type signatures for 25,215 functions from 412 packages among the most widely used open source R libraries. We then conduct an evaluation on 8,694 clients of these packages, as well as on end-user code from the Kaggle data science competition website.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexi</first_name>
          <last_name>Turcotte</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://reallytg.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexiturcotte/6881a0a0-5145-40cb-aab4-ff41754a0640/small.jpg</picture_url>
          <person_id>alexiturcotte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Filip</first_name>
          <last_name>Krikava</last_name>
          <affiliation>Czech Technical University, Czechia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fikovnik.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/filipkrikava/12cc1e57-732c-4b7e-880e-ca7b51a07d77/small.jpg</picture_url>
          <person_id>filipkrikava</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University, USA / Czech Technical University, Czechia</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cf796bd0-c1cb-43e6-9ce2-c919df34f2e0</slot_id>
      <event_id>c241afa2-8ebc-4091-ba8b-11b2acfe950d</event_id>
      <title>Can Advanced Type Systems Be Usable? An Empirical Study of Ownership, Assets, and Typestate in Obsidian</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>05:20</end_time>
      <description>Some blockchain programs (smart contracts) have included serious security vulnerabilities. Obsidian is a new typestate-oriented programming language that uses a strong type system to rule out some of these vulnerabilities. Although Obsidian was designed to promote usability to make it as easy as possible to write programs, strong type systems can cause a language to be difficult to use. In particular, ownership, typestate, and assets, which Obsidian uses to provide safety guarantees, have not seen broad adoption together in popular languages and result in significant usability challenges. We performed an empirical study with 20 participants comparing Obsidian to Solidity, which is the language most commonly used for writing smart contracts today. We observed that Obsidian participants were able to successfully complete more of the programming tasks than the Solidity participants. We also found that the Solidity participants commonly inserted asset-related bugs, which Obsidian detects at compile time.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Coblenz</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umd.edu/~mcoblenz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelcoblenz/aa74b306-529b-44d4-987f-a5e4fd6d3ca2/small.jpg</picture_url>
          <person_id>michaelcoblenz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brad</first_name>
          <last_name>Myers</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~bam/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/bradmyers/7d93ede9-5674-40e8-9ba5-f9dfab4873e1/small.jpg</picture_url>
          <person_id>bradmyers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Sunshine</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jssunshi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joshuasunshine/474067e5-86e8-476c-9622-5c89be145f4b/small.jpg</picture_url>
          <person_id>joshuasunshine</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9bc86e63-1839-4c99-9dae-a56a63348b0a</subevent_id>
    <title>SPLASH OOPSLA: R-6</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>1fac136f-748b-473d-8f34-c30b1f4a34a4</slot_id>
      <title>Session: SPLASH OOPSLA - R-6</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Filip</first_name>
          <last_name>Niksic</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://fniksic.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/filipniksic/22f726ab-2c20-4f80-b6d4-32a9530437d5/small.jpg</picture_url>
          <person_id>filipniksic</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Adam</first_name>
          <last_name>Welc</last_name>
          <affiliation>Uber Technologies</affiliation>
          <bio>Adam Welc currently works at Uber Technologies. Previously, he worked at Huawei, focusing on optimizing Java for execution in the cloud. Adam has also worked as a researcher at Intel, Adobe, and Oracle, developing new language implementations as well as novel approaches for concurrent programming. His research interests are in the area of programming languages implementation, design, and tooling, with specific interests in runtime systems, interpreters and compilers, as well as performance analysis and optimization. Adam holds a PhD in Computer Science from Purdue University.</bio>
          <homepage_url>http://www.adamwelc.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adamwelc/9329d493-932e-4ca3-bf80-a4ea5f806d9b/small.jpg</picture_url>
          <person_id>adamwelc</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>38bebbe7-6648-409e-a9be-5f1eecc7fa56</slot_id>
      <event_id>46ea216e-db41-4d72-adfd-3e70848f065e</event_id>
      <title>Deductive Optimization of Relational Data Storage</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>17:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>17:40</end_time>
      <description>Optimizing the physical data storage and retrieval of data are two key database management problems. In this paper, we propose a language that can express both a relational query and the layout of its data. Our language can express a wide range of physical database layouts, going well beyond the row- and column-based methods that are widely used in database management systems. We use deductive program synthesis to turn a high-level relational representation of a database query into a highly optimized low-level implementation which operates on a specialized layout of the dataset. We build an optimizing compiler for this language and conduct experiments using a popular database benchmark, which shows that the performance of our specialized queries is better than a state-of-the-art in memory compiled database system while achieving an order-of-magnitude reduction in memory use.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Feser</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>John Feser is a PhD student in the Computer Science and Artificial Intelligence Laboratory at MIT, advised by Armando Solar-Lezama. He is interested in program synthesis and databases.</bio>
          <homepage_url>http://people.csail.mit.edu/feser/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnfeser/edee5cf7-267b-4a87-90ca-94f278378c37/small.jpg</picture_url>
          <person_id>johnfeser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Madden</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>sammadden</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nan</first_name>
          <last_name>Tang</last_name>
          <affiliation>QCRI HBKU, n.n.</affiliation>
          <bio>undefined</bio>
          <person_id>nantang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Armando</first_name>
          <last_name>Solar-Lezama</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>Armando Solar-Lezama is an associate professor at MIT where he leads the Computer Aided Programming Group. His research interests include software synthesis and its applications in diverse areas such as high-performance computing, information flow security and probabilistic programming.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/armandosolarlezama/7befe52d-6968-4786-9841-408800f80c71/small.jpg</picture_url>
          <person_id>armandosolarlezama</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>83fce247-762b-4ec4-b8f9-2f7f17904070</slot_id>
      <event_id>2abee499-a6aa-4ad2-9126-979e3981f059</event_id>
      <title>Adding Interactive Visual Syntax to Textual Code</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>17:20</end_time>
      <description>Many programming problems call for turning geometrical thoughts into code: tables, hierarchical structures, nests of objects, trees, forests, graphs, and so on. Linear text does not do justice to such thoughts. But, it has been the dominant programming medium for the past and will remain so for the foreseeable future. 
This paper proposes a novel mechanism for conveniently extending textual programming languages with problem-specific visual syntax. It argues the necessity of this language feature, demonstrates the feasibility with a robust prototype, and sketches a design plan for adapting the idea to other languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Leif</first_name>
          <last_name>Andersen</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/leifandersen/022e7f05-2a9a-4e3d-8be9-418b798e00c0/small.jpg</picture_url>
          <person_id>leifandersen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Ballantyne</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>Michael Ballantyne is a PhD student at the Northeastern University Programming Research Laboratory, advised by Matthias Felleisen. He envisions a future where mainstream programmers regularly create, extend, and fluidly intermix domain-specific languages, with excellent support from their programming language and environment. Recently he’s been developing a formal characterization of macro hygiene that accounts for the full range of program transformations used in embedded DSL implementation, and also improving the type systems as macros approach to integrate macro expansion and typechecking.</bio>
          <homepage_url>http://mballantyne.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelballantyne/0fb0042c-454e-437b-938c-bd6fb195d0cb/small.jpg</picture_url>
          <person_id>michaelballantyne</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Felleisen</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/matthias/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthiasfelleisen/3781509a-02f7-4e22-822d-04481501e833/small.jpg</picture_url>
          <person_id>matthiasfelleisen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ca478550-cb19-4950-9fe7-d1e1c2addbe6</slot_id>
      <event_id>0ec91bc5-4e13-4f05-907b-344b042b9659</event_id>
      <title>Inter-theory Dependency Analysis for SMT String Solvers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>17:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>18:00</end_time>
      <description>Solvers in the framework of Satisfiability Modulo Theories (SMT) have been widely successful in practice. Recently there has been an increasing interest in solvers for string constraints to address security issues in web programming, for example. To be practically useful, the solvers need to support an expressive constraint language over unbounded strings, and in particular, over string lengths. Satisfiability checking for these formulas, especially in the SMT context, is very hard; it is generally undecidable for a rich fragment. In this paper, we propose a form of dependency analysis for a rich fragment of string constraints including high-level operations such as length, contains to deal with their inter-theory interaction so as to solve them more efficiently. We implement our dependency analysis in the string theory of the Z3 solver to obtain a new one, called S3N. Finally, we demonstrate the superior performance of S3N over state-of-the-art string solvers such as Z3str3, CVC4, S3P, and Z3 on several large industrial-strength benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Minh-Thai</first_name>
          <last_name>Trinh</last_name>
          <affiliation>Advanced Digital Sciences Center, Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>thaitrinh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Duc-Hiep</first_name>
          <last_name>Chu</last_name>
          <affiliation>National University of Singapore, Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>duchiepchu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Joxan</first_name>
          <last_name>Jaffar</last_name>
          <affiliation>National University of Singapore, Singapore</affiliation>
          <bio>1982-1986: Lecturer, Monash University 1986-1995: Research Staff Member, IBM T.J. Watson Research Center 1995-Present: Professor of Computer Science, National University of Singapore</bio>
          <homepage_url>http://www.comp.nus.edu.sg/~joxan</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joxanjaffar/f391720a-61ea-4df1-ad81-91f5873a342c/small.jpg</picture_url>
          <person_id>joxanjaffar</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fcbff1ba-3936-4d07-a722-b02a49b14198</slot_id>
      <event_id>19758c97-2c7a-4f32-bfb9-cb729a2cc3b8</event_id>
      <title>Macros for Domain-Specific Languages</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>18:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>18:20</end_time>
      <description>Macros provide a powerful means of extending languages. They have proven useful in both general-purpose and domain-specific programming contexts. This paper presents an architecture for implementing macro-extensible DSLs on top of macro-extensible host languages. The macro expanders of these DSLs inherit the syntax system, hygienic expansion, and more from the host. They transform the extensible DSL syntax into a DSL core language. This arrangement has several important consequences. It becomes straightforward to integrate the syntax of various DSLs and the host language when their expanders share these inherited components. Also, a DSL compiler may be designed around a fixed core language, even for an extensible DSL. Finally, macros empower programmers to safely grow DSLs on their own and tailor them to their needs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Ballantyne</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>Michael Ballantyne is a PhD student at the Northeastern University Programming Research Laboratory, advised by Matthias Felleisen. He envisions a future where mainstream programmers regularly create, extend, and fluidly intermix domain-specific languages, with excellent support from their programming language and environment. Recently he’s been developing a formal characterization of macro hygiene that accounts for the full range of program transformations used in embedded DSL implementation, and also improving the type systems as macros approach to integrate macro expansion and typechecking.</bio>
          <homepage_url>http://mballantyne.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelballantyne/0fb0042c-454e-437b-938c-bd6fb195d0cb/small.jpg</picture_url>
          <person_id>michaelballantyne</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexis</first_name>
          <last_name>King</last_name>
          <affiliation>Northwestern University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexisking/4d4403cc-a825-40f3-a69d-089d8403e71a/small.jpg</picture_url>
          <person_id>alexisking</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Felleisen</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/matthias/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthiasfelleisen/3781509a-02f7-4e22-822d-04481501e833/small.jpg</picture_url>
          <person_id>matthiasfelleisen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c2df977f-ef1c-4e30-93c9-a57b3e4711e3</subevent_id>
    <title>SPLASH OOPSLA: M-5</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>b821fe87-f92c-45e5-952a-583b315eb086</slot_id>
      <title>Session: SPLASH OOPSLA - M-5</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Bernardo</first_name>
          <last_name>Toninho</last_name>
          <affiliation>Nova University of Lisbon, Portugal / NOVA-LINCS, Portugal</affiliation>
          <bio>I am interested in the application of language-based techniques to the development of more robust and safer concurrent and distributed systems. More specifically, I work within the realm of (substructural) type theory, such as those based on Linear Logic and Session Types, and their applications to concurrent programming. I am also interested in using type and logic-based techniques to verify concurrent programs in real languages such as Go, Rust and Scala.</bio>
          <homepage_url>http://ctp.di.fct.unl.pt/~btoninho/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/bernardotoninho/1125bc54-0549-4ee4-bf19-394d89568c34/small.jpg</picture_url>
          <person_id>bernardotoninho</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Xiangzhe</first_name>
          <last_name>Xu</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <person_id>xiangzhexu1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1e9d3b91-cb72-4af3-ac17-e850a80f92b5</slot_id>
      <event_id>f94ed25c-81d9-4aad-b499-42ebb3391f9d</event_id>
      <title>CAMP: Cost-Aware Multiparty Session Protocols</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>03:20</end_time>
      <description>This paper presents CAMP, a new static performance analysis framework for message-passing concurrent and distributed systems, based on the theory of multiparty session types (MPST). Understanding the run-time performance of concurrent and distributed systems is of great importance for the identification of bottlenecks and optimisation opportunities. In the message-passing setting, these bottlenecks are generally communication overheads and synchronisation times. Despite its importance, reasoning about these intensional properties of software, such as performance, has received little attention, compared to verifying extensional properties, such as correctness. Behavioural protocol specifications based on sessions types capture not only extensional, but also intensional properties of concurrent and distributed systems. CAMP augments MPST with annotations of communication latency and local computation cost, defined as estimated execution times, that we use to extract cost equations from protocol descriptions. CAMP is also extendable to analyse asynchronous communication optimisation built on a recent advance of session type theories. We apply our tool to different existing benchmarks and use cases in the literature with a wide range of communication protocols, implemented in C, MPI-C, Scala, Go, and OCaml. Our benchmarks show that, in most of the cases, we predict an upper-bound on the real execution costs with &amp;lt; 15% error.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Castro</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <person_id>davidcastro</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>20022fad-5474-4068-98bf-7da4cd8a6bb2</slot_id>
      <event_id>41308516-fe76-4573-a027-84e9a6af5694</event_id>
      <title>Multiparty Motion Coordination: From Choreographies to Robotics Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>04:00</end_time>
      <description>We present a programming model and typing discipline for complex multi-robot coordination programming. Our model encompasses both synchronisation through message passing and continuous-time dynamic motion primitives in physical space. We specify &amp;lt;i&amp;gt;continuous-time motion primitives&amp;lt;/i&amp;gt; in an assume-guarantee logic that ensures compatibility of motion primitives as well as collision freedom. We specify global behaviour of programs in a &amp;lt;i&amp;gt;choreographic&amp;lt;/i&amp;gt; type system that extends multiparty session types with jointly executed motion primitives, predicated refinements, as well as a &amp;lt;i&amp;gt;separating conjunction&amp;lt;/i&amp;gt; that allows reasoning about subsets of interacting robots. We describe a notion of &amp;lt;i&amp;gt;well-formedness&amp;lt;/i&amp;gt; for global types that ensures motion and communication can be correctly synchronised and provide algorithms for checking well-formedness, projecting a type, and local type checking. A well-typed program is &amp;lt;i&amp;gt;communication safe&amp;lt;/i&amp;gt;, &amp;lt;i&amp;gt;motion compatible&amp;lt;/i&amp;gt;, and &amp;lt;i&amp;gt;collision free&amp;lt;/i&amp;gt;. Our type system provides a compositional approach to ensuring these properties. 
We have implemented our model on top of the ROS framework. This allows us to program multi-robot coordination scenarios on top of commercial and custom robotics hardware platforms. We show through case studies that we can model and statically verify quite complex manoeuvres involving multiple manipulators and mobile robots—such examples are beyond the scope of previous approaches.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rupak</first_name>
          <last_name>Majumdar</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~rupak</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rupakmajumdar/3289b197-9f9a-4880-94c5-d9cf6d764bb1/small.jpg</picture_url>
          <person_id>rupakmajumdar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Damien</first_name>
          <last_name>Zufferey</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://dzufferey.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/damienzufferey/5dc321db-5cef-4f4b-bd3c-a5bbb2f11dd1/small.jpg</picture_url>
          <person_id>damienzufferey</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>56a5f7a8-de7c-48a7-8150-e3fd32bc9197</slot_id>
      <event_id>8ec74bdb-391c-4417-a0de-3cfe60039dfb</event_id>
      <title>On the Unusual Effectiveness of Type-Aware Operator Mutations for Testing SMT Solvers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>04:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>04:20</end_time>
      <description>We propose type-aware operator mutation, a simple, but unusually effective approach for testing SMT solvers. The key idea is to mutate operators of conforming types within the seed formulas to generate well-typed mutant formulas. These mutant formulas are then used as the test cases for SMT solvers. We realized type-aware operator mutation within the OpFuzz tool and used it to stress-test Z3 and CVC4, two state-of-the-art SMT solvers. Type-aware operator mutations are unusually effective: During one year of extensive testing with OpFuzz, we reported 1092 bugs on Z3’s and CVC4’s respective GitHub issue trackers, out of which 819 unique bugs were confirmed and 685 of the confirmed bugs were fixed by the developers. The detected bugs are highly diverse — we found bugs of many different types (soundness bugs, invalid model bugs, crashes, etc.), logics and solver configurations. We have further conducted an in-depth study of the bugs found by OpFuzz. The study results show that the bugs found by OpFuzz are of high quality. Many of them affect core components of the SMT solvers’ codebases, and some required major changes for the developers to fix. Among the 819 confirmed bugs found by OpFuzz,184 were soundness bugs, the most critical bugs in SMT solvers,and 489 were in the default modes of the solvers. Notably, OpFuzz found 27 critical soundness bugs in CVC4, which has proved to be a very stable SMT solver.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dominik</first_name>
          <last_name>Winterer</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/dominikwinterer/f89f4b13-8156-4541-b618-d5128446e27f/small.jpg</picture_url>
          <person_id>dominikwinterer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chengyu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>East China Normal University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.chengyuzhang.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/chengyuzhang/eee80413-7fee-43ac-88d2-72212b8b352a/small.jpg</picture_url>
          <person_id>chengyuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>aa587aeb-f856-4a7e-ba3b-e865b0afd81c</slot_id>
      <event_id>d3521f08-1659-438b-8e27-401ba4d8046c</event_id>
      <title>Counterexample-Guided Correlation Algorithm for Translation Validation</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>03:40</end_time>
      <description>Automatic translation validation across the unoptimized intermediate representation (IR) of the original source code and the optimized executable assembly code is a desirable capability, and has the potential to compete with existing approaches to verified compilation such as CompCert. A difficult subproblem is the automatic identification of the correlations across the transitions between the two programs' respective locations. We present a counterexample-guided algorithm to identify these correlations in a robust and scalable manner. Our algorithm has both theoretical and empirical advantages over prior work in this problem space.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shubhani</first_name>
          <last_name>Gupta</last_name>
          <affiliation>IIT Delhi, India</affiliation>
          <bio>undefined</bio>
          <person_id>shubhani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Abhishek</first_name>
          <last_name>Rose</last_name>
          <affiliation>IIT Delhi, India</affiliation>
          <bio>undefined</bio>
          <person_id>abhishekrose</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sorav</first_name>
          <last_name>Bansal</last_name>
          <affiliation>IIT Delhi, India</affiliation>
          <bio>See http://compiler.ai for recent work</bio>
          <homepage_url>http://www.cse.iitd.ac.in/~sbansal</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/soravbansal1/3bacf39b-3a07-41a7-9acd-f6b4c27d2f89/small.jpg</picture_url>
          <person_id>soravbansal1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>97525099-e787-4fd1-8b76-933dfd5e2afa</subevent_id>
    <title>SPLASH OOPSLA: F-2B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>c43456f3-2dd2-4726-86f6-0ac5545b1c92</slot_id>
      <title>Session: SPLASH OOPSLA - F-2B</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>21:00</start_time>
      <end_time>22:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1895bd73-71c5-4ee6-94f2-ac2b6fc13eb3</slot_id>
      <event_id>aed381e3-4082-4aea-8916-ec4572cabcbf</event_id>
      <title>Testing Differential Privacy with Dual Interpreters</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>21:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>21:40</end_time>
      <description>Applying differential privacy at scale requires convenient ways to check that programs computing with sensitive data appropriately preserve privacy. We propose here a fully automated framework for {\em testing} differential privacy, adapting a well-known ``pointwise'' technique from informal proofs of differential privacy. Our framework, called DPCheck, requires no programmer annotations, handles all previously verified or tested algorithms, and is the first fully automated framework to distinguish correct and buggy implementations of PrivTree, a probabilistically terminating algorithm that has not previously been mechanically checked. 
We analyze the probability of DPCheck mistakenly accepting a non-private program and prove that, theoretically, the probability of false acceptance can be made exponentially small by suitable choice of test size. 
We demonstrate DPCheck's utility empirically by implementing all benchmark algorithms from prior work on mechanical verification of differential privacy, plus several others and their incorrect variants, and show DPCheck accepts the correct implementations and rejects the incorrect variants. 
We also demonstrate how DPCheck can be deployed in a practical workflow to test differentially privacy for the 2020 US Census Disclosure Avoidance System (DAS).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hengchu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <person_id>hengchuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Edo</first_name>
          <last_name>Roth</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <person_id>edoroth</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Haeberlen</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <person_id>andreashaeberlen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Benjamin C.</first_name>
          <last_name>Pierce</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>Benjamin Pierce is Henry Salvatori Professor of Computer and Information Science at the University of Pennsylvania and a Fellow of the ACM. His research interests include programming languages, type systems, language-based security, computer-assisted formal verification, differential privacy, and synchronization technologies. He is the author of the widely used graduate textbooks Types and Programming Languages and Software Foundations. He has served as co-Editor in Chief of the Journal of Functional Programming, as Managing Editor for Logical Methods in Computer Science, and as editorial board member of Mathematical Structures in Computer Science, Formal Aspects of Computing, and ACM Transactions on Programming Languages and Systems. He is also the lead designer of the popular Unison file synchronizer and co-developer of the Clowdr virtual conference platform.</bio>
          <homepage_url>http://www.cis.upenn.edu/~bcpierce/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/benjamincpierce/f2ee6f41-5bf7-4a0d-9b8d-71de6a666b1b/small.jpg</picture_url>
          <person_id>benjamincpierce</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Roth</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <person_id>aaronroth</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9daa922c-4573-4c78-a8a5-a97aa118c87c</slot_id>
      <event_id>9759a59c-e7fe-44ff-91d0-9250476fa15d</event_id>
      <title>Differentially-Private Software Frequency Profiling under Linear Constraints</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>22:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>22:20</end_time>
      <description>Differential privacy has emerged as a leading theoretical framework for privacy-preserving data gathering and analysis. It allows meaningful statistics to be collected for a population without revealing ``too much'' information about any individual member of the population. For software profiling, this machinery allows profiling data from many users of a deployed software system to be collected and analyzed in a privacy-preserving manner. Such a solution is appealing to many stakeholders, including software users, software developers, infrastructure providers, and government agencies. 
We propose an approach for differentially-private collection of frequency vectors from software executions. Frequency information is reported with the addition of random noise drawn from the Laplace distribution. A key observation behind the design of our scheme is that event frequencies are closely correlated due to the static code structure. Differential privacy protections must account for such relationships; otherwise, a seemingly-strong privacy guarantee is actually weaker than it appears. Motivated by this observation, we propose a novel and general differentially-private profiling scheme when correlations between frequencies can be expressed through linear inequalities. Using a linear programming formulation, we show how to determine the magnitude of random noise that should be added to achieve meaningful privacy protections under such linear constraints. Next, we develop an efficient instance of this general machinery for an important subclass of constraints. Instead of LP, our solution uses a reachability analysis of a constraint graph. As an exemplar, we employ this approach to implement differentially-private method frequency profiling for Android apps. 
Any differentially-private scheme has to balance two competing aspects: privacy and accuracy. Through an experimental study to characterize these trade-offs, we (1) show that our proposed randomization achieves much higher accuracy compared to related prior work, (2) demonstrate that high accuracy and high privacy protection can be achieved simultaneously, and (3) highlight the importance of linear constraints in the design of the randomization. These promising results provide evidence that our approach is a good candidate for privacy-preserving frequency profiling of deployed software.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hailong</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Fordham University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hailongzhang.com</homepage_url>
          <person_id>hailongzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yu</first_name>
          <last_name>Hao</last_name>
          <affiliation>Ohio State University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>yuhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sufian</first_name>
          <last_name>Latif</last_name>
          <affiliation>Ohio State University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>sufianlatif</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Raef</first_name>
          <last_name>Bassily</last_name>
          <affiliation>Ohio State University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>raefbassily</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Atanas</first_name>
          <last_name>Rountev</last_name>
          <affiliation>Ohio State University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.ohio-state.edu/~rountev</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/atanasrountev/57ea0ee0-eebe-48f0-91fe-1ed3a28b5d92/small.jpg</picture_url>
          <person_id>atanasrountev</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a40e0487-786d-4408-8bfe-ea446475b0cd</slot_id>
      <event_id>3d4eac8d-6c79-48a8-b5ab-8b400d1a80ee</event_id>
      <title>Unifying Execution of Imperative Generators and Declarative Specifications</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>21:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>22:00</end_time>
      <description>We present Deuterium—a framework for implementing Java methods as executable contracts. Deuterium introduces a novel, type-safe way to write method contracts entirely in Java, as a combination of imperative generators and declarative specifications (written in a first-order relational logic with transitive closure). Existing approaches are typically based on encoding both the specification and the program heap into a constraint language, and then using an off-the-shelf constraint solver—without any additional guidance—to search for a new program heap that satisfies the specification. Deuterium takes advantage of user-provided generators to prune the search space and reduce incurred overhead of constraint solving. Deuterium supports two ways of solving declarative constraints: SAT-based and search-based with in-memory state exploration. We evaluate our approach on a suite of data structures, established as a standard benchmark by prior work. Furthermore, we use random and sequence-based test generation to create a new benchmark designed to mimic realistic execution scenarios. Our results show that generators improve the performance of executable contracts and that in-memory state exploration is the algorithm of choice when heap sizes are small.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pengyu</first_name>
          <last_name>Nie</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>I’m a Ph.D. student at the University of Texas at Austin. I work with Prof. Milos Gligoric. My research interests focus on the fusion of software engineering, programming languages, and natural language processing. Specific topics include languages for writing executable contracts and executable comments, updating natural language elements for evolving software, and utilizing runtime context to improve ML models for software.</bio>
          <homepage_url>http://cozy.ece.utexas.edu/~pynie/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/pengyunie/eb2ae7b4-4e42-4cbe-ba27-0b4f2fac274a/small.jpg</picture_url>
          <person_id>pengyunie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marinela</first_name>
          <last_name>Parovic</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>marinelaparovic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhiqiang</first_name>
          <last_name>Zang</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>zhiqiangzang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sarfraz</first_name>
          <last_name>Khurshid</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/sarfrazkhurshid/b998e03f-4c99-458b-a9f9-b6c470511e3b/small.jpg</picture_url>
          <person_id>sarfrazkhurshid</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Aleksandar</first_name>
          <last_name>Milicevic</last_name>
          <affiliation>Microsoft, n.n.</affiliation>
          <bio>undefined</bio>
          <person_id>aleksandarmilicevic2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Milos</first_name>
          <last_name>Gligoric</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/milosgligoric/4d0671ae-937e-4f08-b499-092379ff7ad3/small.jpg</picture_url>
          <person_id>milosgligoric</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>edd5668a-9973-4a14-a55e-b6a0f0898d6c</slot_id>
      <event_id>cd599ff5-f878-4129-adc0-ffafc2709664</event_id>
      <title>Feedback-Driven Semi-supervised Synthesis of Program Transformations</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>21:20</end_time>
      <description>While editing code, it is common for developers to make multiple related repeated edits that are all instances of a more general program transformation. Since this process can be tedious and error-prone, we study the problem of automatically learning program transformations from past edits, which can then be used to predict future edits. We take a novel view of the problem as a semi-supervised learning problem: apart from the concrete edits that are instances of the general transformation, the learning procedure also exploits access to additional inputs (program subtrees) that are marked as positive or negative depending on whether the transformation applies on those inputs. We present a procedure to solve the semi-supervised transformation learning problem using anti-unification and programming-by-example synthesis technology. To eliminate reliance on access to marked additional inputs, we generalize the semi-supervised learning procedure to a feedback-driven procedure that also generates the marked additional inputs in an iterative loop. We apply these ideas to build and evaluate three applications that use different mechanisms for generating feedback. Compared to existing tools that learn program transformations from edits, our feedback-driven semi-supervised approach is vastly more effective in successfully predicting edits with significantly lesser amounts of past edit data.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiang</first_name>
          <last_name>Gao</last_name>
          <affiliation>National University of Singapore, Singapore</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.comp.nus.edu.sg/~gaoxiang/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xianggao/482ff4c5-f003-40e7-90cc-d888adbd1e2f/small.jpg</picture_url>
          <person_id>xianggao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shraddha</first_name>
          <last_name>Barke</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shraddhabarke1/4e11ed13-0f46-4d77-8a6d-dd4c07b7fd4b/small.jpg</picture_url>
          <person_id>shraddhabarke1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Radhakrishna</last_name>
          <affiliation>Microsoft, n.n.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://arjunradhakrishna.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjunradhakrishna/5187c933-18de-4045-9119-d97023dd12b7/small.jpg</picture_url>
          <person_id>arjunradhakrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gustavo</first_name>
          <last_name>Soares</last_name>
          <affiliation>Microsoft, n.n.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://gustavoasoares.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gustavosoares/fc1e5a17-f939-4c3d-ab30-85467cb2610b/small.jpg</picture_url>
          <person_id>gustavosoares</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft, USA</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Alan</first_name>
          <last_name>Leung</last_name>
          <affiliation>Microsoft, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://alan.leung.work</homepage_url>
          <person_id>alanleung</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Nachiappan</first_name>
          <last_name>Nagappan</last_name>
          <affiliation>Microsoft Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/nachin/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nachiappannagappan/c34b7330-eb7e-4bf2-8d02-32395689de52/small.jpg</picture_url>
          <person_id>nachiappannagappan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Ashish</first_name>
          <last_name>Tiwari</last_name>
          <affiliation>Microsoft, n.n.</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.csl.sri.com/users/tiwari/</homepage_url>
          <person_id>ashishtiwari</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4a1d6f5a-1a52-4d47-beaa-742a8d77a87c</subevent_id>
    <title>SPLASH OOPSLA: W-5</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>0a443ecf-6ade-4987-ae51-18e28e68b3da</slot_id>
      <title>Session: SPLASH OOPSLA - W-5</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Nengkun</first_name>
          <last_name>Yu</last_name>
          <affiliation>University of Technology Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <person_id>nengkunyu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>18642c7e-7897-42e4-a0ad-d08f9968793b</slot_id>
      <event_id>b766280d-c659-44b7-ad70-289237a4edcc</event_id>
      <title>A Model for Detecting Faults in Build Specifications</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>03:20</end_time>
      <description>Incremental and parallel builds are crucial features of modern build systems. Parallelism enables fast builds by running independent tasks simultaneously, while incrementality saves time and computing resources by processing the build operations that were affected by a particular code change. Writing build definitions that lead to error-free incremental and parallel builds is a challenging task. This is mainly because developers are often unable to predict the effects of build operations on the file system and how different build operations interact with each other. Faulty build scripts may seriously degrade the reliability of automated builds, as they cause build failures, and non-deterministic and incorrect outputs. 
To reason about arbitrary build executions, we present BuildFS, a generally-applicable model that takes into account the specification (as declared in build scripts) and the actual behavior (low-level file system operation) of build operations. We then formally define different types of faults related to incremental and parallel builds in terms of the conditions under which a file system operation violates the specification of a build operation. Our testing approach, which relies on the proposed model, analyzes the execution of single full build, translates it into BuildFS, and uncovers faults by checking for corresponding violations. 
We evaluate the effectiveness, efficiency, and applicability of our approach by examining 612 Make and Gradle projects. Notably, thanks to our treatment of build executions, our method is the first to handle JVM-oriented build systems. The results indicate that our approach is (1) able to uncover several important issues (247 issues found in 47 open-source projects have been confirmed and fixed by the upstream developers), and (2) much faster than a state-of-the-art tool for Make builds (the median and average speedup is 39X and 74X respectively).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thodoris</first_name>
          <last_name>Sotiropoulos</last_name>
          <affiliation>Athens University of Economics and Business, Greece</affiliation>
          <bio>undefined</bio>
          <person_id>thodorissotiropoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stefanos</first_name>
          <last_name>Chaliasos</last_name>
          <affiliation>Athens University of Economics and Business, Greece</affiliation>
          <bio>undefined</bio>
          <person_id>stefanoschaliasos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dimitris</first_name>
          <last_name>Mitropoulos</last_name>
          <affiliation>Athens University of Economics and Business, Greece</affiliation>
          <bio>Dimitris Mitropoulos is the Head of the Reliability Engineering Directorate of the Greek National Infrastructures for Research and Technology (GRNET) and a Researcher at the Athens University of Economics and Business. Previously, he has been a Postdoctoral Researcher at the Network Security Laboratory (NSL) of Columbia University in the City of New York. Dimitris holds a PhD in Computer Security from the Athens University of Economics and Business and has been involved in several EU and US funded R&amp;amp;D projects. His research interests include computer security, software reliability, software engineering and applied cryptography. He is a member of ACM, IEEE, SysSec, and an official writer for the ACM Computing Reviews journal.</bio>
          <homepage_url>https://dimitro.gr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/dimitrismitropoulos/a0d64ae8-d979-4ed9-a834-b808d3cc40d2/small.jpg</picture_url>
          <person_id>dimitrismitropoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Diomidis</first_name>
          <last_name>Spinellis</last_name>
          <affiliation>Athens University of Economics and Business, Greece</affiliation>
          <bio>Diomidis Spinellis is Professor of Software Engineering, Head of the Department of Management Science and Technology, and director of the Business Analytics Laboratory (BALab), at the Athens University of Economics and Business, Greece. His research interests include software engineering, IT security, and computing systems. He has written two award-winning, widely-translated books: Code Reading and Code Quality: The Open Source Perspective. In 2016 he published the book Effective Debugging: 66 Specific Ways to Debug Software and Systems. Dr. Spinellis has also published more than 300 technical papers in journals and refereed conference proceedings, which have received more than 8000 citations. He served for a decade as a member of the IEEE Software editorial board, authoring the regular “Tools of the Trade” column and for four years at the magazine’s Editor in Chief. He has contributed code that ships with Apple’s macOS and BSD Unix and is the developer of CScout, UMLGraph, dgsh, and other open-source software packages, libraries, and tools. He holds an MEng in Software Engineering and a PhD in Computer Science, both from Imperial College London. Dr. Spinellis has served as an elected member of the IEEE Computer Society Board of Governors (2013–2015), and is a senior member of the ACM and the IEEE.</bio>
          <homepage_url>https://www.dmst.aueb.gr/dds</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/diomidisspinellis/a7f21db5-04c0-4282-85ab-614b4394c90a/small.jpg</picture_url>
          <person_id>diomidisspinellis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a6f648a4-4af7-4f3e-8930-076e14663da9</slot_id>
      <event_id>3861b0b2-0efa-45db-a79a-416ae2de5a28</event_id>
      <title>Statically Verified Refinements for Multiparty Protocols</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>04:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>04:20</end_time>
      <description>With distributed computing becoming ubiquitous in the modern era, safe distributed programming is an open challenge. To address this, multiparty session types (MPST) provide a typing discipline for message-passing concurrency, guaranteeing communication safety properties such as deadlock freedom. 
While originally MPST focus on the communication aspects, and employ a simple typing system for communication payloads, communication protocols in the real world usually contain constraints on the payload. We introduce refined multiparty session types (RMPST), an extension of MPST, that express data dependent protocols via refinement types on the data types. 
We provide an implementation of RMPST, in a toolchain called Session*, using Scribble, a toolchain for multiparty protocols, and targeting F*, a verification-oriented functional programming language. Users can describe a protocol in Scribble and implement the endpoints in F* using refinement-typed APIs generated from the protocol. The F* compiler can then statically verify the refinements. Moreover, we use a novel approach of callback-styled API generation, providing static linearity guarantees with the inversion of control. We evaluate our approach with real world examples and show that it has little overhead compared to a naive implementation, while guaranteeing safety properties from the underlying theory.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fangyi</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/fangyizhou/c1ff2787-4ce8-45c7-a584-0cc8f627722c/small.jpg</picture_url>
          <person_id>fangyizhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Francisco</first_name>
          <last_name>Ferreira</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~fferre16/</homepage_url>
          <person_id>franciscoferreira1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Raymond</first_name>
          <last_name>Hu</last_name>
          <affiliation>University of Hertfordshire, UK</affiliation>
          <bio>undefined</bio>
          <person_id>raymondhu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rumyana</first_name>
          <last_name>Neykova</last_name>
          <affiliation>Brunel University London, UK</affiliation>
          <bio>Rumyana Neykova is a lecturer at Brunel University London, previously completed a PhD degree under the supervision of Prof. Nobuko Yoshida at Imperial College London, where she was also research fellow. Her research interests are in the area of distributed systems and networks, as well as type systems and language design. Her PhD focuses on development and applications of a type theory (called session types) for runtime verification of concurrent and distributed systems.</bio>
          <homepage_url>https://www.brunel.ac.uk/people/rumyana-neykova</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rumyananeykova/66457b0a-8e8b-471e-b278-37d7f4242bcb/small.jpg</picture_url>
          <person_id>rumyananeykova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b8b1ea3d-bf7c-48c9-89bb-f82d341c4201</slot_id>
      <event_id>c5a30df7-cf14-473f-9641-714eedc28464</event_id>
      <title>Structure Interpretation of Text Formats</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>04:00</end_time>
      <description>Data repositories often consist of text files in a wide variety of standard formats, ad-hoc formats, as well as mixtures of formats where data in one format is embedded into a different format. It is therefore a significant challenge to parse these files into a structured tabular form, which is important to enable any downstream data processing. 
We present \textsc{Unravel}, an extensible framework for structure interpretation of ad-hoc formats. \textsc{Unravel} can automatically, with no user input, extract tabular data from a diverse range of standard, ad-hoc and mixed format files. The framework is also easily extensible to add support for previously unseen formats, and also supports interactivity from the user in terms of examples to guide the system when specialized data extraction is desired. Our key insight is to allow arbitrary combination of extraction and parsing techniques through a concept called \emph{partial structures}. Partial structures act as a common language through which the file structure can be shared and refined by different techniques. This makes \textsc{Unravel} more powerful than applying the individual techniques in parallel or sequentially. Further, with this rule-based extensible approach, we introduce the novel notion of \emph{re-interpretation} where the variety of techniques supported by our system can be exploited to improve accuracy while optimizing for particular quality measures or restricted environments. On our benchmark of $617$ text files gathered from a variety of sources, \textsc{Unravel} is able to extract the intended table in many more cases compared to state-of-the-art techniques.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft, USA</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vu</first_name>
          <last_name>Le</last_name>
          <affiliation>Microsoft, USA</affiliation>
          <bio>I am a Researcher at Microsoft, working on the Microsoft Program Synthesis using Examples (PROSE) framework. I obtained my PhD in 2015 at UC Davis, advised by Zhendong Su and Sumit Gulwani. My research is about developing novel and practical techniques to help improve the quality of critical software (e.g., compilers and database engines) and make programming accessible for end users. My work has led to the discovery of hundreds of bugs in GCC and LLVM, most of which have been fixed, and shipped in various Microsoft products.</bio>
          <homepage_url>http://vuminhle.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vule/8674b9d0-747d-4a80-b8f0-3c7a435cd9b7/small.jpg</picture_url>
          <person_id>vule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Radhakrishna</last_name>
          <affiliation>Microsoft, n.n.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://arjunradhakrishna.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjunradhakrishna/5187c933-18de-4045-9119-d97023dd12b7/small.jpg</picture_url>
          <person_id>arjunradhakrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Radiček</last_name>
          <affiliation>Microsoft, Austria</affiliation>
          <bio>undefined</bio>
          <person_id>ivanradicek2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Mohammad</first_name>
          <last_name>Raza</last_name>
          <affiliation>Microsoft, USA</affiliation>
          <bio>undefined</bio>
          <person_id>mohammadraza</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c60006a2-218a-4e5a-b127-45b4f3f6230b</slot_id>
      <event_id>fb1f6365-ed4d-47f7-b0d5-c96755f131af</event_id>
      <title>Persistent Owicki-Gries Reasoning: A Program Logic for Reasoning about Persistent Programs on Intel-x86</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>03:40</end_time>
      <description>The advent of non-volatile memory (NVM) technologies is expected to transform how software systems are structured fundamentally, making the task of \emph{correct} programming significantly harder. This is because ensuring that memory stores persist in the correct order is challenging, and requires low-level programming to flush the cache at appropriate points. This has in turn resulted in a noticeable \emph{verification gap}. %causing a significant verification burden. 
To address this, we study the verification of NVM programs, and present \emph{Persistent Owicki-Gries} (POG), the first program logic for reasoning about such programs. We prove the soundness of POG over the recent Intel-x86 model, which formalises the out-of-order persistence of memory stores and the semantics of the Intel cache line flush instructions. We then use POG to verify several programs that interact with NVM.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Azalea</first_name>
          <last_name>Raad</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.SoundAndComplete.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/azalearaad/180ee602-475f-483f-a01b-ea187c9e8ac1/small.jpg</picture_url>
          <person_id>azalearaad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~orilahav/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/orilahav/89b656f6-7634-49d1-9917-4b74da70a976/small.jpg</picture_url>
          <person_id>orilahav</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Vafeiadis</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>Viktor Vafeiadis is a tenured faculty at the Max Planck Institute for Software Systems (MPI-SWS) in Germany. He got his BA and PhD from the University of Cambridge, and held post-doctoral researcher positions at the University of Cambridge and at Microsoft Research Cambridge before joining MPI-SWS in October 2010.</bio>
          <homepage_url>http://www.mpi-sws.org/~viktor/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/viktorvafeiadis/6a063832-47ca-4c32-8047-4bf4f74ae764/small.jpg</picture_url>
          <person_id>viktorvafeiadis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9da82607-5a93-4e06-8fa7-407486d96040</subevent_id>
    <title>SPLASH OOPSLA: R-6</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>48530c48-a457-4763-b41c-6e93499b24e1</slot_id>
      <title>Session: SPLASH OOPSLA - R-6</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Dominik</first_name>
          <last_name>Winterer</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/dominikwinterer/f89f4b13-8156-4541-b618-d5128446e27f/small.jpg</picture_url>
          <person_id>dominikwinterer</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science at Delft University of Technology. He received a master’s and doctorate in computer science from the University of Amsterdam in 1993 and 1997, respectively. Previously he served as postdoc at the Oregon Graduate Institute, as Assistant Professor at Utrecht University, and as Associate Professor at TU Delft. 
His research interests include programming languages, software language engineering, domain-specific programming languages, program transformation, syntax definition, and parsing. With his students he has designed and implemented the Spoofax language workbench, as well as many domain-specific languages, including DSLs for syntax definition (SDF2, SDF3), program transformation (Stratego), static semantics (NaBL, Statix), dynamic semantics (DynSem), software deployment (Nix), web application development (WebDSL), and mobile phone applications (mobl). In the language designer’s workbench project he is pursuing high-level declarative language definition that serves for language implementation and verification.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1ad32226-4d5e-4f0a-9888-ed335514f0ae</slot_id>
      <event_id>19758c97-2c7a-4f32-bfb9-cb729a2cc3b8</event_id>
      <title>Macros for Domain-Specific Languages</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>06:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>06:20</end_time>
      <description>Macros provide a powerful means of extending languages. They have proven useful in both general-purpose and domain-specific programming contexts. This paper presents an architecture for implementing macro-extensible DSLs on top of macro-extensible host languages. The macro expanders of these DSLs inherit the syntax system, hygienic expansion, and more from the host. They transform the extensible DSL syntax into a DSL core language. This arrangement has several important consequences. It becomes straightforward to integrate the syntax of various DSLs and the host language when their expanders share these inherited components. Also, a DSL compiler may be designed around a fixed core language, even for an extensible DSL. Finally, macros empower programmers to safely grow DSLs on their own and tailor them to their needs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Ballantyne</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>Michael Ballantyne is a PhD student at the Northeastern University Programming Research Laboratory, advised by Matthias Felleisen. He envisions a future where mainstream programmers regularly create, extend, and fluidly intermix domain-specific languages, with excellent support from their programming language and environment. Recently he’s been developing a formal characterization of macro hygiene that accounts for the full range of program transformations used in embedded DSL implementation, and also improving the type systems as macros approach to integrate macro expansion and typechecking.</bio>
          <homepage_url>http://mballantyne.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelballantyne/0fb0042c-454e-437b-938c-bd6fb195d0cb/small.jpg</picture_url>
          <person_id>michaelballantyne</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexis</first_name>
          <last_name>King</last_name>
          <affiliation>Northwestern University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexisking/4d4403cc-a825-40f3-a69d-089d8403e71a/small.jpg</picture_url>
          <person_id>alexisking</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Felleisen</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/matthias/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthiasfelleisen/3781509a-02f7-4e22-822d-04481501e833/small.jpg</picture_url>
          <person_id>matthiasfelleisen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5dc1f41b-acf2-4586-b757-407a4e5f9269</slot_id>
      <event_id>0ec91bc5-4e13-4f05-907b-344b042b9659</event_id>
      <title>Inter-theory Dependency Analysis for SMT String Solvers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>05:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>06:00</end_time>
      <description>Solvers in the framework of Satisfiability Modulo Theories (SMT) have been widely successful in practice. Recently there has been an increasing interest in solvers for string constraints to address security issues in web programming, for example. To be practically useful, the solvers need to support an expressive constraint language over unbounded strings, and in particular, over string lengths. Satisfiability checking for these formulas, especially in the SMT context, is very hard; it is generally undecidable for a rich fragment. In this paper, we propose a form of dependency analysis for a rich fragment of string constraints including high-level operations such as length, contains to deal with their inter-theory interaction so as to solve them more efficiently. We implement our dependency analysis in the string theory of the Z3 solver to obtain a new one, called S3N. Finally, we demonstrate the superior performance of S3N over state-of-the-art string solvers such as Z3str3, CVC4, S3P, and Z3 on several large industrial-strength benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Minh-Thai</first_name>
          <last_name>Trinh</last_name>
          <affiliation>Advanced Digital Sciences Center, Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>thaitrinh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Duc-Hiep</first_name>
          <last_name>Chu</last_name>
          <affiliation>National University of Singapore, Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>duchiepchu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Joxan</first_name>
          <last_name>Jaffar</last_name>
          <affiliation>National University of Singapore, Singapore</affiliation>
          <bio>1982-1986: Lecturer, Monash University 1986-1995: Research Staff Member, IBM T.J. Watson Research Center 1995-Present: Professor of Computer Science, National University of Singapore</bio>
          <homepage_url>http://www.comp.nus.edu.sg/~joxan</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joxanjaffar/f391720a-61ea-4df1-ad81-91f5873a342c/small.jpg</picture_url>
          <person_id>joxanjaffar</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b63ca10e-9ef6-4926-aad7-6c4c448efc7f</slot_id>
      <event_id>46ea216e-db41-4d72-adfd-3e70848f065e</event_id>
      <title>Deductive Optimization of Relational Data Storage</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>05:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>05:40</end_time>
      <description>Optimizing the physical data storage and retrieval of data are two key database management problems. In this paper, we propose a language that can express both a relational query and the layout of its data. Our language can express a wide range of physical database layouts, going well beyond the row- and column-based methods that are widely used in database management systems. We use deductive program synthesis to turn a high-level relational representation of a database query into a highly optimized low-level implementation which operates on a specialized layout of the dataset. We build an optimizing compiler for this language and conduct experiments using a popular database benchmark, which shows that the performance of our specialized queries is better than a state-of-the-art in memory compiled database system while achieving an order-of-magnitude reduction in memory use.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Feser</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>John Feser is a PhD student in the Computer Science and Artificial Intelligence Laboratory at MIT, advised by Armando Solar-Lezama. He is interested in program synthesis and databases.</bio>
          <homepage_url>http://people.csail.mit.edu/feser/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnfeser/edee5cf7-267b-4a87-90ca-94f278378c37/small.jpg</picture_url>
          <person_id>johnfeser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Madden</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>sammadden</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nan</first_name>
          <last_name>Tang</last_name>
          <affiliation>QCRI HBKU, n.n.</affiliation>
          <bio>undefined</bio>
          <person_id>nantang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Armando</first_name>
          <last_name>Solar-Lezama</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>Armando Solar-Lezama is an associate professor at MIT where he leads the Computer Aided Programming Group. His research interests include software synthesis and its applications in diverse areas such as high-performance computing, information flow security and probabilistic programming.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/armandosolarlezama/7befe52d-6968-4786-9841-408800f80c71/small.jpg</picture_url>
          <person_id>armandosolarlezama</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f975400b-6fbc-4cfc-8c0d-32071080db20</slot_id>
      <event_id>2abee499-a6aa-4ad2-9126-979e3981f059</event_id>
      <title>Adding Interactive Visual Syntax to Textual Code</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>05:20</end_time>
      <description>Many programming problems call for turning geometrical thoughts into code: tables, hierarchical structures, nests of objects, trees, forests, graphs, and so on. Linear text does not do justice to such thoughts. But, it has been the dominant programming medium for the past and will remain so for the foreseeable future. 
This paper proposes a novel mechanism for conveniently extending textual programming languages with problem-specific visual syntax. It argues the necessity of this language feature, demonstrates the feasibility with a robust prototype, and sketches a design plan for adapting the idea to other languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Leif</first_name>
          <last_name>Andersen</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/leifandersen/022e7f05-2a9a-4e3d-8be9-418b798e00c0/small.jpg</picture_url>
          <person_id>leifandersen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Ballantyne</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>Michael Ballantyne is a PhD student at the Northeastern University Programming Research Laboratory, advised by Matthias Felleisen. He envisions a future where mainstream programmers regularly create, extend, and fluidly intermix domain-specific languages, with excellent support from their programming language and environment. Recently he’s been developing a formal characterization of macro hygiene that accounts for the full range of program transformations used in embedded DSL implementation, and also improving the type systems as macros approach to integrate macro expansion and typechecking.</bio>
          <homepage_url>http://mballantyne.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelballantyne/0fb0042c-454e-437b-938c-bd6fb195d0cb/small.jpg</picture_url>
          <person_id>michaelballantyne</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Felleisen</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/matthias/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthiasfelleisen/3781509a-02f7-4e22-822d-04481501e833/small.jpg</picture_url>
          <person_id>matthiasfelleisen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8f0bebf1-2d3e-40df-94a8-ebf198b7ee0e</subevent_id>
    <title>SPLASH OOPSLA: F-3B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>7294a9c0-cfae-427f-afd5-761ea9b8b229</slot_id>
      <title>Session: SPLASH OOPSLA - F-3B</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Yulei</first_name>
          <last_name>Sui</last_name>
          <affiliation>University of Technology Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuleisui.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yuleisui/e6ce6e88-3cd8-4595-9c61-a8da6f7319f6/small.jpg</picture_url>
          <person_id>yuleisui</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0b5e2ec2-3f98-4fdb-bf46-0a0700a0d79c</slot_id>
      <event_id>1191b34c-6380-48db-9c47-b8e642e28ee2</event_id>
      <title>ιDOT: A DOT Calculus with Object Initialization</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/21</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>00:20</end_time>
      <description>The Dependent Object Types (DOT) calculus serves as a foundation of the Scala programming language, with a machine-verified soundness proof. However, Scala's type system has been shown to be unsound due to null references, which are used as default values of fields of objects before they have been initialized. This paper proposes ιDOT, an extension of DOT for ensuring safe initialization of objects. DOT was previously extended to κDOT with the addition of mutable fields and constructors. To κDOT, ιDOT adds an initialization effect system that statically prevents the possibility of reading a null reference from an uninitialized object. To design ιDOT, we have reformulated the Freedom Before Commitment object initialization scheme in terms of disjoint subheaps to make it easier to formalize in an effect system and prove sound. Soundness of ιDOT depends on the interplay of three systems of rules: a type system close to that of DOT, an effect system to ensure definite assignment of fields in each constructor, and an initialization system that tracks the initialization status of objects in a stack of subheaps. We have proven the overall system sound and verified the soundness proof using the Coq proof assistant.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ifaz</first_name>
          <last_name>Kabir</last_name>
          <affiliation>University of Alberta, Canada</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/ifazkabir/991cbcab-f46c-4c5e-8b8f-c365d1b11d6b/small.jpg</picture_url>
          <person_id>ifazkabir</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yufeng</first_name>
          <last_name>Li</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>yufengli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>61faefff-83a0-4533-980d-dfaeaacbe39e</slot_id>
      <event_id>275f97bd-396a-4f74-95be-90160be2ffc2</event_id>
      <title>Taming Type Annotations in Gradual Typing</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>23:40</end_time>
      <description>Gradual typing provides a methodology to integrate static and dynamic typing, harmonizing their often conflicting advantages in a single language. When a user wants to enjoy the advantages of static typing, most gradual languages require that they add type annotations. Many nontrivial tasks must be undertaken while adding type annotations, including understanding program behaviors and invariants. Unfortunately, if this is done incorrectly then the added type annotations can be wrong–leading to inconsistencies between the program and the type annotations. Gradual typing implementations detect such inconsistencies at runtime, raise cast errors, and generate messages. However, solely relying on such error messages for understanding and fixing inconsistencies and their resulting cast errors is often insufficient for multiple reasons. One reason is that while such messages cover inconsistencies in one execution path, fixing them often requires reconciling information from multiple paths. Another is that users may add many wrong type annotations that they later find difficult to identify and fix, when considering all added annotations. 
Recent studies provide evidence that type annotations added during program migration are often wrong and that many programmers prefer compile-time warnings about wrong annotations. Motivated by these results, we develop exploratory typing to help with the static detection, understanding, and fixing of inconsistencies. The key idea of exploratory typing is that it systematically removes dynamic types and explores alternative types for static type annotations that can remedy inconsistencies. To demonstrate the feasibility of exploratory typing, we have implemented it in PyHound, which targets programs written in Reticulated Python, a gradual variant of Python. We have evaluated PyHound on a set of Python programs, and the evaluation results demonstrate that our idea can effectively detect inconsistencies in 98% of the tested programs and fix 93% of inconsistencies, significantly outperforming pytype, a widely used Python tool for enforcing type annotations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Peter Campora III</last_name>
          <affiliation>University of Louisiana at Lafayette, USA</affiliation>
          <bio>I’m a 3rd year PhD student at ULL advised by Sheng Chen. My current research focus has been improving the usability of gradually typed languages. You can contact me at: petecampora (at) gmail.com.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnpetercamporaiii/62a0c591-991e-49f7-978a-0ecbc5556620/small.jpg</picture_url>
          <person_id>johnpetercamporaiii</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sheng</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Louisiana at Lafayette, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.cmix.louisiana.edu/schen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shengchen1/4561e224-57d6-4243-9b1f-0c895b2c49d7/small.jpg</picture_url>
          <person_id>shengchen1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>88979812-228d-4782-8643-9d58fce37078</slot_id>
      <event_id>49e4b00a-5555-4c4e-8eca-5628b4a98878</event_id>
      <title>Learning Semantic Program Embeddings with Graph Interval Neural Network</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>00:00</end_time>
      <description>Learning distributed representations of source code has been a challenging task for machine learning models. Earlier works treated programs as text so that natural language methods can be readily applied. Unfortunately, such approaches do not capitalize on the rich structural information possessed by source code. Of late, Graph Neural Network (GNN) was proposed to learn embeddings of programs from their graph representations. Due to the homogeneous (i.e. do not take advantage of the program-specific graph characteristics) and expensive (i.e. require heavy information exchange among nodes in the graph) message-passing procedure, GNN can suffer from precision issues, especially when dealing with programs rendered into large graphs. In this paper, we present a new graph neural architecture, called Graph Interval Neural Network (GINN), to tackle the weaknesses of the existing GNN. Unlike the standard GNN, GINN generalizes from a curated graph representation obtained through an abstraction method designed to aid models to learn. In particular, GINN focuses exclusively on intervals (generally manifested in looping construct) for mining the feature representation of a program, furthermore, GINN operates on a hierarchy of intervals for scaling the learning to large graphs. 
We evaluate GINN for two popular downstream applications: variable misuse prediction and method name prediction. Results show in both cases GINN outperforms the state-of-the-art models by a comfortable margin. We have also created a neural bug detector based on GINN to catch null pointer deference bugs in Java code. While learning from the same 9,000 methods extracted from 64 projects, GINN-based bug detector significantly outperforms GNN-based bug detector on 13 unseen test projects. Next, we deploy our trained GINN-based bug detector and Facebook Infer, arguably the state-of-the-art static analysis tool, to scan the codebase of 20 highly starred projects on GitHub. Through our manual inspection, we confirm 38 bugs out of 102 warnings raised by GINN-based bug detector compared to 34 bugs out of 129 warnings for Facebook Infer. We have reported 38 bugs GINN caught to developers, among which 11 have been fixed and 12 have been confirmed (fix pending). GINN has shown to be a general, powerful deep neural network for learning precise, semantic program embeddings.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yu</first_name>
          <last_name>Wang</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <person_id>yuwang2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ke</first_name>
          <last_name>Wang</last_name>
          <affiliation>Visa Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kbwang.bitbucket.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/kewang/37ef656e-ca92-475f-8a51-902dbe44fb72/small.jpg</picture_url>
          <person_id>kewang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Fengjuan</first_name>
          <last_name>Gao</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <person_id>fenjuangao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Linzhang</first_name>
          <last_name>Wang</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <person_id>linzhangwang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fdfbddc1-e6b2-4735-bccc-8c527112d5d0</slot_id>
      <event_id>6a3ae3f8-1ca4-44df-b6b1-bb4756927885</event_id>
      <title>Just-in-Time Learning for Bottom-Up Enumerative Synthesis</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>23:20</end_time>
      <description>A key challenge in program synthesis is the astronomical size of the search space the synthesizer has to explore. In response to this challenge, recent work proposed to guide synthesis using learned probabilistic models. Obtaining such a model, however, might be infeasible for a problem domain where no high-quality training data is available. In this work we introduce an alternative approach to guided program synthesis: instead of training a model ahead of time we show how to bootstrap one just in time, during synthesis, by learning from partial solutions encountered along the way. To make the best use of the model, we also propose a new program enumeration algorithm we dub guided bottom-up search, which extends the efficient bottom-up search with guidance from probabilistic models. 
We implement this approach in a tool called Probe, which targets problems in the popular syntax-guided synthesis (SyGuS) format. We evaluate Probe on benchmarks from the literature and show that it achieves significant performance gains both over unguided bottom-up search and over a state-of-the-art probability-guided synthesizer, which had been trained on a corpus of existing solutions. Moreover, we show that these performance gains do not come at the cost of solution quality: programs generated by Probe are only slightly more verbose than the shortest solutions and perform no unnecessary case-splitting.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shraddha</first_name>
          <last_name>Barke</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shraddhabarke1/4e11ed13-0f46-4d77-8a6d-dd4c07b7fd4b/small.jpg</picture_url>
          <person_id>shraddhabarke1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>050c9673-a337-4734-a069-8fa5298f29b5</subevent_id>
    <title>SPLASH OOPSLA: R-2</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>fb1bd88f-2586-4bbe-8993-2b251f01e6fb</slot_id>
      <title>Session: SPLASH OOPSLA - R-2</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Sheng</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Louisiana at Lafayette, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.cmix.louisiana.edu/schen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shengchen1/4561e224-57d6-4243-9b1f-0c895b2c49d7/small.jpg</picture_url>
          <person_id>shengchen1</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Adrian</first_name>
          <last_name>Sampson</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://adriansampson.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adriansampson/adaa9202-3352-4410-b03a-1eb4718543d5/small.jpg</picture_url>
          <person_id>adriansampson</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>241ea089-5cb6-4728-9396-db07e244a062</slot_id>
      <event_id>7f5b0b0c-f047-4936-8287-c85d0bbd3581</event_id>
      <title>Do You Have Space for Dessert? A Verified Space Cost Semantics for CakeML Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>09:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>09:40</end_time>
      <description>Garbage collectors relieve the programmer from manual memory management, but lead to compiler-generated machine code that can behave differently (e.g.\ out-of-memory errors) from the source code. To ensure that the generated code behaves exactly like the source code, programmers need a way to answer questions of the form: what is a sufficient amount of memory for my program to never reach an out-of-memory error? 
This paper develops a cost semantics that can answer such questions for CakeML programs. The work described in this paper is the first to be able to answer such questions with proofs in the context of a language that depends on garbage collection. We demonstrate that positive answers can be used to transfer liveness results proved for the source code to liveness guarantees about the generated machine code. Without guarantees about space usage, only safety results can be transferred from source to machine code. 
Our cost semantics is phrased in terms of an abstract intermediate language of the CakeML compiler, but results proved at that level map directly to the space cost of the compiler-generated machine code. All of the work described in this paper has been developed in the HOL4 theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alejandro</first_name>
          <last_name>Gómez-Londoño</last_name>
          <affiliation>Chalmers University of Technology, Sweden</affiliation>
          <bio>undefined</bio>
          <person_id>alejandrogomezlondono</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Johannes</first_name>
          <last_name>Åman Pohjola</last_name>
          <affiliation>Data61 at CSIRO, Australia / UNSW, Australia</affiliation>
          <bio>undefined</bio>
          <person_id>johannesamanpohjola</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hira Taqdees</first_name>
          <last_name>Syeda</last_name>
          <affiliation>Chalmers University of Technology, Sweden</affiliation>
          <bio>undefined</bio>
          <person_id>hirataqdeessyeda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Magnus O.</first_name>
          <last_name>Myreen</last_name>
          <affiliation>Chalmers University of Technology, Sweden</affiliation>
          <bio>I did a B.A. in Computer Science at the University of Oxford, tutored by Dr Jeff Sanders. 
I completed my Ph.D. on program verification in 2009 at the University of Cambridge, supervised by Prof. Mike Gordon. My PhD dissertation was selected as the winner of the BCS Distinguished Dissertation Competition 2010. 
In 2012, I became a Royal Society Research Fellow, UK. 
In 2014, I moved to Chalmers where I became a tenured Associate Professor in 2015.</bio>
          <homepage_url>http://www.cse.chalmers.se/~myreen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusomyreen/ccd5e9cd-2811-4ef2-a9f0-3dd7802233ca/small.jpg</picture_url>
          <person_id>magnusomyreen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yong Kiam</first_name>
          <last_name>Tan</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.cmu.edu/~yongkiat/</homepage_url>
          <person_id>yongkiamtan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>60275e1d-95c9-457c-bcf4-d0964110a6b3</slot_id>
      <event_id>9796e9aa-1b8d-46b7-8c85-2c6427f306de</event_id>
      <title>Towards a Formal Foundation of Intermittent Computing</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>10:20</end_time>
      <description>Intermittently powered devices enable new applications in harsh or inaccessible environments, such as space or in-body implants, but also introduce problems in programmability and correctness. Researchers have developed programming models to ensure that programs make progress and do not produce erroneous results due to memory inconsistencies caused by intermittent executions. As the technology has matured, more and more features are added to intermittently powered devices, such as I/O. Prior work has shown that all existing intermittent execution models have problems with repeated device or sensor inputs (RIO). RIOs could leave intermittent executions in an inconsistent state. Such problems and the proliferation of existing intermittent execution models necessitate a formal foundation for intermittent computing. 
In this paper, we formalize intermittent execution models, their correctness properties with respect to memory consistency and inputs, and identify the invariants needed to prove systems correct. We prove equivalence between several existing intermittent systems. To address RIO problems, we define an algorithm for identifying variables affected by RIOs that need to be restored after reboot and prove the algorithm correct. Finally, we implement the algorithm in a novel intermittent runtime system that is correct with respect to input operations and evaluate its performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Milijana</first_name>
          <last_name>Surbatovich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>milijanasurbatovich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Brandon</first_name>
          <last_name>Lucia</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Brandon is a Professor at Carnegie Mellon University working on hardware and software computer systems to answer the question: “How capable can a computing system be, given physical restrictions on its form factor, input power, energy storage, or other resource constraints?” His research has been recognized with 8 best paper awards, the 2019 IEEE TCCA Young Computer Architect Award and the 2015 Bell Labs Prize.</bio>
          <homepage_url>http://brandonlucia.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brandonlucia/e10fc900-d74f-44e7-a793-5e2f21a7dd0b/small.jpg</picture_url>
          <person_id>brandonlucia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Limin</first_name>
          <last_name>Jia</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.andrew.cmu.edu/user/liminjia/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/liminjia/6bc50ee1-2333-4b59-bc4f-3bf74d1e3b64/small.jpg</picture_url>
          <person_id>liminjia</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>94cfe3fe-3ec9-4905-bf1a-a86f598e1f5a</slot_id>
      <event_id>85b0bc7f-a107-41e9-9836-f25f8409f19f</event_id>
      <title>Verifying Replicated Data Types with Typeclass Refinements in Liquid Haskell</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>10:00</end_time>
      <description>This paper presents an extension to Liquid Haskell that facilitates stating and semi-automatically proving properties of typeclasses. Liquid Haskell augments Haskell with \emph{refinement types}—our work allows such types to be attached to typeclass method declarations, and ensures that instance implementations respect these types. The engineering of this extension is a modular interaction between GHC, the Glasgow Haskell Compiler, and Liquid Haskell’s core proof infrastructure. The design sheds light on the interplay between modular proofs and typeclass resolution, which in Haskell is coherent by default (meaning that resolution always selects the same implementation for a particular instantiating type), but in other dependently typed languages is not. 
We demonstrate the utility of our extension by using Liquid Haskell to modularly verify that 34 instances satisfy the laws of five standard typeclasses. 
More substantially, we implement a framework for programming distributed applications based on \emph{replicated data types} (RDTs). We define a typeclass whose Liquid Haskell type captures the mathematical properties RDTs should satisfy; prove in Liquid Haskell that these properties are sufficient to ensure that replicas' states converge despite out-of-order update delivery; implement (and prove correct) several instances of our RDT typeclass; and use them to build two realistic applications, a multi-user calendar event planner and a collaborative text editor.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yiyun</first_name>
          <last_name>Liu</last_name>
          <affiliation>University of Maryland at College Park, USA</affiliation>
          <bio>undefined</bio>
          <person_id>yiyunliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>James</first_name>
          <last_name>Parker</last_name>
          <affiliation>University of Maryland at College Park, USA</affiliation>
          <bio>undefined</bio>
          <person_id>jamesparker</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Redmond</last_name>
          <affiliation>University of California at Santa Cruz, USA</affiliation>
          <bio>undefined</bio>
          <person_id>patrickredmond</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lindsey</first_name>
          <last_name>Kuper</last_name>
          <affiliation>University of California at Santa Cruz, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://users.soe.ucsc.edu/~lkuper/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lindseykuper/f5b1f248-82e4-45ec-ab90-1d543b02d204/small.jpg</picture_url>
          <person_id>lindseykuper</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Hicks</last_name>
          <affiliation>University of Maryland at College Park, USA</affiliation>
          <bio>Michael Hicks is a Professor in the Computer Science department and UMIACS at the University of Maryland, where he co-directs the laboratory for Programming Languages research (PLUM); he is the former Director of the Maryland Cybersecurity Center (MC2) and the Past Chair of ACM SIGPLAN. 
His research focuses on using programming languages and analyses to improve the security, reliability, and availability of software. He is perhaps best known for his work exploring dynamic software updating, a technique with which software can be updated without shutting it down. He has explored the design of new programming languages and analysis tools for helping programmers find bugs and software vulnerabilities, and for identifying suspicious or incorrect program executions. He was worked has combined ideas from PL and cryptography, e.g., to ensure privacy preserving computations. He also leads the development of a new security-oriented programming contest, “build-it, break-it, fix-it,” which has been offered to the public and to students in his Coursera class on software security. He has recently begun to explore programming languages for quantum computation. 
He is the editor of the Programming Languages Enthusiast blog and Tweets at @michael_w_hicks.</bio>
          <homepage_url>http://www.cs.umd.edu/~mwh/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelhicks/aa64e3c6-3516-4e13-affe-77bc32c40565/small.jpg</picture_url>
          <person_id>michaelhicks</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Niki</first_name>
          <last_name>Vazou</last_name>
          <affiliation>IMDEA Software Institute, Spain</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://nikivazou.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nikivazou/8cc6ddec-154b-47e9-b40d-c66e78476391/small.jpg</picture_url>
          <person_id>nikivazou</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d7cde522-7c12-4ac2-9a7e-b61bb2e11d21</slot_id>
      <event_id>90cce21d-a854-4f50-b7f1-09a1af23e318</event_id>
      <title>Automatic and Efficient Variability-Aware Lifting of Functional Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>09:20</end_time>
      <description>A software analysis is a computer program that takes some representation of a software product as input and produces some useful information about that product as output. A software product line encompasses \emph{many} software product variants, and thus existing analyses can be applied to each of the product variations individually, but not to the entire product line as a whole. Enumerating all product variants and analyzing them one by one is usually intractable due to the combinatorial explosion of the number of product variants with respect to product line features. Several software analyses (e.g., type checkers, model checkers, data flow analyses) have been redesigned/re-implemented to support variability. This usually requires a lot of time and effort, and the variability-aware version of the analysis might have new errors/bugs that do not exist in the original one. 
Given an analysis program written in a functional language based on PCF, in this paper we present two approaches to transforming (lifting) it into a semantically equivalent variability-aware analysis. A light-weight approach (referred to as \emph{shallow lifting}) wraps the analysis program into a variability-aware version, exploring all combinations of its input arguments. Deep lifting, on the other hand, is a program rewriting mechanism where the syntactic constructs of the input program are rewritten into their variability-aware counterparts. Compositionally this results in an efficient program semantically equivalent to the input program, modulo variability. 
We present the correctness criteria for functional program lifting, together with correctness proof sketches of shallow lifting. We evaluate our approach on a set of program analyses applied to the BusyBox C-language product line.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ramy</first_name>
          <last_name>Shahin</last_name>
          <affiliation>University of Toronto, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>ramyshahin1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marsha</first_name>
          <last_name>Chechik</last_name>
          <affiliation>University of Toronto, Canada</affiliation>
          <bio>Marsha Chechik is Professor in the Department of Computer Science at the University of Toronto. She received her Ph.D. from the University of Maryland in 1996. Prof. Chechik’s research interests are in the application of formal methods to improve the quality of software. She has authored numerous papers in formal methods, software specification and verification, computer safety and security and requirements engineering. In 2002-2003, Prof. Chechik was a visiting scientist at Lucent Technologies in Murray Hill, NY and at Imperial College, London UK, and in 2013 – at Stonybrook University. She is a member of IFIP WG 2.9 on Requirements Engineering and an Associate Editor in Chief of Journal on Software and Systems Modeling. She is has been an associate editor of IEEE Transactions on Software Engineering 2003-2007, 2010-2013. She regularly serves on program committees of international conferences in the areas of software engineering and automated verification. Marsha Chechik has been Program Committee Co-Chair of the 2018 International Conference in Software Engineering (ICSE18), 2016 International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS’16), the 2016 Working Conference on Verified Software: Theories, Tools, and Experiments (VSTTE16), the 2014 International Conference on Automated Software Engineering (ASE’14), the 2008 International Conference on Concurrency Theory (CONCUR’08), the 2008 International Conference on Computer Science and Software Engineering (CASCON’08), and the 2009 International Conference on Formal Aspects of Software Engineering (FASE’09). She will be PC Co-Chair of ESEC/FSE’2021. She is a Member of ACM SIGSOFT and the IEEE Computer Society.</bio>
          <homepage_url>http://www.cs.toronto.edu/~chechik</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/marshachechik/779292d1-7e1c-4bb1-9f30-e36ee949bd9a/small.jpg</picture_url>
          <person_id>marshachechik</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d36f76a9-54e2-4d4b-ae3f-bcb6e4c04529</subevent_id>
    <title>SPLASH OOPSLA: F-4A</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>b8e83015-ac42-46fb-a8c0-471c5e08e174</slot_id>
      <title>Session: SPLASH OOPSLA - F-4A</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Louis</first_name>
          <last_name>Mandel</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/person/us-lmandel</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/louismandel/17cd9456-7532-4cd8-a35e-47b280338d8e/small.jpg</picture_url>
          <person_id>louismandel</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Ruben</first_name>
          <last_name>Martins</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Ruben Martins is a Systems Scientist at the Carnegie Mellon University. Prior to joining CMU, he was a postdoctoral researcher at UT Austin where he pushed the frontiers of program synthesis and security with constraint solving. Before UT Austin, he was a postdoctoral researcher at the University of Oxford, UK where he worked on CBMC for software verification. He received his PhD with honors from the University of Lisbon, Portugal in 2013. His research aims to improve constraint solvers and broaden their applicability in program analysis, synthesis, and security. Dr. Martins has developed several award winning solvers and has consistently improved the state-of-the-art in MaxSAT solving. He is currently the main developer of Open-WBO: an open source MaxSAT solver that won several awards in the MaxSAT competitions.</bio>
          <homepage_url>https://sat-group.github.io/ruben/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rubenmartins/6cfee429-6785-4395-bcf6-ddb6dd674d58/small.jpg</picture_url>
          <person_id>rubenmartins</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>56ef819d-27b5-4731-a6eb-0b248d0c915f</slot_id>
      <event_id>b9adaa2c-cdbd-450c-bb15-daa638849bd3</event_id>
      <title>Digging for Fold: Synthesis-Aided API Discovery for Haskell</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>14:20</end_time>
      <description>We present Hoogle+, a web-based API discovery tool for Haskell. A Hoogle+ user can specify a programming task using either a type, a set of input-output tests, or both. Given a specification, the tool returns a list of matching programs composed from functions in popular Haskell libraries, and annotated with automatically-generated examples of their behavior. These features of Hoogle+ are powered by three novel techniques. First, to enable efficient type-directed synthesis from tests only, we develop an algorithm that infers likely type specifications from tests. Second, to return high-quality programs even with ambiguous specifications, we develop a technique that automatically eliminates meaningless and repetitive synthesis results. Finally, we show how to extend this elimination technique to automatically generate informative inputs that can be used to demonstrate program behavior to the user. To evaluate the effectiveness of Hoogle+ compared with traditional API search techniques, we perform a user study with 30 participants of varying Haskell proficiency. The study shows that programmers equipped with Hoogle+ generally solve tasks faster and were able to solve 50% more tasks overall.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael B.</first_name>
          <last_name>James</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>Michael James is a 3rd year PhD student at University of California, San Diego studying programming languages and program synthesis under Nadia Polikarpova. He worked as a software engineer for three years before starting his degree. His experience has guided him to research topics that will ultimately flow back to help other engineers and make programming easier for all.</bio>
          <homepage_url>http://michaelbjames.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelbjames/8360df32-2f8d-4f7c-99c1-523f1f811bec/small.jpg</picture_url>
          <person_id>michaelbjames</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zheng</first_name>
          <last_name>Guo</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <person_id>zhengguo1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziteng</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wzt.me/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zitengwang/bf349a37-8935-4553-bcf7-c78094e369c5/small.jpg</picture_url>
          <person_id>zitengwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Shivani</first_name>
          <last_name>Doshi</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>Current Cornell Tech MEng Student, UC San Diego 2020 BS in CS graduate.</bio>
          <homepage_url>https://shivanidoshi26.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shivanidoshi/a3bdf8b0-e4df-4be6-8c43-1cd1aee38f69/small.jpg</picture_url>
          <person_id>shivanidoshi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Ranjit</first_name>
          <last_name>Jhala</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>Nom nom. Chomp. Burp.</bio>
          <homepage_url>http://ranjitjhala.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ranjitjhala/afbdab69-ed23-4022-b7a4-2c57128f20ec/small.jpg</picture_url>
          <person_id>ranjitjhala</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>82ae8c46-b73f-4d4c-8c9c-5b641325edb7</slot_id>
      <event_id>535250d1-14d9-4fb4-b418-2ad1ae511d91</event_id>
      <title>Scaling Exact Inference for Discrete Probabilistic Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>14:00</end_time>
      <description>Probabilistic programming languages (PPLs) are an expressive means of representing and reasoning about probabilistic models. The computational challenge of probabilistic inference remains the primary roadblock for applying PPLs in practice. Inference is fundamentally hard, so there is no one-size-fits all solution. In this work, we target scalable inference for an important class of probabilistic programs: those whose probability distributions are discrete. Discrete distributions are common in many fields, including text analysis, network verification, artificial intelligence, and graph analysis, but they prove to be challenging for existing PPLs. 
We develop a domain-specific probabilistic programming language called Dice that features a new approach to exact discrete probabilistic program inference. Dice exploits program structure in order to factorize inference, enabling us to perform exact inference on probabilistic programs with hundreds of thousands of random variables. Our key technical contribution is a new reduction from discrete probabilistic programs to weighted model counting (WMC). This reduction separates the structure of the distribution from its parameters, enabling logical reasoning tools to exploit that structure for probabilistic inference. We (1) show how to compositionally reduce Dice inference to WMC, (2) prove this compilation correct with respect to a denotational semantics, (3) empirically demonstrate the performance benefits over prior approaches, and (4) analyze the types of structure that allow Dice to scale to large probabilistic programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Steven</first_name>
          <last_name>Holtzen</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am a PhD. student at U.C.L.A., co-advised by Guy Van den Broeck and Todd Millstein.</bio>
          <homepage_url>http://web.cs.ucla.edu/~sholtzen</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stevenholtzen/db2263a6-7a88-4167-9d73-86a4d4b97fc9/small.jpg</picture_url>
          <person_id>stevenholtzen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guy</first_name>
          <last_name>Van den Broeck</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am an Associate Professor and Samueli Fellow at UCLA, in the Computer Science Department. My research interests are in Machine Learning (Statistical Relational Learning), Knowledge Representation and Reasoning (Graphical Models, Lifted Probabilistic Inference), Applications of Probabilistic Reasoning and Learning (Probabilistic Programming, Probabilistic Databases), and Artificial Intelligence in general. I previously was a postdoctoral researcher at UCLA’s Automated Reasoning lab and KU Leuven’s Declarative Languages and Artificial Intelligence lab.</bio>
          <homepage_url>http://web.cs.ucla.edu/~guyvdb/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guyvandenbroeck/4c8a474f-a124-4434-a370-43b4892bbe2c/small.jpg</picture_url>
          <person_id>guyvandenbroeck</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Todd</first_name>
          <last_name>Millstein</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am a Professor in the Computer Science Department at the University of California, Los Angeles (UCLA). 
I was the Program Chair for OOPSLA 2014.</bio>
          <homepage_url>http://www.cs.ucla.edu/~todd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/toddmillstein/03692d64-e4ad-4fb1-a2b0-9271ce27715c/small.jpg</picture_url>
          <person_id>toddmillstein</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e1fbf6c2-b392-4b2c-9690-cfc1f9dae955</slot_id>
      <event_id>e202e9a0-8e64-4364-82a0-a1d2b41e4b74</event_id>
      <title>Interactive Synthesis of Temporal Specifications from Examples and Natural Language</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>13:40</end_time>
      <description>Motivated by applications in robotics, we consider the task of synthesizing linear temporal logic (LTL) specifications based on examples and natural language descriptions. While LTL is a flexible, expressive, and unambiguous language to describe robotic tasks, it is often challenging for non-expert users. In this paper, we present an interactive method for synthesizing LTL specifications from a single example trace and a natural language description. The interaction is limited to showing a small number of behavioral examples to the user who decides whether or not they exhibit the original intent. Our approach generates candidate LTL specifications and distinguishing examples using an encoding into optimization modulo theories problems. Additionally, we use a grammar extension mechanism and a semantic parser to generalize synthesized specifications to parametric task descriptions for subsequent use. Our implementation in the tool LtlTalk starts with a domain-specific language that maps to a fragment of LTL and expands it through example-based user interactions, thus enabling natural language-like robot programming, while maintaining the expressive power and precision of a formal language. Our experiments show that the synthesis method is precise, quick, and asks only a few questions to the users, and we demonstrate in a case study how LtlTalk generalizes from the synthesized tasks to other, yet unseen, tasks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Gavran</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>ivangavran</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eva</first_name>
          <last_name>Darulova</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mpi-sws.org/~eva/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/evadarulova/0d98744b-ec94-4a27-b1c0-0d728d54bdb7/small.jpg</picture_url>
          <person_id>evadarulova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rupak</first_name>
          <last_name>Majumdar</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~rupak</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rupakmajumdar/3289b197-9f9a-4880-94c5-d9cf6d764bb1/small.jpg</picture_url>
          <person_id>rupakmajumdar</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e6143390-4919-4dfa-aa51-f1f188bebfd5</slot_id>
      <event_id>74c28b24-629b-4e90-837d-28d2c9d362d6</event_id>
      <title>A Modular Cost Analysis for Probabilistic Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>13:20</end_time>
      <description>We present a novel methodology for the automated resource analysis of non-deterministic, probabilistic imperative programs, which gives rise to a \emph{modular approach}. Program fragments are analysed in full independence. Moreover, the established results allow us to incorporate sampling from \emph{dynamic distributions}, making our analysis applicable to a wider class of examples, for example the \emph{Coupon Collector's problem}. 
We have implemented our contributions in the tool \ecoimp, exploiting a constraint-solver over iterative refineable cost functions facilitated by off-the-shelf SMT solvers. We provide ample experimental evidence of the prototype's algorithmic power. %MA: downscale superiority. Our experiments show that our tool runs typically at least one \emph{order of magnitude faster} than comparable tools. On more involved examples, it may even be the case that execution times of seconds become milliseconds. At the same time we retain the precision of existing tools. 
The extensions in applicability and the greater efficiency of our prototype, yield scalability of sorts. This effects into a wider class of examples, whose expected cost analysis can be thus be performed fully automatically.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Avanzini</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-sop.inria.fr/members/Martin.Avanzini/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/martinavanzini1/6a7bba4f-db11-478c-9d7c-2dabe34811bc/small.jpg</picture_url>
          <person_id>martinavanzini1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Georg</first_name>
          <last_name>Moser</last_name>
          <affiliation>University of Innsbruck, Austria</affiliation>
          <bio>undefined</bio>
          <person_id>georgmoser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Schaper</last_name>
          <affiliation>University of Innsbruck, Austria</affiliation>
          <bio>undefined</bio>
          <person_id>michaelschaper1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0d72e49a-00b5-4f91-8e57-ab80f273669c</subevent_id>
    <title>SPLASH OOPSLA: T-5</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>a883fab3-e389-4ac0-973b-190d6c540ff1</slot_id>
      <title>Session: SPLASH OOPSLA - T-5</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Sorensen</last_name>
          <affiliation>University of California at Santa Cruz, USA</affiliation>
          <bio>I am a Post Doc researcher at Princeton University working in Margaret Martonosi’s group. My research interests are in concurrency: programming, modeling, testing, and architecture. In particular, I am interested in exploring new heterogeneous architectures and how programming models can enable development of secure and efficient applications. 
I received my PhD from the Multicore Programming Group at Imperial College London supervised by Alastair Donaldson. Previously, I worked with Ganesh Gopalakrishnan and Zvonimir Rakamaric at University of Utah.</bio>
          <homepage_url>https://www.cs.princeton.edu/~ts20/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tylersorensen1/e6c9c5cc-65e1-4a42-87c2-5e4a7d347b0d/small.jpg</picture_url>
          <person_id>tylersorensen1</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Raffi</first_name>
          <last_name>Khatchadourian</last_name>
          <affiliation>City University of New York (CUNY) Hunter College</affiliation>
          <bio>I am an Assistant Professor in the Department of Computer Science at Hunter College and the Graduate Center of the City University of New York (CUNY). My research is centered on techniques for automated software evolution, particularly those related to automated refactoring and source code recommendation systems. My goal is to ease the burden associated with correctly and efficiently evolving large and complex software by providing automated tools that can be easily used by developers. I am also interested in the automated analysis of Object-Oriented and Aspect-Oriented programs. 
I received my MS and Ph.D. degrees in Computer Science from Ohio State University and my BS degree in Computer Science from Monmouth University in New Jersey. Prior to joining CUNY, I was a Software Engineer at Apple, Inc. in Cupertino, California, where I worked on Digital Rights Management (DRM) for iTunes, iBooks, and the App store. I also developed distributed software that tested various features of iPhones, iPads, and iPods. You may also find more information about me by visiting my CUNY Academic Commons profile, my vita, GitHub, and my blog (you can subscribe for updates here).</bio>
          <homepage_url>http://cs.hunter.cuny.edu/~Raffi.Khatchadourian99</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/raffikhatchadourian/5c884f46-e4aa-4dc5-b581-2e37f77d320a/small.jpg</picture_url>
          <person_id>raffikhatchadourian</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>923c0e0f-fcf2-435b-ac8f-aafaaebe0611</slot_id>
      <event_id>b7403f22-9ce1-4712-b204-3d56213b53b9</event_id>
      <title>Regex Matching with Counting-Set Automata</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>16:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>16:20</end_time>
      <description>We propose a solution to the problem of efficient matching regular expressions (regexes) with bounded repetition, such as $\texttt{(ab){1,100}}$, using deterministic automata. For this, we introduce novel \emph{counting-set automata (CsAs)}, automata with registers that can hold sets of bounded integers and can be manipulated by a limited portfolio of constant-time operations. We present an algorithm that compiles a large sub-class of regexes to deterministic CsAs. This includes (1) a novel Antimirov-style translation of regexes with counting to \emph{counting automata (CAs)}, nondeterministic automata with bounded counters, and (2) our main technical contribution, a determinization of CAs that outputs CsAs. The main advantage of this workflow is that \emph{the size of the produced CsAs does not depend on the repetition bounds used in the regex} (while the size of the DFA is exponential to them). Our experimental results confirm that deterministic CsAs produced from practical regexes with repetition are indeed vastly smaller than the corresponding DFAs. More importantly, our prototype matcher based on CsA simulation handles practical regexes with repetition regardless of sizes of counter bounds. It easily copes with regexes with repetition where state-of-the-art matchers struggle.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lenka</first_name>
          <last_name>Turoňová</last_name>
          <affiliation>Brno University of Technology, Czechia</affiliation>
          <bio>undefined</bio>
          <person_id>lenkatoronova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lukáš</first_name>
          <last_name>Holík</last_name>
          <affiliation>Brno University of Technology, Czechia</affiliation>
          <bio>undefined</bio>
          <person_id>lukasholik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ondrej</first_name>
          <last_name>Lengal</last_name>
          <affiliation>Brno University of Technology, Czechia</affiliation>
          <bio>Ph.D. (2015) Brno University of Technology</bio>
          <homepage_url>http://www.fit.vutbr.cz/~lengal</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlengal/3f99d935-777e-4b43-9494-5cfc0fe8894b/small.jpg</picture_url>
          <person_id>ondrejlengal</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Olli</first_name>
          <last_name>Saarikivi</last_name>
          <affiliation>Microsoft Research, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/ollisaarikivi2/3e6d3eb8-2ea9-456c-9c3d-76fe37bd855c/small.jpg</picture_url>
          <person_id>ollisaarikivi2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Margus</first_name>
          <last_name>Veanes</last_name>
          <affiliation>Microsoft Research, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/margusveanes/a5174253-0401-46f7-aff1-e92a3a3ace77/small.jpg</picture_url>
          <person_id>margusveanes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tomas</first_name>
          <last_name>Vojnar</last_name>
          <affiliation>Brno University of Technology, Czechia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fit.vutbr.cz/~vojnar</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomasvojnar/6b1ea9ee-acf7-413d-be4d-431c460af426/small.jpg</picture_url>
          <person_id>tomasvojnar</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>af6e8f92-5439-432c-b032-05229e644fa4</slot_id>
      <event_id>d0b39515-659e-4855-a1b2-516ee32b0539</event_id>
      <title>Knowing When to Ask: Sound Scheduling of Name Resolution in Type Checkers Derived from Declarative Specifications</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>15:40</end_time>
      <description>There is a large gap between the specification of type systems and the implementation of their type checkers, which impedes reasoning about the soundness of the type checker with respect to the specification. A vision to close this gap is to automatically obtain type checkers from declarative programming language specifications. This moves the burden of proving correctness from a case-by-case basis for concrete languages to a single correctness proof for the specification language. This vision is obstructed by an aspect common to all programming languages: name resolution. Naming and scoping are pervasive and complex aspects of the static semantics of programming languages. Implementations of type checkers for languages with name binding features such as modules, imports, classes, and inheritance interleave collection of binding information (i.e., declarations, scoping structure, and imports) and querying that information. This requires scheduling those two aspects in such a way that query answers are stable—i.e., they are computed only after all relevant binding structure has been collected. Type checkers for concrete languages accomplish stability using language-specific knowledge about the type system. 
In this paper we give a language-independent characterization of necessary and sufficient conditions to guarantee stability of name and type queries during type checking in terms of \emph{critical edges in an incomplete scope graph}. We use critical edges to give a formal small-step operational semantics to a declarative specification language for type systems, that achieves soundness by delaying queries that may depend on missing information. This yields type checkers for the specified languages that are sound by construction—i.e., they schedule queries so that the answers are stable, and only accept programs that are name- and type-correct according to the declarative language specification. We implement this approach, and evaluate it against specifications of a small module and record language, as well as subsets of Java and Scala.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Arjen</first_name>
          <last_name>Rouvoet</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ajrouvoet.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjenrouvoet/72c0e303-43d5-4252-a170-5b61600fac4d/small.jpg</picture_url>
          <person_id>arjenrouvoet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hendrik</first_name>
          <last_name>van Antwerpen</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hendrik.van-antwerpen.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hendrikvanantwerpen/2d3f530b-7183-483e-b3b6-80dd4159a4bd/small.jpg</picture_url>
          <person_id>hendrikvanantwerpen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Casper</first_name>
          <last_name>Bach Poulsen</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://casperbp.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/casperbachpoulsen/2cddd6a9-d920-4f73-9fcf-f4d9462eb0e3/small.jpg</picture_url>
          <person_id>casperbachpoulsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Robbert</first_name>
          <last_name>Krebbers</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://robbertkrebbers.nl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/robbertkrebbers/7c0562b5-da08-4f27-aa28-918e54dcaf3d/small.jpg</picture_url>
          <person_id>robbertkrebbers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science at Delft University of Technology. He received a master’s and doctorate in computer science from the University of Amsterdam in 1993 and 1997, respectively. Previously he served as postdoc at the Oregon Graduate Institute, as Assistant Professor at Utrecht University, and as Associate Professor at TU Delft. 
His research interests include programming languages, software language engineering, domain-specific programming languages, program transformation, syntax definition, and parsing. With his students he has designed and implemented the Spoofax language workbench, as well as many domain-specific languages, including DSLs for syntax definition (SDF2, SDF3), program transformation (Stratego), static semantics (NaBL, Statix), dynamic semantics (DynSem), software deployment (Nix), web application development (WebDSL), and mobile phone applications (mobl). In the language designer’s workbench project he is pursuing high-level declarative language definition that serves for language implementation and verification.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bccbe5dd-a2fc-4efc-a764-365a9a389151</slot_id>
      <event_id>5566f7eb-c8ea-4651-9ed7-30715f447f33</event_id>
      <title>Actor Concurrency Bugs: A Comprehensive Study on Symptoms, Root Causes, API Usages, and Differences</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>15:20</end_time>
      <description>Actor concurrency is becoming increasingly important in the development of real-world software systems. Although actor concurrency may be less susceptible to some multithreaded concurrency bugs, such as low-level data races and deadlocks, it comes with its own bugs that may be different. However, the fundamental characteristics of actor concurrency bugs, including their symptoms, root causes, API usages, examples, and differences when they come from different sources are still largely unknown. Actor software development can significantly benefit from a comprehensive qualitative and quantitative understanding of these characteristics, which is the focus of this work, to foster better API documentation, development practices, testing, debugging, repairing, and verification frameworks. To conduct this study, we take the following major steps. First, we construct a set of 186 real-world Akka actor bugs from Stack Overflow and GitHub via manual analysis of 3,924 Stack Overflow questions, answers, and comments and 3,315 GitHub commits, messages, original and modified code snippets, issues, and pull requests. Second, we manually study these actor bugs and their fixes to understand and classify their symptoms, root causes, and API usages. Third, we study the differences between the commonalities and distributions of symptoms, root causes, and API usages of our Stack Overflow and GitHub actor bugs. Fourth, we discuss real-world examples of our actor bugs with these symptoms and root causes. Finally, we investigate the relation of our findings with those of previous work and discuss their implications. A few findings of our study are: (1) symptoms of our actor bugs can be classified into five categories, with Error as the most common symptom and Incorrect Exceptions as the least common, (2) root causes of our actor bugs can be classified into ten categories, with Logic as the most common root cause and Untyped Communication as the least common, (3) a small number of Akka API packages are responsible for most of API usages by our actor bugs, and (4) our Stack Overflow and GitHub actor bugs can differ significantly in commonalities and distributions of their symptoms, root causes, and API usages. While some of our findings agree with those of previous work, others sharply contrast.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mehdi</first_name>
          <last_name>Bagherzadeh</last_name>
          <affiliation>Oakland University, USA</affiliation>
          <bio>Assistant Professor, Department of Computer Science and Engineering</bio>
          <homepage_url>https://mbagherz.bitbucket.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mehdibagherzadeh/95dc6f53-51a0-4bf1-b822-7bbe8c4d223a/small.jpg</picture_url>
          <person_id>mehdibagherzadeh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nicholas</first_name>
          <last_name>Fireman</last_name>
          <affiliation>Oakland University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>nicholasfireman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anas</first_name>
          <last_name>Shawesh</last_name>
          <affiliation>Oakland University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>anasshawesh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Raffi</first_name>
          <last_name>Khatchadourian</last_name>
          <affiliation>City University of New York (CUNY) Hunter College</affiliation>
          <bio>I am an Assistant Professor in the Department of Computer Science at Hunter College and the Graduate Center of the City University of New York (CUNY). My research is centered on techniques for automated software evolution, particularly those related to automated refactoring and source code recommendation systems. My goal is to ease the burden associated with correctly and efficiently evolving large and complex software by providing automated tools that can be easily used by developers. I am also interested in the automated analysis of Object-Oriented and Aspect-Oriented programs. 
I received my MS and Ph.D. degrees in Computer Science from Ohio State University and my BS degree in Computer Science from Monmouth University in New Jersey. Prior to joining CUNY, I was a Software Engineer at Apple, Inc. in Cupertino, California, where I worked on Digital Rights Management (DRM) for iTunes, iBooks, and the App store. I also developed distributed software that tested various features of iPhones, iPads, and iPods. You may also find more information about me by visiting my CUNY Academic Commons profile, my vita, GitHub, and my blog (you can subscribe for updates here).</bio>
          <homepage_url>http://cs.hunter.cuny.edu/~Raffi.Khatchadourian99</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/raffikhatchadourian/5c884f46-e4aa-4dc5-b581-2e37f77d320a/small.jpg</picture_url>
          <person_id>raffikhatchadourian</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c2d8b749-d9ec-49af-a159-c056f705cc51</slot_id>
      <event_id>52f9bfff-ac06-47f4-98ba-4a5085ecbf7b</event_id>
      <title>Fuzzing Channel-Based Concurrency Runtimes using Types and Effects</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>16:00</end_time>
      <description>Modern programming languages support concurrent programming based on channels and processes. Channels enable synchronous and asynchronous message-passing between independent light-weight processes making it easy to express common concurrency patterns. The implementation of channels and processes in compilers and language runtimes is a difficult task that relies heavily on traditional and error-prone low-level concurrency primitives, raising concerns about correctness and reliability. In this paper, we present an automatic program generation technique to test such programming language implementations. We define a type and effect system for programs that communicate over channels and where every execution is guaranteed to eventually terminate. We can generate and run such programs, and if a program fails to terminate, we have found a bug in the programming language implementation. We implement such an automatic program generator and apply it to Go, Kotlin, Crystal, and Flix. We find two new bugs in Flix, and reproduce two bugs; one in Crystal and one in Kotlin.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Quentin</first_name>
          <last_name>Stiévenart</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/~qstieven</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/quentinstievenart/7d195a5f-4ea9-4d26-a55f-2b8d1c5853b8/small.jpg</picture_url>
          <person_id>quentinstievenart</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8a0672f8-701c-47f6-bb2c-44dd10c7aa56</subevent_id>
    <title>SPLASH OOPSLA: W-3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>4b2d9525-6290-41a7-b659-49f6778277ec</slot_id>
      <title>Session: SPLASH OOPSLA - W-3</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science at Delft University of Technology. He received a master’s and doctorate in computer science from the University of Amsterdam in 1993 and 1997, respectively. Previously he served as postdoc at the Oregon Graduate Institute, as Assistant Professor at Utrecht University, and as Associate Professor at TU Delft. 
His research interests include programming languages, software language engineering, domain-specific programming languages, program transformation, syntax definition, and parsing. With his students he has designed and implemented the Spoofax language workbench, as well as many domain-specific languages, including DSLs for syntax definition (SDF2, SDF3), program transformation (Stratego), static semantics (NaBL, Statix), dynamic semantics (DynSem), software deployment (Nix), web application development (WebDSL), and mobile phone applications (mobl). In the language designer’s workbench project he is pursuing high-level declarative language definition that serves for language implementation and verification.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Dan</first_name>
          <last_name>Barowy</last_name>
          <affiliation>Williams College</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.williams.edu/~dbarowy/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/danbarowy/68828093-d4f3-421f-a005-a407e166c9a3/small.jpg</picture_url>
          <person_id>danbarowy</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1f83748d-3cd8-4864-8fdc-fdaf37d2dd8d</slot_id>
      <event_id>9b43b518-879b-4aa7-b841-9f12dc9bcf2a</event_id>
      <title>Automated Policy Synthesis for System Call Sandboxing</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>12:20</end_time>
      <description>System call whitelisting is a powerful sandboxing approach that can significantly reduce the capabilities of an attacker if an application is compromised. Given a \emph{policy} that specifies which system calls can be invoked with what arguments, a sandboxing framework terminates any execution that violates the policy. While this mechanism greatly reduces the attack surface of a system, manually constructing these policies is time-consuming and error-prone. As a result, many applications —including those that take untrusted user input— opt not to use a system call sandbox. 
Motivated by this problem, we propose a technique for automatically constructing system call whitelisting policies for a given application and policy DSL. Our method combines static code analysis and program synthesis to construct \emph{sound and precise policies} that never erroneously terminate the application, while restricting the program's system call usage as much as possible. We have implemented our approach in a tool called \textsc{Abhaya}\xspace and experimentally evaluate it 493 Linux and OpenBSD applications by automatically synthesizing {Seccomp-bpf}\xspace and \text{Pledge}\xspace policies. Our experimental results indicate that \textsc{Abhaya}\xspace can efficiently generate useful and precise sandboxes for real-world applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shankara</first_name>
          <last_name>Pailoor</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>shankarapailoor</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xinyu</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Michigan, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://web.eecs.umich.edu/~xwangsd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xinyuwang/ccbe37b1-293c-4205-8386-295e20bce0d7/small.jpg</picture_url>
          <person_id>xinyuwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hovav</first_name>
          <last_name>Shacham</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>hovavshacham</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Isil</first_name>
          <last_name>Dillig</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>Isil Dillig is an Associate Professor of Computer Science at the University of Texas at Austin where she leads the UToPiA research group. Her main research area is programming languages, with a specific emphasis on static analysis, verification, and program synthesis. The techniques developed by her group aim to make software systems more reliable, secure, and easier to build in a robust way. Dr. Dillig is a Sloan Fellow and a recipient of the NSF CAREER award. She obtained all her degrees (BS, MS, and PhD) from Stanford University.</bio>
          <homepage_url>http://www.cs.utexas.edu/~isil/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/isildillig/e4fa3855-0ae4-4638-84e3-1fe224e64e3f/small.jpg</picture_url>
          <person_id>isildillig</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>43708714-1490-4645-bb2d-780e47d35e71</slot_id>
      <event_id>dc2c4321-bace-402b-a2d9-f08a7830e7e5</event_id>
      <title>Random Testing for C and C++ Compilers with YARPGen</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>11:40</end_time>
      <description>Compilers should not crash and they should not miscompile applications. Random testing is an effective method for finding compiler bugs that have escaped other kinds of testing. This paper presents Yet Another Random Program Generator (YARPGen), a random test-case generator for C and C++ that we used to find and report more than 220 bugs in GCC, LLVM, and the Intel® C++ Compiler. Our research contributions include a method for generating expressive programs that avoid undefined behavior without using dynamic checks, and generation policies, a mechanism for increasing diversity of generated code and for triggering more optimizations. Generation policies decrease the testing time to find hard-to-trigger compiler bugs and, for the kinds of scalar optimizations YARPGen was designed to stress-test, increase the number of times these optimizations are applied by the compiler by an average of 20% for LLVM and 40% for GCC. We also created tools for automating most of the common tasks related to compiler fuzzing; these tools are also useful for fuzzers other than ours.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vsevolod</first_name>
          <last_name>Livinskii</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
          <person_id>vsevolodlivinskii</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dmitry</first_name>
          <last_name>Babokin</last_name>
          <affiliation>Intel Corporation, USA</affiliation>
          <bio>undefined</bio>
          <person_id>dmitrybabokin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>John</first_name>
          <last_name>Regehr</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.utah.edu/~regehr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnregehr/2cb23ab0-042a-487a-a859-cbd3147a46a7/small.jpg</picture_url>
          <person_id>johnregehr</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>514b9f20-75a0-4ee0-8075-198a32c41c7f</slot_id>
      <event_id>a67c5220-155d-4d8b-af2a-ba2543bafbfa</event_id>
      <title>Dynamic Dispatch of Context-Sensitive Optimizations</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>12:00</end_time>
      <description>Academia has spent much effort into making context-sensitive {\em analyses} practical, with great profit. However, the implementation of context-sensitive {\em optimizations}, in contrast to analyses, is still not practical, due to code-size explosion. This growth happens because current technology requires the cloning of full paths in the Calling Context Tree. In this paper, we present a solution to this problem. We combine finite state machines and dynamic dispatching to allow fully context-sensitive specialization while cloning only functions that are effectively optimized. This technique makes it possible to apply very liberal optimizations, such as context-sensitive constant propagation, in large programs—something that could not have been easily done before. We demonstrate the viability of our idea by formalizing it in Prolog, and implementing it in LLVM. As a proof of concept, we have used our state machines to implement context-sensitive constant propagation in LLVM. The binaries produced by traditional full cloning are 2.63 times larger than the binaries that we generate with our state machines. When applied on Mozilla Firefox, our optimization increases binary size from 7.2MB to 9.2MB. Full cloning, in contrast, yields a binary of 34MB.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gabriel</first_name>
          <last_name>Poesia</last_name>
          <affiliation>Federal University of Minas Gerais, Brazil</affiliation>
          <bio>undefined</bio>
          <person_id>gabrielpoesia1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fernando Magno Quintão</first_name>
          <last_name>Pereira</last_name>
          <affiliation>Federal University of Minas Gerais, Brazil</affiliation>
          <bio>Fernando got his Ph.D at UCLA in 2008, under the supervision of Jens Palsberg. He is currently an assistant professor at the Universidade Federal de Minas Gerais, Brazil. His main research interest are in code generation, compiler optimizations and static program analyses.</bio>
          <homepage_url>http://homepages.dcc.ufmg.br/~fernando/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/fernandomagnoquintaopereira/8f86b14f-fbc3-49a4-9f4f-1a8216564d39/small.jpg</picture_url>
          <person_id>fernandomagnoquintaopereira</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9eb7a250-a334-400d-b204-0ec814e48a4c</slot_id>
      <event_id>36a05e0f-c662-4f1b-b7fa-748674279502</event_id>
      <title>Build Scripts with Perfect Dependencies</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>11:20</end_time>
      <description>Build scripts for most build systems describe the actions to run, and the dependencies between those actions - but often build scripts get those dependencies wrong. Most build scripts have both too few dependencies (leading to incorrect build outputs) and too many dependencies (leading to excessive rebuilds and reduced parallelism). Any programmer who has wondered why a small change led to excess compilation, or who resorted to a clean step, has suffered the ill effects of incorrect dependency specification. We outline a build system where dependencies are not specified, but instead captured by tracing execution. The consequence is that dependencies are always correct by construction and build scripts are easier to write. The simplest implementation of our approach would lose parallelism, but we are able to recover parallelism using speculation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sarah</first_name>
          <last_name>Spall</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>sarahspall</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Neil</first_name>
          <last_name>Mitchell</last_name>
          <affiliation>Facebook, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ndmitchell.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/neilmitchell/bcccf5bd-0c3b-4e0e-90c9-ef73780b976c/small.jpg</picture_url>
          <person_id>neilmitchell</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sam</first_name>
          <last_name>Tobin-Hochstadt</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>I am an Assistant Professor in the Department of Computer Science at Indiana University. 
Research Interests: my research focuses on the design and analysis of software and programming languages. I am particularly interested in how programs grow from prototype scripts to robust software, and how programming language design can support this process. My research concerns type systems, software contracts, modularity, and extensibility. I’m currently working with the DARPA CRASH program on Racket and with Mozilla Labs on JavaScript.</bio>
          <homepage_url>http://samth.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/samtobinhochstadt/d817e5c9-fe1c-4664-a4d1-6af45d4d4586/small.jpg</picture_url>
          <person_id>samtobinhochstadt</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e2b151e3-5650-423f-bfba-20eb0205f6b3</subevent_id>
    <title>SPLASH OOPSLA: R-2</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>eb993289-bf96-4291-89d7-cbcc9e338b2d</slot_id>
      <title>Session: SPLASH OOPSLA - R-2</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>21:00</start_time>
      <end_time>22:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Sheng</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Louisiana at Lafayette, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.cmix.louisiana.edu/schen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shengchen1/4561e224-57d6-4243-9b1f-0c895b2c49d7/small.jpg</picture_url>
          <person_id>shengchen1</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>John</first_name>
          <last_name>Peter Campora III</last_name>
          <affiliation>University of Louisiana at Lafayette, USA</affiliation>
          <bio>I’m a 3rd year PhD student at ULL advised by Sheng Chen. My current research focus has been improving the usability of gradually typed languages. You can contact me at: petecampora (at) gmail.com.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnpetercamporaiii/62a0c591-991e-49f7-978a-0ecbc5556620/small.jpg</picture_url>
          <person_id>johnpetercamporaiii</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>45c0bea4-a043-4912-b554-a9bf6c5a1ce7</slot_id>
      <event_id>7f5b0b0c-f047-4936-8287-c85d0bbd3581</event_id>
      <title>Do You Have Space for Dessert? A Verified Space Cost Semantics for CakeML Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>21:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>21:40</end_time>
      <description>Garbage collectors relieve the programmer from manual memory management, but lead to compiler-generated machine code that can behave differently (e.g.\ out-of-memory errors) from the source code. To ensure that the generated code behaves exactly like the source code, programmers need a way to answer questions of the form: what is a sufficient amount of memory for my program to never reach an out-of-memory error? 
This paper develops a cost semantics that can answer such questions for CakeML programs. The work described in this paper is the first to be able to answer such questions with proofs in the context of a language that depends on garbage collection. We demonstrate that positive answers can be used to transfer liveness results proved for the source code to liveness guarantees about the generated machine code. Without guarantees about space usage, only safety results can be transferred from source to machine code. 
Our cost semantics is phrased in terms of an abstract intermediate language of the CakeML compiler, but results proved at that level map directly to the space cost of the compiler-generated machine code. All of the work described in this paper has been developed in the HOL4 theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alejandro</first_name>
          <last_name>Gómez-Londoño</last_name>
          <affiliation>Chalmers University of Technology, Sweden</affiliation>
          <bio>undefined</bio>
          <person_id>alejandrogomezlondono</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Johannes</first_name>
          <last_name>Åman Pohjola</last_name>
          <affiliation>Data61 at CSIRO, Australia / UNSW, Australia</affiliation>
          <bio>undefined</bio>
          <person_id>johannesamanpohjola</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hira Taqdees</first_name>
          <last_name>Syeda</last_name>
          <affiliation>Chalmers University of Technology, Sweden</affiliation>
          <bio>undefined</bio>
          <person_id>hirataqdeessyeda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Magnus O.</first_name>
          <last_name>Myreen</last_name>
          <affiliation>Chalmers University of Technology, Sweden</affiliation>
          <bio>I did a B.A. in Computer Science at the University of Oxford, tutored by Dr Jeff Sanders. 
I completed my Ph.D. on program verification in 2009 at the University of Cambridge, supervised by Prof. Mike Gordon. My PhD dissertation was selected as the winner of the BCS Distinguished Dissertation Competition 2010. 
In 2012, I became a Royal Society Research Fellow, UK. 
In 2014, I moved to Chalmers where I became a tenured Associate Professor in 2015.</bio>
          <homepage_url>http://www.cse.chalmers.se/~myreen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusomyreen/ccd5e9cd-2811-4ef2-a9f0-3dd7802233ca/small.jpg</picture_url>
          <person_id>magnusomyreen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yong Kiam</first_name>
          <last_name>Tan</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.cmu.edu/~yongkiat/</homepage_url>
          <person_id>yongkiamtan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4bf9bec3-9bd2-4fda-b411-d85e70d68954</slot_id>
      <event_id>85b0bc7f-a107-41e9-9836-f25f8409f19f</event_id>
      <title>Verifying Replicated Data Types with Typeclass Refinements in Liquid Haskell</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>21:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>22:00</end_time>
      <description>This paper presents an extension to Liquid Haskell that facilitates stating and semi-automatically proving properties of typeclasses. Liquid Haskell augments Haskell with \emph{refinement types}—our work allows such types to be attached to typeclass method declarations, and ensures that instance implementations respect these types. The engineering of this extension is a modular interaction between GHC, the Glasgow Haskell Compiler, and Liquid Haskell’s core proof infrastructure. The design sheds light on the interplay between modular proofs and typeclass resolution, which in Haskell is coherent by default (meaning that resolution always selects the same implementation for a particular instantiating type), but in other dependently typed languages is not. 
We demonstrate the utility of our extension by using Liquid Haskell to modularly verify that 34 instances satisfy the laws of five standard typeclasses. 
More substantially, we implement a framework for programming distributed applications based on \emph{replicated data types} (RDTs). We define a typeclass whose Liquid Haskell type captures the mathematical properties RDTs should satisfy; prove in Liquid Haskell that these properties are sufficient to ensure that replicas' states converge despite out-of-order update delivery; implement (and prove correct) several instances of our RDT typeclass; and use them to build two realistic applications, a multi-user calendar event planner and a collaborative text editor.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yiyun</first_name>
          <last_name>Liu</last_name>
          <affiliation>University of Maryland at College Park, USA</affiliation>
          <bio>undefined</bio>
          <person_id>yiyunliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>James</first_name>
          <last_name>Parker</last_name>
          <affiliation>University of Maryland at College Park, USA</affiliation>
          <bio>undefined</bio>
          <person_id>jamesparker</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Redmond</last_name>
          <affiliation>University of California at Santa Cruz, USA</affiliation>
          <bio>undefined</bio>
          <person_id>patrickredmond</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lindsey</first_name>
          <last_name>Kuper</last_name>
          <affiliation>University of California at Santa Cruz, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://users.soe.ucsc.edu/~lkuper/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lindseykuper/f5b1f248-82e4-45ec-ab90-1d543b02d204/small.jpg</picture_url>
          <person_id>lindseykuper</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Hicks</last_name>
          <affiliation>University of Maryland at College Park, USA</affiliation>
          <bio>Michael Hicks is a Professor in the Computer Science department and UMIACS at the University of Maryland, where he co-directs the laboratory for Programming Languages research (PLUM); he is the former Director of the Maryland Cybersecurity Center (MC2) and the Past Chair of ACM SIGPLAN. 
His research focuses on using programming languages and analyses to improve the security, reliability, and availability of software. He is perhaps best known for his work exploring dynamic software updating, a technique with which software can be updated without shutting it down. He has explored the design of new programming languages and analysis tools for helping programmers find bugs and software vulnerabilities, and for identifying suspicious or incorrect program executions. He was worked has combined ideas from PL and cryptography, e.g., to ensure privacy preserving computations. He also leads the development of a new security-oriented programming contest, “build-it, break-it, fix-it,” which has been offered to the public and to students in his Coursera class on software security. He has recently begun to explore programming languages for quantum computation. 
He is the editor of the Programming Languages Enthusiast blog and Tweets at @michael_w_hicks.</bio>
          <homepage_url>http://www.cs.umd.edu/~mwh/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelhicks/aa64e3c6-3516-4e13-affe-77bc32c40565/small.jpg</picture_url>
          <person_id>michaelhicks</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Niki</first_name>
          <last_name>Vazou</last_name>
          <affiliation>IMDEA Software Institute, Spain</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://nikivazou.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nikivazou/8cc6ddec-154b-47e9-b40d-c66e78476391/small.jpg</picture_url>
          <person_id>nikivazou</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c75362d3-e972-4e28-a790-2508d4de2cac</slot_id>
      <event_id>9796e9aa-1b8d-46b7-8c85-2c6427f306de</event_id>
      <title>Towards a Formal Foundation of Intermittent Computing</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>22:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>22:20</end_time>
      <description>Intermittently powered devices enable new applications in harsh or inaccessible environments, such as space or in-body implants, but also introduce problems in programmability and correctness. Researchers have developed programming models to ensure that programs make progress and do not produce erroneous results due to memory inconsistencies caused by intermittent executions. As the technology has matured, more and more features are added to intermittently powered devices, such as I/O. Prior work has shown that all existing intermittent execution models have problems with repeated device or sensor inputs (RIO). RIOs could leave intermittent executions in an inconsistent state. Such problems and the proliferation of existing intermittent execution models necessitate a formal foundation for intermittent computing. 
In this paper, we formalize intermittent execution models, their correctness properties with respect to memory consistency and inputs, and identify the invariants needed to prove systems correct. We prove equivalence between several existing intermittent systems. To address RIO problems, we define an algorithm for identifying variables affected by RIOs that need to be restored after reboot and prove the algorithm correct. Finally, we implement the algorithm in a novel intermittent runtime system that is correct with respect to input operations and evaluate its performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Milijana</first_name>
          <last_name>Surbatovich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>milijanasurbatovich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Brandon</first_name>
          <last_name>Lucia</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Brandon is a Professor at Carnegie Mellon University working on hardware and software computer systems to answer the question: “How capable can a computing system be, given physical restrictions on its form factor, input power, energy storage, or other resource constraints?” His research has been recognized with 8 best paper awards, the 2019 IEEE TCCA Young Computer Architect Award and the 2015 Bell Labs Prize.</bio>
          <homepage_url>http://brandonlucia.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brandonlucia/e10fc900-d74f-44e7-a793-5e2f21a7dd0b/small.jpg</picture_url>
          <person_id>brandonlucia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Limin</first_name>
          <last_name>Jia</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.andrew.cmu.edu/user/liminjia/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/liminjia/6bc50ee1-2333-4b59-bc4f-3bf74d1e3b64/small.jpg</picture_url>
          <person_id>liminjia</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fc3324eb-e719-4e94-9994-8d33988181a8</slot_id>
      <event_id>90cce21d-a854-4f50-b7f1-09a1af23e318</event_id>
      <title>Automatic and Efficient Variability-Aware Lifting of Functional Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>21:20</end_time>
      <description>A software analysis is a computer program that takes some representation of a software product as input and produces some useful information about that product as output. A software product line encompasses \emph{many} software product variants, and thus existing analyses can be applied to each of the product variations individually, but not to the entire product line as a whole. Enumerating all product variants and analyzing them one by one is usually intractable due to the combinatorial explosion of the number of product variants with respect to product line features. Several software analyses (e.g., type checkers, model checkers, data flow analyses) have been redesigned/re-implemented to support variability. This usually requires a lot of time and effort, and the variability-aware version of the analysis might have new errors/bugs that do not exist in the original one. 
Given an analysis program written in a functional language based on PCF, in this paper we present two approaches to transforming (lifting) it into a semantically equivalent variability-aware analysis. A light-weight approach (referred to as \emph{shallow lifting}) wraps the analysis program into a variability-aware version, exploring all combinations of its input arguments. Deep lifting, on the other hand, is a program rewriting mechanism where the syntactic constructs of the input program are rewritten into their variability-aware counterparts. Compositionally this results in an efficient program semantically equivalent to the input program, modulo variability. 
We present the correctness criteria for functional program lifting, together with correctness proof sketches of shallow lifting. We evaluate our approach on a set of program analyses applied to the BusyBox C-language product line.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ramy</first_name>
          <last_name>Shahin</last_name>
          <affiliation>University of Toronto, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>ramyshahin1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marsha</first_name>
          <last_name>Chechik</last_name>
          <affiliation>University of Toronto, Canada</affiliation>
          <bio>Marsha Chechik is Professor in the Department of Computer Science at the University of Toronto. She received her Ph.D. from the University of Maryland in 1996. Prof. Chechik’s research interests are in the application of formal methods to improve the quality of software. She has authored numerous papers in formal methods, software specification and verification, computer safety and security and requirements engineering. In 2002-2003, Prof. Chechik was a visiting scientist at Lucent Technologies in Murray Hill, NY and at Imperial College, London UK, and in 2013 – at Stonybrook University. She is a member of IFIP WG 2.9 on Requirements Engineering and an Associate Editor in Chief of Journal on Software and Systems Modeling. She is has been an associate editor of IEEE Transactions on Software Engineering 2003-2007, 2010-2013. She regularly serves on program committees of international conferences in the areas of software engineering and automated verification. Marsha Chechik has been Program Committee Co-Chair of the 2018 International Conference in Software Engineering (ICSE18), 2016 International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS’16), the 2016 Working Conference on Verified Software: Theories, Tools, and Experiments (VSTTE16), the 2014 International Conference on Automated Software Engineering (ASE’14), the 2008 International Conference on Concurrency Theory (CONCUR’08), the 2008 International Conference on Computer Science and Software Engineering (CASCON’08), and the 2009 International Conference on Formal Aspects of Software Engineering (FASE’09). She will be PC Co-Chair of ESEC/FSE’2021. She is a Member of ACM SIGSOFT and the IEEE Computer Society.</bio>
          <homepage_url>http://www.cs.toronto.edu/~chechik</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/marshachechik/779292d1-7e1c-4bb1-9f30-e36ee949bd9a/small.jpg</picture_url>
          <person_id>marshachechik</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6ea314e2-282c-4014-8d0b-fa0c3a939812</subevent_id>
    <title>SPLASH OOPSLA: R-4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>cd2cda48-c3ec-4a5b-a8a9-997f95f219d7</slot_id>
      <title>Session: SPLASH OOPSLA - R-4</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Rand</last_name>
          <affiliation>University of Chicago</affiliation>
          <bio>I am an Assistant Professor of Computer Science at the University of Chicago, part of the Programming Languages Research Group and the Chicago Quantum Exchange. 
My main interest is in applying techniques from programming languages and formal verification to the domain of quantum computation. Some of my major projects include the QWIRE quantum circuit language (with Jennifer Paykin) and the VOQC verified optimizing compiler (with Kesha Hietala). I’m currently interested in verified optimization, error-correction, type systems, and programming abstractions for quantum computing.</bio>
          <homepage_url>http://people.cs.uchicago.edu/~rand/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/robertrand/55e0e41c-245e-4474-9dcc-038bb78ec518/small.jpg</picture_url>
          <person_id>robertrand</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Rohan</first_name>
          <last_name>Padhye</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://rohan.padhye.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rohanpadhye/5b3399f0-7eac-4a98-aa02-d615e7be77c7/small.jpg</picture_url>
          <person_id>rohanpadhye</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1fe76e34-a448-44ce-909c-90d1f249626a</slot_id>
      <event_id>0484f76d-7e8f-42de-be40-69afe1f78f7d</event_id>
      <title>Dataflow-Based Pruning for Speeding up Superoptimization</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>13:40</end_time>
      <description>Superoptimization is a compilation strategy that uses search to improve code quality, rather than relying on a canned sequence of transformations, as traditional optimizing compilers do. % This search can be seen as a program synthesis problem: from unoptimized code serving as a specification, the synthesis procedure attempts to create a more efficient implementation. % An important family of synthesis algorithms works by enumerating candidates and then successively checking if each refines the specification, using an SMT solver. % The contribution of this paper is a pruning technique which reduces the enumerative search space using fast dataflow-based techniques to discard synthesis candidates that contain symbolic constants and uninstantiated instructions. % We demonstrate the effectiveness of this technique by improving the runtime of an enumerative synthesis procedure in the Souper superoptimizer for the LLVM intermediate representation. % The techniques presented in this paper eliminate 65% of the solver calls made by Souper, making it 2.32x faster (14.54 hours vs 33.76 hours baseline, on a large multicore) at solving all 269,113 synthesis problems that Souper encounters when optimizing the C and C++ programs from SPEC CPU 2017.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manasij</first_name>
          <last_name>Mukherjee</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
          <person_id>manasijmukherjee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pranav</first_name>
          <last_name>Kant</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
          <person_id>pranavkant</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhengyang</first_name>
          <last_name>Liu</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.utah.edu/~liuz/</homepage_url>
          <person_id>zhengyangliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>John</first_name>
          <last_name>Regehr</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.utah.edu/~regehr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnregehr/2cb23ab0-042a-487a-a859-cbd3147a46a7/small.jpg</picture_url>
          <person_id>johnregehr</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7f47ee80-2b41-44fd-b79f-0bfe212d2f81</slot_id>
      <event_id>e9ae4c19-f50c-4f0d-b1e6-3e733890b7c4</event_id>
      <title>Enabling Accuracy-Aware Quantum Compilers using Symbolic Resource Estimation</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>14:00</end_time>
      <description>Approximation errors must be taken into account when compiling quantum programs into a low-level gate set. We present a methodology that tracks such errors automatically and then optimizes accuracy parameters to guarantee a specified overall accuracy while aiming to minimize the implementation cost in terms of quantum gates. The core idea of our approach is to extract functions that specify the optimization problem directly from the high-level description of the quantum program. Then, custom compiler passes optimize these functions, turning them into (near-)symbolic expressions for (1) the total error and (2) the implementation cost (e.g., total quantum gate count). All unspecified parameters of the quantum program will show up as variables in these expressions, including accuracy parameters. After solving the corresponding optimization problem, a circuit can be instantiated from the found solution. We develop two prototype implementations, one in C++ based on Clang/LLVM, and another using the Q# compiler infrastructure. We benchmark our prototypes on typical quantum computing programs, including the quantum Fourier transform, quantum phase estimation, and Shor's algorithm.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Giulia</first_name>
          <last_name>Meuli</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>giuliameuli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mathias</first_name>
          <last_name>Soeken</last_name>
          <affiliation>Microsoft, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>mathiassoeken</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Martin</first_name>
          <last_name>Roetteler</last_name>
          <affiliation>Microsoft, USA</affiliation>
          <bio>undefined</bio>
          <person_id>martinroetteler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Häner</last_name>
          <affiliation>Microsoft, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>thomashaner</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a02b87db-c6d1-4a08-9b16-e880048dd07c</slot_id>
      <event_id>c500592f-2d9a-4056-99b3-b5e5865667b4</event_id>
      <title>Assertion-Based Optimization of Quantum Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>13:20</end_time>
      <description>Quantum computers promise to perform certain computations exponentially faster than any classical device. Precise control over their physical implementation and proper shielding from unwanted interactions with the environment become more difficult as the space/time volume of the computation grows. Code optimization is thus crucial in order to reduce resource requirements to the greatest extent possible. Besides manual optimization, previous work has adapted classical methods such as constant-folding and common subexpression elimination to the quantum domain. However, such classically-inspired methods fail to exploit certain optimization opportunities across subroutine boundaries, limiting the effectiveness of software reuse. To address this insufficiency, we introduce an optimization methodology which employs annotations that describe how subsystems are entangled in order to exploit these optimization opportunities. We formalize our approach, prove its correctness, and present benchmarks: Without any prior manual optimization, our methodology is able to reduce, e.g., the qubit requirements of a 64-bit floating-point subroutine by $34\times$.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Häner</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>thomashaner1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Torsten</first_name>
          <last_name>Hoefler</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>Torsten is an Assistant Professor of Computer Science at ETH Zürich, Switzerland. Before joining ETH, he led the performance modeling and simulation efforts of parallel petascale applications for the NSF-funded Blue Waters project at NCSA/UIUC. He is also a key member of the Message Passing Interface (MPI) Forum where he chairs the “Collective Operations and Topologies” working group. Torsten won best paper awards at the ACM/IEEE Supercomputing Conference 2010 (SC10), EuroMPI 2013, ACM/IEEE Supercomputing Conference 2013 (SC13), and other conferences. He published numerous peer-reviewed scientific conference and journal articles and authored chapters of the MPI-2.2 and MPI-3.0 standards. For his work, Torsten received the SIAM SIAG/Supercomputing Junior Scientist Prize in 2012 and the IEEE TCSC Young Achievers in Scalable Computing Award in 2013. Following his Ph.D., the received the Young Alumni Award 2014 from Indiana University. Torsten was elected into the first steering committee of ACM’s SIGHPC in 2013. His research interests revolve around the central topic of “Performance-centric Software Development” and include scalable networks, parallel programming techniques, and performance modeling. Additional information about Torsten can be found on his homepage at htor.inf.ethz.ch.</bio>
          <homepage_url>http://htor.inf.ethz.ch/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/torstenhoefler/b570b3f0-a91f-4651-8a80-cfde60d06190/small.jpg</picture_url>
          <person_id>torstenhoefler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Troyer</last_name>
          <affiliation>Microsoft, USA</affiliation>
          <bio>undefined</bio>
          <person_id>matthiastroyer</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e0a12082-c401-4675-8143-3a5c9eb89020</slot_id>
      <event_id>f2d61eb0-5d2c-45d9-81c7-1137a585afca</event_id>
      <title>Eliminating Abstraction Overhead of Java Stream Pipelines using Ahead-of-Time Program Optimization</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>14:20</end_time>
      <description>Java 8 introduced streams that allow developers to work with collections of data using functional-style operations. Streams are often used in pipelines of operations for processing the data elements, which leads to concise and elegant program code. However, the declarative data processing style comes at a cost. Compared to processing the data with traditional imperative language mechanisms, constructing stream pipelines requires extra heap objects and virtual method calls, which often results in significant run-time overheads. 
In this work we investigate how to mitigate these overheads to enable processing data in the declarative style without sacrificing performance. We argue that ahead-of-time bytecode-to-bytecode transformation is a suitable approach to optimization of stream pipelines, and we present a static analysis that is designed to guide such transformations. Experimental results show a significant performance gain, and that the technique works for realistic stream pipelines. For 10 of 11 micro-benchmarks, the optimizer is able to produce bytecode that is as effective as hand-written imperative-style code. Additionally, 77% of 6879 stream pipelines found in real-world Java programs are optimized successfully.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anders</first_name>
          <last_name>Møller</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
          <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
          <person_id>andersmoller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Oskar</first_name>
          <last_name>Haarklou Veileborg</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/oskarhaarklouveileborg/4b1f271b-c619-4096-8218-ae034b3a1da9/small.jpg</picture_url>
          <person_id>oskarhaarklouveileborg</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>aa3f4162-269f-44a3-a4f2-f476980697ee</subevent_id>
    <title>SPLASH OOPSLA: F-1B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>9f4aced6-1908-456a-add0-5ca50befc252</slot_id>
      <title>Session: SPLASH OOPSLA - F-1B</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>19:00</start_time>
      <end_time>20:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3e48ecad-7841-481f-815a-66e118189a37</slot_id>
      <event_id>256ca32c-494b-45db-903d-d2bbabbfbd1b</event_id>
      <title>Guiding Dynamic Programing via Structural Probability for Accelerating Programming by Example</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>20:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>20:20</end_time>
      <description>Programming by example (PBE) is an important subproblem of program synthesis, and PBE techniques have been applied to many domains. Though many techniques for accelerating PBE systems have been explored, the scalability remains one of the main challenges: There is still a gap between the performances of state-of-the-art synthesizers and the industrial requirement. To further speed up solving PBE tasks, in this paper, we propose a novel PBE framework MaxFlash. MaxFlash uses a model based on structural probability, named topdown prediction models, to guide a search based on dynamic programming, such that the search will focus on subproblems that form probable programs, and avoid improbable programs. Our evaluation shows that MaxFlash achieves $\times 4.107- \times 2080$ speed-ups against state-of-the-art solvers on $244$ real-world tasks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ruyi</first_name>
          <last_name>Ji</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <person_id>ruyiji</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yican</first_name>
          <last_name>Sun</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <person_id>yicansun1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yingfei</first_name>
          <last_name>Xiong</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>Associate Professor</bio>
          <homepage_url>http://sei.pku.edu.cn/~xiongyf04/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yingfeixiong/18fb7368-4f14-462a-b038-9990eebb7a9c/small.jpg</picture_url>
          <person_id>yingfeixiong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhenjiang</first_name>
          <last_name>Hu</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sei.pku.edu.cn/~hu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhenjianghu/5d426480-5589-46be-b4f6-f98cf2acc80e/small.jpg</picture_url>
          <person_id>zhenjianghu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ae530ffd-560a-4206-87da-26475c51153a</slot_id>
      <event_id>29356edb-fec4-4b97-9278-0bf447a06e5d</event_id>
      <title>TacTok: Semantics-Aware Proof Synthesis</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>19:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>20:00</end_time>
      <description>Formally verifying software correctness is a highly manual process. However, because verification proof scripts often share structure, it is possible to learn from existing proof scripts to fully automate some formal verification. The goal of this paper is to improve proof script synthesis and enable fully automating more verification. Interactive theorem provers, such as the Coq proof assistant, allow programmers to write partial proof scripts, observe the semantics of the proof state thus far, and then attempt more progress. Knowing the proof state semantics is a significant aid. Recent research has shown that the proof state can help predict the next step. In this paper, we present TacTok, the first technique that attempts to fully automate proof script synthesis by modeling proof scripts using both the partial proof script written thus far and the semantics of the proof state. Thus, TacTok more completely models the information the programmer has access to when writing proof scripts manually. We evaluate TacTok on a benchmark of 26 software projects in Coq, consisting of over 10 thousand theorems. We compare our approach to five tools. Two prior techniques, CoqHammer, the state-of-the-art proof synthesis technique, and ASTactic, a proof script synthesis technique that models proof state. And three new proof script synthesis technique we create ourselves, SeqOnly, which models only the partial proof script and the initial theorem being proven, and WeightedRandom and WeightedGreedy, which use metaheuristic search biased by frequencies of proof tactics in existing, successful proof scripts. We find that TacTok outperforms WeightedRandom and WeightedGreedy, and is complementary to CoqHammer and ASTactic: for 24 out of the 26 projects, TacTok can synthesize proof scripts for some theorems the prior tools cannot. Together with TacTok, 11.5% more theorems can be proven automatically than by CoqHammer alone, and 20.0% than by ASTactic alone. Compared to a combination of CoqHammer and ASTactic, TacTok can prove an additional 3.6% more theorems, proving 115 theorems no tool could previously prove. Overall, our experiments provide evidence that partial proof script and proof state semantics, together, provide useful information for proof script modeling, and that metaheuristic search is a promising direction for proof script synthesis. TacTok is open-source and we make public all our data and a replication package of our experiments.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Emily</first_name>
          <last_name>First</last_name>
          <affiliation>University of Massachusetts at Amherst, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/emilyfirst/76db7ede-1a2f-4b56-9974-9bb109e78ed1/small.jpg</picture_url>
          <person_id>emilyfirst</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yuriy</first_name>
          <last_name>Brun</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>My research is in software engineering. I am interested in improving our ability to build systems that are smart, and self-adapt to their environment. I am particularly interested in ensuring fairness in software systems. Watch a video describing my latest work on software fairness testing here: http://tinyurl.com/FairnessVideo</bio>
          <homepage_url>http://people.cs.umass.edu/~brun/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yuriybrun/15eff225-fb71-4b2c-9925-a0d731136238/small.jpg</picture_url>
          <person_id>yuriybrun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Guha</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://khoury.northeastern.edu/~arjunguha</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjunguha/284e0782-ec24-4ad9-b6a4-b6a1d0e2fe9a/small.jpg</picture_url>
          <person_id>arjunguha</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b6e155fa-44ef-413b-824f-9d23df63213f</slot_id>
      <event_id>8068ce72-3e63-4d39-8209-298d9b3bc05d</event_id>
      <title>Learning Graph-Based Heuristics for Pointer Analysis without Handcrafting Application-Specific Features</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>19:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>19:40</end_time>
      <description>We present Graphick, a new technique for automatically learning graph-based heuristics for pointer analysis. Striking a balance between precision and scalability of pointer analysis requires designing good analysis heuristics. For example, because applying context sensitivity to all methods in a real-world program is impractical, pointer analysis typically uses a heuristic to employ context sensitivity only when it is necessary. Past research has shown that exploiting the program's graph structure is a promising way of developing cost-effective analysis heuristics, promoting the recent trend of ``graph-based heuristics'' that work on the graph representations of programs obtained from a pre-analysis. Although promising, manually developing such heuristics remains challenging, requiring a great deal of expertise and laborious effort. In this paper, we aim to reduce this burden by learning graph-based heuristics automatically, in particular without hand-crafted application-specific features. To do so, we present a feature language to describe graph structures and an algorithm for learning analysis heuristics within the language. We implemented Graphick on top of Doop and used it to learn graph-based heuristics for object sensitivity and heap abstraction. The evaluation results show that our approach is general and can generate high-quality heuristics. For both instances, the learned heuristics are as competitive as the existing state-of-the-art heuristics designed manually by analysis experts.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Minseok</first_name>
          <last_name>Jeon</last_name>
          <affiliation>Korea University, South Korea</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://prl.korea.ac.kr/~minseok/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/minseokjeon/69505413-080b-41a8-8714-56f24d788995/small.jpg</picture_url>
          <person_id>minseokjeon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Myungho</first_name>
          <last_name>Lee</last_name>
          <affiliation>Korea University, South Korea</affiliation>
          <bio>undefined</bio>
          <person_id>myungholee1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hakjoo</first_name>
          <last_name>Oh</last_name>
          <affiliation>Korea University, South Korea</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://prl.korea.ac.kr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hakjoooh/d607b778-78f3-41c4-84d9-4693c8923bc3/small.jpg</picture_url>
          <person_id>hakjoooh</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bfc45d64-2336-40ce-8762-b3fcd5a2ff6a</slot_id>
      <event_id>fd3d1690-7023-4d0a-a100-6ba2b8f4497c</event_id>
      <title>Incremental Predicate Analysis for Regression Verification</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>19:20</end_time>
      <description>Software products are evolving during their life cycles. Ideally, every revision need be formally verified to ensure software quality. Yet repeated formal verification requires significant computing resources. Verifying each and every revision can be very challenging. It is desirable to ameliorate regression verification for practical purposes. In this paper, we regard predicate analysis as a process of assertion annotation. Assertion annotations can be used as a certificate for the verification results. It is thus a waste of resources to throw them away after each verification. We propose to reuse the previously-yielded assertion annotation in regression verification. A light-weight impact-analysis technique is proposed to analyze the reusability of assertions. A novel assertion strengthening technique is furthermore developed to improve reusability of annotation. With these techniques, we present an incremental predicate analysis technique for regression verification. Correctness of our incremental technique is formally proved. We performed comprehensive experiments on revisions of Linux kernel device drivers. Our technique outperforms the state-of-the-art program verification tool CPAchecker by getting 2.8x speedup in total time and solving additional 393 tasks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Qianshan</first_name>
          <last_name>Yu</last_name>
          <affiliation>Tsinghua University, China</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/qianshanyu/5ab95d6b-de0b-48ef-8655-f7b92c2938c8/small.jpg</picture_url>
          <person_id>qianshanyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fei</first_name>
          <last_name>He</last_name>
          <affiliation>Tsinghua University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://feihe.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/feihe/8546030e-3821-4cb3-8f33-23a258579461/small.jpg</picture_url>
          <person_id>feihe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bow-Yaw</first_name>
          <last_name>Wang</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <person_id>bowyawwang1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4a3195ef-0362-4884-91a7-7f4796acd6df</subevent_id>
    <title>SPLASH OOPSLA: F-4B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>9a2af04b-9f08-4ea2-9fbb-ad39dd5dd123</slot_id>
      <title>Session: SPLASH OOPSLA - F-4B</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>81527de7-221f-44b5-a907-12c21c7069f1</slot_id>
      <event_id>607946f8-4df3-4340-83bb-3317adc76c7a</event_id>
      <title>Certified and Efficient Instruction Scheduling: Application to Interlocked VLIW Processors</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>13:20</end_time>
      <description>CompCert is a moderately optimizing C compiler with a formal, machine-checked, proof of correctness: after successful compilation, the assembly code has a behavior faithful to the source code. Previously, it only supported target instruction sets with sequential semantics, and did not attempt reordering instructions for optimization. 
We present here a CompCert backend for a VLIW core (\textit{i.e.} with explicit parallelism at the instruction level), the first CompCert backend providing scalable and efficient instruction scheduling. Furthermore, its highly modular implementation can be easily adapted to other VLIW or non-VLIW pipelined processors.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cyril</first_name>
          <last_name>Six</last_name>
          <affiliation>Kalray, France / Grenoble Alps University, France / CNRS, France / Grenoble INP, France / VERIMAG, France</affiliation>
          <bio>undefined</bio>
          <person_id>cyrilsix</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sylvain</first_name>
          <last_name>Boulmé</last_name>
          <affiliation>Grenoble Alps University, France / CNRS, France / Grenoble INP, France / VERIMAG, France</affiliation>
          <bio>undefined</bio>
          <person_id>sylvainboulme</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Monniaux</last_name>
          <affiliation>Grenoble Alps University, France / CNRS, France / Grenoble INP, France / VERIMAG, France</affiliation>
          <bio>David Monniaux obtained his PhD in 2001 in Paris under Prof Patrick Cousot; his dissertation was on the static analysis of probabilistic programs by abstract interpretation. He then joined CNRS as a junior researcher and first worked on the Astrée static analyzer, still in Paris. In 2007 he transferred to VERIMAG in Grenoble, where he works on various aspects of program verification (decision procedures, abstract interpretation…). 
He now is a senior researcher at CNRS and an adjunct professor at École polytechnique.</bio>
          <homepage_url>http://www-verimag.imag.fr/~monniaux/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidmonniaux/d285baca-8e32-4918-b3c6-c724e98fc7b3/small.jpg</picture_url>
          <person_id>davidmonniaux</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c2ad7159-9b45-442a-b8ec-e5bc584593fa</slot_id>
      <event_id>ec90eddc-d967-43e8-8847-c0b006802b6a</event_id>
      <title>Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>13:40</end_time>
      <description>Lighthouse projects like CompCert, seL4, IronFleet, and DeepSpec have demonstrated that full system verification is feasible by establishing a refinement between an abstract system specification and an executable implementation. Existing approaches however impose severe restrictions on the abstract system specifications due to their limited expressiveness or versatility, or on the executable code due to their use of suboptimal code extraction or inexpressive program logics. We propose a novel methodology that combines the compositional refinement of event-based models of distributed systems with the verification of full-fledged program code using expressive separation logics, which support features of realistic programming languages like heap data structures and concurrency. Our main technical contribution is a formal framework that soundly relates event-based system models to program specifications in separation logics. This enables protocol development tools to soundly interoperate with program verifiers to establish a refinement between the model and the code. We formalized our framework, Igloo, in Isabelle/HOL. We report on three case studies, a leader election protocol, a replication protocol, and a security protocol, for which we refine formal requirements into program specifications that we implement in Java and Python and prove correct using the VeriFast and Nagini tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Sprenger</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>christophsprenger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Klenze</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>tobiasklenze</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marco</first_name>
          <last_name>Eilers</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch/people/personal/meilers-pers.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/marcoeilers/fbfa4a0a-c277-440b-af64-20c5dbf19d0c/small.jpg</picture_url>
          <person_id>marcoeilers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Felix A.</first_name>
          <last_name>Wolf</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>felixwolf2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Peter</first_name>
          <last_name>Müller</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/petermller/aeb8e276-62cb-4ad1-aa7d-96f76c0c405d/small.jpg</picture_url>
          <person_id>petermller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Martin</first_name>
          <last_name>Clochard</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>martinclochard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>David</first_name>
          <last_name>Basin</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>davidbasin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d4ecabd4-5c59-45b4-b90a-d5e08fb054af</slot_id>
      <event_id>cb73d5d3-92d2-4ee8-bb13-8a1b4731e3a3</event_id>
      <title>Termination Analysis for Evolving Programs: An Incremental Approach by Reusing Certified Modules</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>14:20</end_time>
      <description>Research on program termination has a long tradition. However, most of the existing techniques target a single program only. We propose in this paper an incremental termination analysis approach by reusing certified modules across different program versions. A transformation-based procedure is further developed to increase the reusability of certified modules. The proposed approach has wide applicability, applicable to various program changes. The proposed technique, to the best of our knowledge, represents a novel attempt to the termination analysis of evolving programs. We implemented the approach on top of \textsc{Ultimate Automizer}. Experimental results show dramatic improvement of our approach over the state-of-the-art tool.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fei</first_name>
          <last_name>He</last_name>
          <affiliation>Tsinghua University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://feihe.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/feihe/8546030e-3821-4cb3-8f33-23a258579461/small.jpg</picture_url>
          <person_id>feihe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jitao</first_name>
          <last_name>Han</last_name>
          <affiliation>Tsinghua University, China</affiliation>
          <bio>undefined</bio>
          <person_id>jitaohan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f65e816c-9101-460a-964b-12a9b29ecf22</slot_id>
      <event_id>88401ded-3b58-4749-8aef-7b24b61ab09f</event_id>
      <title>Neural Reverse Engineering of Stripped Binaries using Augmented Control Flow Graphs</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>14:00</end_time>
      <description>We address the problem of reverse engineering of stripped executables, which contain no debug information. This is a challenging problem because of the low amount of syntactic information available in stripped executables, and the diverse assembly code patterns arising from compiler optimizations. We present a novel approach for predicting procedure names in stripped executables. Our approach combines static analysis with neural models. The main idea is to use static analysis to obtain augmented representations of call sites; encode the structure of these call sites using the control-flow graph (CFG) and finally, generate a target name while attending to these call sites. We use our representation to drive graph-based, LSTM-based and Transformer-based architectures. Our evaluation shows that our models produce predictions that are difficult and time consuming for humans, while improving on existing methods by 28% and by 100% over state-of-the-art neural textual models that do not use any static analysis. Code and data for this evaluation are available at https://github.com/tech-srl/Nero.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yaniv</first_name>
          <last_name>David</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://yanivd.cswp.cs.technion.ac.il</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yanivdavid/83ffa94a-79ef-4627-b213-9d48cfeac290/small.jpg</picture_url>
          <person_id>yanivdavid</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Uri</first_name>
          <last_name>Alon</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~urialon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/urialon/a0488e4f-5173-472b-af25-10666c27e3d4/small.jpg</picture_url>
          <person_id>urialon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>Eran Yahav is an associate professor at the Computer Science Department, Technion, Israel. Prior to that, he was a research staff member at the IBM T.J. Watson Research Center (2004-2010). He received his Ph.D. from Tel Aviv University (2005) and his B.Sc. from the Technion in 1996. His research interests include program analysis, program synthesis and program verification. Eran is a recipient of the prestigious Alon Fellowship for Outstanding Young Researchers, the Andre Deloro Career Advancement Chair in Engineering, the ERC Consolidator Grant as well as multiple best paper awards at various conferences.</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
          <person_id>eranyahav</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>307a8b34-7172-4e69-bd67-b4f4b92c989b</subevent_id>
    <title>SPLASH OOPSLA: R-3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>76f60a28-06d4-4f6f-9557-7835a186ccbb</slot_id>
      <title>Session: SPLASH OOPSLA - R-3</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Coblenz</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umd.edu/~mcoblenz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelcoblenz/aa74b306-529b-44d4-987f-a5e4fd6d3ca2/small.jpg</picture_url>
          <person_id>michaelcoblenz</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Marieke</first_name>
          <last_name>Huisman</last_name>
          <affiliation>University of Twente</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wwwhome.cs.utwente.nl/~marieke/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mariekehuisman/22505ee7-e6f4-4999-abda-0c8325ff501f/small.jpg</picture_url>
          <person_id>mariekehuisman</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2f984058-29f9-4c66-9b1f-6182cd2c73f6</slot_id>
      <event_id>a3ab81c8-640a-4a08-9893-24582fac04f3</event_id>
      <title>Compiling Symbolic Execution with Staging and Algebraic Effects</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>11:20</end_time>
      <description>Building effective symbolic execution engines poses challenges in multiple dimensions: an engine must correctly model the program semantics, provide flexibility in symbolic execution strategies, and execute them efficiently. 
This paper proposes a principled approach to building correct, flexible, and efficient symbolic execution engines, directly rooted in the semantics of the underlying language in terms of a high-level definitional interpreter. The definitional interpreter induces algebraic effects to abstract over semantic variants of symbolic execution, e.g., collecting path conditions as a state effect and path exploration as a nondeterminism effect. Different handlers of these effects give rise to different symbolic execution strategies, making execution strategies orthogonal to the symbolic execution semantics, thus improving flexibility. Furthermore, by annotating the symbolic definitional interpreter with binding-times and specializing it to the input program via the first Futamura projection, we obtain a "symbolic compiler", generating efficient instrumented code having the symbolic execution semantics. Our work reconciles the interpretation- and instrumentation-based approaches to building symbolic execution engines in a uniform framework. 
We illustrate our approach on a simple imperative language step-by-step and then scale up to a significant subset of LLVM IR. We also show effect handlers for common path selection strategies. Evaluating our prototype's performance shows speedups of 10~30x over the unstaged counterpart, and ~2x over KLEE, a state-of-the-art symbolic interpreter for LLVM IR.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guannan</first_name>
          <last_name>Wei</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://continuation.passing.style</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guannanwei/e1971b4b-ebd3-429b-b28c-0c2cfb0f0289/small.jpg</picture_url>
          <person_id>guannanwei</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Oliver</first_name>
          <last_name>Bračevac</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://bracevac.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/oliverbracevac/17c0ac71-a156-4868-8df9-d4ae4cd669e7/small.jpg</picture_url>
          <person_id>oliverbracevac</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Shangyin</first_name>
          <last_name>Tan</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shangyintan/05c3151d-071e-451a-9863-639fc66108ca/small.jpg</picture_url>
          <person_id>shangyintan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
          <person_id>tiarkrompf</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>905e2126-2764-419d-a012-7aa0896ac80d</slot_id>
      <event_id>5b2281e0-6ffc-4b3a-976f-ae840b9db5fd</event_id>
      <title>Satune: Synthesizing Efficient SAT Encoders</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>12:00</end_time>
      <description>Modern SAT solvers are extremely efficient at solving boolean satisfiability problems, enabling a wide spectrum of techniques for checking, verifying, and validating real-world programs. What remains challenging, though, is how to encode a domain problem (e.g., model checking) into a SAT formula because the same problem can have multiple distinct encodings, which can yield performance results that are orders-of-magnitude apart, regardless of the underlying solvers used. We develop Satune, a tool that can automatically synthesize SAT encoders for different problem domains. Satune employs a DSL that allows developers to express domain problems at a high level and a search algorithm that can effectively find efficient solutions. The search process is guided by observations made over example encodings and their performance for the domain and hence Satune can quickly synthesize a high-performance encoder by incorporating patterns from examples that yield good performance. A thorough evaluation with JMCR, SyPet, Dirk, Hexiom, Sudoku, and KillerSudoku demonstrates that Satune can easily synthesize high-performance encoders for different domains including model checking, synthesis, and games. These encoders generate constraint problems that are often several orders of magnitude faster to solve than the original encodings used by the tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hamed</first_name>
          <last_name>Gorjiara</last_name>
          <affiliation>University of California at Irvine, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gorjiara.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hamedgorjiara/ac3c3dcb-0d83-409b-91a3-d369cd445f3b/small.jpg</picture_url>
          <person_id>hamedgorjiara</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guoqing Harry</first_name>
          <last_name>Xu</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am an Associate Professor of Computer Science at University of California, Los Angeles (UCLA). I am interested broadly in software and hardware systems — including programming languages, compilers, big data analytics, distributed systems, and computer architecture.</bio>
          <homepage_url>http://web.cs.ucla.edu/~harryxu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/harryxu/5d680c47-2b02-4f5f-a2fb-55c72b5d63ed/small.jpg</picture_url>
          <person_id>harryxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brian</first_name>
          <last_name>Demsky</last_name>
          <affiliation>University of California at Irvine, USA</affiliation>
          <bio>undefined</bio>
          <person_id>briandemsky</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9c11641e-6c93-4cd4-9202-b9a896ac990c</slot_id>
      <event_id>fcea71f9-9bb0-4209-a01f-13ad1fb54e32</event_id>
      <title>The Anchor Verifier for Blocking and Non-blocking Concurrent Software</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>12:20</end_time>
      <description>Verifying the correctness of concurrent software with subtle synchronization is notoriously challenging. We present the Anchor verifier, which is based on a new formalism for specifying synchronization disciplines that describes both (1) what memory accesses are permitted, and (2) how each permitted access commutes with concurrent operations of other threads (to facilitate reduction proofs). Anchor supports the verification of both lock-based blocking and cas-based non-blocking algorithms. Experiments on a variety concurrent data structures and algorithms show that Anchor significantly reduces the burden of concurrent verification.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cormac</first_name>
          <last_name>Flanagan</last_name>
          <affiliation>University of California at Santa Cruz, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://users.soe.ucsc.edu/~cormac/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cormacflanagan/fd454a8e-4230-4fa5-a4da-1d16a1027de3/small.jpg</picture_url>
          <person_id>cormacflanagan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Freund</last_name>
          <affiliation>Williams College, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/stephenfreund/0b468f46-1f87-41c4-bcff-4321da9869c2/small.jpg</picture_url>
          <person_id>stephenfreund</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f246d6b5-79e8-4039-8162-eadd2cd337cf</slot_id>
      <event_id>b9042a01-7709-4b12-9a6d-e627f04668a5</event_id>
      <title>Projection-Based Runtime Assertions for Testing and Debugging Quantum Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>11:40</end_time>
      <description>In this paper, we propose Proq, a runtime assertion scheme for testing and debugging quantum programs on a quantum computer. The predicates in Proq are represented by projections (or equivalently, closed subspaces of the state space), following Birkhoff-von Neumann quantum logic. The satisfaction of a projection by a quantum state can be directly checked upon a small number of projective measurements rather than a large number of repeated executions. On the theory side, we rigorously prove that checking projection-based assertions can help locate bugs or statistically assure that the semantic function of the tested program is close to what we expect, for both exact and approximate quantum programs. On the practice side, we consider hardware constraints and introduce several techniques to transform the assertions, making them directly executable on the measurement-restricted quantum computers. We also propose to achieve simplified assertion implementation using local projection technique with soundness guaranteed. We compare Proq with existing quantum program assertions and demonstrate the effectiveness and efficiency of Proq by its applications to assert two sophisticated quantum algorithms, the Harrow-Hassidim-Lloyd algorithm and Shor’s algorithm.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gushu</first_name>
          <last_name>Li</last_name>
          <affiliation>University of California at Santa Barbara, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.google.com/view/gushuli</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gushuli/5cdbca43-a9df-483d-aa77-d44bad9a5dc3/small.jpg</picture_url>
          <person_id>gushuli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Li</first_name>
          <last_name>Zhou</last_name>
          <affiliation>MPI-SP, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>lizhou1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nengkun</first_name>
          <last_name>Yu</last_name>
          <affiliation>University of Technology Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <person_id>nengkunyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yufei</first_name>
          <last_name>Ding</last_name>
          <affiliation>University of California at Santa Barbara, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ucsb.edu/~yufeiding/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yufeiding/c37f32e5-103b-4441-891c-b82fc8e9640a/small.jpg</picture_url>
          <person_id>yufeiding</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Mingsheng</first_name>
          <last_name>Ying</last_name>
          <affiliation>University of Technology Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://quantum-lab.org/mingsheng/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mingshengying/955ed532-f014-4273-965a-4906017b4b8d/small.jpg</picture_url>
          <person_id>mingshengying</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Yuan</first_name>
          <last_name>Xie</last_name>
          <affiliation>University of California at Santa Barbara, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ece.ucsb.edu/~yuanxie/</homepage_url>
          <person_id>yuanxie</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>930c7498-8bf6-41e1-a992-0fa6d1565376</subevent_id>
    <title>SPLASH OOPSLA: T-4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>32c05868-bc5e-404d-b835-35804d7d1538</slot_id>
      <title>Session: SPLASH OOPSLA - T-4</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Pradel</last_name>
          <affiliation>University of Stuttgart, Germany</affiliation>
          <bio>Michael Pradel is a full professor at University of Stuttgart, which he joined after a PhD at ETH Zurich, a post-doc at UC Berkeley, an assistant professorship at TU Darmstadt, and a sabbatical at Facebook. His research interests span software engineering, programming languages, security, and machine learning, with a focus on tools and techniques for building reliable, efficient, and secure software. In particular, he is interested in dynamic program analysis, test generation, concurrency, performance profiling, JavaScript-based web applications, and machine learning-based program analysis.</bio>
          <homepage_url>http://software-lab.org/people/Michael_Pradel.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelpradel/06ef7ed7-0982-404f-8261-5188acacd15f/small.jpg</picture_url>
          <person_id>michaelpradel</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Sophia</first_name>
          <last_name>Drossopoulou</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Professor of Programming Languages in the Department of Computing, Imperial College, London, UK.</bio>
          <homepage_url>https://wp.doc.ic.ac.uk/sd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sophiadrossopoulou/f9f2890b-55bd-4796-94ab-fe3291277c90/small.jpg</picture_url>
          <person_id>sophiadrossopoulou</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0ae64c62-37ee-4421-8dc9-1d0b09cab129</slot_id>
      <event_id>a4f48195-d136-4257-a4b0-1e97c5e1b2b3</event_id>
      <title>A Systematic Approach to Deriving Incremental Type Checkers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:40</end_time>
      <description>Static typing can guide programmers if feedback is immediate. Therefore, all major IDEs incrementalize type checking in some way. However, prior approaches to incremental type checking are often specialized and hard to transfer to new type systems. In this paper, we propose a systematic approach for deriving incremental type checkers from textbook-style type system specifications. Our approach is based on compiling inference rules to Datalog, a carefully limited logic programming language for which incremental solvers exist. The key contribution of this paper is to discover an encoding of the infinite typing relation as a finite Datalog relation in a way that yields efficient incremental updates. We implemented the compiler as part of a type system DSL and show that it supports simple types, some local type inference, operator overloading, universal types, and iso-recursive types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>André</first_name>
          <last_name>Pacak</last_name>
          <affiliation>Johannes Gutenberg University Mainz, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/andrepacak/7e35f14d-4d06-4a19-8ab8-bc24c2ce8145/small.jpg</picture_url>
          <person_id>andrepacak</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sebastian</first_name>
          <last_name>Erdweg</last_name>
          <affiliation>Johannes Gutenberg University Mainz, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.pl.informatik.uni-mainz.de/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sebastianerdweg/cc4515b1-cefa-4dee-a915-3242f337c8d8/small.jpg</picture_url>
          <person_id>sebastianerdweg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tamás</first_name>
          <last_name>Szabó</last_name>
          <affiliation>Johannes Gutenberg University Mainz, Germany / itemis, Germany</affiliation>
          <bio>Tamás Szabó works as a Software Engineer for itemis in Stuttgart, and he is a PhD student at JGU Mainz. His focus is on DSLs, incremental computing, and static program analysis.</bio>
          <homepage_url>https://szabta89.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tamasszabo/545a3e41-bc8c-47e6-b801-caf7074137ce/small.jpg</picture_url>
          <person_id>tamasszabo</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4d15f386-fbe8-470a-ae21-4fa812e38b3f</slot_id>
      <event_id>b4bfae0b-6b5f-4ee8-9432-65f91d8c51a9</event_id>
      <title>A Structural Model for Contextual Code Changes</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:20</end_time>
      <description>We address the problem of predicting \emph{edit completions} based on a learned model that was trained on past edits. Given a code snippet that is partially edited, our goal is to predict a \emph{completion of the edit for the rest of the snippet}. We refer to this task as the \sname{EditCompletion} task and present a novel approach for tackling it. % The main idea is to directly represent structural edits. This allows us to model the likelihood of the edit itself, rather than learning the likelihood of the edited code. We represent an edit operation as a path in the program's Abstract Syntax Tree (AST), originating from the source of the edit to the target of the edit. Using this representation, we present a powerful and lightweight neural model for the \sname{EditCompletion} task. 
We conduct a thorough evaluation, comparing our approach to a variety of representation and modeling approaches that are driven by multiple strong models such as LSTMs, Transformers, and neural CRFs. Our experiments show that our model achieves a 28% relative gain over state-of-the-art sequential models and $2\times$ higher accuracy than syntactic models that learn to generate the edited \emph{code}, as opposed to modeling the \emph{edits} directly. 
Our code, dataset, and trained models are publicly available at \url{https://github.com/tech-srl/c3po/} .</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shaked</first_name>
          <last_name>Brody</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/people/shakedbr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shakedbrody/54e00e02-0977-4227-be70-21858a5e5626/small.jpg</picture_url>
          <person_id>shakedbrody</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Uri</first_name>
          <last_name>Alon</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~urialon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/urialon/a0488e4f-5173-472b-af25-10666c27e3d4/small.jpg</picture_url>
          <person_id>urialon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>Eran Yahav is an associate professor at the Computer Science Department, Technion, Israel. Prior to that, he was a research staff member at the IBM T.J. Watson Research Center (2004-2010). He received his Ph.D. from Tel Aviv University (2005) and his B.Sc. from the Technion in 1996. His research interests include program analysis, program synthesis and program verification. Eran is a recipient of the prestigious Alon Fellowship for Outstanding Young Researchers, the Andre Deloro Career Advancement Chair in Engineering, the ERC Consolidator Grant as well as multiple best paper awards at various conferences.</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
          <person_id>eranyahav</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>796c14f4-5186-4a91-ad57-55512b4f4fef</slot_id>
      <event_id>4a70ed09-84fe-4afe-8c78-338a350d3ab8</event_id>
      <title>Detecting Locations in JavaScript Programs Affected by Breaking Library Changes</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>14:00</end_time>
      <description>JavaScript libraries are widely used and evolve rapidly. When adapting client code to non-backwards compatible changes in libraries, a major challenge is how to locate affected API uses in client code, which is currently a difficult manual task. In this paper we address this challenge by introducing a simple pattern language for expressing API access points and a pattern-matching tool based on lightweight static analysis. 
Experimental evaluation on 15 popular npm packages shows that typical breaking changes are easy to express as patterns. Running the static analysis on 265 clients of these packages shows that it is accurate and efficient: it reveals usages of breaking APIs with only 14% false positives and no false negatives, and takes less than a second per client on average. In addition, the analysis is able to report its confidence, which makes it easier to identify the false positives. These results suggest that the approach, despite its simplicity, can reduce the manual effort of the client developers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anders</first_name>
          <last_name>Møller</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
          <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
          <person_id>andersmoller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Benjamin Barslev</first_name>
          <last_name>Nielsen</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/benjaminbarslevnielsen/7c6acacc-eb83-4ad2-8f27-d9a7ce64e58e/small.jpg</picture_url>
          <person_id>benjaminbarslevnielsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Martin</first_name>
          <last_name>Toldam Torp</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/martintoldamtorp/692a65a1-9fc3-4bbf-920b-3b1f2c438848/small.jpg</picture_url>
          <person_id>martintoldamtorp</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e2bacf67-89d8-4ff1-b670-07da55823b60</slot_id>
      <event_id>64606eb7-ae14-4006-a27c-2e3b6b5b5c6c</event_id>
      <title>A Type-and-Effect System for Object Initialization</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>14:20</end_time>
      <description>Every newly created object goes through several initialization states: starting from a state where all fields are uninitialized until all of them are assigned. Any operation on the object during its initialization process, which usually happens in the constructor via \emph{this}, has to observe the initialization states of the object for correctness, i.e.~only initialized fields may be used. Checking safe usage of \emph{this} statically, without manual annotation of initialization states in the source code, is a challenge, due to aliasing and virtual method calls on \emph{this}. 
Mainstream languages either do not check initialization errors, such as Java, C++, Scala, or they defend against them by not supporting useful initialization patterns, such as Swift. In parallel, past research has shown that safe initialization can be achieved for varying degrees of expressiveness but by sacrificing syntactic simplicity. 
We approach the problem by upholding \emph{local reasoning about initialization} which avoids whole-program analysis, and we achieve \emph{typestate polymorphism} via subtyping. On this basis, we put forward a novel type-and-effect system that can effectively ensure initialization safety while allowing flexible initialization patterns. We implement an initialization checker in the Scala 3 compiler and evaluate on several real-world projects.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fengyun</first_name>
          <last_name>Liu</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>I’m a PhD student at EPFL, working on Scala.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/fengyunliu/7967ca32-789c-44f7-a256-c5eae78909c1/small.jpg</picture_url>
          <person_id>fengyunliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aggelos</first_name>
          <last_name>Biboudis</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>Software engineer and computer science addict; researcher at heart, excited about extensibility of software, code generation and performance 
 
 Working on frameworks and tools for Data, Analytics &amp;amp; AI @Swisscom 
 Ex-researcher on Scala 3 @ LAMP/@EPFL 
 PhD from @dit_uoa 
 
@biboudis</bio>
          <homepage_url>http://biboudis.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aggelosbiboudis/89ee406d-41be-466b-a4e8-bf4c6aef486d/small.jpg</picture_url>
          <person_id>aggelosbiboudis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Paolo G.</first_name>
          <last_name>Giarrusso</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/paologgiarrusso/e3132edd-aa91-4b50-bd1f-5c280e08256c/small.jpg</picture_url>
          <person_id>paologgiarrusso</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Martin</first_name>
          <last_name>Odersky</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>Martin Odersky is a professor at EPFL in Lausanne, Switzerland. He has been working on programming languages for most of his career. He first studied structured and object-oriented programming as a PhD student of Niklaus Wirth, then fell in love with functional programming while working as a post doc at IBM and Yale. When Java came out, he started to add functional programming constructs to the new platform. This led to Pizza and GJ and eventually to Java 5 with generics. During that time he also developed javac, the current reference compiler for Java. 
Over the last 10 years, Martin worked on unifying object-oriented and functional programming in the Scala language. Scala quickly escaped from the research lab and became a popular open source tool and industrial language. He now oversees development of Scala as head of the programming group at EPFL and as academic director of the Scala center.</bio>
          <homepage_url>http://lampwww.epfl.ch/~odersky/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/martinodersky/fc1dd696-d0d4-47cb-9d9a-bba012d98f9e/small.jpg</picture_url>
          <person_id>martinodersky</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f48e8510-6c51-40d5-9190-e731d1ed3cbe</subevent_id>
    <title>SPLASH OOPSLA: T-6B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>e195dfce-f831-4ce7-8730-f29fce360c59</slot_id>
      <title>Session: SPLASH OOPSLA - T-6B</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Todd</first_name>
          <last_name>Millstein</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am a Professor in the Computer Science Department at the University of California, Los Angeles (UCLA). 
I was the Program Chair for OOPSLA 2014.</bio>
          <homepage_url>http://www.cs.ucla.edu/~todd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/toddmillstein/03692d64-e4ad-4fb1-a2b0-9271ce27715c/small.jpg</picture_url>
          <person_id>toddmillstein</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Manu</first_name>
          <last_name>Sridharan</last_name>
          <affiliation>University of California at Riverside, USA</affiliation>
          <bio>I’m an associate professor at the University of California, Riverside. Previously I worked at IBM Research, Samsung Research, and Uber. My research focuses on developing tools and techniques to make large-scale software more reliable, performant, secure, and maintainable. For more details, see my homepage.</bio>
          <homepage_url>http://manu.sridharan.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manusridharan/00859147-2155-45a9-9a48-7565ce5356ac/small.jpg</picture_url>
          <person_id>manusridharan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>611207e7-2a2f-4c07-aff9-b31143c3f4a8</slot_id>
      <event_id>d9f820f7-6c4c-4457-bbf2-f791d2e1d42d</event_id>
      <title>World Age in Julia: Optimizing Method Dispatch in the Presence of Eval</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>17:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>18:00</end_time>
      <description>Dynamic programming languages face semantic and performance challenges in the presence of features, such as eval, that can inject new code into a running program. The Julia programming language introduces the novel concept of world age to insulate optimized code from one of the most disruptive side-effects of eval: changes to the definition of an existing function. This paper provides the first formal semantics of world age in a core calculus named juliette, and shows how world age enables compiler optimizations, such as inlining, in the presence of eval. While Julia also provides programmers with the means to bypass world age, we found that this mechanism is not used extensively: a static analysis of over 4,000 registered Julia packages shows that only 4-9% of packages bypass world age. This suggests that Julia's semantics aligns with programmer expectations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julia</first_name>
          <last_name>Belyakova</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>Sep 2018 – present: PhD Student, Northeastern University, USA. Sep 2017 – Jul 2018: Researcher, Czech Technical University in Prague, Czech Republic. Jan 2017 – Jun 2017: Research Scientist, Northeastern University, USA. 2014–2016: teaching assistant/lecturer at Southern Federal University, Russia. Received MS in Computer Science from Southern Federal University, Russia in 2014.</bio>
          <homepage_url>https://julbinb.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juliabelyakova/b35236df-c22a-44f1-8048-aecfeba8ac2e/small.jpg</picture_url>
          <person_id>juliabelyakova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Chung</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/benjaminchung/30978af0-bcee-4c1e-9dd1-f2588ea14f38/small.jpg</picture_url>
          <person_id>benjaminchung</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jack</first_name>
          <last_name>Gelinas</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/jackgelinas/f0a65e20-3150-4f2b-bc96-82364dbc2f2c/small.jpg</picture_url>
          <person_id>jackgelinas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jameson</first_name>
          <last_name>Nash</last_name>
          <affiliation>Julia Computing, n.n.</affiliation>
          <bio>undefined</bio>
          <person_id>jamesonnash1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ross</first_name>
          <last_name>Tate</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cornell.edu/~ross/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rosstate/cbcbd066-943d-46a2-a301-1f4084076400/small.jpg</picture_url>
          <person_id>rosstate</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University, USA / Czech Technical University, Czechia</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>68625d2d-4816-435c-af09-e21a3482e96b</slot_id>
      <event_id>9d2e80dd-45d0-4797-be3b-2ed373dc14dd</event_id>
      <title>DynamiTe: Dynamic Termination and Non-termination Proofs</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>17:20</end_time>
      <description>There is growing interest in termination reasoning for nonlinear programs and, meanwhile, recent dynamic strategies have shown they are able to infer invariants for such challenging programs. These advances led us to hypothesize that perhaps such dynamic strategies for nonlinear invariants could be adapted to learn recurrent sets (for non-termination) and/or ranking functions (for termination). 
In this paper, we exploit dynamic analysis and draw termination and non-termination as well as static and dynamic strategies closer together in order to tackle nonlinear programs. For termination, our algorithm infers ranking functions from concrete transitive closures, and, for non-termination, the algorithm iteratively collects executions and dynamically learns conditions to refine recurrent sets. Finally, we describe an integrated algorithm that allows these algorithms to mutually inform each other, taking counterexamples from a failed validation in one endeavor and crossing both the static/dynamic and termination/non-termination lines, to create new execution samples for the other one. 
We have implemented these algorithms in a new tool called DynamiTe. For nonlinear programs, there are currently no SV-COMP termination benchmarks so we created new sets of 38 terminating and 39 non-terminating programs. Our empirical evaluation shows that we can effectively guess (and sometimes even validate) ranking functions and recurrent sets for programs with nonlinear behaviors. Furthermore, we show that counterexamples from one failed validation can be used to generate executions for a dynamic analysis of the opposite property. Although we are focused on nonlinear programs, as a point of comparison, we compare DynamiTe's performance on linear programs with that of the state-of-the-art tool, Ultimate. Although DynamiTe is an order of magnitude slower it is nonetheless somewhat competitive and sometimes finds ranking functions where Ultimate was unable to. Ultimate cannot, however, handle the nonlinear programs in our new benchmark suite.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ton Chanh</first_name>
          <last_name>Le</last_name>
          <affiliation>Stevens Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://chanhle.bitbucket.io/</homepage_url>
          <person_id>tonchanhle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Timos</first_name>
          <last_name>Antonopoulos</last_name>
          <affiliation>Yale University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>timosantonopoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Parisa</first_name>
          <last_name>Fathololumi</last_name>
          <affiliation>Stevens Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>parisafathololumi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Eric</first_name>
          <last_name>Koskinen</last_name>
          <affiliation>Stevens Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.stevens.edu/~ejk/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/erickoskinen/3413fc94-5f0f-4855-af65-da2309d2632f/small.jpg</picture_url>
          <person_id>erickoskinen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>ThanhVu</first_name>
          <last_name>Nguyen</last_name>
          <affiliation>University of Nebraska-Lincoln, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cse.unl.edu/~tnguyen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/thanhvunguyen/db337089-c863-4086-ad33-88d7dbfeb025/small.jpg</picture_url>
          <person_id>thanhvunguyen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e96dcbdc-5663-40c0-b4fc-fdc3042423c6</slot_id>
      <event_id>df17fa6a-2bc8-41ee-8c02-85f4a68c1db1</event_id>
      <title>Programming and Reasoning with Partial Observability</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>17:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>17:40</end_time>
      <description>Computer programs are increasingly being deployed in partially-observable environments. A partially observable environment is an environment whose state is not completely visible to the program, but from which the program receives partial observations. Developers typically deal with partial observability by writing a state estimator that, given observations, attempts to deduce the hidden state of the environment. In safety-critical domains, to formally verify safety properties developers may write an environment model. The model captures the relationship between observations and hidden states and is used to prove the software correct. 
In this paper, we present a new methodology for writing and verifying programs in partially observable environments. We present {\em belief programming}, a programming methodology where developers write an environment model that the program runtime automatically uses to perform state estimation. A belief program dynamically updates and queries a belief state that captures the possible states the environment could be in. To enable verification, we present {\em Epistemic Hoare logic} that reasons about the possible belief states of a belief program the same way that classical Hoare logic reasons about the possible states of a program. We develop these concepts by defining a semantics and a program logic for a simple core language called BLIMP. In a case study, we show how belief programming could be used to write and verify a controller for the Mars Polar Lander in BLIMP. We present an implementation of BLIMP called CBLIMP and evaluate it to determine the feasibility of belief programming.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Atkinson</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>ericatkinson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology. 
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems. 
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fa780211-58c4-4eca-9a78-439375c966a2</slot_id>
      <event_id>c46ee935-d61f-4ade-a84a-9db9d88c737e</event_id>
      <title>Featherweight Go</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/17</date>
      <start_time>18:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>18:20</end_time>
      <description>We describe a design for generics in Go inspired by previous work on Featherweight Java by Igarashi, Pierce, and Wadler. Whereas subtyping in Java is nominal, in Go it is structural, and whereas generics in Java are defined via erasure, in Go we use monomorphisation. Although monomorphisation is widely used, we are one of the first to formalise it. Our design also supports a solution to The Expression Problem.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Griesemer</last_name>
          <affiliation>Google, USA</affiliation>
          <bio>undefined</bio>
          <person_id>robertgriesemer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Raymond</first_name>
          <last_name>Hu</last_name>
          <affiliation>University of Hertfordshire, UK</affiliation>
          <bio>undefined</bio>
          <person_id>raymondhu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Wen</first_name>
          <last_name>Kokke</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wenkokke.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/wenkokke/756e11ff-851e-4355-865b-0b5ce896d4af/small.jpg</picture_url>
          <person_id>wenkokke</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Julien</first_name>
          <last_name>Lange</last_name>
          <affiliation>Royal Holloway University of London, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.rhul.ac.uk/~jlange</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/julienlange1/7f3ad551-a3e6-46ce-9718-954f3147736b/small.jpg</picture_url>
          <person_id>julienlange1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ian Lance</first_name>
          <last_name>Taylor</last_name>
          <affiliation>Google, n.n.</affiliation>
          <bio>undefined</bio>
          <person_id>ianlancetaylor</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Bernardo</first_name>
          <last_name>Toninho</last_name>
          <affiliation>Nova University of Lisbon, Portugal / NOVA-LINCS, Portugal</affiliation>
          <bio>I am interested in the application of language-based techniques to the development of more robust and safer concurrent and distributed systems. More specifically, I work within the realm of (substructural) type theory, such as those based on Linear Logic and Session Types, and their applications to concurrent programming. I am also interested in using type and logic-based techniques to verify concurrent programs in real languages such as Go, Rust and Scala.</bio>
          <homepage_url>http://ctp.di.fct.unl.pt/~btoninho/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/bernardotoninho/1125bc54-0549-4ee4-bf19-394d89568c34/small.jpg</picture_url>
          <person_id>bernardotoninho</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Philip</first_name>
          <last_name>Wadler</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>Philip Wadler is Professor of Theoretical Computer Science at the University of Edinburgh. He is an ACM Fellow and a Fellow of the Royal Society of Edinburgh, past chair of ACM SIGPLAN, past holder of a Royal Society-Wolfson Research Merit Fellowship, winner of the SIGPLAN Distinguished Service Award, and a winner of the POPL Most Influential Paper Award. Previously, he worked or studied at Stanford, Xerox Parc, CMU, Oxford, Chalmers, Glasgow, Bell Labs, and Avaya Labs, and visited as a guest professor in Copenhagen, Sydney, and Paris. He has an h-index of 60, with more than 20,000 citations to his work according to Google Scholar. He contributed to the designs of Haskell, Java, and XQuery, and is a co-author of Introduction to Functional Programming (Prentice Hall, 1988), XQuery from the Experts (Addison Wesley, 2004) and Generics and Collections in Java (O’Reilly, 2006). He has delivered invited talks in locations ranging from Aizu to Zurich.</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/wadler/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philipwadler/55a9683e-908b-4052-9d49-20fb795c74cf/small.jpg</picture_url>
          <person_id>philipwadler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e07e42e5-e07a-4c98-9486-1bc09733092a</subevent_id>
    <title>SPLASH OOPSLA: W-6</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>880b3411-9ab7-495f-9c93-9e571d964bf2</slot_id>
      <title>Session: SPLASH OOPSLA - W-6</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Wickerson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Lecturer in the Department of Electrical and Electronic Engineering at Imperial College London.</bio>
          <homepage_url>http://johnwickerson.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnwickerson/e74d4ce8-1ae7-4f7a-a53d-0aa35c361396/small.jpg</picture_url>
          <person_id>johnwickerson</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2f5f7c3e-d7eb-4169-bfeb-f4de31ea32bd</slot_id>
      <event_id>5ded2007-1aa2-4b18-800b-2c660a495cca</event_id>
      <title>CompCertELF: Verified Separate Compilation of C Programs into ELF Object Files</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>06:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>06:20</end_time>
      <description>&amp;lt;p&amp;gt; We present CompCertELF, the first extension to CompCert that supports verified compilation from C programs all the way to a standard binary file format, i.e., the ELF object format. Previous work on Stack-Aware CompCert provides a verified compilation chain from C programs to assembly programs with a realistic machine memory model. We build CompCertELF by modifying and extending this compilation chain with a verified assembler which further transforms assembly programs into ELF object files. &amp;lt;/p&amp;gt; 
&amp;lt;p&amp;gt; CompCert supports large-scale verification via verified separate compilation: C modules can be written and compiled separately, and then linked together to get a target program that refines the semantics of the program linked from the source modules. However, verified separate compilation in CompCert only works for compilation to assembly programs, not to object files. For the latter, the main difficulty is to bridge the two different views of linking: one for CompCert's programs that allows arbitrary shuffling of global definitions by linking and the other for object files that treats blocks of encoded definitions as indivisible units. &amp;lt;/p&amp;gt; 
&amp;lt;p&amp;gt; We propose a lightweight approach that solves the above problem without any modification to CompCert's framework for verified separate compilation: by introducing a notion of syntactical equivalence between programs and proving the commutativity between syntactical equivalence and the two different kinds of linking, we are able to transit from the more abstract linking operation in CompCert to the more concrete one for ELF object files. By applying this approach to CompCertELF, we obtain the first compiler that supports verified separate compilation of C programs into ELF object files. &amp;lt;/p&amp;gt;</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuting</first_name>
          <last_name>Wang</last_name>
          <affiliation>Shanghai Jiao Tong University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jhc.sjtu.edu.cn/~yutingwang/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yutingwang/963979f5-1f61-418e-9435-0abbb408ef37/small.jpg</picture_url>
          <person_id>yutingwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xiangzhe</first_name>
          <last_name>Xu</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <person_id>xiangzhexu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pierre</first_name>
          <last_name>WILKE</last_name>
          <affiliation>CentraleSupélec, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pwilke.fr/pwilke-en.html</homepage_url>
          <person_id>pierrewilke1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhong</first_name>
          <last_name>Shao</last_name>
          <affiliation>Yale University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/shao/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhongshao/18a2973a-020f-46ed-9073-85bd70626116/small.jpg</picture_url>
          <person_id>zhongshao</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6262dca6-b624-4ac2-a735-3aec7b558e96</slot_id>
      <event_id>7d597c02-ff5f-4db1-a3f8-2f251a9ca0a5</event_id>
      <title>Sound Garbage Collection for C using Pointer Provenance</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>05:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>05:40</end_time>
      <description>Garbage collection (GC) support for unmanaged languages can reduce programming burden in reasoning about liveness of dynamic objects. It also avoids temporal memory safety violations and memory leaks. {\em Sound} GC for weakly-typed languages such as C/C++, however, remains an unsolved problem. Current value-based GC solutions examine values of memory locations to discover the pointers, and the objects they point to. The approach is inherently unsound in the presence of arbitrary type casts and pointer manipulations, which are legal in C/C++. Such language features are regularly used, especially in low-level systems code. 
In this paper, we propose Dynamic Pointer Provenance Tracking to realize sound GC. We observe that pointers cannot be created out-of-thin-air, and they must have provenance to at least one valid allocation. Therefore, by tracking pointer provenance from the source (e.g., \texttt{malloc}) through both explicit data-flow and implicit control-flow, our GC has sound and precise information to compute the set of all reachable objects at any program state. We discuss several static analysis optimizations, that can be employed during compilation aided with profiling, to significantly reduce the overhead of dynamic provenance tracking from nearly $8\times$ to 16% for well-behaved programs that adhere to the C standards. Pointer provenance based sound GC invocation is also 13% faster and reclaims 6% more memory on average, compared to an unsound value-based GC.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Subarno</first_name>
          <last_name>Banerjee</last_name>
          <affiliation>University of Michigan, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.eecs.umich.edu/~subarno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/subarnobanerjee/56075c15-14b6-4177-b624-840d0b02cf22/small.jpg</picture_url>
          <person_id>subarnobanerjee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Devecsery</last_name>
          <affiliation>Georgia Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>daviddevecsery</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter M.</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Michigan, USA</affiliation>
          <bio>undefined</bio>
          <person_id>petermchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Satish</first_name>
          <last_name>Narayanasamy</last_name>
          <affiliation>University of Michigan, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.eecs.umich.edu/~nsatish/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/satishnarayanasamy/cedfbed8-4f1b-40b0-afdd-135766659f94/small.jpg</picture_url>
          <person_id>satishnarayanasamy</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c00e2959-97c4-4755-9428-2dd43b6fd83f</slot_id>
      <event_id>4d0f5a86-a761-438e-b9c1-1c44f16d89f9</event_id>
      <title>Semiring Optimizations: Dynamic Elision of Expressions with Identity and Absorbing Elements</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>05:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>06:00</end_time>
      <description>This paper describes a compiler optimization to eliminates dynamic occurrences of expressions in the format $a \leftarrow a \oplus b \otimes c$. The operation $\oplus$ must admit an identity element $z$, such that $a \oplus z = a$. Also, $z$ must be the absorbing element of $\otimes$, such that $b \otimes z = z \otimes c = z$. Semirings where $\oplus$ is the additive operator and $\otimes$ is the multiplicative operator meet this contract. This pattern is common in high-performance benchmarks—its canonical representative being the multiply-add operation $a \leftarrow a + b \times c$. However, several other expressions involving arithmetic and logic operations satisfy the required algebra. We show that the runtime elimination of such assignments can be implemented in a performance-safe way via online profiling. The elimination of dynamic redundancies involving identity and absorbing elements in 35 programs of the LLVM test suite that present semiring patterns brings an average speedup of 1.19x (total optimized time over total unoptimized time) on top of clang -O3. When projected onto the entire test suite (259 programs) the optimization leads to a speedup of 1.025x. Once added onto \texttt{clang}, semiring optimizations approximates it to TACO, a specialized tensor compiler.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guilherme Vieira</first_name>
          <last_name>Leobas</last_name>
          <affiliation>Federal University of Minas Gerais, Brazil</affiliation>
          <bio>undefined</bio>
          <person_id>guilhermeleobas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fernando Magno Quintão</first_name>
          <last_name>Pereira</last_name>
          <affiliation>Federal University of Minas Gerais, Brazil</affiliation>
          <bio>Fernando got his Ph.D at UCLA in 2008, under the supervision of Jens Palsberg. He is currently an assistant professor at the Universidade Federal de Minas Gerais, Brazil. His main research interest are in code generation, compiler optimizations and static program analyses.</bio>
          <homepage_url>http://homepages.dcc.ufmg.br/~fernando/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/fernandomagnoquintaopereira/8f86b14f-fbc3-49a4-9f4f-1a8216564d39/small.jpg</picture_url>
          <person_id>fernandomagnoquintaopereira</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fb5f5644-bc1f-4b5f-80fe-d2982ae0d407</slot_id>
      <event_id>1ba9a54b-ae12-41da-8d16-8c37c6ab299d</event_id>
      <title>Programming with a Read-Eval-Synth Loop</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>05:20</end_time>
      <description>A frequent programming pattern for small tasks, especially expressions, is to repeatedly evaluate the program on an input as its editing progresses. The Read-Eval-Print Loop (REPL) interaction model has been a successful model for this programming pattern. We present the new notion of Read-Eval-Synth Loop (RESL) that extends REPL by providing in-place synthesis on parts of the expression marked by the user. RESL eases programming by synthesizing parts of a required solution. The underlying synthesizer relies on a partial solution from the programmer and a few examples. 
RESL hinges on bottom-up synthesis with general predicates and sketching, generalizing programming by example. To make RESL practical, we present a formal framework that extends observational equivalence to non-example specifications. 
We evaluate RESL by conducting a controlled within-subjects user-study on $19$ programmers from $8$ companies, where programmers are asked to solve a small but challenging set of competitive programming problems. We find that programmers using RESL solve these problems with far less need to edit the code themselves and by browsing documentation far less. In addition, they are less likely to leave a task unfinished and more likely to be correct.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roi</first_name>
          <last_name>Gabay</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <person_id>roigabay</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Shachar</first_name>
          <last_name>Itzhaky</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~shachari</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shacharitzhaky/649d5921-4057-4ac3-8fc7-75471ee8527b/small.jpg</picture_url>
          <person_id>shacharitzhaky</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>Eran Yahav is an associate professor at the Computer Science Department, Technion, Israel. Prior to that, he was a research staff member at the IBM T.J. Watson Research Center (2004-2010). He received his Ph.D. from Tel Aviv University (2005) and his B.Sc. from the Technion in 1996. His research interests include program analysis, program synthesis and program verification. Eran is a recipient of the prestigious Alon Fellowship for Outstanding Young Researchers, the Andre Deloro Career Advancement Chair in Engineering, the ERC Consolidator Grant as well as multiple best paper awards at various conferences.</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
          <person_id>eranyahav</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>23f2e99f-8c5e-478e-b2cb-27de9e275008</subevent_id>
    <title>SPLASH OOPSLA: T-5</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>3a1528a0-9458-49d9-b097-4bbfd79fa0eb</slot_id>
      <title>Session: SPLASH OOPSLA - T-5</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Burcu</first_name>
          <last_name>Kulahcioglu Ozkan</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://burcuku.github.io/home/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/burcukulahciogluozkan/4a854b1d-126f-47f5-8935-25d6401437c4/small.jpg</picture_url>
          <person_id>burcukulahciogluozkan</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Reuben</first_name>
          <last_name>Rowe</last_name>
          <affiliation>University College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www0.cs.ucl.ac.uk/staff/r.rowe/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/reubenrowe/88fe0ddc-2847-4a93-8fe2-6e9aa9c8a1ff/small.jpg</picture_url>
          <person_id>reubenrowe</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>47fbf813-ea4a-4456-8e48-84bea0c9c182</slot_id>
      <event_id>52f9bfff-ac06-47f4-98ba-4a5085ecbf7b</event_id>
      <title>Fuzzing Channel-Based Concurrency Runtimes using Types and Effects</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>04:00</end_time>
      <description>Modern programming languages support concurrent programming based on channels and processes. Channels enable synchronous and asynchronous message-passing between independent light-weight processes making it easy to express common concurrency patterns. The implementation of channels and processes in compilers and language runtimes is a difficult task that relies heavily on traditional and error-prone low-level concurrency primitives, raising concerns about correctness and reliability. In this paper, we present an automatic program generation technique to test such programming language implementations. We define a type and effect system for programs that communicate over channels and where every execution is guaranteed to eventually terminate. We can generate and run such programs, and if a program fails to terminate, we have found a bug in the programming language implementation. We implement such an automatic program generator and apply it to Go, Kotlin, Crystal, and Flix. We find two new bugs in Flix, and reproduce two bugs; one in Crystal and one in Kotlin.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Quentin</first_name>
          <last_name>Stiévenart</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/~qstieven</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/quentinstievenart/7d195a5f-4ea9-4d26-a55f-2b8d1c5853b8/small.jpg</picture_url>
          <person_id>quentinstievenart</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4fbe8ed9-8e8f-4e41-a602-f2bdeea416f7</slot_id>
      <event_id>b7403f22-9ce1-4712-b204-3d56213b53b9</event_id>
      <title>Regex Matching with Counting-Set Automata</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>04:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>04:20</end_time>
      <description>We propose a solution to the problem of efficient matching regular expressions (regexes) with bounded repetition, such as $\texttt{(ab){1,100}}$, using deterministic automata. For this, we introduce novel \emph{counting-set automata (CsAs)}, automata with registers that can hold sets of bounded integers and can be manipulated by a limited portfolio of constant-time operations. We present an algorithm that compiles a large sub-class of regexes to deterministic CsAs. This includes (1) a novel Antimirov-style translation of regexes with counting to \emph{counting automata (CAs)}, nondeterministic automata with bounded counters, and (2) our main technical contribution, a determinization of CAs that outputs CsAs. The main advantage of this workflow is that \emph{the size of the produced CsAs does not depend on the repetition bounds used in the regex} (while the size of the DFA is exponential to them). Our experimental results confirm that deterministic CsAs produced from practical regexes with repetition are indeed vastly smaller than the corresponding DFAs. More importantly, our prototype matcher based on CsA simulation handles practical regexes with repetition regardless of sizes of counter bounds. It easily copes with regexes with repetition where state-of-the-art matchers struggle.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lenka</first_name>
          <last_name>Turoňová</last_name>
          <affiliation>Brno University of Technology, Czechia</affiliation>
          <bio>undefined</bio>
          <person_id>lenkatoronova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lukáš</first_name>
          <last_name>Holík</last_name>
          <affiliation>Brno University of Technology, Czechia</affiliation>
          <bio>undefined</bio>
          <person_id>lukasholik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ondrej</first_name>
          <last_name>Lengal</last_name>
          <affiliation>Brno University of Technology, Czechia</affiliation>
          <bio>Ph.D. (2015) Brno University of Technology</bio>
          <homepage_url>http://www.fit.vutbr.cz/~lengal</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlengal/3f99d935-777e-4b43-9494-5cfc0fe8894b/small.jpg</picture_url>
          <person_id>ondrejlengal</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Olli</first_name>
          <last_name>Saarikivi</last_name>
          <affiliation>Microsoft Research, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/ollisaarikivi2/3e6d3eb8-2ea9-456c-9c3d-76fe37bd855c/small.jpg</picture_url>
          <person_id>ollisaarikivi2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Margus</first_name>
          <last_name>Veanes</last_name>
          <affiliation>Microsoft Research, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/margusveanes/a5174253-0401-46f7-aff1-e92a3a3ace77/small.jpg</picture_url>
          <person_id>margusveanes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tomas</first_name>
          <last_name>Vojnar</last_name>
          <affiliation>Brno University of Technology, Czechia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fit.vutbr.cz/~vojnar</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomasvojnar/6b1ea9ee-acf7-413d-be4d-431c460af426/small.jpg</picture_url>
          <person_id>tomasvojnar</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8292c782-368f-4b84-8a0d-0b13e3a9dde5</slot_id>
      <event_id>d0b39515-659e-4855-a1b2-516ee32b0539</event_id>
      <title>Knowing When to Ask: Sound Scheduling of Name Resolution in Type Checkers Derived from Declarative Specifications</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>03:40</end_time>
      <description>There is a large gap between the specification of type systems and the implementation of their type checkers, which impedes reasoning about the soundness of the type checker with respect to the specification. A vision to close this gap is to automatically obtain type checkers from declarative programming language specifications. This moves the burden of proving correctness from a case-by-case basis for concrete languages to a single correctness proof for the specification language. This vision is obstructed by an aspect common to all programming languages: name resolution. Naming and scoping are pervasive and complex aspects of the static semantics of programming languages. Implementations of type checkers for languages with name binding features such as modules, imports, classes, and inheritance interleave collection of binding information (i.e., declarations, scoping structure, and imports) and querying that information. This requires scheduling those two aspects in such a way that query answers are stable—i.e., they are computed only after all relevant binding structure has been collected. Type checkers for concrete languages accomplish stability using language-specific knowledge about the type system. 
In this paper we give a language-independent characterization of necessary and sufficient conditions to guarantee stability of name and type queries during type checking in terms of \emph{critical edges in an incomplete scope graph}. We use critical edges to give a formal small-step operational semantics to a declarative specification language for type systems, that achieves soundness by delaying queries that may depend on missing information. This yields type checkers for the specified languages that are sound by construction—i.e., they schedule queries so that the answers are stable, and only accept programs that are name- and type-correct according to the declarative language specification. We implement this approach, and evaluate it against specifications of a small module and record language, as well as subsets of Java and Scala.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Arjen</first_name>
          <last_name>Rouvoet</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ajrouvoet.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjenrouvoet/72c0e303-43d5-4252-a170-5b61600fac4d/small.jpg</picture_url>
          <person_id>arjenrouvoet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hendrik</first_name>
          <last_name>van Antwerpen</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hendrik.van-antwerpen.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hendrikvanantwerpen/2d3f530b-7183-483e-b3b6-80dd4159a4bd/small.jpg</picture_url>
          <person_id>hendrikvanantwerpen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Casper</first_name>
          <last_name>Bach Poulsen</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://casperbp.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/casperbachpoulsen/2cddd6a9-d920-4f73-9fcf-f4d9462eb0e3/small.jpg</picture_url>
          <person_id>casperbachpoulsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Robbert</first_name>
          <last_name>Krebbers</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://robbertkrebbers.nl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/robbertkrebbers/7c0562b5-da08-4f27-aa28-918e54dcaf3d/small.jpg</picture_url>
          <person_id>robbertkrebbers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science at Delft University of Technology. He received a master’s and doctorate in computer science from the University of Amsterdam in 1993 and 1997, respectively. Previously he served as postdoc at the Oregon Graduate Institute, as Assistant Professor at Utrecht University, and as Associate Professor at TU Delft. 
His research interests include programming languages, software language engineering, domain-specific programming languages, program transformation, syntax definition, and parsing. With his students he has designed and implemented the Spoofax language workbench, as well as many domain-specific languages, including DSLs for syntax definition (SDF2, SDF3), program transformation (Stratego), static semantics (NaBL, Statix), dynamic semantics (DynSem), software deployment (Nix), web application development (WebDSL), and mobile phone applications (mobl). In the language designer’s workbench project he is pursuing high-level declarative language definition that serves for language implementation and verification.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ed682cc6-49fc-44b8-a0b8-f0ae97c8a189</slot_id>
      <event_id>5566f7eb-c8ea-4651-9ed7-30715f447f33</event_id>
      <title>Actor Concurrency Bugs: A Comprehensive Study on Symptoms, Root Causes, API Usages, and Differences</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>03:20</end_time>
      <description>Actor concurrency is becoming increasingly important in the development of real-world software systems. Although actor concurrency may be less susceptible to some multithreaded concurrency bugs, such as low-level data races and deadlocks, it comes with its own bugs that may be different. However, the fundamental characteristics of actor concurrency bugs, including their symptoms, root causes, API usages, examples, and differences when they come from different sources are still largely unknown. Actor software development can significantly benefit from a comprehensive qualitative and quantitative understanding of these characteristics, which is the focus of this work, to foster better API documentation, development practices, testing, debugging, repairing, and verification frameworks. To conduct this study, we take the following major steps. First, we construct a set of 186 real-world Akka actor bugs from Stack Overflow and GitHub via manual analysis of 3,924 Stack Overflow questions, answers, and comments and 3,315 GitHub commits, messages, original and modified code snippets, issues, and pull requests. Second, we manually study these actor bugs and their fixes to understand and classify their symptoms, root causes, and API usages. Third, we study the differences between the commonalities and distributions of symptoms, root causes, and API usages of our Stack Overflow and GitHub actor bugs. Fourth, we discuss real-world examples of our actor bugs with these symptoms and root causes. Finally, we investigate the relation of our findings with those of previous work and discuss their implications. A few findings of our study are: (1) symptoms of our actor bugs can be classified into five categories, with Error as the most common symptom and Incorrect Exceptions as the least common, (2) root causes of our actor bugs can be classified into ten categories, with Logic as the most common root cause and Untyped Communication as the least common, (3) a small number of Akka API packages are responsible for most of API usages by our actor bugs, and (4) our Stack Overflow and GitHub actor bugs can differ significantly in commonalities and distributions of their symptoms, root causes, and API usages. While some of our findings agree with those of previous work, others sharply contrast.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mehdi</first_name>
          <last_name>Bagherzadeh</last_name>
          <affiliation>Oakland University, USA</affiliation>
          <bio>Assistant Professor, Department of Computer Science and Engineering</bio>
          <homepage_url>https://mbagherz.bitbucket.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mehdibagherzadeh/95dc6f53-51a0-4bf1-b822-7bbe8c4d223a/small.jpg</picture_url>
          <person_id>mehdibagherzadeh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nicholas</first_name>
          <last_name>Fireman</last_name>
          <affiliation>Oakland University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>nicholasfireman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anas</first_name>
          <last_name>Shawesh</last_name>
          <affiliation>Oakland University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>anasshawesh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Raffi</first_name>
          <last_name>Khatchadourian</last_name>
          <affiliation>City University of New York (CUNY) Hunter College</affiliation>
          <bio>I am an Assistant Professor in the Department of Computer Science at Hunter College and the Graduate Center of the City University of New York (CUNY). My research is centered on techniques for automated software evolution, particularly those related to automated refactoring and source code recommendation systems. My goal is to ease the burden associated with correctly and efficiently evolving large and complex software by providing automated tools that can be easily used by developers. I am also interested in the automated analysis of Object-Oriented and Aspect-Oriented programs. 
I received my MS and Ph.D. degrees in Computer Science from Ohio State University and my BS degree in Computer Science from Monmouth University in New Jersey. Prior to joining CUNY, I was a Software Engineer at Apple, Inc. in Cupertino, California, where I worked on Digital Rights Management (DRM) for iTunes, iBooks, and the App store. I also developed distributed software that tested various features of iPhones, iPads, and iPods. You may also find more information about me by visiting my CUNY Academic Commons profile, my vita, GitHub, and my blog (you can subscribe for updates here).</bio>
          <homepage_url>http://cs.hunter.cuny.edu/~Raffi.Khatchadourian99</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/raffikhatchadourian/5c884f46-e4aa-4dc5-b581-2e37f77d320a/small.jpg</picture_url>
          <person_id>raffikhatchadourian</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>21b4a9a4-f224-4bd8-b5ba-0905f46a83cb</subevent_id>
    <title>SPLASH OOPSLA: T-2</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>f470986b-2a5a-40f0-bd9b-2f2df1ff7e96</slot_id>
      <title>Session: SPLASH OOPSLA - T-2</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>21:00</start_time>
      <end_time>22:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Yaoda</first_name>
          <last_name>Zhou</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <person_id>yaodazhou</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Iulian</first_name>
          <last_name>Neamtiu</last_name>
          <affiliation>New Jersey Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://web.njit.edu/~ineamtiu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/iulianneamtiu/59a11852-72df-4d67-9331-8720d3d19a64/small.jpg</picture_url>
          <person_id>iulianneamtiu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>809f470f-4e1d-4f3b-8fc2-11fffe24e5be</slot_id>
      <event_id>93f41bfd-9988-4002-8de8-22ce8bf00c55</event_id>
      <title>A Large-Scale Longitudinal Study of Flaky Tests</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>21:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>21:40</end_time>
      <description>Flaky tests are tests that can non-deterministically pass or fail for the same code version. These tests undermine regression testing efficiency, because developers cannot easily identify whether a test fails due to their recent changes or due to flakiness. Ideally, one would detect flaky tests right when flakiness is introduced, so that developers can then immediately remove the flakiness. Some software organizations, e.g., Mozilla and Netflix, run some tools—detectors—to detect flaky tests as soon as possible. However, detecting flaky tests is costly due to their inherent non-determinism, so even state-of-the-art detectors are often impractical to be used on all tests for each project change. To combat the high cost of applying detectors, these organizations typically run a detector solely on newly added or directly modified tests, i.e., not on unmodified tests or when other changes occur (including changes to the test suite, the code under test, and library dependencies). However, it is unclear how many flaky tests can be detected or missed by applying detectors in only these limited circumstances. 
To better understand this problem, we conduct a large-scale longitudinal study of flaky tests to determine when flaky tests become flaky and what changes cause them to become flaky. We apply two state-of-theart detectors to 55 Java projects, identifying a total of 245 flaky tests that can be compiled and run in the code version where each test was added. We find that 75% of flaky tests (184 out of 245) are flaky when added, indicating substantial potential value for developers to run detectors specifically on newly added tests. However, running detectors solely on newly added tests would still miss detecting 25% of flaky tests. The percentage of flaky tests that can be detected does increase to 85% when detectors are run on newly added or directly modified tests. The remaining 15% of flaky tests become flaky due to other changes and can be detected only when detectors are always applied to all tests. Our study is the first to empirically evaluate when tests become flaky and to recommend guidelines for applying detectors in the future.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wing</first_name>
          <last_name>Lam</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://winglam2.web.engr.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/winglam/4052f462-6ac0-4252-8c59-92a77a7c33dc/small.jpg</picture_url>
          <person_id>winglam</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stefan</first_name>
          <last_name>Winter</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>I am a postdoctoral researcher at TU Darmstadt in Germany, from where I previously obtained a Ph.D. in computer science. My research interests span a variety of topics related to the design and analysis of dependable software systems from operating system design to system-level test efficiency.</bio>
          <homepage_url>http://www.stefan-winter.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stefanwinter/b2ba53f2-c875-4cd6-b938-2152649c47bb/small.jpg</picture_url>
          <person_id>stefanwinter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anjiang</first_name>
          <last_name>Wei</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/anjiangwei/680e5627-484e-433a-be11-7fcc497f7075/small.jpg</picture_url>
          <person_id>anjiangwei</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tao</first_name>
          <last_name>Xie</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://taoxiease.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/taoxie/14ae8022-1dd6-4455-a54f-157c86bc406d/small.jpg</picture_url>
          <person_id>taoxie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Darko</first_name>
          <last_name>Marinov</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>Please see my website</bio>
          <homepage_url>http://mir.cs.illinois.edu/marinov</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/darkomarinov/715fd20e-8e93-48b7-8f26-4e80ed2aeab5/small.jpg</picture_url>
          <person_id>darkomarinov</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Bell</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>Jon is an Assistant Professor directing research in Software Engineering and Software Systems at Northeastern University. His research makes it easier for developers to create reliable and secure software by improving software testing and program analysis. Jon’s work on accelerating software testing has been recognized with an ACM SIGSOFT Distinguished Paper Award (ICSE ’14 – Unit Test Virtualization with VMVM), and was the basis for an industrial collaboration with Electric Cloud. His program analysis research has resulted in several widely adopted runtime systems for the JVM, including the Phosphor taint tracking system (OOPSLA ’14) and CROCHET checkpoint/rollback tool (ECOOP ’18). His research has been funded by the NSA and the NSF, and he is the recipient of the NSF CAREER award. At George Mason, Jon taught courses in distributed systems, web development, and program analysis. His teaching at GMU has been recognized with a departmental award. Jon serves on a variety of program committees and was recently co-chair of the PLDI 2020 Artifact Evaluation Committee. As part of his efforts to broaden the participation of underrepresented groups in computing, Jon co-organizes the PL/SE mentoring workshop at SPLASH (in 2017, 2018, 2019 and 2020).</bio>
          <homepage_url>http://jonbell.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanbell/1ef3641d-0ed6-4021-aab6-b13b53962e3d/small.jpg</picture_url>
          <person_id>jonathanbell</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ccf74489-f632-41f2-8183-7028eebbcebb</slot_id>
      <event_id>5d1aeb28-75c6-4924-8e7a-5cbbe33cfacd</event_id>
      <title>Formulog: Datalog for SMT-Based Static Analysis</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>21:20</end_time>
      <description>Satisfiability modulo theories (SMT) solving has become a critical part of many static analyses, including symbolic execution, refinement type checking, and model checking. We propose Formulog, a domain-specific language that makes it possible to write a range of SMT-based static analyses in a way that is both close to their formal specifications and amenable to high-level optimizations and efficient evaluation. 
Formulog extends the logic programming language Datalog with a first-order functional language and mechanisms for representing and reasoning about SMT formulas; a novel type system supports the construction of expressive formulas, while ensuring that neither normal evaluation nor SMT solving goes wrong. Our case studies demonstrate that a range of SMT-based analyses can naturally and concisely be encoded in Formulog, and that — thanks to this encoding — high-level Datalog-style optimizations can be automatically and advantageously applied to these analyses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Bembenek</last_name>
          <affiliation>Harvard University, USA</affiliation>
          <bio>Aaron Bembenek is currently a computer science PhD candidate at Harvard University working under Stephen Chong. He previously earned an undergraduate degree in classics from Princeton University.</bio>
          <homepage_url>http://people.seas.harvard.edu/~bembenek/index.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aaronbembenek/def526d3-8049-43ee-a891-2437ec903da6/small.jpg</picture_url>
          <person_id>aaronbembenek</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Greenberg</last_name>
          <affiliation>Pomona College, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.pomona.edu/~michael/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
          <person_id>michaelgreenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chong</last_name>
          <affiliation>Harvard University, USA</affiliation>
          <bio>Stephen Chong is a Gordon McKay Professor of Computer Science in the Harvard John A. Paulson School of Engineering and Applied Sciences. Steve’s research focuses on programming languages, information security, and the intersection of these two areas. He is the recipient of an NSF CAREER award, an AFOSR Young Investigator award, and a Sloan Research Fellowship. He received a PhD from Cornell University, and a bachelor’s degree from Victoria University of Wellington, New Zealand.</bio>
          <homepage_url>https://people.seas.harvard.edu/~chong/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stephenchong/91e43651-bcd6-40dc-b231-4c92711b0e95/small.jpg</picture_url>
          <person_id>stephenchong</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e32b7341-b29d-46a0-8e72-be60dbd55ba8</slot_id>
      <event_id>b5281650-dcac-4963-b682-1fed545a5e0a</event_id>
      <title>WATCHER: In-Situ Failure Diagnosis</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>22:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>22:20</end_time>
      <description>Diagnosing software failures is important but notoriously challenging. Existing work either requires extensive manual effort, imposing a serious privacy concern (for in-production systems), or cannot report sufficient information for bug fixes. This paper presents a novel diagnosis system, named WATCHER, that can pinpoint root causes of program failures within the failing process ("in-situ"), eliminating the privacy concern. It combines identical record-and-replay, binary analysis, dynamic analysis, and hardware support together to perform the diagnosis without human involvement. It further proposes two optimizations to reduce the diagnosis time and diagnose failures with control flow hijacks. WATCHER can be easily deployed, without requiring custom hardware or operating system, program modification, or recompilation. We evaluate WATCHER with 24 program failures in real-world deployed software, including large-scale applications, such as Memcached, SQLite, and OpenJPEG. Experimental results show that WATCHER can accurately identify the root causes in only a few seconds.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hongyu</first_name>
          <last_name>Liu</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://liuhycs.github.io/</homepage_url>
          <person_id>hongyuliu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Silvestro</last_name>
          <affiliation>University of Texas at San Antonio, USA</affiliation>
          <bio>undefined</bio>
          <person_id>samsilvestro</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xiangyu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/xyzhang/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xiangyuzhang/57d4d88e-c02e-41fc-836c-0e22cdf6b3b8/small.jpg</picture_url>
          <person_id>xiangyuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jian</first_name>
          <last_name>Huang</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jianh.web.engr.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jianhuang/f6e25055-585a-40e2-89ae-b28280a62eab/small.jpg</picture_url>
          <person_id>jianhuang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Tongping</first_name>
          <last_name>Liu</last_name>
          <affiliation>University of Massachusetts at Amherst, USA</affiliation>
          <bio>undefined</bio>
          <person_id>tongpingliu1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f1d9ff58-07e3-4db2-a961-80e7f3cfb9f4</slot_id>
      <event_id>bf240e74-90f0-407b-8552-d2d71c9c86e4</event_id>
      <title>Handling Bidirectional Control Flow</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>21:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>22:00</end_time>
      <description>Pressed by the difficulty of writing asynchronous, event-driven code, mainstream languages have recently been building in support for a variety of advanced control-flow features. Meanwhile, experimental language designs have suggested effect handlers as a unifying solution to programmer-defined control effects, subsuming exceptions, generators, and async–await. However, despite these trends, complex control flow—in particular, control flow that exhibits a bidirectional pattern—remains challenging to manage. 
We introduce bidirectional algebraic effects, a new programming abstraction that supports bidirectional control transfer in a more natural way. Handlers of bidirectional effects can raise further effects to transfer control back to the site where the initiating effect was raised, and can use themselves to handle their own effects. We present applications of this expressive power, which falls out naturally as we push toward the unification of effectful programming with object-oriented programming. We pin down the mechanism and the unification formally using a core language that makes generalizations to effect operations and effect handlers. 
The usual propagation semantics of control effects such as exceptions conflicts with modular reasoning in the presence of effect polymorphism—it breaks parametricity. Bidirectionality exacerbates the problem. Hence, we set out to show the core language, which builds on the existing tunneling semantics for algebraic effects, is not only type-safe (no effects go unhandled), but also abstraction-safe (no effects are accidentally handled). We devise a step-indexed logical-relations model, and construct its parametricity and soundness proofs. These core results are fully mechanized in Coq. While a full-featured compiler is left to future work, experiments show that as a first-class language feature, bidirectional handlers can be implemented efficiently.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yizhou</first_name>
          <last_name>Zhang</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.uwaterloo.ca/~yizhou</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yizhouzhang/0629b9fd-c9c0-44e9-ac08-6760a0b35950/small.jpg</picture_url>
          <person_id>yizhouzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guido</first_name>
          <last_name>Salvaneschi</last_name>
          <affiliation>University of St. Gallen, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.guidosalvaneschi.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guidosalvaneschi/6f1373d5-57c6-4d68-b6c3-c0a679ee24ed/small.jpg</picture_url>
          <person_id>guidosalvaneschi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Myers</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>Andrew Myers is a Professor in the Department of Computer Science at Cornell University in Ithaca, NY. His research interests include programming languages, computer security, and distributed and persistent programming systems. Myers is an ACM Fellow. He has received awards for papers appearing in POPL’99, SOSP’01, SOSP’07, CIDR’13, PLDI’13, and PLDI’15. Myers is currently the Editor-in-Chief for ACM Transactions on Programming Languages and Systems (TOPLAS). He has also served as program chair or co-chair for a few conferences: ACM POPL 2018, ACM CCS 2016, POST 2014, IEEE CSF 2010, and IEEE S&amp;amp;P 2009.</bio>
          <homepage_url>http://www.cs.cornell.edu/andru</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andrewmyers/88baadd2-5ed8-4687-b205-3cbbe8b1a848/small.jpg</picture_url>
          <person_id>andrewmyers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>20cc3f73-2788-4cf8-9efa-2cd9aa9c8f78</subevent_id>
    <title>SPLASH OOPSLA: F-2A</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>a75fbdcb-f5fd-4cdf-86c1-fb613c03d565</slot_id>
      <title>Session: SPLASH OOPSLA - F-2A</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>21:00</start_time>
      <end_time>22:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Pranav</first_name>
          <last_name>Kant</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
          <person_id>pranavkant</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Igarashi</last_name>
          <affiliation>Kyoto University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/atsushiigarashi/bbac1695-343a-4091-b33c-b7f01dea73da/small.jpg</picture_url>
          <person_id>atsushiigarashi</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>05ca0578-2be0-4f8b-9f11-8d3258c5945f</slot_id>
      <event_id>fc13e2b3-604c-4954-9997-35f41f87ef1f</event_id>
      <title>Towards a Unified Proof Framework for Automated Fixpoint Reasoning using Matching Logic</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>22:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>22:20</end_time>
      <description>Automation of fixpoint reasoning has been extensively studied for various mathematical structures, logical formalisms, and computational domains, resulting in specialized fixpoint provers for heaps, for streams, for term algebras, for temporal properties, for program correctness, and for many other formal systems and inductive and coinductive properties. However, in spite of great theoretical and practical interest, there is no unified framework for automated fixpoint reasoning. Although several attempts have been made, there is no evidence that such a unified framework is possible, or practical. In this paper, we propose a candidate based on matching logic, a formalism recently shown to theoretically unify the above mentioned formal systems. Unfortunately, the (Knaster-Tarski) proof rule of matching logic, which enables inductive reasoning, is not syntax-driven. Worse, it can be applied at any step during a proof, making automation seem hopeless. Inspired by recent advances in automation of inductive proofs in separation logic, we propose an alternative proof system for matching logic, which is amenable for automation. We then discuss our implementation of it, which although not superior to specialized state-of-the-art automated provers for specific domains, we believe brings some evidence and hope that a unified framework for automated reasoning is not out of reach.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiaohong</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsl.cs.illinois.edu/~xchen</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xiaohongchen1/e982c014-9fda-495c-93d6-b5fdc8158320/small.jpg</picture_url>
          <person_id>xiaohongchen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Minh-Thai</first_name>
          <last_name>Trinh</last_name>
          <affiliation>Advanced Digital Sciences Center, Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>thaitrinh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nishant</first_name>
          <last_name>Rodrigues</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <person_id>nishantrodrigues</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lucas</first_name>
          <last_name>Peña</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <person_id>lucaspena</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Grigore</first_name>
          <last_name>Rosu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsl.cs.illinois.edu/index.php/Grigore_Rosu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/grigorerosu/5d2acd04-bb45-46a0-a743-4826f3d8086c/small.jpg</picture_url>
          <person_id>grigorerosu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>95386c15-d7dc-413f-88c9-4986f90d665d</slot_id>
      <event_id>7907d076-ba43-4ab2-87fb-41a41db9c572</event_id>
      <title>Resolution as Intersection Subtyping via Modus Ponens</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>21:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>21:40</end_time>
      <description>Resolution and subtyping are two common mechanisms in programming languages. Resolution is used by features such as type classes or Scala-style implicits to synthesize values automatically from contextual type information. Subtyping is commonly used to automatically convert the type of a value into another compatible type. So far the two mechanisms have been considered independently of each other. This paper shows that, with a small extension, subtyping with intersection types can subsume resolution. This has three main consequences. Firstly, resolution does not need to be implemented as a separate mechanism. Secondly, the interaction between resolution and subtyping becomes apparent. Finally, the integration of resolution into subtyping enables first-class (implicit) environments. The extension that recovers the power of resolution via subtyping is the modus ponens rule of propositional logic. While it is easily added to declarative subtyping, significant care needs to be taken to retain desirable properties, such as transitivity and decidability of algorithmic subtyping, and coherence. To materialize these ideas we develop $\lambda_i^{MP}$, a calculus that extends a iprevious calculus with disjoint intersection types, and develop its metatheory in the Coq theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Klara</first_name>
          <last_name>Mardirosian</last_name>
          <affiliation>KU Leuven, Belgium</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/klaramardirosian/15cf04a1-de90-4f6d-b88d-cd1a230da0e4/small.jpg</picture_url>
          <person_id>klaramardirosian</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Georgios</first_name>
          <last_name>Karachalias</last_name>
          <affiliation>Tweag I/O, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://gkaracha.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/georgekarachalias/cb10a8f5-6b72-4883-aef0-c9978070378a/small.jpg</picture_url>
          <person_id>georgekarachalias</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a83b7817-d541-46f7-a076-24d71e3f8948</slot_id>
      <event_id>0cd262dc-3c5c-498c-814d-952a4abeecf6</event_id>
      <title>Guided Linking: Dynamic Linking without the Costs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>21:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>22:00</end_time>
      <description>Dynamic linking is extremely common in modern software systems, thanks to the flexibility and space savings it offers. However, this flexibility comes at a cost: it's impossible to perform interprocedural optimizations that involve calls to a dynamic library. The basic problem is that the run-time behavior of the dynamic linker can't be predicted at compile time, so the compiler can make no assumptions about how such calls will behave. 
This paper introduces \textit{guided linking}, a technique for optimizing dynamically linked software when some information about the dynamic linker's behavior is known in advance. The developer provides an arbitrary set of programs, libraries, and plugins to our tool, along with \textit{constraints} that limit the possible dynamic linking behavior of the software. By taking advantage of the constraints, our tool enables \emph{any} existing optimization to be applied across dynamic linking boundaries. For example, the NoOverride constraint can be applied to a function when the developer knows it will never be overridden with a different definition at run time; guided linking then enables the function to be inlined into its callers in other libraries. We also introduce a novel code size optimization that deduplicates identical functions even across different parts of the software set. 
By applying guided linking to the Python interpreter and its dynamically loaded modules, supplying the constraint that no other programs or modules will be used, we increase speed by an average of 9%. By applying guided linking to a dynamically linked distribution of Clang and LLVM, and using the constraint that no other software will use the LLVM libraries, we can increase speed by 5% and reduce file size by 13%. If we relax the constraint to allow other software to use the LLVM libraries, we can still increase speed by 5% and reduce file size by 5%. If we use guided linking to combine 11 different versions of the Boost library, using minimal constraints, we can reduce the total library size by 57%.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sean</first_name>
          <last_name>Bartell</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <person_id>seanbartell</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Will</first_name>
          <last_name>Dietz</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wdtz.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/willdietz/f5b6948e-d200-44b1-ba05-8d21549414f8/small.jpg</picture_url>
          <person_id>willdietz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Vikram S.</first_name>
          <last_name>Adve</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>Vikram Adve is the Donald B. Gillies Professor of Computer Science at the University of Illinois at Urbana-Champaign and a Professor in Electrical and Computer Engineering. He is a Co-founder and Co-Director of the Center for Digital Agriculture and leads AIFARMS, a $20M National Artificial Intelligence Research Institute funded by NIFA and NSF. Adve’s research interests lie in developing and using compiler techniques to improve the performance, programmability and reliability of computer systems. Adve and his Ph.D. student, Chris Lattner, co-designed the LLVM Compiler Infrastructure, which enables a novel approach to “lifelong compilation” of programs in a wide range of general-purpose programming languages. For example, most mobile apps for the iPhone, iPad, Apple Watch and Apple TV are shipped by developers to Apple in the LLVM compiler representation called “LLVM bitcode” and then compiled and specialized for the various end-user devices. LLVM is widely used in industry today, ranging from mobile devices (e.g., iOS and Android) to supercomputers (e.g., at NVIDIA, Cray, IBM and Intel) to data centers (e.g., at Google). Adve, Lattner and Evan Cheng received the ACM Software System Award in 2012 for co-developing LLVM. Adve has won a ten-year-retrospective Most Influential Paper award at CGO 2004, and distinguished paper awards at several conferences including PLDI 2005, SOSP 2007 and ICSE 2011. He has served as the Associate Editor for the ACM Transactions on Programming Languages and Systems, and co-chaired the Program Committees for ASPLOS 2010, VEE 2008, and LCPC 2007. One of Adve’s Ph.D. students, Robert Bocchino, won the 2010 ACM SIGPLAN Outstanding Dissertation Award and another student, John Criswell, won Honorable Mentions for both the 2014 ACM SIGOPS Dissertation Award and the 2014 ACM Doctoral Dissertation Award. Adve is a Fellow of the ACM and was named a University Scholar at the University of Illinois in 2015. He served as Interim Head of the Computer Science Department from 2017 to 2019.</bio>
          <homepage_url>http://vikram.cs.illinois.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vikramadve/a99a9248-20e3-4738-9200-173c353c5fcb/small.jpg</picture_url>
          <person_id>vikramadve</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b45b208d-b6de-42ab-9545-9822f4d06f25</slot_id>
      <event_id>834d57b9-2ff5-4c19-86bb-2d5b6188d63e</event_id>
      <title>A Sparse Iteration Space Transformation Framework for Sparse Tensor Algebra</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>21:20</end_time>
      <description>We address the problem of optimizing sparse tensor algebra in a compiler and show how to define standard loop transformations—split, collapse, and reorder—on sparse iteration spaces. The key idea is to track the transformation functions that map the original iteration space to derived iteration spaces. These functions are needed by the code generator to emit code that maps coordinates between iteration spaces at runtime, since the coordinates in the sparse data structures remain in the original iteration space. We further demonstrate that derived iteration spaces can tile both the universe of coordinates and the subset of nonzero coordinates: the former is analogous to tiling dense iteration spaces, while the latter tiles sparse iteration spaces into statically load-balanced blocks of nonzeros. Tiling the space of nonzeros lets the generated code efficiently exploit heterogeneous compute resources such as threads, vector units, and GPUs. 
We implement these concepts by extending the sparse iteration theory implementation in the TACO system. The associated scheduling API can be used by performance engineers or it can be the target of an automatic scheduling system. We outline one heuristic autoscheduling system, but other systems are possible. Using the scheduling API, we show how to optimize mixed sparse-dense tensor algebra expressions on CPUs and GPUs. Our results show that the sparse transformations are sufficient to generate code with competitive performance to hand-optimized implementations from the literature, while generalizing to all of the tensor algebra.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ryan</first_name>
          <last_name>Senanayake</last_name>
          <affiliation>Reservoir Labs, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.RSenApps.com</homepage_url>
          <person_id>ryansenanayake</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Changwan</first_name>
          <last_name>Hong</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>changwanhong2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziheng</first_name>
          <last_name>Wang</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>zihengwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Amalee</first_name>
          <last_name>Wilson</last_name>
          <affiliation>Stanford University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>amaleewilson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chou</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/s3chou</homepage_url>
          <person_id>stephenchou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Shoaib</first_name>
          <last_name>Kamil</last_name>
          <affiliation>Adobe, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shoaibkamil/2bc60aee-bda5-437e-9e74-e00f5a55c9ef/small.jpg</picture_url>
          <person_id>shoaibkamil</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Saman</first_name>
          <last_name>Amarasinghe</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>Prof. Saman Amarasinghe leads the Commit compiler research group in MIT’s Computer Science &amp;amp; Artificial Intelligence Laboratory (CSAIL), which focuses on programming languages and compilers that maximize application performance on modern computing platforms. He is a world leader in the field of high-performance domain-specific languages. Prof. Amarasinghe’s group developed the Halide, TACO, Simit, StreamIt, StreamJIT, PetaBricks, MILK, Cimple, and GraphIt domain-specific languages and compilers, all of which combine language design and sophisticated compilation techniques to deliver unprecedented performance for targeted application domains such as image processing, stream computations, and graph analytics. Dr. Amarasinghe also pioneered the application of machine learning for compiler optimizations, from Meta optimization in 2003 to OpenTuner extendable autotuner today. With professor Anant Agarwal, he co-led the Raw architecture project, which did pioneering work on scalable multicores. Prof. Amarasinghe’s entrepreneurship activities include founding Determina, Inc. (acquired by VMWare) based on computer security research pioneered in his research group at MIT and co-founding Lanka Internet Services, Ltd., the first Internet Service Provider in Sri Lanka. Prof. Amarasinghe is also the faculty director of MIT Global Startup Labs, whose summer programs in 17 countries have helped to create more than 20 thriving startups. Prof. Amarasinghe developed the popular Performance Engineering of Software Systems (6.172) class with Professor Charles Leiserson. He also created individualized software project classes such as the Open Source Software Project Lab, the Open Source Entrepreneurship Lab, and the Bring Your Own Software Project Lab.</bio>
          <homepage_url>http://people.csail.mit.edu/saman</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/samanamarasinghe/9e4ed1ad-ff3e-468e-b1a8-36ffb2c882ef/small.jpg</picture_url>
          <person_id>samanamarasinghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>02ccad03-6734-4d65-9628-f81c25f1872e</subevent_id>
    <title>SPLASH OOPSLA: T-3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>3df3e93d-1303-4a51-96be-9fc9db55cacc</slot_id>
      <title>Session: SPLASH OOPSLA - T-3</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Chengyu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>East China Normal University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.chengyuzhang.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/chengyuzhang/eee80413-7fee-43ac-88d2-72212b8b352a/small.jpg</picture_url>
          <person_id>chengyuzhang</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Ting</first_name>
          <last_name>Cao</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/ticao/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tingcao/aaa80a03-c7ea-4dec-86ce-5c2e3c913853/small.jpg</picture_url>
          <person_id>tingcao</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>16f2c9fd-522e-4847-922e-339d712a2e46</slot_id>
      <event_id>b926e1ec-10a6-4b30-9b63-77836ac884b7</event_id>
      <title>Koord: A Language for Programming and Verifying Distributed Robotics Application</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>23:20</end_time>
      <description>A robot’s code needs to sense the environment, control the hardware, and communicate with other robots. Current programming languages do not provide suitable abstractions that are independent of hardware platforms. Currently, developing robot applications requires detailed knowledge of signal processing, control, path planning, network protocols, and various platform-specific details. Further, porting applications across hardware platforms remains tedious. We present Koord—a domain specific language for distributed robotics—which abstracts platform-specific functions for sensing, communication, and low-level control. Koord makes the platform-independent control and coordination code portable and modularly verifiable. Koord raises the level of abstraction in programming by providing distributed shared memory for coordination and port interfaces for sensing and control. We have developed the formal executable semantics of Koord in the K framework. With this symbolic execution engine, we can identify assumptions (proof obligations) needed for gaining high assurance from Koord applications. We illustrate the power of Koord through three applications: formation flight, distributed delivery, and distributed mapping. We also use the three applications to demonstrate how platform-independent proof obligations can be discharged using the Koord Prover while platform-specific proof obligations can be checked by verifying the obligations using physics-based models and hybrid verification tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ritwika</first_name>
          <last_name>Ghosh</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <person_id>ritwikaghosh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chiao</first_name>
          <last_name>Hsieh</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <person_id>chiaohsieh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sasa</first_name>
          <last_name>Misailovic</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://misailo.cs.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sasamisailovic/6e3299c7-e0f5-4e78-a5f3-7ea49e488545/small.jpg</picture_url>
          <person_id>sasamisailovic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>sayan</first_name>
          <last_name>mitra</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>Sayan Mitra is a Professor of Electrical and Computer Engineering at the University of Illinois at Urbana-Champaign. His research interests are in formal verification, autonomous systems, and robotics. He holds a PhD from MIT, MSc from the Indian Institute of Science, Bangalore, and an undergraduate degree in Electrical Engineering from Jadavpur University, Kolkata. He was a postdoctoral fellow at the Center for Mathematics of Information of CalTech, and held visiting faculty positions at Oxford University and Kirtland Air Force Research Laboratory. Sayan received the National Science Foundation’s CAREER Award in 2011, AFOSR Young Investigator Research Program Award in 2012, IEEE-HKN C. Holmes MacDonald Outstanding Teaching Award (2013), a RiSE Fellowship from TU Vienna, and several best paper awards.</bio>
          <homepage_url>http://mitras.ece.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sayanmitra/62982710-8e2c-4be7-98f8-068227c8a067/small.jpg</picture_url>
          <person_id>sayanmitra</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>63777313-d9b3-4e71-a636-24117533937e</slot_id>
      <event_id>de7d97dc-0089-49e1-bfce-2e7b14b648ee</event_id>
      <title>LiveDroid: Identifying and Preserving Mobile App State in Volatile Runtime Environments</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>00:00</end_time>
      <description>Mobile operating systems, especially Android, expose apps to a volatile runtime environment. The app state that reflects past user interaction and system environment updates (e.g., battery status changes) can be destroyed implicitly, in response to runtime configuration changes (e.g., screen rotations) or memory pressure. Developers are therefore responsible for identifying app state affected by volatility and preserving it across app lifecycles. When handled inappropriately, the app may lose state or end up in an inconsistent state after a runtime configuration change or when users return to the app. 
To free developers from this tedious and error-prone task, we propose a systematic solution, LiveDroid, which precisely identifies the {\em necessary} part of the app state that needs to be preserved across app lifecycles, and automatically saves and restores it. LiveDroid consists of: (i) a static analyzer that reasons about app source code and resource files to pinpoint the program variables and GUI properties that represent the necessary app state, and (ii) a runtime system that manages the state saving and recovering. We implemented LiveDroid as a plugin in Android Studio and a patching tool for APKs. Our evaluation shows that LiveDroid can be successfully applied to 966 Android apps. A focused study with 36 Android apps shows that LiveDroid identifies app state much more precisely than an existing solution that includes all mutable program variables but ignores GUI properties. As a result, on average, LiveDroid is able to reduce the costs of state saving and restoring by 16.6X (1.7X - 141.1X) and 9.5X (1.1X - 43.8X), respectively. Furthermore, compared with the manual state handling performed by developers, our analysis reveals a set of 46 issues due to incomplete state saving/restoring, all of which can be successfully eliminated by LiveDroid.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Umar</first_name>
          <last_name>Farooq</last_name>
          <affiliation>University of California at Riverside, USA</affiliation>
          <bio>My research lies at the intersection of software engineering, programming languages, and mobile systems. I develop program analysis and runtime systems to automatically detect, prevent, and fix reliability and efficiency issues in software. In addition, I have a keen interest in exploiting the synergy between software engineering and emerging techniques (in Big Data and Deep Learning) to address issues in both research areas.</bio>
          <homepage_url>https://www.cs.ucr.edu/~ufaro001/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/umarfarooq2/e0d30810-d987-42da-b3cb-576592015d8d/small.jpg</picture_url>
          <person_id>umarfarooq2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zhijia</first_name>
          <last_name>Zhao</last_name>
          <affiliation>University of California at Riverside, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ucr.edu/~zhijia/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhijiazhao/5e266673-0c51-4bfe-bc81-2fb37155ad8b/small.jpg</picture_url>
          <person_id>zhijiazhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Manu</first_name>
          <last_name>Sridharan</last_name>
          <affiliation>University of California at Riverside, USA</affiliation>
          <bio>I’m an associate professor at the University of California, Riverside. Previously I worked at IBM Research, Samsung Research, and Uber. My research focuses on developing tools and techniques to make large-scale software more reliable, performant, secure, and maintainable. For more details, see my homepage.</bio>
          <homepage_url>http://manu.sridharan.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manusridharan/00859147-2155-45a9-9a48-7565ce5356ac/small.jpg</picture_url>
          <person_id>manusridharan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Iulian</first_name>
          <last_name>Neamtiu</last_name>
          <affiliation>New Jersey Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://web.njit.edu/~ineamtiu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/iulianneamtiu/59a11852-72df-4d67-9331-8720d3d19a64/small.jpg</picture_url>
          <person_id>iulianneamtiu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6a2c1fa9-6ff4-437a-b112-b9ef447f9f99</slot_id>
      <event_id>72a7c48b-8eba-4f07-b5bc-03af82474540</event_id>
      <title>Shiftry: RNN Inference in 2KB of RAM</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>00:20</end_time>
      <description>Traditionally, IoT devices send collected sensor data to an intelligent cloud where machine learning (ML) inference happens. However, this course is rapidly changing and there is a recent trend to run ML on the edge IoT devices themselves. An intelligent edge is attractive because it saves network round trip (efficiency) and keeps user data at the source (privacy). However, the IoT devices are much more resource constrained than the cloud, which makes running ML on them challenging. Specifically, consider Arduino Uno, a commonly used board, that has 2KB of RAM and 32KB of read-only Flash memory. Although recent breakthroughs in ML have created novel recurrent neural network (RNN) models that provide good accuracy with KB-sized models, deploying them on tiny devices with such hard memory requirements has remained elusive. 
We provide, Shiftry, an automatic compiler from high-level floating-point ML models to fixed-point C-programs with 8-bit and 16-bit integers, which have significantly lower memory requirements. For this conversion, Shiftry uses a data-driven float-to-fixed procedure and a RAM management mechanism. These techniques enable us to provide first empirical evaluation of RNNs running on tiny edge devices. On simpler ML models that prior work could handle, Shiftry-generated code has lower latency and higher accuracy.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aayan</first_name>
          <last_name>Kumar</last_name>
          <affiliation>Microsoft Research, India</affiliation>
          <bio>undefined</bio>
          <person_id>aayankumar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vivek</first_name>
          <last_name>Seshadri</last_name>
          <affiliation>Microsoft Research, India</affiliation>
          <bio>undefined</bio>
          <person_id>vivekseshadri</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rahul</first_name>
          <last_name>Sharma</last_name>
          <affiliation>Microsoft Research, India</affiliation>
          <bio>Rahul Sharma is a researcher at Microsoft Research India. He received a Ph.D. in Computer Science from Stanford University, where he was advised by Prof. Alex Aiken. Before Stanford, he graduated with a B.Tech. from IIT Delhi. His research interests include program analysis, compilers, machine learning, and secure cloud computing.</bio>
          <homepage_url>http://cs.stanford.edu/people/sharmar</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rahulsharma/6d60eca8-356f-4141-af5d-4c6af0fadcd8/small.jpg</picture_url>
          <person_id>rahulsharma</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>99b7ae06-430b-4b21-90dd-3b80c530a347</slot_id>
      <event_id>7425f134-286b-4c4d-998b-71b90c993ce0</event_id>
      <title>Learning-Based Controlled Concurrency Testing</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>23:40</end_time>
      <description>Concurrency bugs are notoriously hard to detect and reproduce. Controlled concurrency testing (CCT) techniques aim to offer a solution, where a scheduler explores the space of possible interleavings of a concurrent program looking for bugs. Since the set of possible interleavings is typically very large, these schedulers employ heuristics that prioritize the search to “interesting” subspaces. However, current heuristics are typically tuned to specific bug patterns, which limits their effectiveness in practice. 
In this paper, we present QL, a learning-based CCT framework where the likelihood of an action being selected by the scheduler is influenced by earlier explorations. We leverage the classical Q-learning algorithm to explore the space of possible interleavings, allowing the exploration to adapt to the program under test, unlike previous techniques. We have implemented and evaluated QL on a set of microbenchmarks, complex protocols, as well as production cloud services. In our experiments, we found QL to consistently outperform the state-of-the-art in CCT.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Suvam</first_name>
          <last_name>Mukherjee</last_name>
          <affiliation>Microsoft Research, India</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://suvamm.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/suvammukherjee1/0b04e282-4b61-4f63-9abf-4d9516cf0b1e/small.jpg</picture_url>
          <person_id>suvammukherjee1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pantazis</first_name>
          <last_name>Deligiannis</last_name>
          <affiliation>Microsoft Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pdeligia.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/pantazisdeligiannis/a2d73510-7695-48bd-9b09-2ce6ec50b5d1/small.jpg</picture_url>
          <person_id>pantazisdeligiannis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arpita</first_name>
          <last_name>Biswas</last_name>
          <affiliation>IISc Bangalore, India</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.google.com/view/arpitabiswas</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arpitabiswas/c7b67b3e-4a6b-4a0c-8139-6cc114ed3ea1/small.jpg</picture_url>
          <person_id>arpitabiswas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Akash</first_name>
          <last_name>Lal</last_name>
          <affiliation>Microsoft Research, India</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.microsoft.com/en-us/people/akashl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/akashlal/96032ffc-99b4-4b90-b99d-01b1f833751a/small.jpg</picture_url>
          <person_id>akashlal</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2e25f672-eab0-4b3c-ab58-ecbd3997af93</subevent_id>
    <title>SPLASH OOPSLA: F-3B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>9eaf970b-65ba-41e3-a308-7321c3e86b49</slot_id>
      <title>Session: SPLASH OOPSLA - F-3B</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Yaniv</first_name>
          <last_name>David</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://yanivd.cswp.cs.technion.ac.il</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yanivdavid/83ffa94a-79ef-4627-b213-9d48cfeac290/small.jpg</picture_url>
          <person_id>yanivdavid</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Francisco</first_name>
          <last_name>Ferreira</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~fferre16/</homepage_url>
          <person_id>franciscoferreira1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>14140688-2baa-4cdf-8839-20311cc02ace</slot_id>
      <event_id>49e4b00a-5555-4c4e-8eca-5628b4a98878</event_id>
      <title>Learning Semantic Program Embeddings with Graph Interval Neural Network</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>12:00</end_time>
      <description>Learning distributed representations of source code has been a challenging task for machine learning models. Earlier works treated programs as text so that natural language methods can be readily applied. Unfortunately, such approaches do not capitalize on the rich structural information possessed by source code. Of late, Graph Neural Network (GNN) was proposed to learn embeddings of programs from their graph representations. Due to the homogeneous (i.e. do not take advantage of the program-specific graph characteristics) and expensive (i.e. require heavy information exchange among nodes in the graph) message-passing procedure, GNN can suffer from precision issues, especially when dealing with programs rendered into large graphs. In this paper, we present a new graph neural architecture, called Graph Interval Neural Network (GINN), to tackle the weaknesses of the existing GNN. Unlike the standard GNN, GINN generalizes from a curated graph representation obtained through an abstraction method designed to aid models to learn. In particular, GINN focuses exclusively on intervals (generally manifested in looping construct) for mining the feature representation of a program, furthermore, GINN operates on a hierarchy of intervals for scaling the learning to large graphs. 
We evaluate GINN for two popular downstream applications: variable misuse prediction and method name prediction. Results show in both cases GINN outperforms the state-of-the-art models by a comfortable margin. We have also created a neural bug detector based on GINN to catch null pointer deference bugs in Java code. While learning from the same 9,000 methods extracted from 64 projects, GINN-based bug detector significantly outperforms GNN-based bug detector on 13 unseen test projects. Next, we deploy our trained GINN-based bug detector and Facebook Infer, arguably the state-of-the-art static analysis tool, to scan the codebase of 20 highly starred projects on GitHub. Through our manual inspection, we confirm 38 bugs out of 102 warnings raised by GINN-based bug detector compared to 34 bugs out of 129 warnings for Facebook Infer. We have reported 38 bugs GINN caught to developers, among which 11 have been fixed and 12 have been confirmed (fix pending). GINN has shown to be a general, powerful deep neural network for learning precise, semantic program embeddings.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yu</first_name>
          <last_name>Wang</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <person_id>yuwang2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ke</first_name>
          <last_name>Wang</last_name>
          <affiliation>Visa Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kbwang.bitbucket.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/kewang/37ef656e-ca92-475f-8a51-902dbe44fb72/small.jpg</picture_url>
          <person_id>kewang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Fengjuan</first_name>
          <last_name>Gao</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <person_id>fenjuangao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Linzhang</first_name>
          <last_name>Wang</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <person_id>linzhangwang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>300cf933-3384-48fc-90ff-22d87f35da06</slot_id>
      <event_id>6a3ae3f8-1ca4-44df-b6b1-bb4756927885</event_id>
      <title>Just-in-Time Learning for Bottom-Up Enumerative Synthesis</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>11:20</end_time>
      <description>A key challenge in program synthesis is the astronomical size of the search space the synthesizer has to explore. In response to this challenge, recent work proposed to guide synthesis using learned probabilistic models. Obtaining such a model, however, might be infeasible for a problem domain where no high-quality training data is available. In this work we introduce an alternative approach to guided program synthesis: instead of training a model ahead of time we show how to bootstrap one just in time, during synthesis, by learning from partial solutions encountered along the way. To make the best use of the model, we also propose a new program enumeration algorithm we dub guided bottom-up search, which extends the efficient bottom-up search with guidance from probabilistic models. 
We implement this approach in a tool called Probe, which targets problems in the popular syntax-guided synthesis (SyGuS) format. We evaluate Probe on benchmarks from the literature and show that it achieves significant performance gains both over unguided bottom-up search and over a state-of-the-art probability-guided synthesizer, which had been trained on a corpus of existing solutions. Moreover, we show that these performance gains do not come at the cost of solution quality: programs generated by Probe are only slightly more verbose than the shortest solutions and perform no unnecessary case-splitting.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shraddha</first_name>
          <last_name>Barke</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shraddhabarke1/4e11ed13-0f46-4d77-8a6d-dd4c07b7fd4b/small.jpg</picture_url>
          <person_id>shraddhabarke1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>37f9968e-8ec8-4555-8c3b-01043eb73ef2</slot_id>
      <event_id>1191b34c-6380-48db-9c47-b8e642e28ee2</event_id>
      <title>ιDOT: A DOT Calculus with Object Initialization</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>12:20</end_time>
      <description>The Dependent Object Types (DOT) calculus serves as a foundation of the Scala programming language, with a machine-verified soundness proof. However, Scala's type system has been shown to be unsound due to null references, which are used as default values of fields of objects before they have been initialized. This paper proposes ιDOT, an extension of DOT for ensuring safe initialization of objects. DOT was previously extended to κDOT with the addition of mutable fields and constructors. To κDOT, ιDOT adds an initialization effect system that statically prevents the possibility of reading a null reference from an uninitialized object. To design ιDOT, we have reformulated the Freedom Before Commitment object initialization scheme in terms of disjoint subheaps to make it easier to formalize in an effect system and prove sound. Soundness of ιDOT depends on the interplay of three systems of rules: a type system close to that of DOT, an effect system to ensure definite assignment of fields in each constructor, and an initialization system that tracks the initialization status of objects in a stack of subheaps. We have proven the overall system sound and verified the soundness proof using the Coq proof assistant.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ifaz</first_name>
          <last_name>Kabir</last_name>
          <affiliation>University of Alberta, Canada</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/ifazkabir/991cbcab-f46c-4c5e-8b8f-c365d1b11d6b/small.jpg</picture_url>
          <person_id>ifazkabir</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yufeng</first_name>
          <last_name>Li</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>yufengli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5fb954b7-9168-42eb-9226-cc67e1456b99</slot_id>
      <event_id>275f97bd-396a-4f74-95be-90160be2ffc2</event_id>
      <title>Taming Type Annotations in Gradual Typing</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>11:40</end_time>
      <description>Gradual typing provides a methodology to integrate static and dynamic typing, harmonizing their often conflicting advantages in a single language. When a user wants to enjoy the advantages of static typing, most gradual languages require that they add type annotations. Many nontrivial tasks must be undertaken while adding type annotations, including understanding program behaviors and invariants. Unfortunately, if this is done incorrectly then the added type annotations can be wrong–leading to inconsistencies between the program and the type annotations. Gradual typing implementations detect such inconsistencies at runtime, raise cast errors, and generate messages. However, solely relying on such error messages for understanding and fixing inconsistencies and their resulting cast errors is often insufficient for multiple reasons. One reason is that while such messages cover inconsistencies in one execution path, fixing them often requires reconciling information from multiple paths. Another is that users may add many wrong type annotations that they later find difficult to identify and fix, when considering all added annotations. 
Recent studies provide evidence that type annotations added during program migration are often wrong and that many programmers prefer compile-time warnings about wrong annotations. Motivated by these results, we develop exploratory typing to help with the static detection, understanding, and fixing of inconsistencies. The key idea of exploratory typing is that it systematically removes dynamic types and explores alternative types for static type annotations that can remedy inconsistencies. To demonstrate the feasibility of exploratory typing, we have implemented it in PyHound, which targets programs written in Reticulated Python, a gradual variant of Python. We have evaluated PyHound on a set of Python programs, and the evaluation results demonstrate that our idea can effectively detect inconsistencies in 98% of the tested programs and fix 93% of inconsistencies, significantly outperforming pytype, a widely used Python tool for enforcing type annotations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Peter Campora III</last_name>
          <affiliation>University of Louisiana at Lafayette, USA</affiliation>
          <bio>I’m a 3rd year PhD student at ULL advised by Sheng Chen. My current research focus has been improving the usability of gradually typed languages. You can contact me at: petecampora (at) gmail.com.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnpetercamporaiii/62a0c591-991e-49f7-978a-0ecbc5556620/small.jpg</picture_url>
          <person_id>johnpetercamporaiii</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sheng</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Louisiana at Lafayette, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.cmix.louisiana.edu/schen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shengchen1/4561e224-57d6-4243-9b1f-0c895b2c49d7/small.jpg</picture_url>
          <person_id>shengchen1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>83dee1df-08a1-4401-803f-754d7c76b66e</subevent_id>
    <title>SPLASH OOPSLA: W-4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>32f87215-2ae1-4eff-af7c-9d336c53696f</slot_id>
      <title>Session: SPLASH OOPSLA - W-4</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Koskinen</last_name>
          <affiliation>Stevens Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.stevens.edu/~ejk/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/erickoskinen/3413fc94-5f0f-4855-af65-da2309d2632f/small.jpg</picture_url>
          <person_id>erickoskinen</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Justin</first_name>
          <last_name>Hsu</last_name>
          <affiliation>University of Wisconsin-Madison, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.justinh.su</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/justinhsu/a2c25b60-0dc3-48ad-a41d-238071e3fbab/small.jpg</picture_url>
          <person_id>justinhsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>33e1d675-3439-4c2a-bfba-fb598beb63e8</slot_id>
      <event_id>dba90368-d2da-4b07-8bd6-dc1e3f236813</event_id>
      <title>How Do Programmers Use Unsafe Rust?</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>14:20</end_time>
      <description>Rust's ownership type system enforces a strict discipline on how memory locations are accessed and shared. This discipline allows the compiler to statically prevent memory errors, data races, inadvertent side effects through aliasing, and other errors that frequently occur in conventional imperative programs. However, the restrictions imposed by Rust's type system make it difficult or impossible to implement certain designs, such as data structures that require aliasing (e.g. doubly-linked lists and shared caches). To work around this limitation, Rust allows code blocks to be declared as \emph{unsafe} and thereby exempted from certain restrictions of the type system, for instance, to manipulate C-style raw pointers. Ensuring the safety of unsafe code is the responsibility of the programmer. However, an important assumption of the Rust language, which we dub the \emph{Rust hypothesis}, is that programmers use Rust by following three main principles: use unsafe code sparingly, make it easy to review, and hide it behind a safe abstraction such that client code can be written in safe Rust. 
Understanding how Rust programmers use unsafe code and, in particular, whether the Rust hypothesis holds is essential for Rust developers and testers, language and library designers, as well as tool developers. This paper studies empirically how unsafe code is used in practice by analysing a large corpus of Rust projects to assess the validity of the Rust hypothesis and to classify the purpose of unsafe code. We identify queries that can be answered by automatically inspecting the program's source code, its intermediate representation MIR, as well as type information provided by the Rust compiler; we complement the results by manual code inspection. Our study supports the Rust hypothesis partially: While most unsafe code is simple and well-encapsulated, unsafe features are used extensively, especially for interoperability with other languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vytautas</first_name>
          <last_name>Astrauskas</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>vytautasastrauskas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Matheja</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>christophmatheja1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Federico</first_name>
          <last_name>Poli</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>federicopoli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Peter</first_name>
          <last_name>Müller</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/petermller/aeb8e276-62cb-4ad1-aa7d-96f76c0c405d/small.jpg</picture_url>
          <person_id>petermller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Alexander J.</first_name>
          <last_name>Summers</last_name>
          <affiliation>University of British Columbia, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.inf.ethz.ch/summersa/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexanderjsummers/f97b84a8-d46a-4e76-aa73-cc4b38c4ec41/small.jpg</picture_url>
          <person_id>alexanderjsummers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7de19414-abdf-41f2-900b-b92265caf425</slot_id>
      <event_id>c3abeda5-100d-409c-8506-b3ec6c6db79f</event_id>
      <title>Finding Bugs in Database Systems via Query Partitioning</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>13:40</end_time>
      <description>Logic bugs in Database Management Systems (DBMSs) are bugs that cause an incorrect result for a given query, for example, by omitting a row that should be fetched. These bugs are critical, since they are likely to go unnoticed by users. We propose Query Partitioning, a general and effective approach for finding logic bugs in DBMSs. The core idea of Query Partitioning is to, starting from a given original query, derive multiple, more complex queries (called partitioning queries), each of which computes a partition of the result. The individual partitions are then composed to compute a result set that must be equivalent to the original query's result set. A bug in the DBMS is detected when these result sets differ. Our intuition is that due to the increased complexity, the partitioning queries are more likely to stress the DBMS and trigger a logic bug than the original query. As a concrete instance of a partitioning strategy, we propose Ternary Logic Partitioning (TLP), which is based on the observation that a boolean predicate p can either evaluate to TRUE, FALSE, or NULL. Accordingly, a query can be decomposed into three partitioning queries, each of which computes its result on rows or intermediate results for which p, NOT p, and p IS NULL hold. This technique is versatile, and can be used to test WHERE, GROUP BY, as well as HAVING clauses, aggregate functions, and DISTINCT queries. As part of an extensive testing campaign, we found 175 bugs in widely-used DBMSs such as MySQL, TiDB, SQLite, and CockroachDB, 125 of which have been fixed. Notably, 77 of these were logic bugs, while the remaining were error and crash bugs. We expect that the effectiveness and wide applicability of Query Partitioning will lead to its broad adoption in practice, and the formulation of additional partitioning strategies.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Rigger</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>Manuel Rigger is a postdoctoral researcher in the Advanced Software Technologies (AST) Lab at ETH Zurich, mentored by Zhendong Su. He is working on programming language implementation, software reliability, and systems. He completed his PhD at Johannes Kepler University Linz, mentored by Hanspeter Mössenböck, and is known for his work on Sulong to support the safe execution of LLVM-based languages.</bio>
          <homepage_url>http://www.manuelrigger.at/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelrigger/47e268e9-158c-471f-a7e9-442216c54550/small.jpg</picture_url>
          <person_id>manuelrigger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a7364c47-e51b-450e-9d04-34f056fa402b</slot_id>
      <event_id>9609351d-7346-41c3-a781-926327d9a68c</event_id>
      <title>Proving Highly-Concurrent Traversals Correct</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>14:00</end_time>
      <description>Modern highly-concurrent search data structures, such as search trees, obtain multi-core scalability and performance by having operations traverse the data structure without any synchronization. As a result, however, these algorithms are notoriously difficult to prove linearizable, which requires identifying a point in time in which the traversal's result is correct. The problem is that traversing the data structure as it undergoes modifications leads to complex behaviors, necessitating intricate reasoning about all interleavings of reads by traversals and writes mutating the data structure. 
In this paper, we present a general proof technique for proving unsynchronized traversals correct in a significantly simpler manner, compared to typical concurrent reasoning and prior proof techniques. Our framework relies only on sequential properties} of traversals and on a conceptually simple and widely-applicable condition about the ways an algorithm's writes mutate the data structure. Establishing that a target data structure satisfies our condition requires only simple concurrent reasoning, without considering interactions of writes and reads. This reasoning can be further simplified by using our framework. 
To demonstrate our technique, we apply it to prove several interesting and challenging concurrent binary search trees: the logical-ordering AVL tree, the Citrus tree, and the full contention-friendly tree. Both the logical-ordering tree and the full contention-friendly tree are beyond the reach of previous approaches targeted at simplifying linearizability proofs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yotam</first_name>
          <last_name>Feldman</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/research/yotam.feldman/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yotamfeldman/ed864714-e66c-4ec1-a171-8c2ac69d62a1/small.jpg</picture_url>
          <person_id>yotamfeldman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Artem</first_name>
          <last_name>Khyzha</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://artkhyzha.github.io/</homepage_url>
          <person_id>artemkhyzha1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Constantin</first_name>
          <last_name>Enea</last_name>
          <affiliation>University of Paris Diderot, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~cenea/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/constantinenea/2dfe8bfe-ddfe-4012-a2e2-01cc8b953734/small.jpg</picture_url>
          <person_id>constantinenea</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Adam</first_name>
          <last_name>Morrison</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~mad</homepage_url>
          <person_id>adammorrison1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Aleksandar</first_name>
          <last_name>Nanevski</last_name>
          <affiliation>IMDEA Software Institute, Spain</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://software.imdea.org/~aleks</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aleksandarnanevski/6612f235-0493-478f-9ecd-d86045a7619a/small.jpg</picture_url>
          <person_id>aleksandarnanevski</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Noam</first_name>
          <last_name>Rinetzky</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~maon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/noamrinetzky/1ea9bd0d-bd16-4b15-bb66-a8a576ffaa40/small.jpg</picture_url>
          <person_id>noamrinetzky</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Sharon</first_name>
          <last_name>Shoham</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.tau.ac.il/~sharonshoham/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sharonshoham/52ca243a-805e-43b9-9f5a-bd1bae25fccb/small.jpg</picture_url>
          <person_id>sharonshoham</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ca42eea0-c832-4cc0-bb9f-31c317ea3502</slot_id>
      <event_id>589e08b8-be04-449c-9c40-7dc3797f2c0b</event_id>
      <title>Adversarial Examples for Models of Code</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>13:20</end_time>
      <description>Neural models of code have shown impressive results when performing tasks such as predicting method names and identifying certain kinds of bugs. We show that these models are vulnerable to \emph{adversarial examples}, and introduce a novel approach for \emph{attacking} trained models of code using adversarial examples. The main idea of our approach is to force a given trained model to make an incorrect prediction, as specified by the adversary, by introducing small perturbations that do not change the program's semantics, thereby creating an adversarial example. To find such perturbations, we present a new technique for Discrete Adversarial Manipulation of Programs (DAMP). DAMP works by deriving the desired prediction with respect to the model's \emph{inputs}, while holding the model weights constant, and following the gradients to slightly modify the input code. 
We show that our DAMP attack is effective across three neural architectures: code2vec, GGNN, and GNN-FiLM, in both Java and C#. Our evaluations demonstrate that DAMP has up to 89% success rate in changing a prediction to the adversary's choice (a targeted attack) and a success rate of up to 94% in changing a given prediction to any incorrect prediction (a non-targeted attack). To defend a model against such attacks, we empirically examine a variety of possible defenses and discuss their trade-offs. We show that some of these defenses can dramatically drop the success rate of the attacker, with a minor penalty of 2% relative degradation in accuracy when they are not performing under attack. 
Our code, data, and trained models are available at \url{https://github.com/tech-srl/adversarial-examples} .</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Noam</first_name>
          <last_name>Yefet</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <person_id>noamyefet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Uri</first_name>
          <last_name>Alon</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~urialon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/urialon/a0488e4f-5173-472b-af25-10666c27e3d4/small.jpg</picture_url>
          <person_id>urialon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>Eran Yahav is an associate professor at the Computer Science Department, Technion, Israel. Prior to that, he was a research staff member at the IBM T.J. Watson Research Center (2004-2010). He received his Ph.D. from Tel Aviv University (2005) and his B.Sc. from the Technion in 1996. His research interests include program analysis, program synthesis and program verification. Eran is a recipient of the prestigious Alon Fellowship for Outstanding Young Researchers, the Andre Deloro Career Advancement Chair in Engineering, the ERC Consolidator Grant as well as multiple best paper awards at various conferences.</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
          <person_id>eranyahav</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3adf108f-e665-4b8f-8f31-4432f14d77e4</subevent_id>
    <title>SPLASH OOPSLA: F-4A</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>2fab182b-e18d-4337-a886-ff6285eec8b4</slot_id>
      <title>Session: SPLASH OOPSLA - F-4A</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>21abcd88-7657-4302-bb2d-3685dddf7f1d</slot_id>
      <event_id>535250d1-14d9-4fb4-b418-2ad1ae511d91</event_id>
      <title>Scaling Exact Inference for Discrete Probabilistic Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>02:00</end_time>
      <description>Probabilistic programming languages (PPLs) are an expressive means of representing and reasoning about probabilistic models. The computational challenge of probabilistic inference remains the primary roadblock for applying PPLs in practice. Inference is fundamentally hard, so there is no one-size-fits all solution. In this work, we target scalable inference for an important class of probabilistic programs: those whose probability distributions are discrete. Discrete distributions are common in many fields, including text analysis, network verification, artificial intelligence, and graph analysis, but they prove to be challenging for existing PPLs. 
We develop a domain-specific probabilistic programming language called Dice that features a new approach to exact discrete probabilistic program inference. Dice exploits program structure in order to factorize inference, enabling us to perform exact inference on probabilistic programs with hundreds of thousands of random variables. Our key technical contribution is a new reduction from discrete probabilistic programs to weighted model counting (WMC). This reduction separates the structure of the distribution from its parameters, enabling logical reasoning tools to exploit that structure for probabilistic inference. We (1) show how to compositionally reduce Dice inference to WMC, (2) prove this compilation correct with respect to a denotational semantics, (3) empirically demonstrate the performance benefits over prior approaches, and (4) analyze the types of structure that allow Dice to scale to large probabilistic programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Steven</first_name>
          <last_name>Holtzen</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am a PhD. student at U.C.L.A., co-advised by Guy Van den Broeck and Todd Millstein.</bio>
          <homepage_url>http://web.cs.ucla.edu/~sholtzen</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stevenholtzen/db2263a6-7a88-4167-9d73-86a4d4b97fc9/small.jpg</picture_url>
          <person_id>stevenholtzen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guy</first_name>
          <last_name>Van den Broeck</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am an Associate Professor and Samueli Fellow at UCLA, in the Computer Science Department. My research interests are in Machine Learning (Statistical Relational Learning), Knowledge Representation and Reasoning (Graphical Models, Lifted Probabilistic Inference), Applications of Probabilistic Reasoning and Learning (Probabilistic Programming, Probabilistic Databases), and Artificial Intelligence in general. I previously was a postdoctoral researcher at UCLA’s Automated Reasoning lab and KU Leuven’s Declarative Languages and Artificial Intelligence lab.</bio>
          <homepage_url>http://web.cs.ucla.edu/~guyvdb/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guyvandenbroeck/4c8a474f-a124-4434-a370-43b4892bbe2c/small.jpg</picture_url>
          <person_id>guyvandenbroeck</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Todd</first_name>
          <last_name>Millstein</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am a Professor in the Computer Science Department at the University of California, Los Angeles (UCLA). 
I was the Program Chair for OOPSLA 2014.</bio>
          <homepage_url>http://www.cs.ucla.edu/~todd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/toddmillstein/03692d64-e4ad-4fb1-a2b0-9271ce27715c/small.jpg</picture_url>
          <person_id>toddmillstein</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>752143a7-e4f2-46de-b1f7-b641ab1a3c04</slot_id>
      <event_id>74c28b24-629b-4e90-837d-28d2c9d362d6</event_id>
      <title>A Modular Cost Analysis for Probabilistic Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>01:20</end_time>
      <description>We present a novel methodology for the automated resource analysis of non-deterministic, probabilistic imperative programs, which gives rise to a \emph{modular approach}. Program fragments are analysed in full independence. Moreover, the established results allow us to incorporate sampling from \emph{dynamic distributions}, making our analysis applicable to a wider class of examples, for example the \emph{Coupon Collector's problem}. 
We have implemented our contributions in the tool \ecoimp, exploiting a constraint-solver over iterative refineable cost functions facilitated by off-the-shelf SMT solvers. We provide ample experimental evidence of the prototype's algorithmic power. %MA: downscale superiority. Our experiments show that our tool runs typically at least one \emph{order of magnitude faster} than comparable tools. On more involved examples, it may even be the case that execution times of seconds become milliseconds. At the same time we retain the precision of existing tools. 
The extensions in applicability and the greater efficiency of our prototype, yield scalability of sorts. This effects into a wider class of examples, whose expected cost analysis can be thus be performed fully automatically.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Avanzini</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-sop.inria.fr/members/Martin.Avanzini/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/martinavanzini1/6a7bba4f-db11-478c-9d7c-2dabe34811bc/small.jpg</picture_url>
          <person_id>martinavanzini1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Georg</first_name>
          <last_name>Moser</last_name>
          <affiliation>University of Innsbruck, Austria</affiliation>
          <bio>undefined</bio>
          <person_id>georgmoser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Schaper</last_name>
          <affiliation>University of Innsbruck, Austria</affiliation>
          <bio>undefined</bio>
          <person_id>michaelschaper1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c213a6b6-12b8-4c25-a8ac-085c09363945</slot_id>
      <event_id>b9adaa2c-cdbd-450c-bb15-daa638849bd3</event_id>
      <title>Digging for Fold: Synthesis-Aided API Discovery for Haskell</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>02:20</end_time>
      <description>We present Hoogle+, a web-based API discovery tool for Haskell. A Hoogle+ user can specify a programming task using either a type, a set of input-output tests, or both. Given a specification, the tool returns a list of matching programs composed from functions in popular Haskell libraries, and annotated with automatically-generated examples of their behavior. These features of Hoogle+ are powered by three novel techniques. First, to enable efficient type-directed synthesis from tests only, we develop an algorithm that infers likely type specifications from tests. Second, to return high-quality programs even with ambiguous specifications, we develop a technique that automatically eliminates meaningless and repetitive synthesis results. Finally, we show how to extend this elimination technique to automatically generate informative inputs that can be used to demonstrate program behavior to the user. To evaluate the effectiveness of Hoogle+ compared with traditional API search techniques, we perform a user study with 30 participants of varying Haskell proficiency. The study shows that programmers equipped with Hoogle+ generally solve tasks faster and were able to solve 50% more tasks overall.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael B.</first_name>
          <last_name>James</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>Michael James is a 3rd year PhD student at University of California, San Diego studying programming languages and program synthesis under Nadia Polikarpova. He worked as a software engineer for three years before starting his degree. His experience has guided him to research topics that will ultimately flow back to help other engineers and make programming easier for all.</bio>
          <homepage_url>http://michaelbjames.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelbjames/8360df32-2f8d-4f7c-99c1-523f1f811bec/small.jpg</picture_url>
          <person_id>michaelbjames</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zheng</first_name>
          <last_name>Guo</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <person_id>zhengguo1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziteng</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wzt.me/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zitengwang/bf349a37-8935-4553-bcf7-c78094e369c5/small.jpg</picture_url>
          <person_id>zitengwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Shivani</first_name>
          <last_name>Doshi</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>Current Cornell Tech MEng Student, UC San Diego 2020 BS in CS graduate.</bio>
          <homepage_url>https://shivanidoshi26.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shivanidoshi/a3bdf8b0-e4df-4be6-8c43-1cd1aee38f69/small.jpg</picture_url>
          <person_id>shivanidoshi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Ranjit</first_name>
          <last_name>Jhala</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>Nom nom. Chomp. Burp.</bio>
          <homepage_url>http://ranjitjhala.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ranjitjhala/afbdab69-ed23-4022-b7a4-2c57128f20ec/small.jpg</picture_url>
          <person_id>ranjitjhala</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e9a66a3b-9cd8-4caf-87b3-fae4df74f0b6</slot_id>
      <event_id>e202e9a0-8e64-4364-82a0-a1d2b41e4b74</event_id>
      <title>Interactive Synthesis of Temporal Specifications from Examples and Natural Language</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>01:40</end_time>
      <description>Motivated by applications in robotics, we consider the task of synthesizing linear temporal logic (LTL) specifications based on examples and natural language descriptions. While LTL is a flexible, expressive, and unambiguous language to describe robotic tasks, it is often challenging for non-expert users. In this paper, we present an interactive method for synthesizing LTL specifications from a single example trace and a natural language description. The interaction is limited to showing a small number of behavioral examples to the user who decides whether or not they exhibit the original intent. Our approach generates candidate LTL specifications and distinguishing examples using an encoding into optimization modulo theories problems. Additionally, we use a grammar extension mechanism and a semantic parser to generalize synthesized specifications to parametric task descriptions for subsequent use. Our implementation in the tool LtlTalk starts with a domain-specific language that maps to a fragment of LTL and expands it through example-based user interactions, thus enabling natural language-like robot programming, while maintaining the expressive power and precision of a formal language. Our experiments show that the synthesis method is precise, quick, and asks only a few questions to the users, and we demonstrate in a case study how LtlTalk generalizes from the synthesized tasks to other, yet unseen, tasks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Gavran</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>ivangavran</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eva</first_name>
          <last_name>Darulova</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mpi-sws.org/~eva/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/evadarulova/0d98744b-ec94-4a27-b1c0-0d728d54bdb7/small.jpg</picture_url>
          <person_id>evadarulova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rupak</first_name>
          <last_name>Majumdar</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~rupak</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rupakmajumdar/3289b197-9f9a-4880-94c5-d9cf6d764bb1/small.jpg</picture_url>
          <person_id>rupakmajumdar</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8c341dd6-a43b-4c21-a90b-82308ca6e070</subevent_id>
    <title>SPLASH OOPSLA: F-3A</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>75bf2d47-560f-4724-8b5e-13d2941970c8</slot_id>
      <title>Session: SPLASH OOPSLA - F-3A</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Hidehiko</first_name>
          <last_name>Masuhara</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>Hidehiko Masuhara is a Professor of Mathematical and Computing Science, Tokyo Institute of Technology since April 2013. He received his B.S., M.S., and Ph.D. in Computer Science from Department of Information Science, University of Tokyo in 1992, 1994, and 1999, respectively, and served as an assistant professor, lecturer, and associate professor at Graphics and Computer Science, Graduate School of Arts and Sciences, University of Tokyo from 1995 until 2013.</bio>
          <homepage_url>http://prg.is.titech.ac.jp/people/masuhara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hidehikomasuhara/3ea94269-6fb5-4c6d-8d6f-0435717377d6/small.jpg</picture_url>
          <person_id>hidehikomasuhara</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>560c9e06-ccb7-4600-9b24-5eefb3879b81</slot_id>
      <event_id>50c0fcb1-ef71-4df6-9d10-ebeddb89add2</event_id>
      <title>Polymorphic Types and Effects with Boolean Unification</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>00:20</end_time>
      <description>We present a simple, practical, and expressive type and effect system based on Boolean constraints. The effect system extends the Hindley-Milner type system, supports parametric polymorphism, and preserves principal types modulo Boolean equivalence. We show how to support type inference by extending Algorithm W with Boolean unification based on the successive variable elimination algorithm. 
We implement the type and effect system in the Flix programming language. We perform an in-depth evaluation on the impact of Boolean unification on type inference time and end-to-end compilation time. While the computational complexity of Boolean unification is NP-hard, the experimental results demonstrate that it works well in practice. We find that the impact on type inference time is on average a 1.4x slowdown and the overall impact on end-to-end compilation time is a 1.1x slowdown.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jaco</first_name>
          <last_name>van de Pol</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>Jaco van de Pol started his research in Utrecht on rewrite systems, in particular termination of higher-order rewrite systems. At CWI Amsterdam, he published several papers on theorem proving and model checking for concurrent systems in process algebra and contributed to the µCRL toolset. In Twente, he started a new research line on parallel model checking algorithms. This resulted in the LTSmin toolset for high-performance model checking. He worked on applications in embedded systems, safety &amp;amp; security and systems biology. He published ~25 journal papers, ~100 conference papers, and edited ~10 volumes. Publications at Google Scholar and DBLP. 
Affiliations: 
 
 MSc Utrecht University (supervisor Hans Zantema) 
 PhD Utrecht University (supervisor Jan Bergstra) 
 Research Assistant LMU Mathematisches Institute Munich (with Helmut Schwichtenberg) 
 Postdoc Technical University of Eindhoven (with Jozef Hooman) 
 Senior Researcher CWI (1999-2007) 
 Associate Professor Technical University of Eindhoven (2004-2007, 20%) 
 Professor Formal Methods and Tools at University of Twente (2007-2018; from Nov 2018 10%) 
 Professor Computer Science at Aarhus University (from Nov 2018) 
</bio>
          <homepage_url>http://fmt.cs.utwente.nl/~vdpol/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jacovandepol/b053e08d-fe52-46a9-b4cd-b863ea6c9c07/small.jpg</picture_url>
          <person_id>jacovandepol</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>774389c4-670d-4c1a-b771-fc63423da52d</slot_id>
      <event_id>c3da127b-d137-44d6-888b-a9da4ddc54a5</event_id>
      <title>Verifying and Improving Halide’s Term Rewriting System with Program Synthesis</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>00:00</end_time>
      <description>Halide is a domain-specific language for high-performance image processing and tensor computations, widely adopted in industry. Internally, the Halide compiler relies on a term rewriting system to prove properties of code required for efficient and correct compilation. This rewrite system is a collection of handwritten transformation rules that incrementally rewrite expressions into simpler forms; the system requires high performance in both time and memory usage to keep compile times low, while operating over the undecidable theory of integers. In this work, we apply formal techniques to prove the correctness of existing rewrite rules and provide a guarantee of termination. Then, we build an automatic program synthesis system in order to craft new, provably correct rules from failure cases where the compiler was unable to prove properties. We identify and fix 4 incorrect rules as well as 8 rules which could give rise to infinite rewriting loops. We demonstrate that the synthesizer can produce better rules than hand-authored ones in five bug fixes, and describe four cases in which it has served as an assistant to a human compiler engineer. We further show that it can proactively improve weaknesses in the compiler by synthesizing a large number of rules without human supervision and showing that the enhanced ruleset lowers peak memory usage of compiled code without appreciably increasing compilation times.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julie L.</first_name>
          <last_name>Newcomb</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jn80842.github.io/</homepage_url>
          <person_id>julielnewcomb</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Adams</last_name>
          <affiliation>Adobe, n.n.</affiliation>
          <bio>undefined</bio>
          <person_id>andrewadams</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Steven</first_name>
          <last_name>Johnson</last_name>
          <affiliation>Google, n.n.</affiliation>
          <bio>undefined</bio>
          <person_id>stevenjohnson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rastislav</first_name>
          <last_name>Bodik</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://homes.cs.washington.edu/~bodik</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rastislavbodik/ae16ae8e-9d00-41c4-9067-0c37da65dde7/small.jpg</picture_url>
          <person_id>rastislavbodik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Shoaib</first_name>
          <last_name>Kamil</last_name>
          <affiliation>Adobe, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shoaibkamil/2bc60aee-bda5-437e-9e74-e00f5a55c9ef/small.jpg</picture_url>
          <person_id>shoaibkamil</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c548632f-d7df-4952-bdc2-1202e7fc9977</slot_id>
      <event_id>8cf8faa8-1f32-4ec8-b6ba-b5a6fc13efef</event_id>
      <title>Contextual Dispatch for Function Specialization</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>23:20</end_time>
      <description>In order to generate efficient code, dynamic language compilers often need information, such as dynamic types, not readily available in the program source. Leveraging a mixture of static and dynamic information, these compilers speculate on the missing information. Within one compilation unit, they specialize the generated code to the previously observed behaviors, betting that past is prologue. When speculation fails, the execution must jump back to unoptimized code. In this paper, we propose an approach to further the specialization, by disentangling classes of behaviors into separate optimization units. With contextual dispatch, functions are versioned and each version is compiled under different assumptions. When a function is invoked, the implementation dispatches to a version optimized under assumptions matching the dynamic context of the call. As a proof-of-concept, we describe a compiler for the R language which uses this approach. Our implementation is, on average, $1.7\times$ faster than the GNU R reference implementation. We evaluate contextual dispatch on a set of benchmarks and measure additional speedup, on top of traditional speculation with deoptimization techniques. In this setting contextual dispatch improves the performance of 18 out of 46 programs in our benchmark suite.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Flückiger</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.o1o.ch</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/olivierfluckiger/6051271d-0eac-48f3-b931-bff878bbce61/small.jpg</picture_url>
          <person_id>olivierfluckiger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guido</first_name>
          <last_name>Chari</last_name>
          <affiliation>Asapp, Argentina</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://charig.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guidochari/a0147ecd-ef4f-404e-ba4a-ffa5894e8830/small.jpg</picture_url>
          <person_id>guidochari</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ming-Ho</first_name>
          <last_name>Yee</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>I’m currently a Ph.D. student in computer science at Northeastern University in Boston, Massachusetts. I work on programming language design and implementation with Jan Vitek.</bio>
          <homepage_url>http://mhyee.com</homepage_url>
          <person_id>minghoyee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jan</first_name>
          <last_name>Jecmen</last_name>
          <affiliation>Czech Technical University, Czechia</affiliation>
          <bio>undefined</bio>
          <person_id>janjecmen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jakob</first_name>
          <last_name>Hain</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.linkedin.com/in/jakobeha/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jakobhain/d10d3ad5-e905-4e33-93d6-7d1545e3ab22/small.jpg</picture_url>
          <person_id>jakobhain</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University, USA / Czech Technical University, Czechia</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ed2a5cb8-35ad-4f8e-8c8b-f01d399f8841</slot_id>
      <event_id>8d09d351-1484-4e6f-a97b-31fc3a8589f5</event_id>
      <title>Fixpoints for the Masses: Programming with First-Class Datalog Constraints</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>23:40</end_time>
      <description>Datalog is a declarative logic programming language that has been used in a variety of applications, including big-data analytics, language processing, networking and distributed systems, and program analysis. 
In this paper, we propose first-class Datalog constraints as a mechanism to construct, compose, and solve Datalog programs at run time. The benefits are twofold: We gain the full power of a functional programming language to operate on Datalog constraints-as-values, while simultaneously we can use Datalog where it really shines: to declaratively express and solve fixpoint problems. 
We present an extension of the lambda calculus with first-class Datalog constraints, including its semantics and a type system with row polymorphism based on Hindley-Milner. We prove soundness of the type system and implement it as an extension of the Flix programming language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>30ccda91-da2d-4258-b786-5b066a131cf8</subevent_id>
    <title>SPLASH OOPSLA: R-5</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>cb2e5aff-9e63-4caf-9039-5a36c0de666b</slot_id>
      <title>Session: SPLASH OOPSLA - R-5</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Anitha</first_name>
          <last_name>Gollamudi</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://scholar.harvard.edu/anithag</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anithagollamudi/8fb48e67-0664-40de-b6fa-163655dda95a/small.jpg</picture_url>
          <person_id>anithagollamudi</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>486d2d98-a5e2-4d91-af13-39cfcbfcf81e</slot_id>
      <event_id>762acf95-3734-44cf-94f3-333cf54f7969</event_id>
      <title>Precise Static Modeling of Ethereum “Memory”</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>15:20</end_time>
      <description>Static analysis of smart contracts as-deployed on the Ethereum blockchain has received much recent attention. However, high-precision analyses currently face significant challenges when dealing with the Ethereum VM (EVM) execution model. A major such challenge is the modeling of low-level, transient memory&amp;amp;#39;&amp;amp;#39; (as opposed to persistent, on-blockchainstorage'') that smart contracts employ. Statically understanding the usage patterns of memory is non-trivial, due to the dynamic allocation nature of in-memory buffers. We offer an analysis that models EVM memory, recovering high-level concepts (e.g., arrays, buffers, call arguments) via deep modeling of the flow of values. Our analysis opens the door to Ethereum static analyses with drastically increased precision. One such analysis detects the extraction of ERC20 tokens by unauthorized users. For another practical vulnerability (redundant calls, possibly used as an attack vector), our memory modeling yields analysis precision of 89%, compared to 16% for a state-of-the-art tool without precise memory modeling. Additionally, precise memory modeling enables the static computation of a contract's gas cost. This gas-cost analysis has recently been instrumental in the evaluation of the impact of the EIP-1884 repricing (in terms of gas costs) of EVM operations, leading to a reward and significant publicity from the Ethereum Foundation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sifis</first_name>
          <last_name>Lagouvardos</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/sifislagouvardos/7bff730b-e719-4f0c-935c-245291f18d9d/small.jpg</picture_url>
          <person_id>sifislagouvardos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Neville</first_name>
          <last_name>Grech</last_name>
          <affiliation>University of Malta</affiliation>
          <bio>I am a Lecturer at the University of Malta. My expertise is focused on program analysis, applied to security and other high-level applications. My research work has been recently highlighted by ACM SIGPLAN and Communications of the ACM. I am also interested in the areas of energy efficient systems, smart contracts, semantics and generative programming. My research tools include decompilers and security analyzers for the Ethereum platform (Gigahorse) and Java pointer and taint analysis frameworks (Doop, P/Taint and HeapDL). Previously, I was Reach High Fellow at the University of Athens, a Senior Research Associate at the University of Bristol, and have worked in industry as a Data Scientist and Software Engineer. I hold a PhD from the University of Southampton.</bio>
          <homepage_url>http://www.nevillegrech.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nevillegrech/e0405613-3240-4ef2-a51f-cb7536870dc5/small.jpg</picture_url>
          <person_id>nevillegrech</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ilias</first_name>
          <last_name>Tsatiris</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/iliastsatiris/b33fd835-f771-4b76-b5e8-00452e460cf7/small.jpg</picture_url>
          <person_id>iliastsatiris</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>Research Interests: programming languages and software engineering 
 
 Program analysis (static analysis, test generation, invariant inference, symbolic execution) 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality) 
</bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
          <person_id>yannissmaragdakis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>757cfdaa-103f-4f80-a0e0-ce84ef8de68e</slot_id>
      <event_id>e19d9707-bf19-4fc6-a3cd-80b6c920be7f</event_id>
      <title>Exposing Cache Timing Side-Channel Leaks through Out-of-Order Symbolic Execution</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>16:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>16:20</end_time>
      <description>As one of the fundamental optimizations in modern processors, the \emph{out-of-order} execution boosts the pipeline throughput by executing independent instructions in parallel rather than in their program orders. However, due to the side effects introduced by such microarchitectural optimization to the CPU cache, secret-critical applications may suffer from timing side-channel leaks. This paper presents a symbolic execution-based technique, named {\sc SymO$_3$}, for exposing cache timing leaks under the context of \emph{out-of-order} execution. {\sc SymO$_3$} proposes new components that address the modeling, reduction, and reasoning challenges of accommodating program analysis to the software code \emph{out-of-order} analysis. We implemented {\sc SymO$_3$} upon KLEE and conducted three evaluations on it. Experimental results show that {\sc SymO$_3$} successfully uncovers a set of cache timing leaks in five real-world programs. Also, {\sc SymO$_3$} finds that, in general, program transformation from compiler optimizations shrink the surface to timing leaks. Furthermore, augmented with a speculative execution modeling, {\sc SymO$_3$} identifies five more leaky programs based on the compound analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shengjian</first_name>
          <last_name>Guo</last_name>
          <affiliation>Baidu Security, USA</affiliation>
          <bio>undefined</bio>
          <person_id>shengjianguo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yueqi</first_name>
          <last_name>Chen</last_name>
          <affiliation>Pennsylvania State University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>yueqichen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jiyong</first_name>
          <last_name>Yu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <person_id>jiyongyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Meng</first_name>
          <last_name>Wu</last_name>
          <affiliation>Ant Group, China</affiliation>
          <bio>undefined</bio>
          <person_id>mengwu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Zhiqiang</first_name>
          <last_name>Zuo</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://zuozhiqiang.bitbucket.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhiqiangzuo/deb374c0-3456-4c74-b48d-8f855a64643c/small.jpg</picture_url>
          <person_id>zhiqiangzuo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Peng</first_name>
          <last_name>Li</last_name>
          <affiliation>Baidu Security, USA</affiliation>
          <bio>undefined</bio>
          <person_id>pengli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Yueqiang</first_name>
          <last_name>Cheng</last_name>
          <affiliation>Baidu Security, USA</affiliation>
          <bio>Yueqiang Cheng is a Senior Staff Security Scientist at Baidu Research and Baidu Security. His research interests are in the areas of data security and privacy, hardware security, and system security. His works have been published on top academic conferences, e.g., IEEE TDSC, ASPLOS, Usenix Security, NDSS, and ICSE.</bio>
          <homepage_url>https://sites.google.com/site/strongerwillcheng/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yueqiangcheng1/62c07e08-2bfd-49de-84a3-43049547d1d7/small.jpg</picture_url>
          <person_id>yueqiangcheng1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Huibo</first_name>
          <last_name>Wang</last_name>
          <affiliation>Baidu X-Lab</affiliation>
          <bio>undefined</bio>
          <person_id>huibowang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ea0d8b9b-7584-492c-85fb-f5918ec2f725</slot_id>
      <event_id>d6245b1d-c06a-4095-a451-8337b829c6c7</event_id>
      <title>Perfectly Parallel Fairness Certification of Neural Networks</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>15:40</end_time>
      <description>Recently, there is growing concern that machine-learned software, which currently assists or even automates decision making, reproduces, and in the worst case reinforces, bias present in the training data. The development of tools and techniques for certifying fairness of this software or describing its biases is, therefore, critical. In this paper, we propose a perfectly parallel static analysis for certifying fairness of feed-forward neural networks used for classification of tabular data. When certification succeeds, our approach provides definite guarantees, otherwise, it describes and quantifies the biased input space regions. We design the analysis to be sound, in practice also exact, and configurable in terms of scalability and precision, thereby enabling pay-as-you-go certification. We implement our approach in an open-source tool called Libra and demonstrate its effectiveness on neural networks trained on popular datasets.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Caterina</first_name>
          <last_name>Urban</last_name>
          <affiliation>Inria, France / ENS, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://caterinaurban.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/caterinaurban1/a945f9bd-bc13-4fe2-945a-59528d7d7e2a/small.jpg</picture_url>
          <person_id>caterinaurban1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Maria</first_name>
          <last_name>Christakis</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mariachris.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mariachristakis/b7bf39cc-368b-44aa-bbcb-c83734e1e8fa/small.jpg</picture_url>
          <person_id>mariachristakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Valentin</first_name>
          <last_name>Wüstholz</last_name>
          <affiliation>ConsenSys, Germany</affiliation>
          <bio>Valentin is a software security researcher at ConsenSys Diligence and has held positions both in academia (at ETH Zürich and UT Austin) and in industry (at Microsoft and Google). He is passionate about developing tools and techniques that allow us to produce more reliable and correct software.</bio>
          <homepage_url>http://www.wuestholz.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/valentinwustholz/c6ff5691-4f3e-472c-8454-168eaaebb7eb/small.jpg</picture_url>
          <person_id>valentinwustholz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Fuyuan</first_name>
          <last_name>Zhang</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>fuyuanzhang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f4f0fc68-04ed-42b3-8acf-32a00bf9ee21</slot_id>
      <event_id>8f64a7c7-6637-4768-a862-bef448adb89f</event_id>
      <title>Taming Callbacks for Smart Contract Modularity</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>16:00</end_time>
      <description>Callbacks are an effective programming discipline for implementing event-driven programming, especially in environments like Ethereum which forbid shared global state and concurrency. Callbacks allow a callee to delegate the execution back to the caller. Though effective, they can lead to subtle mistakes principally in open environments where callbacks can be added in a new code. Indeed, several high profile bugs in smart contracts exploit callbacks. 
We present the first static technique ensuring \emph{modularity} in the presence of callbacks and apply it to verify prominent smart contracts. Modularity ensures that external calls to other contracts cannot affect the behavior of the contract. Importantly, modularity is guaranteed without restricting programming. 
In general, checking modularity is undecidable—even for programs without loops. This paper describes an effective technique for soundly ensuring modularity harnessing SMT solvers. The main idea is to define a constructive version of modularity using \emph{commutativity} and \emph{projection} operations on program segments. We believe that this approach is also accessible to programmers, since counterexamples to modularity can be generated automatically by the SMT solvers, allowing programmers to understand and fix the error. 
We implemented our approach in order to demonstrate the precision of the modularity analysis and applied it to real smart contracts, including a subset of the 150 most active contracts in Ethereum. Our implementation decompiles bytecode programs into an intermediate representation and then implements the modularity checking using SMT queries. Overall, we argue that our experimental results indicate that the method can be applied to many realistic contracts, and that it is able to prove modularity where other methods fail.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Elvira</first_name>
          <last_name>Albert</last_name>
          <affiliation>Complutense University of Madrid, Spain</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/elviraalbert1/9c4fd401-4969-4cc6-ba12-d79d92acee62/small.jpg</picture_url>
          <person_id>elviraalbert1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shelly</first_name>
          <last_name>Grossman</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shellygrossman/c4b389a6-6165-44ef-a938-4b1acbecaaa8/small.jpg</picture_url>
          <person_id>shellygrossman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Noam</first_name>
          <last_name>Rinetzky</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~maon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/noamrinetzky/1ea9bd0d-bd16-4b15-bb66-a8a576ffaa40/small.jpg</picture_url>
          <person_id>noamrinetzky</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Clara</first_name>
          <last_name>Rodríguez-Núñez</last_name>
          <affiliation>Complutense University of Madrid, Spain</affiliation>
          <bio>undefined</bio>
          <person_id>clararodriguez</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Albert</first_name>
          <last_name>Rubio</last_name>
          <affiliation>Complutense University of Madrid, Spain</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://costa.fdi.ucm.es/~arubio/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/albertrubio1/effd4c9a-16fb-4d5d-83cb-a32d83d40c47/small.jpg</picture_url>
          <person_id>albertrubio1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Mooly</first_name>
          <last_name>Sagiv</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>My research focuses on easing the task of developing reliable and efficient software systems. I am particularly interested in static program analysis which combines two disciplines: automated theorem proving and abstract interpretation. In the next decade, I am hoping to develop useful techniques in order to change the ways modern software is built. I am particularly interested in proof automation, given a program and a requirement, automatically prove or disprove that all executions of the program satisfy the requirements. This problem is in general undecidable and untractable. I am interested in developing practical solutions to proof-automation by: (i) exploring modularity of the system and (ii) relying on semi-automatic and interactive process, where the user manually and interactively guides the proof automation, and (iii) simplifying the verification task by using domain-specific abstractions expressed in a decidable logic. I am applying these techniques to verify safety of liveness of distributed systems.</bio>
          <homepage_url>http://www.cs.tau.ac.il/~msagiv/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/moolysagiv/5ff34ce2-4812-410c-aa6d-e1457fc2f1ac/small.jpg</picture_url>
          <person_id>moolysagiv</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f808aa73-9cc1-41d5-bf89-5dd19de1a31a</subevent_id>
    <title>SPLASH OOPSLA: F-2B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>847782a8-b7b2-4e93-869f-b44df20d8889</slot_id>
      <title>Session: SPLASH OOPSLA - F-2B</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1e451afe-cdf6-4c0d-aedc-d976c7a047f5</slot_id>
      <event_id>cd599ff5-f878-4129-adc0-ffafc2709664</event_id>
      <title>Feedback-Driven Semi-supervised Synthesis of Program Transformations</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>09:20</end_time>
      <description>While editing code, it is common for developers to make multiple related repeated edits that are all instances of a more general program transformation. Since this process can be tedious and error-prone, we study the problem of automatically learning program transformations from past edits, which can then be used to predict future edits. We take a novel view of the problem as a semi-supervised learning problem: apart from the concrete edits that are instances of the general transformation, the learning procedure also exploits access to additional inputs (program subtrees) that are marked as positive or negative depending on whether the transformation applies on those inputs. We present a procedure to solve the semi-supervised transformation learning problem using anti-unification and programming-by-example synthesis technology. To eliminate reliance on access to marked additional inputs, we generalize the semi-supervised learning procedure to a feedback-driven procedure that also generates the marked additional inputs in an iterative loop. We apply these ideas to build and evaluate three applications that use different mechanisms for generating feedback. Compared to existing tools that learn program transformations from edits, our feedback-driven semi-supervised approach is vastly more effective in successfully predicting edits with significantly lesser amounts of past edit data.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiang</first_name>
          <last_name>Gao</last_name>
          <affiliation>National University of Singapore, Singapore</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.comp.nus.edu.sg/~gaoxiang/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xianggao/482ff4c5-f003-40e7-90cc-d888adbd1e2f/small.jpg</picture_url>
          <person_id>xianggao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shraddha</first_name>
          <last_name>Barke</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shraddhabarke1/4e11ed13-0f46-4d77-8a6d-dd4c07b7fd4b/small.jpg</picture_url>
          <person_id>shraddhabarke1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Radhakrishna</last_name>
          <affiliation>Microsoft, n.n.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://arjunradhakrishna.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjunradhakrishna/5187c933-18de-4045-9119-d97023dd12b7/small.jpg</picture_url>
          <person_id>arjunradhakrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gustavo</first_name>
          <last_name>Soares</last_name>
          <affiliation>Microsoft, n.n.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://gustavoasoares.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gustavosoares/fc1e5a17-f939-4c3d-ab30-85467cb2610b/small.jpg</picture_url>
          <person_id>gustavosoares</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft, USA</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Alan</first_name>
          <last_name>Leung</last_name>
          <affiliation>Microsoft, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://alan.leung.work</homepage_url>
          <person_id>alanleung</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Nachiappan</first_name>
          <last_name>Nagappan</last_name>
          <affiliation>Microsoft Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/nachin/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nachiappannagappan/c34b7330-eb7e-4bf2-8d02-32395689de52/small.jpg</picture_url>
          <person_id>nachiappannagappan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Ashish</first_name>
          <last_name>Tiwari</last_name>
          <affiliation>Microsoft, n.n.</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.csl.sri.com/users/tiwari/</homepage_url>
          <person_id>ashishtiwari</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5bc75700-b762-4b5c-8286-28456ab6e56b</slot_id>
      <event_id>aed381e3-4082-4aea-8916-ec4572cabcbf</event_id>
      <title>Testing Differential Privacy with Dual Interpreters</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>09:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>09:40</end_time>
      <description>Applying differential privacy at scale requires convenient ways to check that programs computing with sensitive data appropriately preserve privacy. We propose here a fully automated framework for {\em testing} differential privacy, adapting a well-known ``pointwise'' technique from informal proofs of differential privacy. Our framework, called DPCheck, requires no programmer annotations, handles all previously verified or tested algorithms, and is the first fully automated framework to distinguish correct and buggy implementations of PrivTree, a probabilistically terminating algorithm that has not previously been mechanically checked. 
We analyze the probability of DPCheck mistakenly accepting a non-private program and prove that, theoretically, the probability of false acceptance can be made exponentially small by suitable choice of test size. 
We demonstrate DPCheck's utility empirically by implementing all benchmark algorithms from prior work on mechanical verification of differential privacy, plus several others and their incorrect variants, and show DPCheck accepts the correct implementations and rejects the incorrect variants. 
We also demonstrate how DPCheck can be deployed in a practical workflow to test differentially privacy for the 2020 US Census Disclosure Avoidance System (DAS).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hengchu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <person_id>hengchuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Edo</first_name>
          <last_name>Roth</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <person_id>edoroth</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Haeberlen</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <person_id>andreashaeberlen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Benjamin C.</first_name>
          <last_name>Pierce</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>Benjamin Pierce is Henry Salvatori Professor of Computer and Information Science at the University of Pennsylvania and a Fellow of the ACM. His research interests include programming languages, type systems, language-based security, computer-assisted formal verification, differential privacy, and synchronization technologies. He is the author of the widely used graduate textbooks Types and Programming Languages and Software Foundations. He has served as co-Editor in Chief of the Journal of Functional Programming, as Managing Editor for Logical Methods in Computer Science, and as editorial board member of Mathematical Structures in Computer Science, Formal Aspects of Computing, and ACM Transactions on Programming Languages and Systems. He is also the lead designer of the popular Unison file synchronizer and co-developer of the Clowdr virtual conference platform.</bio>
          <homepage_url>http://www.cis.upenn.edu/~bcpierce/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/benjamincpierce/f2ee6f41-5bf7-4a0d-9b8d-71de6a666b1b/small.jpg</picture_url>
          <person_id>benjamincpierce</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Roth</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <person_id>aaronroth</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bceecc5f-13d0-48be-b3ad-dea83c68bfad</slot_id>
      <event_id>9759a59c-e7fe-44ff-91d0-9250476fa15d</event_id>
      <title>Differentially-Private Software Frequency Profiling under Linear Constraints</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>10:20</end_time>
      <description>Differential privacy has emerged as a leading theoretical framework for privacy-preserving data gathering and analysis. It allows meaningful statistics to be collected for a population without revealing ``too much'' information about any individual member of the population. For software profiling, this machinery allows profiling data from many users of a deployed software system to be collected and analyzed in a privacy-preserving manner. Such a solution is appealing to many stakeholders, including software users, software developers, infrastructure providers, and government agencies. 
We propose an approach for differentially-private collection of frequency vectors from software executions. Frequency information is reported with the addition of random noise drawn from the Laplace distribution. A key observation behind the design of our scheme is that event frequencies are closely correlated due to the static code structure. Differential privacy protections must account for such relationships; otherwise, a seemingly-strong privacy guarantee is actually weaker than it appears. Motivated by this observation, we propose a novel and general differentially-private profiling scheme when correlations between frequencies can be expressed through linear inequalities. Using a linear programming formulation, we show how to determine the magnitude of random noise that should be added to achieve meaningful privacy protections under such linear constraints. Next, we develop an efficient instance of this general machinery for an important subclass of constraints. Instead of LP, our solution uses a reachability analysis of a constraint graph. As an exemplar, we employ this approach to implement differentially-private method frequency profiling for Android apps. 
Any differentially-private scheme has to balance two competing aspects: privacy and accuracy. Through an experimental study to characterize these trade-offs, we (1) show that our proposed randomization achieves much higher accuracy compared to related prior work, (2) demonstrate that high accuracy and high privacy protection can be achieved simultaneously, and (3) highlight the importance of linear constraints in the design of the randomization. These promising results provide evidence that our approach is a good candidate for privacy-preserving frequency profiling of deployed software.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hailong</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Fordham University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hailongzhang.com</homepage_url>
          <person_id>hailongzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yu</first_name>
          <last_name>Hao</last_name>
          <affiliation>Ohio State University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>yuhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sufian</first_name>
          <last_name>Latif</last_name>
          <affiliation>Ohio State University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>sufianlatif</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Raef</first_name>
          <last_name>Bassily</last_name>
          <affiliation>Ohio State University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>raefbassily</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Atanas</first_name>
          <last_name>Rountev</last_name>
          <affiliation>Ohio State University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.ohio-state.edu/~rountev</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/atanasrountev/57ea0ee0-eebe-48f0-91fe-1ed3a28b5d92/small.jpg</picture_url>
          <person_id>atanasrountev</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f2b57e56-2c01-4dcf-a2fb-3bfccb7a24f0</slot_id>
      <event_id>3d4eac8d-6c79-48a8-b5ab-8b400d1a80ee</event_id>
      <title>Unifying Execution of Imperative Generators and Declarative Specifications</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>10:00</end_time>
      <description>We present Deuterium—a framework for implementing Java methods as executable contracts. Deuterium introduces a novel, type-safe way to write method contracts entirely in Java, as a combination of imperative generators and declarative specifications (written in a first-order relational logic with transitive closure). Existing approaches are typically based on encoding both the specification and the program heap into a constraint language, and then using an off-the-shelf constraint solver—without any additional guidance—to search for a new program heap that satisfies the specification. Deuterium takes advantage of user-provided generators to prune the search space and reduce incurred overhead of constraint solving. Deuterium supports two ways of solving declarative constraints: SAT-based and search-based with in-memory state exploration. We evaluate our approach on a suite of data structures, established as a standard benchmark by prior work. Furthermore, we use random and sequence-based test generation to create a new benchmark designed to mimic realistic execution scenarios. Our results show that generators improve the performance of executable contracts and that in-memory state exploration is the algorithm of choice when heap sizes are small.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pengyu</first_name>
          <last_name>Nie</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>I’m a Ph.D. student at the University of Texas at Austin. I work with Prof. Milos Gligoric. My research interests focus on the fusion of software engineering, programming languages, and natural language processing. Specific topics include languages for writing executable contracts and executable comments, updating natural language elements for evolving software, and utilizing runtime context to improve ML models for software.</bio>
          <homepage_url>http://cozy.ece.utexas.edu/~pynie/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/pengyunie/eb2ae7b4-4e42-4cbe-ba27-0b4f2fac274a/small.jpg</picture_url>
          <person_id>pengyunie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marinela</first_name>
          <last_name>Parovic</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>marinelaparovic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhiqiang</first_name>
          <last_name>Zang</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>zhiqiangzang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sarfraz</first_name>
          <last_name>Khurshid</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/sarfrazkhurshid/b998e03f-4c99-458b-a9f9-b6c470511e3b/small.jpg</picture_url>
          <person_id>sarfrazkhurshid</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Aleksandar</first_name>
          <last_name>Milicevic</last_name>
          <affiliation>Microsoft, n.n.</affiliation>
          <bio>undefined</bio>
          <person_id>aleksandarmilicevic2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Milos</first_name>
          <last_name>Gligoric</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/milosgligoric/4d0671ae-937e-4f08-b499-092379ff7ad3/small.jpg</picture_url>
          <person_id>milosgligoric</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>be31db10-0385-4df5-946a-6f8a8275e9d4</subevent_id>
    <title>SPLASH OOPSLA: W-4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>f6016ecb-9d16-4158-af26-47eac54700b7</slot_id>
      <title>Session: SPLASH OOPSLA - W-4</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Sophia</first_name>
          <last_name>Drossopoulou</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Professor of Programming Languages in the Department of Computing, Imperial College, London, UK.</bio>
          <homepage_url>https://wp.doc.ic.ac.uk/sd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sophiadrossopoulou/f9f2890b-55bd-4796-94ab-fe3291277c90/small.jpg</picture_url>
          <person_id>sophiadrossopoulou</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1de870e1-2600-4470-b0ff-459a82a1ab96</slot_id>
      <event_id>589e08b8-be04-449c-9c40-7dc3797f2c0b</event_id>
      <title>Adversarial Examples for Models of Code</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>01:20</end_time>
      <description>Neural models of code have shown impressive results when performing tasks such as predicting method names and identifying certain kinds of bugs. We show that these models are vulnerable to \emph{adversarial examples}, and introduce a novel approach for \emph{attacking} trained models of code using adversarial examples. The main idea of our approach is to force a given trained model to make an incorrect prediction, as specified by the adversary, by introducing small perturbations that do not change the program's semantics, thereby creating an adversarial example. To find such perturbations, we present a new technique for Discrete Adversarial Manipulation of Programs (DAMP). DAMP works by deriving the desired prediction with respect to the model's \emph{inputs}, while holding the model weights constant, and following the gradients to slightly modify the input code. 
We show that our DAMP attack is effective across three neural architectures: code2vec, GGNN, and GNN-FiLM, in both Java and C#. Our evaluations demonstrate that DAMP has up to 89% success rate in changing a prediction to the adversary's choice (a targeted attack) and a success rate of up to 94% in changing a given prediction to any incorrect prediction (a non-targeted attack). To defend a model against such attacks, we empirically examine a variety of possible defenses and discuss their trade-offs. We show that some of these defenses can dramatically drop the success rate of the attacker, with a minor penalty of 2% relative degradation in accuracy when they are not performing under attack. 
Our code, data, and trained models are available at \url{https://github.com/tech-srl/adversarial-examples} .</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Noam</first_name>
          <last_name>Yefet</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <person_id>noamyefet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Uri</first_name>
          <last_name>Alon</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~urialon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/urialon/a0488e4f-5173-472b-af25-10666c27e3d4/small.jpg</picture_url>
          <person_id>urialon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>Eran Yahav is an associate professor at the Computer Science Department, Technion, Israel. Prior to that, he was a research staff member at the IBM T.J. Watson Research Center (2004-2010). He received his Ph.D. from Tel Aviv University (2005) and his B.Sc. from the Technion in 1996. His research interests include program analysis, program synthesis and program verification. Eran is a recipient of the prestigious Alon Fellowship for Outstanding Young Researchers, the Andre Deloro Career Advancement Chair in Engineering, the ERC Consolidator Grant as well as multiple best paper awards at various conferences.</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
          <person_id>eranyahav</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>599b99ef-463c-4756-9056-3672194b0c04</slot_id>
      <event_id>c3abeda5-100d-409c-8506-b3ec6c6db79f</event_id>
      <title>Finding Bugs in Database Systems via Query Partitioning</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>01:40</end_time>
      <description>Logic bugs in Database Management Systems (DBMSs) are bugs that cause an incorrect result for a given query, for example, by omitting a row that should be fetched. These bugs are critical, since they are likely to go unnoticed by users. We propose Query Partitioning, a general and effective approach for finding logic bugs in DBMSs. The core idea of Query Partitioning is to, starting from a given original query, derive multiple, more complex queries (called partitioning queries), each of which computes a partition of the result. The individual partitions are then composed to compute a result set that must be equivalent to the original query's result set. A bug in the DBMS is detected when these result sets differ. Our intuition is that due to the increased complexity, the partitioning queries are more likely to stress the DBMS and trigger a logic bug than the original query. As a concrete instance of a partitioning strategy, we propose Ternary Logic Partitioning (TLP), which is based on the observation that a boolean predicate p can either evaluate to TRUE, FALSE, or NULL. Accordingly, a query can be decomposed into three partitioning queries, each of which computes its result on rows or intermediate results for which p, NOT p, and p IS NULL hold. This technique is versatile, and can be used to test WHERE, GROUP BY, as well as HAVING clauses, aggregate functions, and DISTINCT queries. As part of an extensive testing campaign, we found 175 bugs in widely-used DBMSs such as MySQL, TiDB, SQLite, and CockroachDB, 125 of which have been fixed. Notably, 77 of these were logic bugs, while the remaining were error and crash bugs. We expect that the effectiveness and wide applicability of Query Partitioning will lead to its broad adoption in practice, and the formulation of additional partitioning strategies.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Rigger</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>Manuel Rigger is a postdoctoral researcher in the Advanced Software Technologies (AST) Lab at ETH Zurich, mentored by Zhendong Su. He is working on programming language implementation, software reliability, and systems. He completed his PhD at Johannes Kepler University Linz, mentored by Hanspeter Mössenböck, and is known for his work on Sulong to support the safe execution of LLVM-based languages.</bio>
          <homepage_url>http://www.manuelrigger.at/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelrigger/47e268e9-158c-471f-a7e9-442216c54550/small.jpg</picture_url>
          <person_id>manuelrigger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8f15d83b-6d81-4b50-9275-c4f59a5fd856</slot_id>
      <event_id>dba90368-d2da-4b07-8bd6-dc1e3f236813</event_id>
      <title>How Do Programmers Use Unsafe Rust?</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>02:20</end_time>
      <description>Rust's ownership type system enforces a strict discipline on how memory locations are accessed and shared. This discipline allows the compiler to statically prevent memory errors, data races, inadvertent side effects through aliasing, and other errors that frequently occur in conventional imperative programs. However, the restrictions imposed by Rust's type system make it difficult or impossible to implement certain designs, such as data structures that require aliasing (e.g. doubly-linked lists and shared caches). To work around this limitation, Rust allows code blocks to be declared as \emph{unsafe} and thereby exempted from certain restrictions of the type system, for instance, to manipulate C-style raw pointers. Ensuring the safety of unsafe code is the responsibility of the programmer. However, an important assumption of the Rust language, which we dub the \emph{Rust hypothesis}, is that programmers use Rust by following three main principles: use unsafe code sparingly, make it easy to review, and hide it behind a safe abstraction such that client code can be written in safe Rust. 
Understanding how Rust programmers use unsafe code and, in particular, whether the Rust hypothesis holds is essential for Rust developers and testers, language and library designers, as well as tool developers. This paper studies empirically how unsafe code is used in practice by analysing a large corpus of Rust projects to assess the validity of the Rust hypothesis and to classify the purpose of unsafe code. We identify queries that can be answered by automatically inspecting the program's source code, its intermediate representation MIR, as well as type information provided by the Rust compiler; we complement the results by manual code inspection. Our study supports the Rust hypothesis partially: While most unsafe code is simple and well-encapsulated, unsafe features are used extensively, especially for interoperability with other languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vytautas</first_name>
          <last_name>Astrauskas</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>vytautasastrauskas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Matheja</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>christophmatheja1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Federico</first_name>
          <last_name>Poli</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>federicopoli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Peter</first_name>
          <last_name>Müller</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/petermller/aeb8e276-62cb-4ad1-aa7d-96f76c0c405d/small.jpg</picture_url>
          <person_id>petermller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Alexander J.</first_name>
          <last_name>Summers</last_name>
          <affiliation>University of British Columbia, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.inf.ethz.ch/summersa/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexanderjsummers/f97b84a8-d46a-4e76-aa73-cc4b38c4ec41/small.jpg</picture_url>
          <person_id>alexanderjsummers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f596b67d-f56e-4446-b8b1-cf6b32dc1681</slot_id>
      <event_id>9609351d-7346-41c3-a781-926327d9a68c</event_id>
      <title>Proving Highly-Concurrent Traversals Correct</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>02:00</end_time>
      <description>Modern highly-concurrent search data structures, such as search trees, obtain multi-core scalability and performance by having operations traverse the data structure without any synchronization. As a result, however, these algorithms are notoriously difficult to prove linearizable, which requires identifying a point in time in which the traversal's result is correct. The problem is that traversing the data structure as it undergoes modifications leads to complex behaviors, necessitating intricate reasoning about all interleavings of reads by traversals and writes mutating the data structure. 
In this paper, we present a general proof technique for proving unsynchronized traversals correct in a significantly simpler manner, compared to typical concurrent reasoning and prior proof techniques. Our framework relies only on sequential properties} of traversals and on a conceptually simple and widely-applicable condition about the ways an algorithm's writes mutate the data structure. Establishing that a target data structure satisfies our condition requires only simple concurrent reasoning, without considering interactions of writes and reads. This reasoning can be further simplified by using our framework. 
To demonstrate our technique, we apply it to prove several interesting and challenging concurrent binary search trees: the logical-ordering AVL tree, the Citrus tree, and the full contention-friendly tree. Both the logical-ordering tree and the full contention-friendly tree are beyond the reach of previous approaches targeted at simplifying linearizability proofs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yotam</first_name>
          <last_name>Feldman</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/research/yotam.feldman/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yotamfeldman/ed864714-e66c-4ec1-a171-8c2ac69d62a1/small.jpg</picture_url>
          <person_id>yotamfeldman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Artem</first_name>
          <last_name>Khyzha</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://artkhyzha.github.io/</homepage_url>
          <person_id>artemkhyzha1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Constantin</first_name>
          <last_name>Enea</last_name>
          <affiliation>University of Paris Diderot, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~cenea/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/constantinenea/2dfe8bfe-ddfe-4012-a2e2-01cc8b953734/small.jpg</picture_url>
          <person_id>constantinenea</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Adam</first_name>
          <last_name>Morrison</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~mad</homepage_url>
          <person_id>adammorrison1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Aleksandar</first_name>
          <last_name>Nanevski</last_name>
          <affiliation>IMDEA Software Institute, Spain</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://software.imdea.org/~aleks</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aleksandarnanevski/6612f235-0493-478f-9ecd-d86045a7619a/small.jpg</picture_url>
          <person_id>aleksandarnanevski</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Noam</first_name>
          <last_name>Rinetzky</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~maon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/noamrinetzky/1ea9bd0d-bd16-4b15-bb66-a8a576ffaa40/small.jpg</picture_url>
          <person_id>noamrinetzky</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Sharon</first_name>
          <last_name>Shoham</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.tau.ac.il/~sharonshoham/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sharonshoham/52ca243a-805e-43b9-9f5a-bd1bae25fccb/small.jpg</picture_url>
          <person_id>sharonshoham</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0dea8e8b-8f06-4175-8904-47d820bd3113</subevent_id>
    <title>SPLASH OOPSLA: W-1</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>eafa6481-2c1c-43a9-ba74-08c92809bcc2</slot_id>
      <title>Session: SPLASH OOPSLA - W-1</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>07:00</start_time>
      <end_time>08:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Karim</first_name>
          <last_name>Ali</last_name>
          <affiliation>University of Alberta</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://karimali.ca</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/karimali/460ecc0b-764d-462b-a93e-66a3270d72ef/small.jpg</picture_url>
          <person_id>karimali</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Benjamin C.</first_name>
          <last_name>Pierce</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>Benjamin Pierce is Henry Salvatori Professor of Computer and Information Science at the University of Pennsylvania and a Fellow of the ACM. His research interests include programming languages, type systems, language-based security, computer-assisted formal verification, differential privacy, and synchronization technologies. He is the author of the widely used graduate textbooks Types and Programming Languages and Software Foundations. He has served as co-Editor in Chief of the Journal of Functional Programming, as Managing Editor for Logical Methods in Computer Science, and as editorial board member of Mathematical Structures in Computer Science, Formal Aspects of Computing, and ACM Transactions on Programming Languages and Systems. He is also the lead designer of the popular Unison file synchronizer and co-developer of the Clowdr virtual conference platform.</bio>
          <homepage_url>http://www.cis.upenn.edu/~bcpierce/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/benjamincpierce/f2ee6f41-5bf7-4a0d-9b8d-71de6a666b1b/small.jpg</picture_url>
          <person_id>benjamincpierce</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>71b50b13-174a-44ce-baaa-328c8c04482e</slot_id>
      <event_id>ab26b4f9-908b-48a6-88f1-36f0a94e32cc</event_id>
      <title>Mossad: Defeating Software Plagiarism Detection</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>07:20</end_time>
      <description>Automatic software plagiarism detection tools are widely used in educational settings to ensure that submitted work was not copied. These tools have grown in use together with the rise in enrollments in computer science programs and the widespread availability of code on-line. Educators rely on the robustness of plagiarism detection tools; the working assumption is that the effort required to evade detection is as high as that required to actually do the assigned work. 
This paper shows this is not the case. It presents an entirely automatic program transformation approach, MOSSAD, that defeats popular software plagiarism detection tools. MOSSAD comprises a framework that couples techniques inspired by genetic programming with domain-specific knowledge to effectively undermine plagiarism detectors. MOSSAD is effective at defeating four plagiarism detectors, including Moss and JPlag. MOSSAD is both fast and effective: it can, in minutes, generate modified versions of programs that are likely to escape detection. More insidiously, because of its non-deterministic approach, MOSSAD can, from a single program, generate \emph{dozens} of variants, which are classified as no more suspicious than legitimate assignments. A detailed study of MOSSAD across a corpus of real student assignments demonstrates its efficacy at evading detection. A user study shows that graduate student assistants consistently rate MOSSAD-generated code as just as readable as authentic student code. This work motivates the need for both research on more robust plagiarism detection tools and greater integration of naturally plagiarism-resistant methodologies like code review into computer science education.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Breanna</first_name>
          <last_name>Devore-McDonald</last_name>
          <affiliation>University of Massachusetts at Amherst, USA</affiliation>
          <bio>undefined</bio>
          <person_id>breannadevoremcdonald</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Emery</first_name>
          <last_name>Berger</last_name>
          <affiliation>University of Massachusetts at Amherst, USA</affiliation>
          <bio>Emery is a Professor at the University of Massachusetts Amherst. He researches languages, runtime systems, and operating systems, with a particular focus on systems that transparently improve reliability, security, and performance. Emery and friends have created Hoard, the first scalable memory manager (malloc), on which the Mac OS X memory manager is based; DieHard, an error-avoiding memory manager that directly influenced the design of the Windows 7 Fault-Tolerant Heap; DieHarder, a secure memory manager that was an inspiration for hardening changes made to the Windows 8 heap; the Coz profiler, which ships with modern Linux distros; and more. He was named an ACM Fellow in 2019.</bio>
          <homepage_url>http://www.emeryberger.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/emeryberger/6187feeb-700c-48d5-aceb-6d7b87490a7a/small.jpg</picture_url>
          <person_id>emeryberger</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8d96bdf5-144b-44ef-884f-b0eb117fd24f</slot_id>
      <event_id>fcd71652-1e16-475e-bda3-bcb0432637a2</event_id>
      <title>Program Equivalence for Assisted Grading of Functional Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>07:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>08:00</end_time>
      <description>In courses that involve programming assignments, giving meaningful feedback to students is an important challenge. Human beings can give useful feedback by manually grading the programs but this is a time-consuming, labor intensive, and usually boring process. Automatic graders can be fast and scale well but they usually provide poor feedback. Although there has been research on improving automatic graders, research on scaling and improving human grading is limited. 
We propose to scale human grading by augmenting the manual grading process with an equivalence algorithm that can identify the equivalences between student submissions. This enables human graders to give targeted feedback for multiple student submissions at once. Our technique is conservative in two aspects. First, it identifies equivalence between submissions that are algorithmically similar, e.g., it cannot identify the equivalence between quicksort and mergesort. Second, it uses formal methods instead of clustering algorithms from the machine learning literature. This allows us to prove a soundness result that guarantees that submissions will never be clustered together in error. Despite only reporting equivalence when there is algorithmic similarity and the ability to formally prove equivalence, we show that our technique can significantly reduce grading time for thousands of programming submissions from an introductory functional programming course.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Clune</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>joshuaclune</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vijay</first_name>
          <last_name>Ramamurthy</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>vijayramamurthy</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ruben</first_name>
          <last_name>Martins</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Ruben Martins is a Systems Scientist at the Carnegie Mellon University. Prior to joining CMU, he was a postdoctoral researcher at UT Austin where he pushed the frontiers of program synthesis and security with constraint solving. Before UT Austin, he was a postdoctoral researcher at the University of Oxford, UK where he worked on CBMC for software verification. He received his PhD with honors from the University of Lisbon, Portugal in 2013. His research aims to improve constraint solvers and broaden their applicability in program analysis, synthesis, and security. Dr. Martins has developed several award winning solvers and has consistently improved the state-of-the-art in MaxSAT solving. He is currently the main developer of Open-WBO: an open source MaxSAT solver that won several awards in the MaxSAT competitions.</bio>
          <homepage_url>https://sat-group.github.io/ruben/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rubenmartins/6cfee429-6785-4395-bcf6-ddb6dd674d58/small.jpg</picture_url>
          <person_id>rubenmartins</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Umut A.</first_name>
          <last_name>Acar</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/umutacar/645140f1-714c-4def-ab34-8c78d85a50bf/small.jpg</picture_url>
          <person_id>umutacar</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ec9e935a-4be4-4acd-bf43-2d1fee10ca06</slot_id>
      <event_id>15674d02-5f12-493f-b843-8068fb89ee09</event_id>
      <title>Revisiting Iso-Recursive Subtyping</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>08:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>08:20</end_time>
      <description>The Amber rules are well-known and widely used for subtyping iso-recursive types. They were first briefly and informally introduced in 1985 by Cardelli in a manuscript describing the Amber language. Despite their use over many years, important aspects of the metatheory of the iso-recursive style Amber rules have not been studied in depth or turn out to be quite challenging to formalize. 
This paper aims to revisit the problem of subtyping iso-recursive types. We start by introducing a novel declarative specification that we believe captures the ``spirit'' of Amber-style iso-recursive subtyping. Informally, the specification states that two recursive types are subtypes \emph{if all their finite unfoldings are subtypes}. The Amber rules are shown to be sound with respect to this declarative specification. We then derive a \emph{sound}, \emph{complete} and \emph{decidable} algorithmic formulation of subtyping that employs a novel \emph{double unfolding} rule. Compared to the Amber rules, the double unfolding rule has the advantage of: 1) being modular; 2) not requiring reflexivity to be built in; and 3) leading to an easy proof of transitivity of subtyping. This work sheds new insights on the theory of subtyping iso-recursive types, and the new double unfolding rule has important advantages over the original Amber rules for both implementations and metatheoretical studies involving recursive types. All results are mechanically formalized in the Coq theorem prover. As far as we know, this is the first comprehensive treatment of iso-recursive subtyping dealing with unrestricted recursive types in a theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yaoda</first_name>
          <last_name>Zhou</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <person_id>yaodazhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jinxu</first_name>
          <last_name>Zhao</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <person_id>jinxuzhao</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ece7329c-1b58-4a64-a100-9eb5c38195bb</slot_id>
      <event_id>68a84a17-ccd2-48b6-9085-63301738428f</event_id>
      <title>Precise Inference of Expressive Units of Measurement Types</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>07:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>07:40</end_time>
      <description>Ensuring computations are unit-wise consistent is an important task in software development. Numeric computations are usually performed with primitive types instead of abstract data types, which results in very weak static guarantees about correct usage and conversion of units. This paper presents PUnits, a pluggable type system for expressive units of measurement types and a precise, whole-program inference approach for these types. PUnits can be used in three modes: (1) modularly check the correctness of a program, (2) ensure a possible unit typing exists, and (3) annotate a program with units. Annotation mode allows human inspection and is essential since having a valid typing does not guarantee that the inferred specification expresses design intent. PUnits is the first units type system with this capability. Compared to prior work, PUnits strikes a novel balance between expressiveness, inference complexity, and annotation effort. We implement PUnits for Java and evaluate it by specifying the correct usage of frequently used JDK methods. We analyze 234k lines of code from eight open-source scientific computing projects with PUnits. We compare PUnits against an encapsulation-based units API (the javax.measure package) and discovered unit errors that the API failed to find. PUnits infers 90 scientific units for five of the projects and generates well-specified applications. The experiments show that PUnits is an effective, sound, and scalable alternative to using encapsulation-based units APIs, enabling Java developers to reap the performance benefits of using primitive types instead of abstract data types for unit-wise consistent scientific computations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tongtong</first_name>
          <last_name>Xiang</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>tongtongxiang1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jeff Y.</first_name>
          <last_name>Luo</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>jeffluo1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Werner</first_name>
          <last_name>Dietl</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ece.uwaterloo.ca/~wdietl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/wernerdietl/f6ddc3ef-7134-4260-a182-a71ed88842cb/small.jpg</picture_url>
          <person_id>wernerdietl</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2454dc0e-cdf4-42ed-a692-ef9118122ca9</subevent_id>
    <title>SPLASH OOPSLA: W-1</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>a4cc183c-b9c9-4e29-a6ed-46d15cd2ec44</slot_id>
      <title>Session: SPLASH OOPSLA - W-1</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>19:00</start_time>
      <end_time>20:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Lam</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://patricklam.ca</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/patricklam/d94f6246-8d4e-4896-a263-379eb20a9b24/small.jpg</picture_url>
          <person_id>patricklam</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Julia</first_name>
          <last_name>Belyakova</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>Sep 2018 – present: PhD Student, Northeastern University, USA. Sep 2017 – Jul 2018: Researcher, Czech Technical University in Prague, Czech Republic. Jan 2017 – Jun 2017: Research Scientist, Northeastern University, USA. 2014–2016: teaching assistant/lecturer at Southern Federal University, Russia. Received MS in Computer Science from Southern Federal University, Russia in 2014.</bio>
          <homepage_url>https://julbinb.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juliabelyakova/b35236df-c22a-44f1-8048-aecfeba8ac2e/small.jpg</picture_url>
          <person_id>juliabelyakova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>30ff694a-ce3a-4378-9a3f-dcd9c431b282</slot_id>
      <event_id>15674d02-5f12-493f-b843-8068fb89ee09</event_id>
      <title>Revisiting Iso-Recursive Subtyping</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>20:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>20:20</end_time>
      <description>The Amber rules are well-known and widely used for subtyping iso-recursive types. They were first briefly and informally introduced in 1985 by Cardelli in a manuscript describing the Amber language. Despite their use over many years, important aspects of the metatheory of the iso-recursive style Amber rules have not been studied in depth or turn out to be quite challenging to formalize. 
This paper aims to revisit the problem of subtyping iso-recursive types. We start by introducing a novel declarative specification that we believe captures the ``spirit'' of Amber-style iso-recursive subtyping. Informally, the specification states that two recursive types are subtypes \emph{if all their finite unfoldings are subtypes}. The Amber rules are shown to be sound with respect to this declarative specification. We then derive a \emph{sound}, \emph{complete} and \emph{decidable} algorithmic formulation of subtyping that employs a novel \emph{double unfolding} rule. Compared to the Amber rules, the double unfolding rule has the advantage of: 1) being modular; 2) not requiring reflexivity to be built in; and 3) leading to an easy proof of transitivity of subtyping. This work sheds new insights on the theory of subtyping iso-recursive types, and the new double unfolding rule has important advantages over the original Amber rules for both implementations and metatheoretical studies involving recursive types. All results are mechanically formalized in the Coq theorem prover. As far as we know, this is the first comprehensive treatment of iso-recursive subtyping dealing with unrestricted recursive types in a theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yaoda</first_name>
          <last_name>Zhou</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <person_id>yaodazhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jinxu</first_name>
          <last_name>Zhao</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <person_id>jinxuzhao</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7dd4dd57-0180-4966-a2cb-c7b9ba64cbac</slot_id>
      <event_id>68a84a17-ccd2-48b6-9085-63301738428f</event_id>
      <title>Precise Inference of Expressive Units of Measurement Types</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>19:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>19:40</end_time>
      <description>Ensuring computations are unit-wise consistent is an important task in software development. Numeric computations are usually performed with primitive types instead of abstract data types, which results in very weak static guarantees about correct usage and conversion of units. This paper presents PUnits, a pluggable type system for expressive units of measurement types and a precise, whole-program inference approach for these types. PUnits can be used in three modes: (1) modularly check the correctness of a program, (2) ensure a possible unit typing exists, and (3) annotate a program with units. Annotation mode allows human inspection and is essential since having a valid typing does not guarantee that the inferred specification expresses design intent. PUnits is the first units type system with this capability. Compared to prior work, PUnits strikes a novel balance between expressiveness, inference complexity, and annotation effort. We implement PUnits for Java and evaluate it by specifying the correct usage of frequently used JDK methods. We analyze 234k lines of code from eight open-source scientific computing projects with PUnits. We compare PUnits against an encapsulation-based units API (the javax.measure package) and discovered unit errors that the API failed to find. PUnits infers 90 scientific units for five of the projects and generates well-specified applications. The experiments show that PUnits is an effective, sound, and scalable alternative to using encapsulation-based units APIs, enabling Java developers to reap the performance benefits of using primitive types instead of abstract data types for unit-wise consistent scientific computations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tongtong</first_name>
          <last_name>Xiang</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>tongtongxiang1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jeff Y.</first_name>
          <last_name>Luo</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>jeffluo1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Werner</first_name>
          <last_name>Dietl</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ece.uwaterloo.ca/~wdietl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/wernerdietl/f6ddc3ef-7134-4260-a182-a71ed88842cb/small.jpg</picture_url>
          <person_id>wernerdietl</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>81ff04ab-ce8d-4ca5-9277-9ca366d7dc0c</slot_id>
      <event_id>fcd71652-1e16-475e-bda3-bcb0432637a2</event_id>
      <title>Program Equivalence for Assisted Grading of Functional Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>19:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>20:00</end_time>
      <description>In courses that involve programming assignments, giving meaningful feedback to students is an important challenge. Human beings can give useful feedback by manually grading the programs but this is a time-consuming, labor intensive, and usually boring process. Automatic graders can be fast and scale well but they usually provide poor feedback. Although there has been research on improving automatic graders, research on scaling and improving human grading is limited. 
We propose to scale human grading by augmenting the manual grading process with an equivalence algorithm that can identify the equivalences between student submissions. This enables human graders to give targeted feedback for multiple student submissions at once. Our technique is conservative in two aspects. First, it identifies equivalence between submissions that are algorithmically similar, e.g., it cannot identify the equivalence between quicksort and mergesort. Second, it uses formal methods instead of clustering algorithms from the machine learning literature. This allows us to prove a soundness result that guarantees that submissions will never be clustered together in error. Despite only reporting equivalence when there is algorithmic similarity and the ability to formally prove equivalence, we show that our technique can significantly reduce grading time for thousands of programming submissions from an introductory functional programming course.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Clune</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>joshuaclune</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vijay</first_name>
          <last_name>Ramamurthy</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>vijayramamurthy</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ruben</first_name>
          <last_name>Martins</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Ruben Martins is a Systems Scientist at the Carnegie Mellon University. Prior to joining CMU, he was a postdoctoral researcher at UT Austin where he pushed the frontiers of program synthesis and security with constraint solving. Before UT Austin, he was a postdoctoral researcher at the University of Oxford, UK where he worked on CBMC for software verification. He received his PhD with honors from the University of Lisbon, Portugal in 2013. His research aims to improve constraint solvers and broaden their applicability in program analysis, synthesis, and security. Dr. Martins has developed several award winning solvers and has consistently improved the state-of-the-art in MaxSAT solving. He is currently the main developer of Open-WBO: an open source MaxSAT solver that won several awards in the MaxSAT competitions.</bio>
          <homepage_url>https://sat-group.github.io/ruben/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rubenmartins/6cfee429-6785-4395-bcf6-ddb6dd674d58/small.jpg</picture_url>
          <person_id>rubenmartins</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Umut A.</first_name>
          <last_name>Acar</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/umutacar/645140f1-714c-4def-ab34-8c78d85a50bf/small.jpg</picture_url>
          <person_id>umutacar</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>934f158e-86aa-43d9-8883-82369f71dc33</slot_id>
      <event_id>ab26b4f9-908b-48a6-88f1-36f0a94e32cc</event_id>
      <title>Mossad: Defeating Software Plagiarism Detection</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>19:20</end_time>
      <description>Automatic software plagiarism detection tools are widely used in educational settings to ensure that submitted work was not copied. These tools have grown in use together with the rise in enrollments in computer science programs and the widespread availability of code on-line. Educators rely on the robustness of plagiarism detection tools; the working assumption is that the effort required to evade detection is as high as that required to actually do the assigned work. 
This paper shows this is not the case. It presents an entirely automatic program transformation approach, MOSSAD, that defeats popular software plagiarism detection tools. MOSSAD comprises a framework that couples techniques inspired by genetic programming with domain-specific knowledge to effectively undermine plagiarism detectors. MOSSAD is effective at defeating four plagiarism detectors, including Moss and JPlag. MOSSAD is both fast and effective: it can, in minutes, generate modified versions of programs that are likely to escape detection. More insidiously, because of its non-deterministic approach, MOSSAD can, from a single program, generate \emph{dozens} of variants, which are classified as no more suspicious than legitimate assignments. A detailed study of MOSSAD across a corpus of real student assignments demonstrates its efficacy at evading detection. A user study shows that graduate student assistants consistently rate MOSSAD-generated code as just as readable as authentic student code. This work motivates the need for both research on more robust plagiarism detection tools and greater integration of naturally plagiarism-resistant methodologies like code review into computer science education.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Breanna</first_name>
          <last_name>Devore-McDonald</last_name>
          <affiliation>University of Massachusetts at Amherst, USA</affiliation>
          <bio>undefined</bio>
          <person_id>breannadevoremcdonald</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Emery</first_name>
          <last_name>Berger</last_name>
          <affiliation>University of Massachusetts at Amherst, USA</affiliation>
          <bio>Emery is a Professor at the University of Massachusetts Amherst. He researches languages, runtime systems, and operating systems, with a particular focus on systems that transparently improve reliability, security, and performance. Emery and friends have created Hoard, the first scalable memory manager (malloc), on which the Mac OS X memory manager is based; DieHard, an error-avoiding memory manager that directly influenced the design of the Windows 7 Fault-Tolerant Heap; DieHarder, a secure memory manager that was an inspiration for hardening changes made to the Windows 8 heap; the Coz profiler, which ships with modern Linux distros; and more. He was named an ACM Fellow in 2019.</bio>
          <homepage_url>http://www.emeryberger.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/emeryberger/6187feeb-700c-48d5-aceb-6d7b87490a7a/small.jpg</picture_url>
          <person_id>emeryberger</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6d204bc8-3eb1-4e6e-a743-f6ac402b00aa</subevent_id>
    <title>SPLASH OOPSLA: T-4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>ccd89aaf-1e40-433f-bfaf-0eea1cea8d1b</slot_id>
      <title>Session: SPLASH OOPSLA - T-4</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>533b1adb-2cc7-4fd4-b7b5-8e5a1e5b367c</slot_id>
      <event_id>64606eb7-ae14-4006-a27c-2e3b6b5b5c6c</event_id>
      <title>A Type-and-Effect System for Object Initialization</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>02:20</end_time>
      <description>Every newly created object goes through several initialization states: starting from a state where all fields are uninitialized until all of them are assigned. Any operation on the object during its initialization process, which usually happens in the constructor via \emph{this}, has to observe the initialization states of the object for correctness, i.e.~only initialized fields may be used. Checking safe usage of \emph{this} statically, without manual annotation of initialization states in the source code, is a challenge, due to aliasing and virtual method calls on \emph{this}. 
Mainstream languages either do not check initialization errors, such as Java, C++, Scala, or they defend against them by not supporting useful initialization patterns, such as Swift. In parallel, past research has shown that safe initialization can be achieved for varying degrees of expressiveness but by sacrificing syntactic simplicity. 
We approach the problem by upholding \emph{local reasoning about initialization} which avoids whole-program analysis, and we achieve \emph{typestate polymorphism} via subtyping. On this basis, we put forward a novel type-and-effect system that can effectively ensure initialization safety while allowing flexible initialization patterns. We implement an initialization checker in the Scala 3 compiler and evaluate on several real-world projects.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fengyun</first_name>
          <last_name>Liu</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>I’m a PhD student at EPFL, working on Scala.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/fengyunliu/7967ca32-789c-44f7-a256-c5eae78909c1/small.jpg</picture_url>
          <person_id>fengyunliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aggelos</first_name>
          <last_name>Biboudis</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>Software engineer and computer science addict; researcher at heart, excited about extensibility of software, code generation and performance 
 
 Working on frameworks and tools for Data, Analytics &amp;amp; AI @Swisscom 
 Ex-researcher on Scala 3 @ LAMP/@EPFL 
 PhD from @dit_uoa 
 
@biboudis</bio>
          <homepage_url>http://biboudis.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aggelosbiboudis/89ee406d-41be-466b-a4e8-bf4c6aef486d/small.jpg</picture_url>
          <person_id>aggelosbiboudis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Paolo G.</first_name>
          <last_name>Giarrusso</last_name>
          <affiliation>Delft University of Technology, Netherlands</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/paologgiarrusso/e3132edd-aa91-4b50-bd1f-5c280e08256c/small.jpg</picture_url>
          <person_id>paologgiarrusso</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Martin</first_name>
          <last_name>Odersky</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>Martin Odersky is a professor at EPFL in Lausanne, Switzerland. He has been working on programming languages for most of his career. He first studied structured and object-oriented programming as a PhD student of Niklaus Wirth, then fell in love with functional programming while working as a post doc at IBM and Yale. When Java came out, he started to add functional programming constructs to the new platform. This led to Pizza and GJ and eventually to Java 5 with generics. During that time he also developed javac, the current reference compiler for Java. 
Over the last 10 years, Martin worked on unifying object-oriented and functional programming in the Scala language. Scala quickly escaped from the research lab and became a popular open source tool and industrial language. He now oversees development of Scala as head of the programming group at EPFL and as academic director of the Scala center.</bio>
          <homepage_url>http://lampwww.epfl.ch/~odersky/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/martinodersky/fc1dd696-d0d4-47cb-9d9a-bba012d98f9e/small.jpg</picture_url>
          <person_id>martinodersky</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9c5d4c56-bc85-48a1-ad4c-39c686c7a97f</slot_id>
      <event_id>a4f48195-d136-4257-a4b0-1e97c5e1b2b3</event_id>
      <title>A Systematic Approach to Deriving Incremental Type Checkers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:40</end_time>
      <description>Static typing can guide programmers if feedback is immediate. Therefore, all major IDEs incrementalize type checking in some way. However, prior approaches to incremental type checking are often specialized and hard to transfer to new type systems. In this paper, we propose a systematic approach for deriving incremental type checkers from textbook-style type system specifications. Our approach is based on compiling inference rules to Datalog, a carefully limited logic programming language for which incremental solvers exist. The key contribution of this paper is to discover an encoding of the infinite typing relation as a finite Datalog relation in a way that yields efficient incremental updates. We implemented the compiler as part of a type system DSL and show that it supports simple types, some local type inference, operator overloading, universal types, and iso-recursive types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>André</first_name>
          <last_name>Pacak</last_name>
          <affiliation>Johannes Gutenberg University Mainz, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/andrepacak/7e35f14d-4d06-4a19-8ab8-bc24c2ce8145/small.jpg</picture_url>
          <person_id>andrepacak</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sebastian</first_name>
          <last_name>Erdweg</last_name>
          <affiliation>Johannes Gutenberg University Mainz, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.pl.informatik.uni-mainz.de/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sebastianerdweg/cc4515b1-cefa-4dee-a915-3242f337c8d8/small.jpg</picture_url>
          <person_id>sebastianerdweg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tamás</first_name>
          <last_name>Szabó</last_name>
          <affiliation>Johannes Gutenberg University Mainz, Germany / itemis, Germany</affiliation>
          <bio>Tamás Szabó works as a Software Engineer for itemis in Stuttgart, and he is a PhD student at JGU Mainz. His focus is on DSLs, incremental computing, and static program analysis.</bio>
          <homepage_url>https://szabta89.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tamasszabo/545a3e41-bc8c-47e6-b801-caf7074137ce/small.jpg</picture_url>
          <person_id>tamasszabo</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>aeb06990-e2c4-4098-b5d9-5b15aeaa68cd</slot_id>
      <event_id>4a70ed09-84fe-4afe-8c78-338a350d3ab8</event_id>
      <title>Detecting Locations in JavaScript Programs Affected by Breaking Library Changes</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>02:00</end_time>
      <description>JavaScript libraries are widely used and evolve rapidly. When adapting client code to non-backwards compatible changes in libraries, a major challenge is how to locate affected API uses in client code, which is currently a difficult manual task. In this paper we address this challenge by introducing a simple pattern language for expressing API access points and a pattern-matching tool based on lightweight static analysis. 
Experimental evaluation on 15 popular npm packages shows that typical breaking changes are easy to express as patterns. Running the static analysis on 265 clients of these packages shows that it is accurate and efficient: it reveals usages of breaking APIs with only 14% false positives and no false negatives, and takes less than a second per client on average. In addition, the analysis is able to report its confidence, which makes it easier to identify the false positives. These results suggest that the approach, despite its simplicity, can reduce the manual effort of the client developers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anders</first_name>
          <last_name>Møller</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
          <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
          <person_id>andersmoller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Benjamin Barslev</first_name>
          <last_name>Nielsen</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/benjaminbarslevnielsen/7c6acacc-eb83-4ad2-8f27-d9a7ce64e58e/small.jpg</picture_url>
          <person_id>benjaminbarslevnielsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Martin</first_name>
          <last_name>Toldam Torp</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/martintoldamtorp/692a65a1-9fc3-4bbf-920b-3b1f2c438848/small.jpg</picture_url>
          <person_id>martintoldamtorp</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>de99acbd-6b0f-4bb1-929e-b079f3d2f10c</slot_id>
      <event_id>b4bfae0b-6b5f-4ee8-9432-65f91d8c51a9</event_id>
      <title>A Structural Model for Contextual Code Changes</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:20</end_time>
      <description>We address the problem of predicting \emph{edit completions} based on a learned model that was trained on past edits. Given a code snippet that is partially edited, our goal is to predict a \emph{completion of the edit for the rest of the snippet}. We refer to this task as the \sname{EditCompletion} task and present a novel approach for tackling it. % The main idea is to directly represent structural edits. This allows us to model the likelihood of the edit itself, rather than learning the likelihood of the edited code. We represent an edit operation as a path in the program's Abstract Syntax Tree (AST), originating from the source of the edit to the target of the edit. Using this representation, we present a powerful and lightweight neural model for the \sname{EditCompletion} task. 
We conduct a thorough evaluation, comparing our approach to a variety of representation and modeling approaches that are driven by multiple strong models such as LSTMs, Transformers, and neural CRFs. Our experiments show that our model achieves a 28% relative gain over state-of-the-art sequential models and $2\times$ higher accuracy than syntactic models that learn to generate the edited \emph{code}, as opposed to modeling the \emph{edits} directly. 
Our code, dataset, and trained models are publicly available at \url{https://github.com/tech-srl/c3po/} .</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shaked</first_name>
          <last_name>Brody</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/people/shakedbr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shakedbrody/54e00e02-0977-4227-be70-21858a5e5626/small.jpg</picture_url>
          <person_id>shakedbrody</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Uri</first_name>
          <last_name>Alon</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~urialon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/urialon/a0488e4f-5173-472b-af25-10666c27e3d4/small.jpg</picture_url>
          <person_id>urialon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>Eran Yahav is an associate professor at the Computer Science Department, Technion, Israel. Prior to that, he was a research staff member at the IBM T.J. Watson Research Center (2004-2010). He received his Ph.D. from Tel Aviv University (2005) and his B.Sc. from the Technion in 1996. His research interests include program analysis, program synthesis and program verification. Eran is a recipient of the prestigious Alon Fellowship for Outstanding Young Researchers, the Andre Deloro Career Advancement Chair in Engineering, the ERC Consolidator Grant as well as multiple best paper awards at various conferences.</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
          <person_id>eranyahav</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5e4bdfb0-84b7-4749-9c39-21010f2315c9</subevent_id>
    <title>SPLASH OOPSLA: T-3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>861f45b3-6495-4444-a453-f73e81b58c65</slot_id>
      <title>Session: SPLASH OOPSLA - T-3</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Tardieu</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.ibm.com/researcher/view.php?person=us-tardieu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/oliviertardieu/443dae7a-79e1-40af-8ac3-b4762aca41c5/small.jpg</picture_url>
          <person_id>oliviertardieu</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Burcu</first_name>
          <last_name>Kulahcioglu Ozkan</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://burcuku.github.io/home/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/burcukulahciogluozkan/4a854b1d-126f-47f5-8935-25d6401437c4/small.jpg</picture_url>
          <person_id>burcukulahciogluozkan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3d53ab84-1ff2-418b-be19-dddf9133857d</slot_id>
      <event_id>7425f134-286b-4c4d-998b-71b90c993ce0</event_id>
      <title>Learning-Based Controlled Concurrency Testing</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>11:40</end_time>
      <description>Concurrency bugs are notoriously hard to detect and reproduce. Controlled concurrency testing (CCT) techniques aim to offer a solution, where a scheduler explores the space of possible interleavings of a concurrent program looking for bugs. Since the set of possible interleavings is typically very large, these schedulers employ heuristics that prioritize the search to “interesting” subspaces. However, current heuristics are typically tuned to specific bug patterns, which limits their effectiveness in practice. 
In this paper, we present QL, a learning-based CCT framework where the likelihood of an action being selected by the scheduler is influenced by earlier explorations. We leverage the classical Q-learning algorithm to explore the space of possible interleavings, allowing the exploration to adapt to the program under test, unlike previous techniques. We have implemented and evaluated QL on a set of microbenchmarks, complex protocols, as well as production cloud services. In our experiments, we found QL to consistently outperform the state-of-the-art in CCT.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Suvam</first_name>
          <last_name>Mukherjee</last_name>
          <affiliation>Microsoft Research, India</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://suvamm.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/suvammukherjee1/0b04e282-4b61-4f63-9abf-4d9516cf0b1e/small.jpg</picture_url>
          <person_id>suvammukherjee1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pantazis</first_name>
          <last_name>Deligiannis</last_name>
          <affiliation>Microsoft Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pdeligia.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/pantazisdeligiannis/a2d73510-7695-48bd-9b09-2ce6ec50b5d1/small.jpg</picture_url>
          <person_id>pantazisdeligiannis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arpita</first_name>
          <last_name>Biswas</last_name>
          <affiliation>IISc Bangalore, India</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.google.com/view/arpitabiswas</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arpitabiswas/c7b67b3e-4a6b-4a0c-8139-6cc114ed3ea1/small.jpg</picture_url>
          <person_id>arpitabiswas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Akash</first_name>
          <last_name>Lal</last_name>
          <affiliation>Microsoft Research, India</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.microsoft.com/en-us/people/akashl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/akashlal/96032ffc-99b4-4b90-b99d-01b1f833751a/small.jpg</picture_url>
          <person_id>akashlal</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6149a84c-dcda-4f36-9756-5e1fd5ed92b2</slot_id>
      <event_id>de7d97dc-0089-49e1-bfce-2e7b14b648ee</event_id>
      <title>LiveDroid: Identifying and Preserving Mobile App State in Volatile Runtime Environments</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>12:00</end_time>
      <description>Mobile operating systems, especially Android, expose apps to a volatile runtime environment. The app state that reflects past user interaction and system environment updates (e.g., battery status changes) can be destroyed implicitly, in response to runtime configuration changes (e.g., screen rotations) or memory pressure. Developers are therefore responsible for identifying app state affected by volatility and preserving it across app lifecycles. When handled inappropriately, the app may lose state or end up in an inconsistent state after a runtime configuration change or when users return to the app. 
To free developers from this tedious and error-prone task, we propose a systematic solution, LiveDroid, which precisely identifies the {\em necessary} part of the app state that needs to be preserved across app lifecycles, and automatically saves and restores it. LiveDroid consists of: (i) a static analyzer that reasons about app source code and resource files to pinpoint the program variables and GUI properties that represent the necessary app state, and (ii) a runtime system that manages the state saving and recovering. We implemented LiveDroid as a plugin in Android Studio and a patching tool for APKs. Our evaluation shows that LiveDroid can be successfully applied to 966 Android apps. A focused study with 36 Android apps shows that LiveDroid identifies app state much more precisely than an existing solution that includes all mutable program variables but ignores GUI properties. As a result, on average, LiveDroid is able to reduce the costs of state saving and restoring by 16.6X (1.7X - 141.1X) and 9.5X (1.1X - 43.8X), respectively. Furthermore, compared with the manual state handling performed by developers, our analysis reveals a set of 46 issues due to incomplete state saving/restoring, all of which can be successfully eliminated by LiveDroid.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Umar</first_name>
          <last_name>Farooq</last_name>
          <affiliation>University of California at Riverside, USA</affiliation>
          <bio>My research lies at the intersection of software engineering, programming languages, and mobile systems. I develop program analysis and runtime systems to automatically detect, prevent, and fix reliability and efficiency issues in software. In addition, I have a keen interest in exploiting the synergy between software engineering and emerging techniques (in Big Data and Deep Learning) to address issues in both research areas.</bio>
          <homepage_url>https://www.cs.ucr.edu/~ufaro001/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/umarfarooq2/e0d30810-d987-42da-b3cb-576592015d8d/small.jpg</picture_url>
          <person_id>umarfarooq2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zhijia</first_name>
          <last_name>Zhao</last_name>
          <affiliation>University of California at Riverside, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ucr.edu/~zhijia/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhijiazhao/5e266673-0c51-4bfe-bc81-2fb37155ad8b/small.jpg</picture_url>
          <person_id>zhijiazhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Manu</first_name>
          <last_name>Sridharan</last_name>
          <affiliation>University of California at Riverside, USA</affiliation>
          <bio>I’m an associate professor at the University of California, Riverside. Previously I worked at IBM Research, Samsung Research, and Uber. My research focuses on developing tools and techniques to make large-scale software more reliable, performant, secure, and maintainable. For more details, see my homepage.</bio>
          <homepage_url>http://manu.sridharan.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manusridharan/00859147-2155-45a9-9a48-7565ce5356ac/small.jpg</picture_url>
          <person_id>manusridharan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Iulian</first_name>
          <last_name>Neamtiu</last_name>
          <affiliation>New Jersey Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://web.njit.edu/~ineamtiu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/iulianneamtiu/59a11852-72df-4d67-9331-8720d3d19a64/small.jpg</picture_url>
          <person_id>iulianneamtiu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c664d262-2bd0-4fba-a1f7-579d1c5a50f6</slot_id>
      <event_id>b926e1ec-10a6-4b30-9b63-77836ac884b7</event_id>
      <title>Koord: A Language for Programming and Verifying Distributed Robotics Application</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>11:20</end_time>
      <description>A robot’s code needs to sense the environment, control the hardware, and communicate with other robots. Current programming languages do not provide suitable abstractions that are independent of hardware platforms. Currently, developing robot applications requires detailed knowledge of signal processing, control, path planning, network protocols, and various platform-specific details. Further, porting applications across hardware platforms remains tedious. We present Koord—a domain specific language for distributed robotics—which abstracts platform-specific functions for sensing, communication, and low-level control. Koord makes the platform-independent control and coordination code portable and modularly verifiable. Koord raises the level of abstraction in programming by providing distributed shared memory for coordination and port interfaces for sensing and control. We have developed the formal executable semantics of Koord in the K framework. With this symbolic execution engine, we can identify assumptions (proof obligations) needed for gaining high assurance from Koord applications. We illustrate the power of Koord through three applications: formation flight, distributed delivery, and distributed mapping. We also use the three applications to demonstrate how platform-independent proof obligations can be discharged using the Koord Prover while platform-specific proof obligations can be checked by verifying the obligations using physics-based models and hybrid verification tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ritwika</first_name>
          <last_name>Ghosh</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <person_id>ritwikaghosh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chiao</first_name>
          <last_name>Hsieh</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <person_id>chiaohsieh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sasa</first_name>
          <last_name>Misailovic</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://misailo.cs.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sasamisailovic/6e3299c7-e0f5-4e78-a5f3-7ea49e488545/small.jpg</picture_url>
          <person_id>sasamisailovic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>sayan</first_name>
          <last_name>mitra</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>Sayan Mitra is a Professor of Electrical and Computer Engineering at the University of Illinois at Urbana-Champaign. His research interests are in formal verification, autonomous systems, and robotics. He holds a PhD from MIT, MSc from the Indian Institute of Science, Bangalore, and an undergraduate degree in Electrical Engineering from Jadavpur University, Kolkata. He was a postdoctoral fellow at the Center for Mathematics of Information of CalTech, and held visiting faculty positions at Oxford University and Kirtland Air Force Research Laboratory. Sayan received the National Science Foundation’s CAREER Award in 2011, AFOSR Young Investigator Research Program Award in 2012, IEEE-HKN C. Holmes MacDonald Outstanding Teaching Award (2013), a RiSE Fellowship from TU Vienna, and several best paper awards.</bio>
          <homepage_url>http://mitras.ece.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sayanmitra/62982710-8e2c-4be7-98f8-068227c8a067/small.jpg</picture_url>
          <person_id>sayanmitra</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f6a8a9ec-f5a4-43a5-903e-b1bfbf22d3b1</slot_id>
      <event_id>72a7c48b-8eba-4f07-b5bc-03af82474540</event_id>
      <title>Shiftry: RNN Inference in 2KB of RAM</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>12:20</end_time>
      <description>Traditionally, IoT devices send collected sensor data to an intelligent cloud where machine learning (ML) inference happens. However, this course is rapidly changing and there is a recent trend to run ML on the edge IoT devices themselves. An intelligent edge is attractive because it saves network round trip (efficiency) and keeps user data at the source (privacy). However, the IoT devices are much more resource constrained than the cloud, which makes running ML on them challenging. Specifically, consider Arduino Uno, a commonly used board, that has 2KB of RAM and 32KB of read-only Flash memory. Although recent breakthroughs in ML have created novel recurrent neural network (RNN) models that provide good accuracy with KB-sized models, deploying them on tiny devices with such hard memory requirements has remained elusive. 
We provide, Shiftry, an automatic compiler from high-level floating-point ML models to fixed-point C-programs with 8-bit and 16-bit integers, which have significantly lower memory requirements. For this conversion, Shiftry uses a data-driven float-to-fixed procedure and a RAM management mechanism. These techniques enable us to provide first empirical evaluation of RNNs running on tiny edge devices. On simpler ML models that prior work could handle, Shiftry-generated code has lower latency and higher accuracy.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aayan</first_name>
          <last_name>Kumar</last_name>
          <affiliation>Microsoft Research, India</affiliation>
          <bio>undefined</bio>
          <person_id>aayankumar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vivek</first_name>
          <last_name>Seshadri</last_name>
          <affiliation>Microsoft Research, India</affiliation>
          <bio>undefined</bio>
          <person_id>vivekseshadri</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rahul</first_name>
          <last_name>Sharma</last_name>
          <affiliation>Microsoft Research, India</affiliation>
          <bio>Rahul Sharma is a researcher at Microsoft Research India. He received a Ph.D. in Computer Science from Stanford University, where he was advised by Prof. Alex Aiken. Before Stanford, he graduated with a B.Tech. from IIT Delhi. His research interests include program analysis, compilers, machine learning, and secure cloud computing.</bio>
          <homepage_url>http://cs.stanford.edu/people/sharmar</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rahulsharma/6d60eca8-356f-4141-af5d-4c6af0fadcd8/small.jpg</picture_url>
          <person_id>rahulsharma</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2d10e572-29fd-487f-b370-76c7e62a20d6</subevent_id>
    <title>SPLASH OOPSLA: R-4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>83dc2e9c-0c83-423f-8f58-4981c4f0f018</slot_id>
      <title>Session: SPLASH OOPSLA - R-4</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Gushu</first_name>
          <last_name>Li</last_name>
          <affiliation>University of California at Santa Barbara, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.google.com/view/gushuli</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gushuli/5cdbca43-a9df-483d-aa77-d44bad9a5dc3/small.jpg</picture_url>
          <person_id>gushuli</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9fcd4830-690f-45ab-ba13-e5df0d62eec6</slot_id>
      <event_id>f2d61eb0-5d2c-45d9-81c7-1137a585afca</event_id>
      <title>Eliminating Abstraction Overhead of Java Stream Pipelines using Ahead-of-Time Program Optimization</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>02:20</end_time>
      <description>Java 8 introduced streams that allow developers to work with collections of data using functional-style operations. Streams are often used in pipelines of operations for processing the data elements, which leads to concise and elegant program code. However, the declarative data processing style comes at a cost. Compared to processing the data with traditional imperative language mechanisms, constructing stream pipelines requires extra heap objects and virtual method calls, which often results in significant run-time overheads. 
In this work we investigate how to mitigate these overheads to enable processing data in the declarative style without sacrificing performance. We argue that ahead-of-time bytecode-to-bytecode transformation is a suitable approach to optimization of stream pipelines, and we present a static analysis that is designed to guide such transformations. Experimental results show a significant performance gain, and that the technique works for realistic stream pipelines. For 10 of 11 micro-benchmarks, the optimizer is able to produce bytecode that is as effective as hand-written imperative-style code. Additionally, 77% of 6879 stream pipelines found in real-world Java programs are optimized successfully.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anders</first_name>
          <last_name>Møller</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
          <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
          <person_id>andersmoller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Oskar</first_name>
          <last_name>Haarklou Veileborg</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/oskarhaarklouveileborg/4b1f271b-c619-4096-8218-ae034b3a1da9/small.jpg</picture_url>
          <person_id>oskarhaarklouveileborg</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a39b5465-f98c-4e65-83cd-e69c8c51140d</slot_id>
      <event_id>c500592f-2d9a-4056-99b3-b5e5865667b4</event_id>
      <title>Assertion-Based Optimization of Quantum Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>01:20</end_time>
      <description>Quantum computers promise to perform certain computations exponentially faster than any classical device. Precise control over their physical implementation and proper shielding from unwanted interactions with the environment become more difficult as the space/time volume of the computation grows. Code optimization is thus crucial in order to reduce resource requirements to the greatest extent possible. Besides manual optimization, previous work has adapted classical methods such as constant-folding and common subexpression elimination to the quantum domain. However, such classically-inspired methods fail to exploit certain optimization opportunities across subroutine boundaries, limiting the effectiveness of software reuse. To address this insufficiency, we introduce an optimization methodology which employs annotations that describe how subsystems are entangled in order to exploit these optimization opportunities. We formalize our approach, prove its correctness, and present benchmarks: Without any prior manual optimization, our methodology is able to reduce, e.g., the qubit requirements of a 64-bit floating-point subroutine by $34\times$.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Häner</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>thomashaner1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Torsten</first_name>
          <last_name>Hoefler</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>Torsten is an Assistant Professor of Computer Science at ETH Zürich, Switzerland. Before joining ETH, he led the performance modeling and simulation efforts of parallel petascale applications for the NSF-funded Blue Waters project at NCSA/UIUC. He is also a key member of the Message Passing Interface (MPI) Forum where he chairs the “Collective Operations and Topologies” working group. Torsten won best paper awards at the ACM/IEEE Supercomputing Conference 2010 (SC10), EuroMPI 2013, ACM/IEEE Supercomputing Conference 2013 (SC13), and other conferences. He published numerous peer-reviewed scientific conference and journal articles and authored chapters of the MPI-2.2 and MPI-3.0 standards. For his work, Torsten received the SIAM SIAG/Supercomputing Junior Scientist Prize in 2012 and the IEEE TCSC Young Achievers in Scalable Computing Award in 2013. Following his Ph.D., the received the Young Alumni Award 2014 from Indiana University. Torsten was elected into the first steering committee of ACM’s SIGHPC in 2013. His research interests revolve around the central topic of “Performance-centric Software Development” and include scalable networks, parallel programming techniques, and performance modeling. Additional information about Torsten can be found on his homepage at htor.inf.ethz.ch.</bio>
          <homepage_url>http://htor.inf.ethz.ch/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/torstenhoefler/b570b3f0-a91f-4651-8a80-cfde60d06190/small.jpg</picture_url>
          <person_id>torstenhoefler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Troyer</last_name>
          <affiliation>Microsoft, USA</affiliation>
          <bio>undefined</bio>
          <person_id>matthiastroyer</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c241f786-2cb3-4e38-a17e-d2301ba5c3fb</slot_id>
      <event_id>0484f76d-7e8f-42de-be40-69afe1f78f7d</event_id>
      <title>Dataflow-Based Pruning for Speeding up Superoptimization</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>01:40</end_time>
      <description>Superoptimization is a compilation strategy that uses search to improve code quality, rather than relying on a canned sequence of transformations, as traditional optimizing compilers do. % This search can be seen as a program synthesis problem: from unoptimized code serving as a specification, the synthesis procedure attempts to create a more efficient implementation. % An important family of synthesis algorithms works by enumerating candidates and then successively checking if each refines the specification, using an SMT solver. % The contribution of this paper is a pruning technique which reduces the enumerative search space using fast dataflow-based techniques to discard synthesis candidates that contain symbolic constants and uninstantiated instructions. % We demonstrate the effectiveness of this technique by improving the runtime of an enumerative synthesis procedure in the Souper superoptimizer for the LLVM intermediate representation. % The techniques presented in this paper eliminate 65% of the solver calls made by Souper, making it 2.32x faster (14.54 hours vs 33.76 hours baseline, on a large multicore) at solving all 269,113 synthesis problems that Souper encounters when optimizing the C and C++ programs from SPEC CPU 2017.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manasij</first_name>
          <last_name>Mukherjee</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
          <person_id>manasijmukherjee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pranav</first_name>
          <last_name>Kant</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
          <person_id>pranavkant</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhengyang</first_name>
          <last_name>Liu</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.utah.edu/~liuz/</homepage_url>
          <person_id>zhengyangliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>John</first_name>
          <last_name>Regehr</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.utah.edu/~regehr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnregehr/2cb23ab0-042a-487a-a859-cbd3147a46a7/small.jpg</picture_url>
          <person_id>johnregehr</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e3ab10fd-8ebf-478e-86c6-aa53c4bac261</slot_id>
      <event_id>e9ae4c19-f50c-4f0d-b1e6-3e733890b7c4</event_id>
      <title>Enabling Accuracy-Aware Quantum Compilers using Symbolic Resource Estimation</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>02:00</end_time>
      <description>Approximation errors must be taken into account when compiling quantum programs into a low-level gate set. We present a methodology that tracks such errors automatically and then optimizes accuracy parameters to guarantee a specified overall accuracy while aiming to minimize the implementation cost in terms of quantum gates. The core idea of our approach is to extract functions that specify the optimization problem directly from the high-level description of the quantum program. Then, custom compiler passes optimize these functions, turning them into (near-)symbolic expressions for (1) the total error and (2) the implementation cost (e.g., total quantum gate count). All unspecified parameters of the quantum program will show up as variables in these expressions, including accuracy parameters. After solving the corresponding optimization problem, a circuit can be instantiated from the found solution. We develop two prototype implementations, one in C++ based on Clang/LLVM, and another using the Q# compiler infrastructure. We benchmark our prototypes on typical quantum computing programs, including the quantum Fourier transform, quantum phase estimation, and Shor's algorithm.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Giulia</first_name>
          <last_name>Meuli</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>giuliameuli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mathias</first_name>
          <last_name>Soeken</last_name>
          <affiliation>Microsoft, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>mathiassoeken</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Martin</first_name>
          <last_name>Roetteler</last_name>
          <affiliation>Microsoft, USA</affiliation>
          <bio>undefined</bio>
          <person_id>martinroetteler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Häner</last_name>
          <affiliation>Microsoft, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>thomashaner</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>718b1d8d-3571-44b5-a702-222564e4d1a3</subevent_id>
    <title>SPLASH OOPSLA: T-6A</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>bf921f3b-52a5-4671-adbe-e0b071fa8759</slot_id>
      <title>Session: SPLASH OOPSLA - T-6A</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Zhefeng</first_name>
          <last_name>Wu</last_name>
          <affiliation>Alibaba Group, China</affiliation>
          <bio>undefined</bio>
          <person_id>zhefengwu</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Filip</first_name>
          <last_name>Niksic</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://fniksic.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/filipniksic/22f726ab-2c20-4f80-b6d4-32a9530437d5/small.jpg</picture_url>
          <person_id>filipniksic</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>33ace67f-0a6c-4a7c-bad9-0b41cb19858e</slot_id>
      <event_id>a1340467-2468-4939-918c-5b03056c26fd</event_id>
      <title>FlowCFL: Generalized Type-Based Reachability Analysis: Graph Reduction and Equivalence of CFL-Based and Type-Based Reachability</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>17:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>17:40</end_time>
      <description>Reachability analysis is a fundamental program analysis with a wide variety of applications. We present FlowCFL, a type-based reachability analysis that accounts for mutable heap data. The underlying semantics of FlowCFL is Context-Free-Language (CFL)-reachability. 
We make three contributions. First, we define a dynamic semantics that captures the notion of flow commonly used in reachability analysis. Second, we establish correctness of CFL-reachability over graphs with inverse edges (inverse edges are necessary for the handling of mutable heap data). Our approach combines CFL-reachability with reference immutability to avoid the addition of certain inverse edges, which results in graph reduction and precision improvement. The key contribution of our work is the formal account of correctness, which extends to the case when inverse edges are removed. Third, we present a type-based reachability analysis and establish equivalence between a certain CFL-reachability analysis and the type-based analysis, thus proving correctness of the type-based analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ana</first_name>
          <last_name>Milanova</last_name>
          <affiliation>Rensselaer Polytechnic Institute, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.rpi.edu/~milanova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anamilanova/4fa9038c-d0e6-44ca-b1b7-2420329714f4/small.jpg</picture_url>
          <person_id>anamilanova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b9d95123-48d8-4e1a-badd-922990e91ed1</slot_id>
      <event_id>bebba2c1-25ac-4031-96fd-49f091a06a15</event_id>
      <title>Flow2Vec: Value-Flow-Based Precise Code Embedding</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>17:20</end_time>
      <description>Code embedding, as an emerging paradigm for source code analysis, has attracted much attention over the past few years. It aims to represent code semantics through distributed vector representations, which can be used to support a variety of program analysis tasks (e.g., code summarization and semantic labeling). However, existing code embedding approaches are intraprocedural, alias-unaware and ignoring the asymmetric transitivity of directed graphs abstracted from source code, thus they are still ineffective in preserving the structural information of code. 
This paper presents Flow2Vec, a new code embedding approach that precisely preserves interprocedural program dependence (a.k.a value-flows). By approximating the high-order proximity, i.e., the asymmetric transitivity of value-flows, Flow2Vec embeds control-flows and alias-aware data-flows of a program in a low-dimensional vector space. Our value-flow embedding is formulated as matrix multiplication to preserve context-sensitive transitivity through CFL reachability by filtering out infeasible value-flow paths. We have evaluated Flow2Vec using 32 popular open-source projects. Results from our experiments show that Flow2Vec successfully boosts the performance of two recent code embedding approaches codevec and codeseq for two client applications, i.e., code classification and code summarization. For code classification, Flow2Vec improves codevec with an average increase of 21.2%, 20.1% and 20.7% in precision, recall and F1, respectively. For code summarization, Flow2Vec outperforms codeseq by an average of 13.2%, 18.8% and 16.0% in precision, recall and F1, respectively.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yulei</first_name>
          <last_name>Sui</last_name>
          <affiliation>University of Technology Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuleisui.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yuleisui/e6ce6e88-3cd8-4595-9c61-a8da6f7319f6/small.jpg</picture_url>
          <person_id>yuleisui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xiao</first_name>
          <last_name>Cheng</last_name>
          <affiliation>Beijing University of Posts and Telecommunications, China</affiliation>
          <bio>undefined</bio>
          <person_id>xiaocheng</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Guanqin</first_name>
          <last_name>Zhang</last_name>
          <affiliation>University of Technology Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <person_id>guanqinzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Haoyu</first_name>
          <last_name>Wang</last_name>
          <affiliation>Beijing University of Posts and Telecommunications, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://howiepku.github.io/</homepage_url>
          <person_id>haoyuwang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e2b5a2ba-21f5-4d47-9c68-2ff57c9aebda</slot_id>
      <event_id>71956917-c601-44ae-8f7c-0e7327f4fa45</event_id>
      <title>Gradual Verification of Recursive Heap Data Structures</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>18:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>18:20</end_time>
      <description>Current static verification techniques do not provide good support for incrementality, making it difficult for developers to focus on specifying and verifying the properties and components that are most important. Dynamic verification approaches support incrementality, but cannot provide static guarantees. To bridge this gap, prior work proposed gradual verification, which supports incrementality by allowing every assertion to be complete, partial, or omitted, and provides sound verification that smoothly scales from dynamic to static checking. The prior approach to gradual verification, however, was limited to programs without recursive data structures. This paper extends gradual verification to programs that manipulate recursive, mutable data structures on the heap. We address several technical challenges, such as semantically connecting iso- and equi-recursive interpretations of abstract predicates, and supporting gradual verification of heap ownership. This work thus lays the foundation for future tools that work on realistic programs and support verification within an engineering process in which cost-benefit trade-offs can be made.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jenna</first_name>
          <last_name>Wise</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jlwise/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jennawise/614a00d0-d8ab-4b2f-8ec7-96abcb5c3d5b/small.jpg</picture_url>
          <person_id>jennawise</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Johannes</first_name>
          <last_name>Bader</last_name>
          <affiliation>Jane Street</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.johannes-bader.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johannesbader/0b7e635c-fba7-4113-a53d-4451edd44ca5/small.jpg</picture_url>
          <person_id>johannesbader</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Cameron</first_name>
          <last_name>Wong</last_name>
          <affiliation>Jane Street</affiliation>
          <bio>Wannabe type theorist.</bio>
          <homepage_url>https://camdar.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cameronwong/1e4412d3-e79b-4f6a-8465-6b756986e1d0/small.jpg</picture_url>
          <person_id>cameronwong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile, Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
          <person_id>etanter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Sunshine</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jssunshi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joshuasunshine/474067e5-86e8-476c-9622-5c89be145f4b/small.jpg</picture_url>
          <person_id>joshuasunshine</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f2baf200-f36b-46aa-aca2-bf9e8bc288a7</slot_id>
      <event_id>970b6051-9a69-4c86-97a5-c53ea48536a0</event_id>
      <title>Hidden Inheritance: An Inline Caching Design for TypeScript Performance</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>17:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>18:00</end_time>
      <description>TypeScript is a dynamically typed language widely used to develop large-scale applications nowadays. These applications are usually designed with complex class or interface hierarchies and have highly polymorphic behaviors. These object-oriented (OO) features will lead to inefficient inline caches (ICs) or trigger deoptimizations, which impact the performance of TypeScript applications. 
To address this problem, we introduce an inline caching design called hidden inheritance (HI). The basic idea of HI is to cache the static information of class or interface hierarchies into hidden classes, which are leveraged to generate efficient inline caches for improving the performance of OO-style TypeScript programs. The HI design is implemented in a TypeScript engine STSC (Static TypeScript Compiler) including a static compiler and a runtime system. STSC statically generates hidden classes and enhanced inline caches, which are applied to generate specialized machine code via ahead-of-time compilation (AOTC) or just-in-time compilation (JITC). To evaluate the efficiency of this technique, we implement STSC on a state-of-the-art JavaScript virtual machine V8 and demonstrate its performance improvements on industrial benchmarks and applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zhefeng</first_name>
          <last_name>Wu</last_name>
          <affiliation>Alibaba Group, China</affiliation>
          <bio>undefined</bio>
          <person_id>zhefengwu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zhe</first_name>
          <last_name>Sun</last_name>
          <affiliation>Alibaba Group, China</affiliation>
          <bio>undefined</bio>
          <person_id>zhesun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kai</first_name>
          <last_name>Gong</last_name>
          <affiliation>Alibaba Group, China</affiliation>
          <bio>undefined</bio>
          <person_id>kaigong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>lingyun</first_name>
          <last_name>Chen</last_name>
          <affiliation>Alibaba Group, China</affiliation>
          <bio>undefined</bio>
          <person_id>lingyunchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Bin</first_name>
          <last_name>Liao</last_name>
          <affiliation>Alibaba Group, China</affiliation>
          <bio>undefined</bio>
          <person_id>binliao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Yihua</first_name>
          <last_name>Jin</last_name>
          <affiliation>Alibaba Group, China</affiliation>
          <bio>undefined</bio>
          <person_id>yihuajin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1e365d45-f79d-4003-821d-1e4a7e5c3be7</subevent_id>
    <title>SPLASH OOPSLA: F-2A</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>ae524bfb-1f36-4d89-bff7-3f71e48778c4</slot_id>
      <title>Session: SPLASH OOPSLA - F-2A</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Reuben</first_name>
          <last_name>Rowe</last_name>
          <affiliation>University College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www0.cs.ucl.ac.uk/staff/r.rowe/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/reubenrowe/88fe0ddc-2847-4a93-8fe2-6e9aa9c8a1ff/small.jpg</picture_url>
          <person_id>reubenrowe</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bff26a75-db43-4e11-9682-a824900c1936</slot_id>
      <event_id>834d57b9-2ff5-4c19-86bb-2d5b6188d63e</event_id>
      <title>A Sparse Iteration Space Transformation Framework for Sparse Tensor Algebra</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>09:20</end_time>
      <description>We address the problem of optimizing sparse tensor algebra in a compiler and show how to define standard loop transformations—split, collapse, and reorder—on sparse iteration spaces. The key idea is to track the transformation functions that map the original iteration space to derived iteration spaces. These functions are needed by the code generator to emit code that maps coordinates between iteration spaces at runtime, since the coordinates in the sparse data structures remain in the original iteration space. We further demonstrate that derived iteration spaces can tile both the universe of coordinates and the subset of nonzero coordinates: the former is analogous to tiling dense iteration spaces, while the latter tiles sparse iteration spaces into statically load-balanced blocks of nonzeros. Tiling the space of nonzeros lets the generated code efficiently exploit heterogeneous compute resources such as threads, vector units, and GPUs. 
We implement these concepts by extending the sparse iteration theory implementation in the TACO system. The associated scheduling API can be used by performance engineers or it can be the target of an automatic scheduling system. We outline one heuristic autoscheduling system, but other systems are possible. Using the scheduling API, we show how to optimize mixed sparse-dense tensor algebra expressions on CPUs and GPUs. Our results show that the sparse transformations are sufficient to generate code with competitive performance to hand-optimized implementations from the literature, while generalizing to all of the tensor algebra.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ryan</first_name>
          <last_name>Senanayake</last_name>
          <affiliation>Reservoir Labs, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.RSenApps.com</homepage_url>
          <person_id>ryansenanayake</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Changwan</first_name>
          <last_name>Hong</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>changwanhong2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziheng</first_name>
          <last_name>Wang</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>zihengwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Amalee</first_name>
          <last_name>Wilson</last_name>
          <affiliation>Stanford University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>amaleewilson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chou</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/s3chou</homepage_url>
          <person_id>stephenchou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Shoaib</first_name>
          <last_name>Kamil</last_name>
          <affiliation>Adobe, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shoaibkamil/2bc60aee-bda5-437e-9e74-e00f5a55c9ef/small.jpg</picture_url>
          <person_id>shoaibkamil</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Saman</first_name>
          <last_name>Amarasinghe</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>Prof. Saman Amarasinghe leads the Commit compiler research group in MIT’s Computer Science &amp;amp; Artificial Intelligence Laboratory (CSAIL), which focuses on programming languages and compilers that maximize application performance on modern computing platforms. He is a world leader in the field of high-performance domain-specific languages. Prof. Amarasinghe’s group developed the Halide, TACO, Simit, StreamIt, StreamJIT, PetaBricks, MILK, Cimple, and GraphIt domain-specific languages and compilers, all of which combine language design and sophisticated compilation techniques to deliver unprecedented performance for targeted application domains such as image processing, stream computations, and graph analytics. Dr. Amarasinghe also pioneered the application of machine learning for compiler optimizations, from Meta optimization in 2003 to OpenTuner extendable autotuner today. With professor Anant Agarwal, he co-led the Raw architecture project, which did pioneering work on scalable multicores. Prof. Amarasinghe’s entrepreneurship activities include founding Determina, Inc. (acquired by VMWare) based on computer security research pioneered in his research group at MIT and co-founding Lanka Internet Services, Ltd., the first Internet Service Provider in Sri Lanka. Prof. Amarasinghe is also the faculty director of MIT Global Startup Labs, whose summer programs in 17 countries have helped to create more than 20 thriving startups. Prof. Amarasinghe developed the popular Performance Engineering of Software Systems (6.172) class with Professor Charles Leiserson. He also created individualized software project classes such as the Open Source Software Project Lab, the Open Source Entrepreneurship Lab, and the Bring Your Own Software Project Lab.</bio>
          <homepage_url>http://people.csail.mit.edu/saman</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/samanamarasinghe/9e4ed1ad-ff3e-468e-b1a8-36ffb2c882ef/small.jpg</picture_url>
          <person_id>samanamarasinghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d097f74e-7aee-4590-99d6-530f4574ab5d</slot_id>
      <event_id>fc13e2b3-604c-4954-9997-35f41f87ef1f</event_id>
      <title>Towards a Unified Proof Framework for Automated Fixpoint Reasoning using Matching Logic</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>10:20</end_time>
      <description>Automation of fixpoint reasoning has been extensively studied for various mathematical structures, logical formalisms, and computational domains, resulting in specialized fixpoint provers for heaps, for streams, for term algebras, for temporal properties, for program correctness, and for many other formal systems and inductive and coinductive properties. However, in spite of great theoretical and practical interest, there is no unified framework for automated fixpoint reasoning. Although several attempts have been made, there is no evidence that such a unified framework is possible, or practical. In this paper, we propose a candidate based on matching logic, a formalism recently shown to theoretically unify the above mentioned formal systems. Unfortunately, the (Knaster-Tarski) proof rule of matching logic, which enables inductive reasoning, is not syntax-driven. Worse, it can be applied at any step during a proof, making automation seem hopeless. Inspired by recent advances in automation of inductive proofs in separation logic, we propose an alternative proof system for matching logic, which is amenable for automation. We then discuss our implementation of it, which although not superior to specialized state-of-the-art automated provers for specific domains, we believe brings some evidence and hope that a unified framework for automated reasoning is not out of reach.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiaohong</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsl.cs.illinois.edu/~xchen</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xiaohongchen1/e982c014-9fda-495c-93d6-b5fdc8158320/small.jpg</picture_url>
          <person_id>xiaohongchen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Minh-Thai</first_name>
          <last_name>Trinh</last_name>
          <affiliation>Advanced Digital Sciences Center, Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>thaitrinh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nishant</first_name>
          <last_name>Rodrigues</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <person_id>nishantrodrigues</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lucas</first_name>
          <last_name>Peña</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <person_id>lucaspena</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Grigore</first_name>
          <last_name>Rosu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsl.cs.illinois.edu/index.php/Grigore_Rosu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/grigorerosu/5d2acd04-bb45-46a0-a743-4826f3d8086c/small.jpg</picture_url>
          <person_id>grigorerosu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d3fc75e8-b072-4a94-ae3a-42a81a54e4b3</slot_id>
      <event_id>7907d076-ba43-4ab2-87fb-41a41db9c572</event_id>
      <title>Resolution as Intersection Subtyping via Modus Ponens</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>09:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>09:40</end_time>
      <description>Resolution and subtyping are two common mechanisms in programming languages. Resolution is used by features such as type classes or Scala-style implicits to synthesize values automatically from contextual type information. Subtyping is commonly used to automatically convert the type of a value into another compatible type. So far the two mechanisms have been considered independently of each other. This paper shows that, with a small extension, subtyping with intersection types can subsume resolution. This has three main consequences. Firstly, resolution does not need to be implemented as a separate mechanism. Secondly, the interaction between resolution and subtyping becomes apparent. Finally, the integration of resolution into subtyping enables first-class (implicit) environments. The extension that recovers the power of resolution via subtyping is the modus ponens rule of propositional logic. While it is easily added to declarative subtyping, significant care needs to be taken to retain desirable properties, such as transitivity and decidability of algorithmic subtyping, and coherence. To materialize these ideas we develop $\lambda_i^{MP}$, a calculus that extends a iprevious calculus with disjoint intersection types, and develop its metatheory in the Coq theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Klara</first_name>
          <last_name>Mardirosian</last_name>
          <affiliation>KU Leuven, Belgium</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/klaramardirosian/15cf04a1-de90-4f6d-b88d-cd1a230da0e4/small.jpg</picture_url>
          <person_id>klaramardirosian</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Georgios</first_name>
          <last_name>Karachalias</last_name>
          <affiliation>Tweag I/O, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://gkaracha.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/georgekarachalias/cb10a8f5-6b72-4883-aef0-c9978070378a/small.jpg</picture_url>
          <person_id>georgekarachalias</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>dee154f2-7c36-49dd-b3e0-c94fed7a80df</slot_id>
      <event_id>0cd262dc-3c5c-498c-814d-952a4abeecf6</event_id>
      <title>Guided Linking: Dynamic Linking without the Costs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>10:00</end_time>
      <description>Dynamic linking is extremely common in modern software systems, thanks to the flexibility and space savings it offers. However, this flexibility comes at a cost: it's impossible to perform interprocedural optimizations that involve calls to a dynamic library. The basic problem is that the run-time behavior of the dynamic linker can't be predicted at compile time, so the compiler can make no assumptions about how such calls will behave. 
This paper introduces \textit{guided linking}, a technique for optimizing dynamically linked software when some information about the dynamic linker's behavior is known in advance. The developer provides an arbitrary set of programs, libraries, and plugins to our tool, along with \textit{constraints} that limit the possible dynamic linking behavior of the software. By taking advantage of the constraints, our tool enables \emph{any} existing optimization to be applied across dynamic linking boundaries. For example, the NoOverride constraint can be applied to a function when the developer knows it will never be overridden with a different definition at run time; guided linking then enables the function to be inlined into its callers in other libraries. We also introduce a novel code size optimization that deduplicates identical functions even across different parts of the software set. 
By applying guided linking to the Python interpreter and its dynamically loaded modules, supplying the constraint that no other programs or modules will be used, we increase speed by an average of 9%. By applying guided linking to a dynamically linked distribution of Clang and LLVM, and using the constraint that no other software will use the LLVM libraries, we can increase speed by 5% and reduce file size by 13%. If we relax the constraint to allow other software to use the LLVM libraries, we can still increase speed by 5% and reduce file size by 5%. If we use guided linking to combine 11 different versions of the Boost library, using minimal constraints, we can reduce the total library size by 57%.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sean</first_name>
          <last_name>Bartell</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <person_id>seanbartell</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Will</first_name>
          <last_name>Dietz</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wdtz.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/willdietz/f5b6948e-d200-44b1-ba05-8d21549414f8/small.jpg</picture_url>
          <person_id>willdietz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Vikram S.</first_name>
          <last_name>Adve</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>Vikram Adve is the Donald B. Gillies Professor of Computer Science at the University of Illinois at Urbana-Champaign and a Professor in Electrical and Computer Engineering. He is a Co-founder and Co-Director of the Center for Digital Agriculture and leads AIFARMS, a $20M National Artificial Intelligence Research Institute funded by NIFA and NSF. Adve’s research interests lie in developing and using compiler techniques to improve the performance, programmability and reliability of computer systems. Adve and his Ph.D. student, Chris Lattner, co-designed the LLVM Compiler Infrastructure, which enables a novel approach to “lifelong compilation” of programs in a wide range of general-purpose programming languages. For example, most mobile apps for the iPhone, iPad, Apple Watch and Apple TV are shipped by developers to Apple in the LLVM compiler representation called “LLVM bitcode” and then compiled and specialized for the various end-user devices. LLVM is widely used in industry today, ranging from mobile devices (e.g., iOS and Android) to supercomputers (e.g., at NVIDIA, Cray, IBM and Intel) to data centers (e.g., at Google). Adve, Lattner and Evan Cheng received the ACM Software System Award in 2012 for co-developing LLVM. Adve has won a ten-year-retrospective Most Influential Paper award at CGO 2004, and distinguished paper awards at several conferences including PLDI 2005, SOSP 2007 and ICSE 2011. He has served as the Associate Editor for the ACM Transactions on Programming Languages and Systems, and co-chaired the Program Committees for ASPLOS 2010, VEE 2008, and LCPC 2007. One of Adve’s Ph.D. students, Robert Bocchino, won the 2010 ACM SIGPLAN Outstanding Dissertation Award and another student, John Criswell, won Honorable Mentions for both the 2014 ACM SIGOPS Dissertation Award and the 2014 ACM Doctoral Dissertation Award. Adve is a Fellow of the ACM and was named a University Scholar at the University of Illinois in 2015. He served as Interim Head of the Computer Science Department from 2017 to 2019.</bio>
          <homepage_url>http://vikram.cs.illinois.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vikramadve/a99a9248-20e3-4738-9200-173c353c5fcb/small.jpg</picture_url>
          <person_id>vikramadve</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b366d8a2-e804-4fd4-901b-12e27304c019</subevent_id>
    <title>SPLASH OOPSLA: R-5</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>8cf86a13-e6ce-4fb6-80a0-12ae579829d1</slot_id>
      <title>Session: SPLASH OOPSLA - R-5</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Sophia</first_name>
          <last_name>Drossopoulou</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Professor of Programming Languages in the Department of Computing, Imperial College, London, UK.</bio>
          <homepage_url>https://wp.doc.ic.ac.uk/sd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sophiadrossopoulou/f9f2890b-55bd-4796-94ab-fe3291277c90/small.jpg</picture_url>
          <person_id>sophiadrossopoulou</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6e86f488-671e-4ee5-a35b-b3c48294ce27</slot_id>
      <event_id>e19d9707-bf19-4fc6-a3cd-80b6c920be7f</event_id>
      <title>Exposing Cache Timing Side-Channel Leaks through Out-of-Order Symbolic Execution</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>04:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>04:20</end_time>
      <description>As one of the fundamental optimizations in modern processors, the \emph{out-of-order} execution boosts the pipeline throughput by executing independent instructions in parallel rather than in their program orders. However, due to the side effects introduced by such microarchitectural optimization to the CPU cache, secret-critical applications may suffer from timing side-channel leaks. This paper presents a symbolic execution-based technique, named {\sc SymO$_3$}, for exposing cache timing leaks under the context of \emph{out-of-order} execution. {\sc SymO$_3$} proposes new components that address the modeling, reduction, and reasoning challenges of accommodating program analysis to the software code \emph{out-of-order} analysis. We implemented {\sc SymO$_3$} upon KLEE and conducted three evaluations on it. Experimental results show that {\sc SymO$_3$} successfully uncovers a set of cache timing leaks in five real-world programs. Also, {\sc SymO$_3$} finds that, in general, program transformation from compiler optimizations shrink the surface to timing leaks. Furthermore, augmented with a speculative execution modeling, {\sc SymO$_3$} identifies five more leaky programs based on the compound analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shengjian</first_name>
          <last_name>Guo</last_name>
          <affiliation>Baidu Security, USA</affiliation>
          <bio>undefined</bio>
          <person_id>shengjianguo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yueqi</first_name>
          <last_name>Chen</last_name>
          <affiliation>Pennsylvania State University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>yueqichen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jiyong</first_name>
          <last_name>Yu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <person_id>jiyongyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Meng</first_name>
          <last_name>Wu</last_name>
          <affiliation>Ant Group, China</affiliation>
          <bio>undefined</bio>
          <person_id>mengwu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Zhiqiang</first_name>
          <last_name>Zuo</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://zuozhiqiang.bitbucket.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhiqiangzuo/deb374c0-3456-4c74-b48d-8f855a64643c/small.jpg</picture_url>
          <person_id>zhiqiangzuo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Peng</first_name>
          <last_name>Li</last_name>
          <affiliation>Baidu Security, USA</affiliation>
          <bio>undefined</bio>
          <person_id>pengli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Yueqiang</first_name>
          <last_name>Cheng</last_name>
          <affiliation>Baidu Security, USA</affiliation>
          <bio>Yueqiang Cheng is a Senior Staff Security Scientist at Baidu Research and Baidu Security. His research interests are in the areas of data security and privacy, hardware security, and system security. His works have been published on top academic conferences, e.g., IEEE TDSC, ASPLOS, Usenix Security, NDSS, and ICSE.</bio>
          <homepage_url>https://sites.google.com/site/strongerwillcheng/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yueqiangcheng1/62c07e08-2bfd-49de-84a3-43049547d1d7/small.jpg</picture_url>
          <person_id>yueqiangcheng1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Huibo</first_name>
          <last_name>Wang</last_name>
          <affiliation>Baidu X-Lab</affiliation>
          <bio>undefined</bio>
          <person_id>huibowang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8c9c5772-ed98-41ef-add5-286e69b26dfe</slot_id>
      <event_id>762acf95-3734-44cf-94f3-333cf54f7969</event_id>
      <title>Precise Static Modeling of Ethereum “Memory”</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>03:20</end_time>
      <description>Static analysis of smart contracts as-deployed on the Ethereum blockchain has received much recent attention. However, high-precision analyses currently face significant challenges when dealing with the Ethereum VM (EVM) execution model. A major such challenge is the modeling of low-level, transient memory&amp;amp;#39;&amp;amp;#39; (as opposed to persistent, on-blockchainstorage'') that smart contracts employ. Statically understanding the usage patterns of memory is non-trivial, due to the dynamic allocation nature of in-memory buffers. We offer an analysis that models EVM memory, recovering high-level concepts (e.g., arrays, buffers, call arguments) via deep modeling of the flow of values. Our analysis opens the door to Ethereum static analyses with drastically increased precision. One such analysis detects the extraction of ERC20 tokens by unauthorized users. For another practical vulnerability (redundant calls, possibly used as an attack vector), our memory modeling yields analysis precision of 89%, compared to 16% for a state-of-the-art tool without precise memory modeling. Additionally, precise memory modeling enables the static computation of a contract's gas cost. This gas-cost analysis has recently been instrumental in the evaluation of the impact of the EIP-1884 repricing (in terms of gas costs) of EVM operations, leading to a reward and significant publicity from the Ethereum Foundation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sifis</first_name>
          <last_name>Lagouvardos</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/sifislagouvardos/7bff730b-e719-4f0c-935c-245291f18d9d/small.jpg</picture_url>
          <person_id>sifislagouvardos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Neville</first_name>
          <last_name>Grech</last_name>
          <affiliation>University of Malta</affiliation>
          <bio>I am a Lecturer at the University of Malta. My expertise is focused on program analysis, applied to security and other high-level applications. My research work has been recently highlighted by ACM SIGPLAN and Communications of the ACM. I am also interested in the areas of energy efficient systems, smart contracts, semantics and generative programming. My research tools include decompilers and security analyzers for the Ethereum platform (Gigahorse) and Java pointer and taint analysis frameworks (Doop, P/Taint and HeapDL). Previously, I was Reach High Fellow at the University of Athens, a Senior Research Associate at the University of Bristol, and have worked in industry as a Data Scientist and Software Engineer. I hold a PhD from the University of Southampton.</bio>
          <homepage_url>http://www.nevillegrech.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nevillegrech/e0405613-3240-4ef2-a51f-cb7536870dc5/small.jpg</picture_url>
          <person_id>nevillegrech</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ilias</first_name>
          <last_name>Tsatiris</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/iliastsatiris/b33fd835-f771-4b76-b5e8-00452e460cf7/small.jpg</picture_url>
          <person_id>iliastsatiris</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>Research Interests: programming languages and software engineering 
 
 Program analysis (static analysis, test generation, invariant inference, symbolic execution) 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality) 
</bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
          <person_id>yannissmaragdakis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d9d9cc88-1cc3-4885-96fc-6420c4e63d67</slot_id>
      <event_id>d6245b1d-c06a-4095-a451-8337b829c6c7</event_id>
      <title>Perfectly Parallel Fairness Certification of Neural Networks</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>03:40</end_time>
      <description>Recently, there is growing concern that machine-learned software, which currently assists or even automates decision making, reproduces, and in the worst case reinforces, bias present in the training data. The development of tools and techniques for certifying fairness of this software or describing its biases is, therefore, critical. In this paper, we propose a perfectly parallel static analysis for certifying fairness of feed-forward neural networks used for classification of tabular data. When certification succeeds, our approach provides definite guarantees, otherwise, it describes and quantifies the biased input space regions. We design the analysis to be sound, in practice also exact, and configurable in terms of scalability and precision, thereby enabling pay-as-you-go certification. We implement our approach in an open-source tool called Libra and demonstrate its effectiveness on neural networks trained on popular datasets.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Caterina</first_name>
          <last_name>Urban</last_name>
          <affiliation>Inria, France / ENS, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://caterinaurban.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/caterinaurban1/a945f9bd-bc13-4fe2-945a-59528d7d7e2a/small.jpg</picture_url>
          <person_id>caterinaurban1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Maria</first_name>
          <last_name>Christakis</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mariachris.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mariachristakis/b7bf39cc-368b-44aa-bbcb-c83734e1e8fa/small.jpg</picture_url>
          <person_id>mariachristakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Valentin</first_name>
          <last_name>Wüstholz</last_name>
          <affiliation>ConsenSys, Germany</affiliation>
          <bio>Valentin is a software security researcher at ConsenSys Diligence and has held positions both in academia (at ETH Zürich and UT Austin) and in industry (at Microsoft and Google). He is passionate about developing tools and techniques that allow us to produce more reliable and correct software.</bio>
          <homepage_url>http://www.wuestholz.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/valentinwustholz/c6ff5691-4f3e-472c-8454-168eaaebb7eb/small.jpg</picture_url>
          <person_id>valentinwustholz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Fuyuan</first_name>
          <last_name>Zhang</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>fuyuanzhang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>de5fb532-e1a9-4570-8070-5dacf3421347</slot_id>
      <event_id>8f64a7c7-6637-4768-a862-bef448adb89f</event_id>
      <title>Taming Callbacks for Smart Contract Modularity</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>04:00</end_time>
      <description>Callbacks are an effective programming discipline for implementing event-driven programming, especially in environments like Ethereum which forbid shared global state and concurrency. Callbacks allow a callee to delegate the execution back to the caller. Though effective, they can lead to subtle mistakes principally in open environments where callbacks can be added in a new code. Indeed, several high profile bugs in smart contracts exploit callbacks. 
We present the first static technique ensuring \emph{modularity} in the presence of callbacks and apply it to verify prominent smart contracts. Modularity ensures that external calls to other contracts cannot affect the behavior of the contract. Importantly, modularity is guaranteed without restricting programming. 
In general, checking modularity is undecidable—even for programs without loops. This paper describes an effective technique for soundly ensuring modularity harnessing SMT solvers. The main idea is to define a constructive version of modularity using \emph{commutativity} and \emph{projection} operations on program segments. We believe that this approach is also accessible to programmers, since counterexamples to modularity can be generated automatically by the SMT solvers, allowing programmers to understand and fix the error. 
We implemented our approach in order to demonstrate the precision of the modularity analysis and applied it to real smart contracts, including a subset of the 150 most active contracts in Ethereum. Our implementation decompiles bytecode programs into an intermediate representation and then implements the modularity checking using SMT queries. Overall, we argue that our experimental results indicate that the method can be applied to many realistic contracts, and that it is able to prove modularity where other methods fail.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Elvira</first_name>
          <last_name>Albert</last_name>
          <affiliation>Complutense University of Madrid, Spain</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/elviraalbert1/9c4fd401-4969-4cc6-ba12-d79d92acee62/small.jpg</picture_url>
          <person_id>elviraalbert1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shelly</first_name>
          <last_name>Grossman</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shellygrossman/c4b389a6-6165-44ef-a938-4b1acbecaaa8/small.jpg</picture_url>
          <person_id>shellygrossman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Noam</first_name>
          <last_name>Rinetzky</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~maon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/noamrinetzky/1ea9bd0d-bd16-4b15-bb66-a8a576ffaa40/small.jpg</picture_url>
          <person_id>noamrinetzky</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Clara</first_name>
          <last_name>Rodríguez-Núñez</last_name>
          <affiliation>Complutense University of Madrid, Spain</affiliation>
          <bio>undefined</bio>
          <person_id>clararodriguez</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Albert</first_name>
          <last_name>Rubio</last_name>
          <affiliation>Complutense University of Madrid, Spain</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://costa.fdi.ucm.es/~arubio/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/albertrubio1/effd4c9a-16fb-4d5d-83cb-a32d83d40c47/small.jpg</picture_url>
          <person_id>albertrubio1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Mooly</first_name>
          <last_name>Sagiv</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>My research focuses on easing the task of developing reliable and efficient software systems. I am particularly interested in static program analysis which combines two disciplines: automated theorem proving and abstract interpretation. In the next decade, I am hoping to develop useful techniques in order to change the ways modern software is built. I am particularly interested in proof automation, given a program and a requirement, automatically prove or disprove that all executions of the program satisfy the requirements. This problem is in general undecidable and untractable. I am interested in developing practical solutions to proof-automation by: (i) exploring modularity of the system and (ii) relying on semi-automatic and interactive process, where the user manually and interactively guides the proof automation, and (iii) simplifying the verification task by using domain-specific abstractions expressed in a decidable logic. I am applying these techniques to verify safety of liveness of distributed systems.</bio>
          <homepage_url>http://www.cs.tau.ac.il/~msagiv/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/moolysagiv/5ff34ce2-4812-410c-aa6d-e1457fc2f1ac/small.jpg</picture_url>
          <person_id>moolysagiv</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6804922c-72bd-4b96-9cf6-35c4b60c8780</subevent_id>
    <title>SPLASH OOPSLA: R-3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>c7c4d502-f952-42fa-9d48-6e200c56ef8c</slot_id>
      <title>Session: SPLASH OOPSLA - R-3</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Xiangzhe</first_name>
          <last_name>Xu</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <person_id>xiangzhexu1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>22d62595-943d-4552-90c2-db2071d0d645</slot_id>
      <event_id>fcea71f9-9bb0-4209-a01f-13ad1fb54e32</event_id>
      <title>The Anchor Verifier for Blocking and Non-blocking Concurrent Software</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>00:20</end_time>
      <description>Verifying the correctness of concurrent software with subtle synchronization is notoriously challenging. We present the Anchor verifier, which is based on a new formalism for specifying synchronization disciplines that describes both (1) what memory accesses are permitted, and (2) how each permitted access commutes with concurrent operations of other threads (to facilitate reduction proofs). Anchor supports the verification of both lock-based blocking and cas-based non-blocking algorithms. Experiments on a variety concurrent data structures and algorithms show that Anchor significantly reduces the burden of concurrent verification.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cormac</first_name>
          <last_name>Flanagan</last_name>
          <affiliation>University of California at Santa Cruz, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://users.soe.ucsc.edu/~cormac/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cormacflanagan/fd454a8e-4230-4fa5-a4da-1d16a1027de3/small.jpg</picture_url>
          <person_id>cormacflanagan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Freund</last_name>
          <affiliation>Williams College, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/stephenfreund/0b468f46-1f87-41c4-bcff-4321da9869c2/small.jpg</picture_url>
          <person_id>stephenfreund</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>49d98079-a4b8-4698-8bbe-a91e183da6b8</slot_id>
      <event_id>b9042a01-7709-4b12-9a6d-e627f04668a5</event_id>
      <title>Projection-Based Runtime Assertions for Testing and Debugging Quantum Programs</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>23:40</end_time>
      <description>In this paper, we propose Proq, a runtime assertion scheme for testing and debugging quantum programs on a quantum computer. The predicates in Proq are represented by projections (or equivalently, closed subspaces of the state space), following Birkhoff-von Neumann quantum logic. The satisfaction of a projection by a quantum state can be directly checked upon a small number of projective measurements rather than a large number of repeated executions. On the theory side, we rigorously prove that checking projection-based assertions can help locate bugs or statistically assure that the semantic function of the tested program is close to what we expect, for both exact and approximate quantum programs. On the practice side, we consider hardware constraints and introduce several techniques to transform the assertions, making them directly executable on the measurement-restricted quantum computers. We also propose to achieve simplified assertion implementation using local projection technique with soundness guaranteed. We compare Proq with existing quantum program assertions and demonstrate the effectiveness and efficiency of Proq by its applications to assert two sophisticated quantum algorithms, the Harrow-Hassidim-Lloyd algorithm and Shor’s algorithm.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gushu</first_name>
          <last_name>Li</last_name>
          <affiliation>University of California at Santa Barbara, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.google.com/view/gushuli</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gushuli/5cdbca43-a9df-483d-aa77-d44bad9a5dc3/small.jpg</picture_url>
          <person_id>gushuli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Li</first_name>
          <last_name>Zhou</last_name>
          <affiliation>MPI-SP, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>lizhou1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nengkun</first_name>
          <last_name>Yu</last_name>
          <affiliation>University of Technology Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <person_id>nengkunyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yufei</first_name>
          <last_name>Ding</last_name>
          <affiliation>University of California at Santa Barbara, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ucsb.edu/~yufeiding/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yufeiding/c37f32e5-103b-4441-891c-b82fc8e9640a/small.jpg</picture_url>
          <person_id>yufeiding</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Mingsheng</first_name>
          <last_name>Ying</last_name>
          <affiliation>University of Technology Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://quantum-lab.org/mingsheng/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mingshengying/955ed532-f014-4273-965a-4906017b4b8d/small.jpg</picture_url>
          <person_id>mingshengying</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Yuan</first_name>
          <last_name>Xie</last_name>
          <affiliation>University of California at Santa Barbara, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ece.ucsb.edu/~yuanxie/</homepage_url>
          <person_id>yuanxie</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d19ffc61-b7c5-4ddd-a8af-6b7742bacbcd</slot_id>
      <event_id>a3ab81c8-640a-4a08-9893-24582fac04f3</event_id>
      <title>Compiling Symbolic Execution with Staging and Algebraic Effects</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>23:20</end_time>
      <description>Building effective symbolic execution engines poses challenges in multiple dimensions: an engine must correctly model the program semantics, provide flexibility in symbolic execution strategies, and execute them efficiently. 
This paper proposes a principled approach to building correct, flexible, and efficient symbolic execution engines, directly rooted in the semantics of the underlying language in terms of a high-level definitional interpreter. The definitional interpreter induces algebraic effects to abstract over semantic variants of symbolic execution, e.g., collecting path conditions as a state effect and path exploration as a nondeterminism effect. Different handlers of these effects give rise to different symbolic execution strategies, making execution strategies orthogonal to the symbolic execution semantics, thus improving flexibility. Furthermore, by annotating the symbolic definitional interpreter with binding-times and specializing it to the input program via the first Futamura projection, we obtain a "symbolic compiler", generating efficient instrumented code having the symbolic execution semantics. Our work reconciles the interpretation- and instrumentation-based approaches to building symbolic execution engines in a uniform framework. 
We illustrate our approach on a simple imperative language step-by-step and then scale up to a significant subset of LLVM IR. We also show effect handlers for common path selection strategies. Evaluating our prototype's performance shows speedups of 10~30x over the unstaged counterpart, and ~2x over KLEE, a state-of-the-art symbolic interpreter for LLVM IR.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guannan</first_name>
          <last_name>Wei</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://continuation.passing.style</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guannanwei/e1971b4b-ebd3-429b-b28c-0c2cfb0f0289/small.jpg</picture_url>
          <person_id>guannanwei</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Oliver</first_name>
          <last_name>Bračevac</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://bracevac.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/oliverbracevac/17c0ac71-a156-4868-8df9-d4ae4cd669e7/small.jpg</picture_url>
          <person_id>oliverbracevac</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Shangyin</first_name>
          <last_name>Tan</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shangyintan/05c3151d-071e-451a-9863-639fc66108ca/small.jpg</picture_url>
          <person_id>shangyintan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
          <person_id>tiarkrompf</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fe4b6647-548f-4ae4-8fad-b50ce113f83c</slot_id>
      <event_id>5b2281e0-6ffc-4b3a-976f-ae840b9db5fd</event_id>
      <title>Satune: Synthesizing Efficient SAT Encoders</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>00:00</end_time>
      <description>Modern SAT solvers are extremely efficient at solving boolean satisfiability problems, enabling a wide spectrum of techniques for checking, verifying, and validating real-world programs. What remains challenging, though, is how to encode a domain problem (e.g., model checking) into a SAT formula because the same problem can have multiple distinct encodings, which can yield performance results that are orders-of-magnitude apart, regardless of the underlying solvers used. We develop Satune, a tool that can automatically synthesize SAT encoders for different problem domains. Satune employs a DSL that allows developers to express domain problems at a high level and a search algorithm that can effectively find efficient solutions. The search process is guided by observations made over example encodings and their performance for the domain and hence Satune can quickly synthesize a high-performance encoder by incorporating patterns from examples that yield good performance. A thorough evaluation with JMCR, SyPet, Dirk, Hexiom, Sudoku, and KillerSudoku demonstrates that Satune can easily synthesize high-performance encoders for different domains including model checking, synthesis, and games. These encoders generate constraint problems that are often several orders of magnitude faster to solve than the original encodings used by the tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hamed</first_name>
          <last_name>Gorjiara</last_name>
          <affiliation>University of California at Irvine, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gorjiara.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hamedgorjiara/ac3c3dcb-0d83-409b-91a3-d369cd445f3b/small.jpg</picture_url>
          <person_id>hamedgorjiara</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guoqing Harry</first_name>
          <last_name>Xu</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am an Associate Professor of Computer Science at University of California, Los Angeles (UCLA). I am interested broadly in software and hardware systems — including programming languages, compilers, big data analytics, distributed systems, and computer architecture.</bio>
          <homepage_url>http://web.cs.ucla.edu/~harryxu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/harryxu/5d680c47-2b02-4f5f-a2fb-55c72b5d63ed/small.jpg</picture_url>
          <person_id>harryxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brian</first_name>
          <last_name>Demsky</last_name>
          <affiliation>University of California at Irvine, USA</affiliation>
          <bio>undefined</bio>
          <person_id>briandemsky</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6aaaf58c-f57c-4f6a-95f6-f7dbbc839ae4</subevent_id>
    <title>SPLASH OOPSLA: W-5</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>29d66576-6927-441a-ac32-f9453dad6ea9</slot_id>
      <title>Session: SPLASH OOPSLA - W-5</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Dan</first_name>
          <last_name>Barowy</last_name>
          <affiliation>Williams College</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.williams.edu/~dbarowy/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/danbarowy/68828093-d4f3-421f-a005-a407e166c9a3/small.jpg</picture_url>
          <person_id>danbarowy</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Mohsen</first_name>
          <last_name>Lesani</last_name>
          <affiliation>University of California at Riverside, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ucr.edu/~lesani/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mohsenlesani/9891c046-f676-41fd-a333-3603988b9484/small.jpg</picture_url>
          <person_id>mohsenlesani</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>09496b66-93ff-4d0c-ac05-810c55621cd7</slot_id>
      <event_id>fb1f6365-ed4d-47f7-b0d5-c96755f131af</event_id>
      <title>Persistent Owicki-Gries Reasoning: A Program Logic for Reasoning about Persistent Programs on Intel-x86</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>15:40</end_time>
      <description>The advent of non-volatile memory (NVM) technologies is expected to transform how software systems are structured fundamentally, making the task of \emph{correct} programming significantly harder. This is because ensuring that memory stores persist in the correct order is challenging, and requires low-level programming to flush the cache at appropriate points. This has in turn resulted in a noticeable \emph{verification gap}. %causing a significant verification burden. 
To address this, we study the verification of NVM programs, and present \emph{Persistent Owicki-Gries} (POG), the first program logic for reasoning about such programs. We prove the soundness of POG over the recent Intel-x86 model, which formalises the out-of-order persistence of memory stores and the semantics of the Intel cache line flush instructions. We then use POG to verify several programs that interact with NVM.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Azalea</first_name>
          <last_name>Raad</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.SoundAndComplete.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/azalearaad/180ee602-475f-483f-a01b-ea187c9e8ac1/small.jpg</picture_url>
          <person_id>azalearaad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~orilahav/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/orilahav/89b656f6-7634-49d1-9917-4b74da70a976/small.jpg</picture_url>
          <person_id>orilahav</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Vafeiadis</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>Viktor Vafeiadis is a tenured faculty at the Max Planck Institute for Software Systems (MPI-SWS) in Germany. He got his BA and PhD from the University of Cambridge, and held post-doctoral researcher positions at the University of Cambridge and at Microsoft Research Cambridge before joining MPI-SWS in October 2010.</bio>
          <homepage_url>http://www.mpi-sws.org/~viktor/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/viktorvafeiadis/6a063832-47ca-4c32-8047-4bf4f74ae764/small.jpg</picture_url>
          <person_id>viktorvafeiadis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>234056b0-9400-4fd4-8b03-18fb9a61a8f0</slot_id>
      <event_id>c5a30df7-cf14-473f-9641-714eedc28464</event_id>
      <title>Structure Interpretation of Text Formats</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>16:00</end_time>
      <description>Data repositories often consist of text files in a wide variety of standard formats, ad-hoc formats, as well as mixtures of formats where data in one format is embedded into a different format. It is therefore a significant challenge to parse these files into a structured tabular form, which is important to enable any downstream data processing. 
We present \textsc{Unravel}, an extensible framework for structure interpretation of ad-hoc formats. \textsc{Unravel} can automatically, with no user input, extract tabular data from a diverse range of standard, ad-hoc and mixed format files. The framework is also easily extensible to add support for previously unseen formats, and also supports interactivity from the user in terms of examples to guide the system when specialized data extraction is desired. Our key insight is to allow arbitrary combination of extraction and parsing techniques through a concept called \emph{partial structures}. Partial structures act as a common language through which the file structure can be shared and refined by different techniques. This makes \textsc{Unravel} more powerful than applying the individual techniques in parallel or sequentially. Further, with this rule-based extensible approach, we introduce the novel notion of \emph{re-interpretation} where the variety of techniques supported by our system can be exploited to improve accuracy while optimizing for particular quality measures or restricted environments. On our benchmark of $617$ text files gathered from a variety of sources, \textsc{Unravel} is able to extract the intended table in many more cases compared to state-of-the-art techniques.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft, USA</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vu</first_name>
          <last_name>Le</last_name>
          <affiliation>Microsoft, USA</affiliation>
          <bio>I am a Researcher at Microsoft, working on the Microsoft Program Synthesis using Examples (PROSE) framework. I obtained my PhD in 2015 at UC Davis, advised by Zhendong Su and Sumit Gulwani. My research is about developing novel and practical techniques to help improve the quality of critical software (e.g., compilers and database engines) and make programming accessible for end users. My work has led to the discovery of hundreds of bugs in GCC and LLVM, most of which have been fixed, and shipped in various Microsoft products.</bio>
          <homepage_url>http://vuminhle.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vule/8674b9d0-747d-4a80-b8f0-3c7a435cd9b7/small.jpg</picture_url>
          <person_id>vule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Radhakrishna</last_name>
          <affiliation>Microsoft, n.n.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://arjunradhakrishna.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjunradhakrishna/5187c933-18de-4045-9119-d97023dd12b7/small.jpg</picture_url>
          <person_id>arjunradhakrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Radiček</last_name>
          <affiliation>Microsoft, Austria</affiliation>
          <bio>undefined</bio>
          <person_id>ivanradicek2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Mohammad</first_name>
          <last_name>Raza</last_name>
          <affiliation>Microsoft, USA</affiliation>
          <bio>undefined</bio>
          <person_id>mohammadraza</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>503cbb2c-2040-49a9-9c0b-7ef6de329d73</slot_id>
      <event_id>b766280d-c659-44b7-ad70-289237a4edcc</event_id>
      <title>A Model for Detecting Faults in Build Specifications</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>15:20</end_time>
      <description>Incremental and parallel builds are crucial features of modern build systems. Parallelism enables fast builds by running independent tasks simultaneously, while incrementality saves time and computing resources by processing the build operations that were affected by a particular code change. Writing build definitions that lead to error-free incremental and parallel builds is a challenging task. This is mainly because developers are often unable to predict the effects of build operations on the file system and how different build operations interact with each other. Faulty build scripts may seriously degrade the reliability of automated builds, as they cause build failures, and non-deterministic and incorrect outputs. 
To reason about arbitrary build executions, we present BuildFS, a generally-applicable model that takes into account the specification (as declared in build scripts) and the actual behavior (low-level file system operation) of build operations. We then formally define different types of faults related to incremental and parallel builds in terms of the conditions under which a file system operation violates the specification of a build operation. Our testing approach, which relies on the proposed model, analyzes the execution of single full build, translates it into BuildFS, and uncovers faults by checking for corresponding violations. 
We evaluate the effectiveness, efficiency, and applicability of our approach by examining 612 Make and Gradle projects. Notably, thanks to our treatment of build executions, our method is the first to handle JVM-oriented build systems. The results indicate that our approach is (1) able to uncover several important issues (247 issues found in 47 open-source projects have been confirmed and fixed by the upstream developers), and (2) much faster than a state-of-the-art tool for Make builds (the median and average speedup is 39X and 74X respectively).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thodoris</first_name>
          <last_name>Sotiropoulos</last_name>
          <affiliation>Athens University of Economics and Business, Greece</affiliation>
          <bio>undefined</bio>
          <person_id>thodorissotiropoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stefanos</first_name>
          <last_name>Chaliasos</last_name>
          <affiliation>Athens University of Economics and Business, Greece</affiliation>
          <bio>undefined</bio>
          <person_id>stefanoschaliasos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dimitris</first_name>
          <last_name>Mitropoulos</last_name>
          <affiliation>Athens University of Economics and Business, Greece</affiliation>
          <bio>Dimitris Mitropoulos is the Head of the Reliability Engineering Directorate of the Greek National Infrastructures for Research and Technology (GRNET) and a Researcher at the Athens University of Economics and Business. Previously, he has been a Postdoctoral Researcher at the Network Security Laboratory (NSL) of Columbia University in the City of New York. Dimitris holds a PhD in Computer Security from the Athens University of Economics and Business and has been involved in several EU and US funded R&amp;amp;D projects. His research interests include computer security, software reliability, software engineering and applied cryptography. He is a member of ACM, IEEE, SysSec, and an official writer for the ACM Computing Reviews journal.</bio>
          <homepage_url>https://dimitro.gr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/dimitrismitropoulos/a0d64ae8-d979-4ed9-a834-b808d3cc40d2/small.jpg</picture_url>
          <person_id>dimitrismitropoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Diomidis</first_name>
          <last_name>Spinellis</last_name>
          <affiliation>Athens University of Economics and Business, Greece</affiliation>
          <bio>Diomidis Spinellis is Professor of Software Engineering, Head of the Department of Management Science and Technology, and director of the Business Analytics Laboratory (BALab), at the Athens University of Economics and Business, Greece. His research interests include software engineering, IT security, and computing systems. He has written two award-winning, widely-translated books: Code Reading and Code Quality: The Open Source Perspective. In 2016 he published the book Effective Debugging: 66 Specific Ways to Debug Software and Systems. Dr. Spinellis has also published more than 300 technical papers in journals and refereed conference proceedings, which have received more than 8000 citations. He served for a decade as a member of the IEEE Software editorial board, authoring the regular “Tools of the Trade” column and for four years at the magazine’s Editor in Chief. He has contributed code that ships with Apple’s macOS and BSD Unix and is the developer of CScout, UMLGraph, dgsh, and other open-source software packages, libraries, and tools. He holds an MEng in Software Engineering and a PhD in Computer Science, both from Imperial College London. Dr. Spinellis has served as an elected member of the IEEE Computer Society Board of Governors (2013–2015), and is a senior member of the ACM and the IEEE.</bio>
          <homepage_url>https://www.dmst.aueb.gr/dds</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/diomidisspinellis/a7f21db5-04c0-4282-85ab-614b4394c90a/small.jpg</picture_url>
          <person_id>diomidisspinellis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7018de7c-999e-41da-96a0-20e10b69f389</slot_id>
      <event_id>3861b0b2-0efa-45db-a79a-416ae2de5a28</event_id>
      <title>Statically Verified Refinements for Multiparty Protocols</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>16:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>16:20</end_time>
      <description>With distributed computing becoming ubiquitous in the modern era, safe distributed programming is an open challenge. To address this, multiparty session types (MPST) provide a typing discipline for message-passing concurrency, guaranteeing communication safety properties such as deadlock freedom. 
While originally MPST focus on the communication aspects, and employ a simple typing system for communication payloads, communication protocols in the real world usually contain constraints on the payload. We introduce refined multiparty session types (RMPST), an extension of MPST, that express data dependent protocols via refinement types on the data types. 
We provide an implementation of RMPST, in a toolchain called Session*, using Scribble, a toolchain for multiparty protocols, and targeting F*, a verification-oriented functional programming language. Users can describe a protocol in Scribble and implement the endpoints in F* using refinement-typed APIs generated from the protocol. The F* compiler can then statically verify the refinements. Moreover, we use a novel approach of callback-styled API generation, providing static linearity guarantees with the inversion of control. We evaluate our approach with real world examples and show that it has little overhead compared to a naive implementation, while guaranteeing safety properties from the underlying theory.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fangyi</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/fangyizhou/c1ff2787-4ce8-45c7-a584-0cc8f627722c/small.jpg</picture_url>
          <person_id>fangyizhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Francisco</first_name>
          <last_name>Ferreira</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~fferre16/</homepage_url>
          <person_id>franciscoferreira1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Raymond</first_name>
          <last_name>Hu</last_name>
          <affiliation>University of Hertfordshire, UK</affiliation>
          <bio>undefined</bio>
          <person_id>raymondhu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rumyana</first_name>
          <last_name>Neykova</last_name>
          <affiliation>Brunel University London, UK</affiliation>
          <bio>Rumyana Neykova is a lecturer at Brunel University London, previously completed a PhD degree under the supervision of Prof. Nobuko Yoshida at Imperial College London, where she was also research fellow. Her research interests are in the area of distributed systems and networks, as well as type systems and language design. Her PhD focuses on development and applications of a type theory (called session types) for runtime verification of concurrent and distributed systems.</bio>
          <homepage_url>https://www.brunel.ac.uk/people/rumyana-neykova</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rumyananeykova/66457b0a-8e8b-471e-b278-37d7f4242bcb/small.jpg</picture_url>
          <person_id>rumyananeykova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>80a27d2f-91d7-4d27-a9a7-c853a7b13e72</subevent_id>
    <title>SPLASH OOPSLA: F-5B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-III</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>e54fd9a6-19eb-46b9-a735-d5926ee13a05</slot_id>
      <title>Session: SPLASH OOPSLA - F-5B</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Mohsen</first_name>
          <last_name>Lesani</last_name>
          <affiliation>University of California at Riverside, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ucr.edu/~lesani/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mohsenlesani/9891c046-f676-41fd-a333-3603988b9484/small.jpg</picture_url>
          <person_id>mohsenlesani</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>055a9df6-645a-4f0b-9cb3-bd125d6ca831</slot_id>
      <event_id>67d39e09-ddf4-4c9d-8d1b-b8dffa795e2f</event_id>
      <title>Testing Consensus Implementations using Communication Closure</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>16:00</end_time>
      <description>Large scale production distributed systems are difficult to design and test. Correctness must be ensured when processes run asynchronously, at arbitrary rates relative to each other, and in the presence of failures, e.g., process crashes or message losses. These conditions create a huge space of executions that is difficult to explore in a principled way. Current testing techniques focus on systematic or randomized exploration of all executions of an implementation while treating the implemented algorithms as black boxes. On the other hand, proofs of correctness of many of the underlying algorithms often exploit semantic properties that reduce reasoning about correctness to a subset of behaviors. For example, the \emph{communication-closure} property, used in many proofs of distributed consensus algorithms, shows that every asynchronous execution of the algorithm is equivalent to a \emph{lossy synchronous} execution, thus reducing the burden of proof to only that subset. In a lossy synchronous execution, processes execute in lock-step rounds, and messages are either received in the same round or lost forever—such executions form a small subset of all asynchronous ones. 
We formulate the \emph{communication-closure hypothesis}, which states that bugs in implementations of distributed consensus algorithms will already manifest in lossy synchronous executions and present a testing algorithm based on this hypothesis. We prioritize the search space based on a bound on the number of failures in the execution and the rate at which these failures are recovered. We show that a random testing algorithm based on sampling lossy synchronous executions can empirically find a number of bugs—including previously unknown ones—in production distributed systems such as Zookeeper, Cassandra, and Ratis, and also produce more understandable bug traces.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cezara</first_name>
          <last_name>Drăgoi</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.di.ens.fr/~cezarad/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cezaradragoi/3403e4d3-23e5-41ac-8cf7-48cc033f3d48/small.jpg</picture_url>
          <person_id>cezaradragoi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Constantin</first_name>
          <last_name>Enea</last_name>
          <affiliation>University of Paris Diderot, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~cenea/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/constantinenea/2dfe8bfe-ddfe-4012-a2e2-01cc8b953734/small.jpg</picture_url>
          <person_id>constantinenea</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Burcu</first_name>
          <last_name>Kulahcioglu Ozkan</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://burcuku.github.io/home/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/burcukulahciogluozkan/4a854b1d-126f-47f5-8935-25d6401437c4/small.jpg</picture_url>
          <person_id>burcukulahciogluozkan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rupak</first_name>
          <last_name>Majumdar</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~rupak</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rupakmajumdar/3289b197-9f9a-4880-94c5-d9cf6d764bb1/small.jpg</picture_url>
          <person_id>rupakmajumdar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Filip</first_name>
          <last_name>Niksic</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://fniksic.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/filipniksic/22f726ab-2c20-4f80-b6d4-32a9530437d5/small.jpg</picture_url>
          <person_id>filipniksic</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7c051174-a874-416e-ae69-c8a0537e589a</slot_id>
      <event_id>3f3bef96-f531-418a-9389-fe359db5c7a1</event_id>
      <title>Rethinking Safe Consistency in Distributed Object-Oriented Programming</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>15:40</end_time>
      <description>Large scale distributed systems require to embrace the trade off between consistency and availability, accepting lower levels of consistency to guarantee higher availability. Existing programming languages are, however, agnostic to this compromise, resulting in consistency guarantees that are the same for the whole application and are implicitly adopted from the middleware or hardcoded in configuration files. In this paper, we propose to integrate availability in the design of an object-oriented language, allowing developers to specify different consistency and isolation constraints in the same application at the granularity of single objects. We investigate how availability levels interact with object structure and define a type system that preserves correct program behavior. Our evaluation shows that our solution performs efficiently and improves the design of distributed applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mirko</first_name>
          <last_name>Köhler</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>mirkokohler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nafise</first_name>
          <last_name>Eskandani Masoule</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.stg.tu-darmstadt.de/staff/nafise_eskandani</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nafiseeskandanimasoule/6eac9bf0-bfcf-4440-ba06-24fa9145cb4e/small.jpg</picture_url>
          <person_id>nafiseeskandanimasoule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pascal</first_name>
          <last_name>Weisenburger</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/pascalweisenburger/bf663f00-24ac-4d12-919b-ef1e2ff8e128/small.jpg</picture_url>
          <person_id>pascalweisenburger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Alessandro</first_name>
          <last_name>Margara</last_name>
          <affiliation>Politecnico di Milano, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://margara.faculty.polimi.it</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alessandromargara/c43a91d0-b824-4046-ab28-23a6ad3c2c3b/small.jpg</picture_url>
          <person_id>alessandromargara</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Guido</first_name>
          <last_name>Salvaneschi</last_name>
          <affiliation>University of St. Gallen, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.guidosalvaneschi.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guidosalvaneschi/6f1373d5-57c6-4d68-b6c3-c0a679ee24ed/small.jpg</picture_url>
          <person_id>guidosalvaneschi</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>810b594e-6e75-4f9b-872e-50182c33ff11</slot_id>
      <event_id>193eb222-e5b0-4ec0-88fe-28f689c66880</event_id>
      <title>Programming at the Edge of Synchrony</title>
      <room>Online | SPLASH-III</room>
      <date>2020/11/20</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>15:20</end_time>
      <description>Synchronization primitives for fault-tolerant distributed systems that ensure an effective and efficient cooperation among processes are an important challenge in the programming languages community. We present a new programming abstraction, ReSync, for implementing benign and Byzantine fault-tolerant protocols. ReSync has a new round structure that offers a simple abstraction for group communication, like it is customary in synchronous systems, but also allows messages to be received one by one, like in the asynchronous systems. This extension allows implementing network and algorithm-specific policies for the message reception, which is not possible in classic round models. 
The execution of ReSync programs is based on a new generic round switch protocol that generalizes the famous theoretical result about consensus in the presence of partial synchrony by of Dwork, Lynch, and Stockmeyer. We evaluate experimentally the performance of ReSync’s execution platform, by comparing consensus implementations in ReSync with LibPaxos3, etcd, and Bft-SMaRt, three consensus libraries tolerant to benign, resp. byzantine faults.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cezara</first_name>
          <last_name>Drăgoi</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.di.ens.fr/~cezarad/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cezaradragoi/3403e4d3-23e5-41ac-8cf7-48cc033f3d48/small.jpg</picture_url>
          <person_id>cezaradragoi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Josef</first_name>
          <last_name>Widder</last_name>
          <affiliation>Informal Systems, n.n.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://forsyte.at/widder</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/josefwidder1/44228499-3e67-4144-be7a-4bcc366c4dd7/small.jpg</picture_url>
          <person_id>josefwidder1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Damien</first_name>
          <last_name>Zufferey</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://dzufferey.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/damienzufferey/5dc321db-5cef-4f4b-bd3c-a5bbb2f11dd1/small.jpg</picture_url>
          <person_id>damienzufferey</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>80612a65-fb84-48cc-a7ad-ee22a6be0819</subevent_id>
    <title>SPLASH OOPSLA: W-6</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>d26929c2-bbd2-4529-93f4-9bf3e5f17f58</slot_id>
      <title>Session: SPLASH OOPSLA - W-6</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Anitha</first_name>
          <last_name>Gollamudi</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://scholar.harvard.edu/anithag</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anithagollamudi/8fb48e67-0664-40de-b6fa-163655dda95a/small.jpg</picture_url>
          <person_id>anithagollamudi</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Hans-J.</first_name>
          <last_name>Boehm</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hboehm.info</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hansjboehm/cc58482a-75bd-4d4f-85fc-73f60b132d04/small.jpg</picture_url>
          <person_id>hansjboehm</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1d66b77f-70fa-41bf-a850-7332c6c77a25</slot_id>
      <event_id>1ba9a54b-ae12-41da-8d16-8c37c6ab299d</event_id>
      <title>Programming with a Read-Eval-Synth Loop</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>17:20</end_time>
      <description>A frequent programming pattern for small tasks, especially expressions, is to repeatedly evaluate the program on an input as its editing progresses. The Read-Eval-Print Loop (REPL) interaction model has been a successful model for this programming pattern. We present the new notion of Read-Eval-Synth Loop (RESL) that extends REPL by providing in-place synthesis on parts of the expression marked by the user. RESL eases programming by synthesizing parts of a required solution. The underlying synthesizer relies on a partial solution from the programmer and a few examples. 
RESL hinges on bottom-up synthesis with general predicates and sketching, generalizing programming by example. To make RESL practical, we present a formal framework that extends observational equivalence to non-example specifications. 
We evaluate RESL by conducting a controlled within-subjects user-study on $19$ programmers from $8$ companies, where programmers are asked to solve a small but challenging set of competitive programming problems. We find that programmers using RESL solve these problems with far less need to edit the code themselves and by browsing documentation far less. In addition, they are less likely to leave a task unfinished and more likely to be correct.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roi</first_name>
          <last_name>Gabay</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <person_id>roigabay</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Shachar</first_name>
          <last_name>Itzhaky</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~shachari</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shacharitzhaky/649d5921-4057-4ac3-8fc7-75471ee8527b/small.jpg</picture_url>
          <person_id>shacharitzhaky</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>Eran Yahav is an associate professor at the Computer Science Department, Technion, Israel. Prior to that, he was a research staff member at the IBM T.J. Watson Research Center (2004-2010). He received his Ph.D. from Tel Aviv University (2005) and his B.Sc. from the Technion in 1996. His research interests include program analysis, program synthesis and program verification. Eran is a recipient of the prestigious Alon Fellowship for Outstanding Young Researchers, the Andre Deloro Career Advancement Chair in Engineering, the ERC Consolidator Grant as well as multiple best paper awards at various conferences.</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
          <person_id>eranyahav</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>62a04932-24d5-4715-8aea-3f14c5b31a32</slot_id>
      <event_id>5ded2007-1aa2-4b18-800b-2c660a495cca</event_id>
      <title>CompCertELF: Verified Separate Compilation of C Programs into ELF Object Files</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>18:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>18:20</end_time>
      <description>&amp;lt;p&amp;gt; We present CompCertELF, the first extension to CompCert that supports verified compilation from C programs all the way to a standard binary file format, i.e., the ELF object format. Previous work on Stack-Aware CompCert provides a verified compilation chain from C programs to assembly programs with a realistic machine memory model. We build CompCertELF by modifying and extending this compilation chain with a verified assembler which further transforms assembly programs into ELF object files. &amp;lt;/p&amp;gt; 
&amp;lt;p&amp;gt; CompCert supports large-scale verification via verified separate compilation: C modules can be written and compiled separately, and then linked together to get a target program that refines the semantics of the program linked from the source modules. However, verified separate compilation in CompCert only works for compilation to assembly programs, not to object files. For the latter, the main difficulty is to bridge the two different views of linking: one for CompCert's programs that allows arbitrary shuffling of global definitions by linking and the other for object files that treats blocks of encoded definitions as indivisible units. &amp;lt;/p&amp;gt; 
&amp;lt;p&amp;gt; We propose a lightweight approach that solves the above problem without any modification to CompCert's framework for verified separate compilation: by introducing a notion of syntactical equivalence between programs and proving the commutativity between syntactical equivalence and the two different kinds of linking, we are able to transit from the more abstract linking operation in CompCert to the more concrete one for ELF object files. By applying this approach to CompCertELF, we obtain the first compiler that supports verified separate compilation of C programs into ELF object files. &amp;lt;/p&amp;gt;</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuting</first_name>
          <last_name>Wang</last_name>
          <affiliation>Shanghai Jiao Tong University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jhc.sjtu.edu.cn/~yutingwang/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yutingwang/963979f5-1f61-418e-9435-0abbb408ef37/small.jpg</picture_url>
          <person_id>yutingwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xiangzhe</first_name>
          <last_name>Xu</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <person_id>xiangzhexu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pierre</first_name>
          <last_name>WILKE</last_name>
          <affiliation>CentraleSupélec, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pwilke.fr/pwilke-en.html</homepage_url>
          <person_id>pierrewilke1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhong</first_name>
          <last_name>Shao</last_name>
          <affiliation>Yale University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/shao/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhongshao/18a2973a-020f-46ed-9073-85bd70626116/small.jpg</picture_url>
          <person_id>zhongshao</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7b2229db-e070-4a04-9d3c-f809592e0644</slot_id>
      <event_id>7d597c02-ff5f-4db1-a3f8-2f251a9ca0a5</event_id>
      <title>Sound Garbage Collection for C using Pointer Provenance</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>17:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>17:40</end_time>
      <description>Garbage collection (GC) support for unmanaged languages can reduce programming burden in reasoning about liveness of dynamic objects. It also avoids temporal memory safety violations and memory leaks. {\em Sound} GC for weakly-typed languages such as C/C++, however, remains an unsolved problem. Current value-based GC solutions examine values of memory locations to discover the pointers, and the objects they point to. The approach is inherently unsound in the presence of arbitrary type casts and pointer manipulations, which are legal in C/C++. Such language features are regularly used, especially in low-level systems code. 
In this paper, we propose Dynamic Pointer Provenance Tracking to realize sound GC. We observe that pointers cannot be created out-of-thin-air, and they must have provenance to at least one valid allocation. Therefore, by tracking pointer provenance from the source (e.g., \texttt{malloc}) through both explicit data-flow and implicit control-flow, our GC has sound and precise information to compute the set of all reachable objects at any program state. We discuss several static analysis optimizations, that can be employed during compilation aided with profiling, to significantly reduce the overhead of dynamic provenance tracking from nearly $8\times$ to 16% for well-behaved programs that adhere to the C standards. Pointer provenance based sound GC invocation is also 13% faster and reclaims 6% more memory on average, compared to an unsound value-based GC.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Subarno</first_name>
          <last_name>Banerjee</last_name>
          <affiliation>University of Michigan, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.eecs.umich.edu/~subarno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/subarnobanerjee/56075c15-14b6-4177-b624-840d0b02cf22/small.jpg</picture_url>
          <person_id>subarnobanerjee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Devecsery</last_name>
          <affiliation>Georgia Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>daviddevecsery</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter M.</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Michigan, USA</affiliation>
          <bio>undefined</bio>
          <person_id>petermchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Satish</first_name>
          <last_name>Narayanasamy</last_name>
          <affiliation>University of Michigan, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.eecs.umich.edu/~nsatish/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/satishnarayanasamy/cedfbed8-4f1b-40b0-afdd-135766659f94/small.jpg</picture_url>
          <person_id>satishnarayanasamy</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ca5e0489-650e-4d31-a81b-54a150c0c318</slot_id>
      <event_id>4d0f5a86-a761-438e-b9c1-1c44f16d89f9</event_id>
      <title>Semiring Optimizations: Dynamic Elision of Expressions with Identity and Absorbing Elements</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>17:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>18:00</end_time>
      <description>This paper describes a compiler optimization to eliminates dynamic occurrences of expressions in the format $a \leftarrow a \oplus b \otimes c$. The operation $\oplus$ must admit an identity element $z$, such that $a \oplus z = a$. Also, $z$ must be the absorbing element of $\otimes$, such that $b \otimes z = z \otimes c = z$. Semirings where $\oplus$ is the additive operator and $\otimes$ is the multiplicative operator meet this contract. This pattern is common in high-performance benchmarks—its canonical representative being the multiply-add operation $a \leftarrow a + b \times c$. However, several other expressions involving arithmetic and logic operations satisfy the required algebra. We show that the runtime elimination of such assignments can be implemented in a performance-safe way via online profiling. The elimination of dynamic redundancies involving identity and absorbing elements in 35 programs of the LLVM test suite that present semiring patterns brings an average speedup of 1.19x (total optimized time over total unoptimized time) on top of clang -O3. When projected onto the entire test suite (259 programs) the optimization leads to a speedup of 1.025x. Once added onto \texttt{clang}, semiring optimizations approximates it to TACO, a specialized tensor compiler.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guilherme Vieira</first_name>
          <last_name>Leobas</last_name>
          <affiliation>Federal University of Minas Gerais, Brazil</affiliation>
          <bio>undefined</bio>
          <person_id>guilhermeleobas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fernando Magno Quintão</first_name>
          <last_name>Pereira</last_name>
          <affiliation>Federal University of Minas Gerais, Brazil</affiliation>
          <bio>Fernando got his Ph.D at UCLA in 2008, under the supervision of Jens Palsberg. He is currently an assistant professor at the Universidade Federal de Minas Gerais, Brazil. His main research interest are in code generation, compiler optimizations and static program analyses.</bio>
          <homepage_url>http://homepages.dcc.ufmg.br/~fernando/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/fernandomagnoquintaopereira/8f86b14f-fbc3-49a4-9f4f-1a8216564d39/small.jpg</picture_url>
          <person_id>fernandomagnoquintaopereira</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>41eed975-ea43-475b-87cb-172380f11881</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Dinner in Delhi</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>469d74ae-d370-4f6e-88e8-419d58ad21e8</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Dinner in Delhi</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>06:20</start_time>
      <end_time>07:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ccf31134-d942-4fcf-95d3-d3804e8340b1</slot_id>
      <event_id>41344328-debe-4b54-a95f-00473bea98e4</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>06:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>07:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f1d76aa3-7097-415b-9336-e9bf90f8c509</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Dinner in Delhi</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>888dbd5f-80fa-476b-8965-6e8c20a5bd2e</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Dinner in Delhi</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>06:20</start_time>
      <end_time>07:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9c0a2c44-a879-4250-851a-7ece2a89a755</slot_id>
      <event_id>af0a9139-5efc-4433-848e-f879847a8593</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>06:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>07:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>290cbc29-e0e4-4730-9a9c-f8a7b32290b6</subevent_id>
    <title>SPLASH Meet The Speakers (MTS):  Breakfast in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>e443e75b-a225-40e3-b882-8f2c0c49141b</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) -  Breakfast in Paris</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>00:20</start_time>
      <end_time>01:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>be202520-c09c-4b03-a10c-ec29fc6beec0</slot_id>
      <event_id>8010406f-2804-40f1-8c0c-b519197640c0</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>01:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9efd3000-546e-4e07-b16f-491e96093660</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in Sydney</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>afa9e49f-8715-44a1-b6ed-43fbc01e7fad</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in Sydney</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>02:20</start_time>
      <end_time>03:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f8449caa-0f13-4db5-a61a-bf1f0476f999</slot_id>
      <event_id>f20253ce-958e-48d0-b23f-bd511a5cab7b</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>02:20</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>03:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>38700b30-3854-4560-92d3-8470fc26a5b9</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Dinner in Bejing</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>6797bc5c-2307-4e8a-84df-ea46385b82ac</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Dinner in Bejing</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>04:20</start_time>
      <end_time>05:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>28b438c8-2bb8-4c84-9d21-6e2026f92db5</slot_id>
      <event_id>5a1b823c-58b7-45a2-a372-1295a926866d</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>04:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>05:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2556bb91-6f47-4214-9176-ac03c58ef23d</subevent_id>
    <title>SPLASH Meet The Speakers (MTS):  Breakfast in Wellington</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>6a878f38-c3bd-4065-a934-b4a0c0bd9d65</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) -  Breakfast in Wellington</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>12:20</start_time>
      <end_time>13:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5f7abeca-7a33-4d3d-a9a1-e09952cd681d</slot_id>
      <event_id>8010406f-2804-40f1-8c0c-b519197640c0</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>13:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2835ba52-2fcf-46c2-9819-1b41dc5788ed</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Wellington</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>de8a3daa-4a5f-436f-acf7-8827b5bb0156</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Wellington</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>12:20</start_time>
      <end_time>13:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>79d319e1-aae0-4d5b-a989-c5f07e8f2a47</slot_id>
      <event_id>ef0da7f6-6951-418c-81ac-a80a2cc82709</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>13:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>090f1831-79bf-451d-89eb-6216171828d7</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in Rio</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>7fcd6326-d0fe-444f-9bef-e01ba210a18c</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in Rio</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>18:20</start_time>
      <end_time>19:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0db1e0aa-166d-4e42-93a6-49fe07fe3b76</slot_id>
      <event_id>fd62e782-7287-4a4f-9fd1-4d11e89b96bb</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>18:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>19:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>100c923e-49fe-4578-9df6-99bff9fb354d</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Dinner in Beijing</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>e3648b24-f6f5-42f5-b118-a85a3c14692a</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Dinner in Beijing</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>04:20</start_time>
      <end_time>05:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ba08d855-3c45-46bc-b3de-7dbf3d486433</slot_id>
      <event_id>fb550191-b8f9-4f85-adbd-b8f8cb30a311</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>04:20</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>05:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5da90891-02f7-4c04-b462-a4512aff7a7d</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Dinner in Beijing</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>4b1cbcfc-b7a2-41d5-acc0-e66efb40e429</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Dinner in Beijing</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>04:20</start_time>
      <end_time>05:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1ff7370a-b874-459e-ae4f-8f65c24f1e96</slot_id>
      <event_id>8e461460-7155-4f2e-8aeb-88ff712acfac</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>04:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>05:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ccda1cf9-d754-4113-9f65-c68358446fea</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in Sydney</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>c23db3cb-cd3e-4541-843f-9736f29c5c48</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in Sydney</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>02:20</start_time>
      <end_time>03:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>811c4765-b7f9-4651-a4fa-6302b865b1bf</slot_id>
      <event_id>8e014af6-7d2d-484b-bc92-75fe6dda785d</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>02:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>03:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>10ae67d5-ba3d-4fa2-9dec-6c84daafe01b</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Seoul</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>8e05bc92-a3d7-4fd8-a53b-2635f31e16e0</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Seoul</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>16:20</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>49ee09e2-15ca-4c92-b843-6201c955ff55</slot_id>
      <event_id>8fea7ac6-5aca-4951-82b6-6af04e2e6e57</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>16:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>17:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>45fca3c6-94a2-4a73-9a2e-e845ca6fc2c9</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in Sydney</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>15651b93-1a9b-4ae6-a9de-3c9344a65b1d</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in Sydney</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>02:20</start_time>
      <end_time>03:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bf69ae78-670e-4210-9256-0136323113e6</slot_id>
      <event_id>7ec665e0-18d7-40be-9c73-3fb71ad0d3a5</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>02:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>03:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>87e4b5ea-eed7-45b7-bbdf-b0dc87df67e2</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in Sydney</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>fc314b4b-fdeb-4529-8645-af352e5f8610</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in Sydney</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>02:20</start_time>
      <end_time>03:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4664f198-7455-4844-b3f8-982f3054091f</slot_id>
      <event_id>a2e0574b-823d-4e03-8d1e-cf786722b3da</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>02:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>03:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0264e737-d989-4046-ab5e-91e029b6993f</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Lunch in Tokyo</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>794edee4-faec-4029-b7f2-b35fcc203565</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Lunch in Tokyo</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>22:20</start_time>
      <end_time>23:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ea3ea7af-035a-4d65-8d22-f205cab85f8b</slot_id>
      <event_id>6d16dad2-294f-4901-8698-c501a6a5a6e6</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>23:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>06dc8b3d-08fa-4d37-a33f-96fcdd6ae79b</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>5207c506-c488-4c32-9863-6ed490999319</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in Paris</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>14:20</start_time>
      <end_time>15:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>abc1e095-7c22-49a5-a3e5-af5de34fd3c1</slot_id>
      <event_id>6fc744f4-fc7f-4b96-b70f-e25251614484</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>14:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>15:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>110887f5-3971-48cc-b32e-09a8fc65c79a</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>18b9c24d-87d8-49e6-8a83-85828e998fc3</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in Paris</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>14:20</start_time>
      <end_time>15:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1effe11a-a3e6-490d-81ca-368fd8097004</slot_id>
      <event_id>7ec665e0-18d7-40be-9c73-3fb71ad0d3a5</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>14:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>15:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>183ae9da-3ef3-4369-821b-2d04247e6dc2</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Dinner in Delhi</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>39d98bdb-509d-4c1e-9679-2b3a8460f536</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Dinner in Delhi</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>06:20</start_time>
      <end_time>07:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>de69b4ff-f9cc-4d98-8962-8478ec631050</slot_id>
      <event_id>a2314e5c-fecf-4e32-bc37-5c8af0e8395d</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>06:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>07:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>946113d2-7dca-4cf4-bf18-65828238a8e6</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Lunch in Tokyo</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>72306046-424a-45de-833c-3ee4361502ba</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Lunch in Tokyo</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>22:20</start_time>
      <end_time>23:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>40b0c6a8-8dfc-49c6-b8e0-4f6aaa04fcd8</slot_id>
      <event_id>b3d90584-8297-4112-b66a-f612567a4efe</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>23:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>31270720-18f3-48bf-a63d-96e0caa0f99a</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Seattle</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>4e1fc14b-cd15-4205-a38c-691c22c3b0bb</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Seattle</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>10:20</start_time>
      <end_time>11:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5dcaaf21-711c-4f4a-8fd5-9fa521a51447</slot_id>
      <event_id>b3d90584-8297-4112-b66a-f612567a4efe</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>11:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5de1e31e-1b7b-43cb-a75a-82ac2976712d</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Dinner in Delhi</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>8efd584e-4797-4534-aeec-59fe3f423cf7</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Dinner in Delhi</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>06:20</start_time>
      <end_time>07:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a561cd0e-b83c-4d22-9fa0-d71ebdeec5d2</slot_id>
      <event_id>74621f0c-91df-4fb7-857c-a74d1e6bede3</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>06:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>07:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9235bc39-57f1-4331-ae71-ff9f9a03425b</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Dinner in Beijing</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>50e4280c-0f7e-47f3-ab5f-5c6ae3248ecd</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Dinner in Beijing</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>04:20</start_time>
      <end_time>05:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4730d618-60da-42ff-ab71-c9ed92788011</slot_id>
      <event_id>69feb002-c268-4ad4-aa4b-b2c2ac601cfc</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>04:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>05:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>dcb7c099-6f68-44ca-9993-0ad9e4ce089c</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Dinner in Beijing</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>35660a14-ea2b-4c07-a870-fd368b154bb4</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Dinner in Beijing</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>04:20</start_time>
      <end_time>05:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bf8aa1bb-debe-4319-b674-d869eb3ac7e1</slot_id>
      <event_id>70d3b92e-67ed-4b25-9ef7-8685970e6aa1</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>04:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>05:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>96b04dc9-609d-4add-a4ca-d54905355fa2</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Seoul</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>f7e72578-1caa-4bc8-ba04-1966c0258c07</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Seoul</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>16:20</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e27ab703-0158-4b31-97a6-46bab42ff367</slot_id>
      <event_id>fb550191-b8f9-4f85-adbd-b8f8cb30a311</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>16:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>17:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>159e9c65-67d3-424f-8e04-1494b46c5ad5</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>0f92abb2-e2ee-45cf-a1bc-4643a45baa64</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in Paris</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>14:20</start_time>
      <end_time>15:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3bff6fff-e28b-409f-98fe-d4e1a71df530</slot_id>
      <event_id>8e014af6-7d2d-484b-bc92-75fe6dda785d</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>14:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>15:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6bd6e8e8-8929-4589-924c-9de6ed952d96</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Seattle</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>c0e085d4-3671-420d-9c32-2a116e89bb33</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Seattle</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>10:20</start_time>
      <end_time>11:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>44bdbff9-0f7a-48a5-9ced-41c280b4bf36</slot_id>
      <event_id>e45cad66-437c-4dad-b3d5-e726922b664b</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>11:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>29157bcf-d097-4226-b688-34189b84769d</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Seoul</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>154e7480-3b26-4dc8-8b61-7b96589e1bad</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Seoul</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>16:20</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bc62cc2c-0854-4d56-9ad9-01f05f3675d1</slot_id>
      <event_id>69feb002-c268-4ad4-aa4b-b2c2ac601cfc</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>16:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>17:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>eab5fd2f-be93-4fe4-bfd2-d96ca4577c91</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in Rio</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>df6d9734-3c01-4713-b334-6c94ca0a780f</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in Rio</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>18:20</start_time>
      <end_time>19:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7f978100-6d5a-4d3f-939a-adc2e6ecae65</slot_id>
      <event_id>74621f0c-91df-4fb7-857c-a74d1e6bede3</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>18:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>19:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>23c7f168-e0e1-488f-937b-c20c81a3a312</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in New York</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>badcc3b3-97e4-463a-9412-d5497a9b5985</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in New York</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>20:20</start_time>
      <end_time>21:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>79b265f6-61cc-424c-96fb-f54b774d2d11</slot_id>
      <event_id>ff5144df-c9fe-48d0-886c-d050a8ed6101</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>21:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4a687b5e-d441-4544-bdd4-35e6390cc82d</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>fc078588-7024-455d-994c-add4b46e8b29</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in Paris</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>14:20</start_time>
      <end_time>15:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3b288bef-d6f5-4b53-81a3-3bba2c8ac8d8</slot_id>
      <event_id>a2e0574b-823d-4e03-8d1e-cf786722b3da</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/15</date>
      <start_time>14:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>15:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>63be007a-33fa-4eab-a13b-8f491c70c001</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Chicago</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>7ec23b2e-bba2-4487-84ce-c9b7fb2dd1ab</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Chicago</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>08:20</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c3ed0288-c732-4fac-b38a-3766f95a412f</slot_id>
      <event_id>0412756b-8f59-4c3c-ac47-94351e60bc25</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>09:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6ebf9556-6d55-4fff-82de-e3d73a079efb</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in Rio</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>d5efed96-a892-40d8-8fa1-1a50c22c1cd7</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in Rio</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>18:20</start_time>
      <end_time>19:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2e115366-93c3-4f21-a8e7-24e86007a95a</slot_id>
      <event_id>41344328-debe-4b54-a95f-00473bea98e4</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>18:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>19:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b97335be-91a7-48bb-b480-7a16f563491a</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in New York</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>4bf94259-40c3-43da-be46-3a0c2cff5331</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in New York</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>20:20</start_time>
      <end_time>21:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>98fd09a5-985b-458c-8bb5-a3a8f78a24b3</slot_id>
      <event_id>0412756b-8f59-4c3c-ac47-94351e60bc25</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>21:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>52ba652d-ede3-4545-8785-4ecb2a449793</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Chicago</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>536cb29b-cc93-40c3-822e-a39a35c6e09c</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Chicago</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>08:20</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0b92ada1-6942-45ea-b6cf-ede61050f669</slot_id>
      <event_id>5dda3903-b7f6-4d55-9d84-82a865e29e54</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>09:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fa2dae48-2be3-4095-967d-e3540344aa3c</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in Rio</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>f80a1b61-11d0-498d-bb3e-979685b90f6d</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in Rio</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>18:20</start_time>
      <end_time>19:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b13f8297-83c5-4b5a-b471-fe12eee8ec07</slot_id>
      <event_id>af0a9139-5efc-4433-848e-f879847a8593</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>18:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>19:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8a72ec77-51f9-4238-9aa4-23ca7c1fe551</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>8918cf84-baed-4db8-b4a3-6b79fe6e4932</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Paris</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>00:20</start_time>
      <end_time>01:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1b01cb71-50c5-4eae-87a7-1e1f869c8b67</slot_id>
      <event_id>ef0da7f6-6951-418c-81ac-a80a2cc82709</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/21</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>01:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3cbc034c-d41d-498c-ad74-bb5a6c619435</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in New York</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>d526105c-526d-4c3d-98f7-c26566d47a3f</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in New York</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>20:20</start_time>
      <end_time>21:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3d5cc542-a518-49e2-bf11-f6005292cd63</slot_id>
      <event_id>badde84c-bc9d-4fef-bd68-58ecc99fd8a5</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>21:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>28c4e27e-2082-4eac-8f27-655b118396a4</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Dinner in Beijing</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>63c58641-3bdb-404f-a828-8f1cdc7ff603</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Dinner in Beijing</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>04:20</start_time>
      <end_time>05:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5af4d813-8303-4e72-9d4c-a91c25c2529f</slot_id>
      <event_id>8fea7ac6-5aca-4951-82b6-6af04e2e6e57</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>04:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>05:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>900fc1a6-6c4e-4f8b-80ec-47014cfe7648</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Seoul</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>5d30929f-48bb-4cb2-8a78-755f096e88b6</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Seoul</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>16:20</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7b597fe4-019b-4808-93da-7167de334119</slot_id>
      <event_id>70d3b92e-67ed-4b25-9ef7-8685970e6aa1</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>16:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>17:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4540c921-5e28-4aee-819c-4022e01632ab</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Seattle</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>c8753a8b-4736-478b-b379-9cbff18ba569</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Seattle</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>10:20</start_time>
      <end_time>11:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cae5b9b8-4fd8-4e34-964d-2991005b303f</slot_id>
      <event_id>414c7d00-15da-4ae3-9e59-0564783ef8a6</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>11:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>22c7551a-91e1-4088-835c-687b4279608d</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>a9e58204-796c-4033-8b61-672eb5418ad7</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in Paris</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>14:20</start_time>
      <end_time>15:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>584b5226-0d4c-4608-977d-dff4be0a7d7c</slot_id>
      <event_id>f20253ce-958e-48d0-b23f-bd511a5cab7b</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>14:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>15:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d8c93115-4f66-40b3-979c-2b9484cffc0b</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in Rio</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>ecd3c6f9-7500-4ddd-a390-0223cac52cee</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in Rio</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>18:20</start_time>
      <end_time>19:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>57de7806-1e6b-4b9c-8a39-e852615f5e8d</slot_id>
      <event_id>a2314e5c-fecf-4e32-bc37-5c8af0e8395d</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>18:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>19:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2fb14507-a159-4e84-8673-160b2266ea26</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Seattle</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>c5650e01-bcbb-4625-b15c-e33301575bb4</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Seattle</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>10:20</start_time>
      <end_time>11:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c2eb141d-1841-40a2-9330-297b5777801b</slot_id>
      <event_id>0946af88-5fc0-40d0-827b-f00b431464d2</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>11:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>cfc5f1c7-ca5c-45bb-83f5-d056f851b1fc</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Seoul</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>6603b7b6-acfc-4a5b-be06-748b355a0bbd</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Seoul</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>16:20</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a7522d94-002d-410d-9465-602ddb9f8a41</slot_id>
      <event_id>8e461460-7155-4f2e-8aeb-88ff712acfac</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>16:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>17:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>95fa77a0-bc5b-47f8-b2e3-77f5ce68b2ae</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Seoul</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>568214cf-4aa7-4ccb-9161-b6d5a4a94246</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Seoul</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>16:20</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>234b049b-70e0-4bf0-beec-c531f765c6a0</slot_id>
      <event_id>5a1b823c-58b7-45a2-a372-1295a926866d</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>16:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>17:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8883ccc9-409e-418c-aab3-f2960a4c6145</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Wellington</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>52bb859a-5600-47bf-96fb-dba1e553b11b</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Wellington</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>12:20</start_time>
      <end_time>13:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9672cea2-0ebc-460b-aca7-24eedb525581</slot_id>
      <event_id>20fd4662-e02e-4f90-9009-d4e240b955c1</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>13:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1116d7ac-0a5b-4130-b0fe-b0d43baa7ec6</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Lunch in Tokyo</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>9a1bd4e7-8bfd-4357-8133-d27d2b705fe5</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Lunch in Tokyo</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>22:20</start_time>
      <end_time>23:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8d5f9848-74e7-436a-9435-543a00449405</slot_id>
      <event_id>e45cad66-437c-4dad-b3d5-e726922b664b</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>23:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a312dc73-0928-4aef-a9f1-367f35ec0582</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Wellington</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>46860f9d-95be-41cd-be6f-adb1313e2406</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Wellington</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>12:20</start_time>
      <end_time>13:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4a316931-1993-4ff3-a89a-2d61489b3ba1</slot_id>
      <event_id>1eafc361-05aa-48dd-80e5-a8708d7ac2c8</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>13:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>45b7f00d-1236-47a6-8f75-11ab3ef59aa4</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Wellington</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>a7d0071f-d669-43db-b1e7-27b4ba249e9f</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Wellington</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>12:20</start_time>
      <end_time>13:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6f8af9ec-c7a9-4898-ad9c-e17609ce3843</slot_id>
      <event_id>8b0a455d-2f61-4671-8f81-7977952de337</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>13:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>06815c4c-c89b-4f70-a660-523a827fbd33</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Lunch in Tokyo</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>7a6cdc9c-cf5c-4f2d-8d73-dd1590006579</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Lunch in Tokyo</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>22:20</start_time>
      <end_time>23:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>68fca7ac-5f44-4021-a949-4d2deb85a634</slot_id>
      <event_id>414c7d00-15da-4ae3-9e59-0564783ef8a6</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>23:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a74bf172-bc9d-41d8-baea-2271a84d93eb</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>c6023619-3c91-46b8-b882-634f640cf65c</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Paris</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>00:20</start_time>
      <end_time>01:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c5a7dede-31a7-40d3-a94d-a92a8c9c88b3</slot_id>
      <event_id>1eafc361-05aa-48dd-80e5-a8708d7ac2c8</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>01:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c301703c-b9e9-49c9-a722-7d51a41c6a69</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Lunch in Tokyo</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>cf3e426f-e593-4ab9-ae8b-3e76fa95bbac</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Lunch in Tokyo</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>22:20</start_time>
      <end_time>23:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d15030ec-ac9a-426e-8e5e-6a259dae4c9b</slot_id>
      <event_id>0946af88-5fc0-40d0-827b-f00b431464d2</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>23:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9120fd32-a14b-40ba-9b86-de9aa36eb10c</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in Sydney</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>8f96b452-7f3b-4fef-8a97-5c314a8a88e5</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in Sydney</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>02:20</start_time>
      <end_time>03:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>88c33a85-936c-49e3-960c-5cf996f1cba4</slot_id>
      <event_id>6fc744f4-fc7f-4b96-b70f-e25251614484</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>02:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>03:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a4b9b6ee-e0e1-466d-a2c0-6066ea29e65b</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in New York</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>880733c8-d6a2-4ffa-b107-584f1a586e5d</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in New York</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>20:20</start_time>
      <end_time>21:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ce2e21ea-ba86-4250-9d12-3483b3a07ef7</slot_id>
      <event_id>5dda3903-b7f6-4d55-9d84-82a865e29e54</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>21:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5ca4cc26-ba9c-4da3-958f-bf8749b7e69d</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Dinner in Delhi</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>eb94dabc-de48-4ffb-9684-70be3666fd27</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Dinner in Delhi</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>06:20</start_time>
      <end_time>07:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d165938f-5a58-4bea-b8a5-9d5585503f09</slot_id>
      <event_id>fd62e782-7287-4a4f-9fd1-4d11e89b96bb</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/16</date>
      <start_time>06:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>07:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9fa92caa-773d-43e7-ac1b-6c1c3991a711</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>05c3ed95-5b71-4ad0-bdd1-91a5f8b1ded2</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in Paris</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>14:20</start_time>
      <end_time>15:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8fb562d2-89db-4b84-b513-3fc5a2adb915</slot_id>
      <event_id>4c9081af-aa92-4d04-a815-22b427724873</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/17</date>
      <start_time>14:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>15:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8493e0d9-35dd-45f7-a2f3-ce3635d8ce5d</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Cocktails in Sydney</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>3d9f2844-e2d9-43df-879f-cb712b19b6cf</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Cocktails in Sydney</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>02:20</start_time>
      <end_time>03:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d058804c-dca1-403c-a7a1-fc4ae37a346b</slot_id>
      <event_id>4c9081af-aa92-4d04-a815-22b427724873</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/18</date>
      <start_time>02:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>03:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>420ad0eb-9487-4639-a69e-11b24c4d4d15</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Chicago</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>50b0fccc-37ae-4bee-a50a-dae49feec5c5</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Chicago</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>08:20</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f011b6e1-c921-4aac-b12f-6358f3b6fd80</slot_id>
      <event_id>badde84c-bc9d-4fef-bd68-58ecc99fd8a5</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>09:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2be5ebe4-181b-4172-a56e-b0926ffad517</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>5b653b82-1e9d-4bac-b447-8bee0ba21a26</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Paris</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>00:20</start_time>
      <end_time>01:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3e15f315-6f74-4c2c-9997-d0b7189c963d</slot_id>
      <event_id>20fd4662-e02e-4f90-9009-d4e240b955c1</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/20</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>01:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8b87cdb8-4da6-468e-8ba4-0d75b309aecc</subevent_id>
    <title>SPLASH Meet The Speakers (MTS): Breakfast in Chicago</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH-I</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet The Speakers (MTS)</url_link_display>
    <tracks>
      <track>Meet The Speakers (MTS)</track>
    </tracks>
    <timeslot>
      <slot_id>86007b86-6881-4fde-8245-d39d9eb1ca4c</slot_id>
      <title>Session: SPLASH Meet The Speakers (MTS) - Breakfast in Chicago</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>08:20</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b5ae5a71-008e-42fd-ae8d-47b981d24e46</slot_id>
      <event_id>ff5144df-c9fe-48d0-886c-d050a8ed6101</event_id>
      <title>Meet The Speakers</title>
      <room>Online | SPLASH-I</room>
      <date>2020/11/19</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>09:00</end_time>
      <description>Please go to the breakrooms at Clowdr.</description>
      <tracks>
        <track>Meet The Speakers (MTS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <timezone_id>America/Chicago</timezone_id>
</event>
