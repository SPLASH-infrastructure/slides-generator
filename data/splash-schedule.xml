<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE event [<!ELEMENT zip_code (#PCDATA)><!ELEMENT url_link_display (#PCDATA)><!ELEMENT url (#PCDATA)><!ELEMENT tracks (track+)><!ELEMENT track (#PCDATA)><!ELEMENT title (#PCDATA)><!ELEMENT timeslot (slot_id?, event_id?, title, room, date, start_time, end_date?, end_time, description?, acm_doi?, persons?, tracks?, tags?)><!ELEMENT tags (tag+)><!ELEMENT tag (#PCDATA)><!ELEMENT suffix (#PCDATA)><!ELEMENT subevent_logo_url (#PCDATA)><!ELEMENT subevent_id (#PCDATA)><!ELEMENT subevent (subevent_id?, title, acronym?, subevent_type, description?, room, date, url?, url_link_display?, subevent_logo_url?, acm_doi?, persons?, tracks?, tags?, sponsor?, timeslot*)><!ELEMENT state (#PCDATA)><!ELEMENT start_time (#PCDATA)><!ELEMENT start_date (#PCDATA)><!ELEMENT sponsor (#PCDATA)><!ELEMENT sort_key (#PCDATA)><!ELEMENT slot_id (#PCDATA)><!ELEMENT subevent_type EMPTY><!ATTLIST subevent_type	type (case_study | demonstration | poster | regular | tutorial | workshop) #IMPLIED><!ELEMENT room (#PCDATA)><!ELEMENT role (#PCDATA)><!ELEMENT picture_url (#PCDATA)><!ELEMENT persons (person+)><!ELEMENT person (role, sort_key, first_name, middle_name?, last_name, suffix?, affiliation, acm_profile_id?, email?, bio?, homepage_url?, picture_url?, person_id?)><!ELEMENT middle_name (#PCDATA)><!ELEMENT location (facility_name, facility_map_url?, address, city, state?, country, zip_code?)><!ELEMENT last_name (#PCDATA)><!ELEMENT homepage_url (#PCDATA)><!ELEMENT first_name (#PCDATA)><!ELEMENT facility_name (#PCDATA)><!ELEMENT facility_map_url (#PCDATA)><!ELEMENT event_type EMPTY><!ATTLIST event_type	type (conference|workshop|symposium) #IMPLIED><!ELEMENT event (event_details, subevent*, timeslot*, timezone_id?)><!ELEMENT event_logo_url (#PCDATA)><!ELEMENT event_details (title, acronym, event_type, start_date, end_date, location, description, url?, url_link_display?, event_logo_url?, persons?)><!ELEMENT end_time (#PCDATA)><!ELEMENT end_date (#PCDATA)><!ELEMENT email (#PCDATA)><!ELEMENT description (#PCDATA)><!ELEMENT date (#PCDATA)><!ELEMENT country (#PCDATA)><!ELEMENT city (#PCDATA)><!ELEMENT bio (#PCDATA)><!ELEMENT affiliation (#PCDATA)><!ELEMENT address (#PCDATA)><!ELEMENT acronym (#PCDATA)><!ELEMENT acm_profile_id (#PCDATA)><!ELEMENT acm_doi (#PCDATA)>]>
<event>
  <event_details>
    <title>SPLASH 2020</title>
    <acronym>SPLASH 2020</acronym>
    <event_type type="conference"/>
    <start_date>2020/11/15</start_date>
    <end_date>2020/11/21</end_date>
    <location>
      <facility_name>Online</facility_name>
      <address>undefined</address>
      <city>Online Conference</city>
      <country>undefined</country>
    </location>
    <description>Welcome to the website of the SPLASH 2020 conference!
SPLASH is the ACM SIGPLAN conference on Systems, Programming, Languages, and Applications: Software for Humanity. SPLASH embraces all aspects of software construction and delivery, to make it the premier conference on the applications of programming languages—at the intersection of programming languages and software engineering. SPLASH 2020 will take place from Sunday 15th to Friday 20th of November 2020.
SPLASH includes the following co-located conferences: OOPSLA, Onward!, GPCE, SLE, DLS, ECOOP and SAS; as well as a large array of workshops and events.
VIRTUAL SPLASH will run in three main streams:

 OOPSLA/ECOOP will exclusively contain OOPSLA and ECOOP research papers;
 REBASE will exclusively contain Rebase industry-oriented talks;
 SPLASH will contain the major co-located events: GPCE/SLE on Sunday/Monday; Onward! Papers and Essays on Tuesday; SAS/DLS on Wednesday/Thursday; and OOPSLA research papers on Friday.

NB! All other events, such as workshops, will take place outside the main three stream six day event. Please consult their individual pages for specific details.
MIRRORING In what we think is world first, SPLASH will do 12 hour mirroring where each of the six conference days will be exactly 12 hours long with every single talk scheduled to repeat with a 12 hour delay (a.k.a. mirror). Therefore:
whatever YOUR time zone happens to be, you are welcome to attend SPLASH during any convenient 12 hour block on each of the six days
For example: Alex from New Zealand plans to attend between 8am and 8pm NZ Standard Time; Jan from Czechia plans to attend between 8am and 8pm Central European Time, while Hridesh from Iowa plans to attend between 9am and 9pm Central Daylight Time!</description>
    <url>https://2020.splashcon.org</url>
    <url_link_display>SPLASH 2020</url_link_display>
    <persons>
      <person>
        <role>General Chair in Organizing Committee, Committee Member in Steering Committee</role>
        <sort_key>1</sort_key>
        <first_name>Hridesh</first_name>
        <last_name>Rajan</last_name>
        <affiliation>Iowa State University, USA</affiliation>
        <bio>Hridesh Rajan is a Professor of Computer Science at Iowa State University, where he has been since 2005. Professor Rajan earned his MS and Ph.D. from the University of Virginia in 2004 and 2005 respectively. Professor Rajan’s recent research and educational activities are aimed at decreasing the barrier to entry to data-driven sciences to broaden participation. His work on the Boa project is aimed at the invention and refinement of programming languages and cyberinfrastructures that democratize data-driven science &amp;amp; engineering, including software engineering. His work on the Midwest Big Data Summer School is experimenting with broadly accessible data science curricula. Professor Rajan was the founding general chair of the Midwest Big Data Summer School. Professor Rajan’s research interests also include programming language design and implementation, and software engineering. He leads two research projects: Panini, whose goals are to enable modular reasoning about concurrent programs, and Boa that was established in Summer 2012 as an end-to-end infrastructure for analyzing large-scale software repositories and other open data sets. Professor Rajan is the director of the Laboratory for Software Design at Iowa State University, director of graduate admissions and recruitment for the Department of Computer Science. He serves as the interim chair of the Department of Computer Science and served as the Professor-In-Charge of the Data Science education programs at Iowa State University from 2017-2019, and chair of the information technology committee for the university from 2015-2019. Professor Rajan served on the steering committee of the Midwest Big Data Hub, a consortium of universities in the Midwest region of the United States focused on promoting data science activities. Professor Rajan is a recipient of the National Science Foundation CAREER award in 2009, LAS Award for Early Achievement in Research in 2010, a Big-12 Fellowship in 2012. He is a 2018-19 Fulbright U.S. Scholar, a distinguished member of the ACM, and a member of IEEE, and AAAS. He is also the inaugural holder of the Kingland Professorship in the Department of Computer Science.</bio>
        <homepage_url>https://hridesh.github.io</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/hrideshrajan/f57a0842-20af-4fd4-b79f-5d673c2c485c/small.jpg</picture_url>
        <person_id>hrideshrajan</person_id>
      </person>
      <person>
        <role>Chair in Steering Committee</role>
        <sort_key>2</sort_key>
        <first_name>Eelco</first_name>
        <last_name>Visser</last_name>
        <affiliation>Delft University of Technology</affiliation>
        <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science at Delft University of Technology. He received a master’s and doctorate in computer science from the University of Amsterdam in 1993 and 1997, respectively. Previously he served as postdoc at the Oregon Graduate Institute, as Assistant Professor at Utrecht University, and as Associate Professor at TU Delft.
His research interests include programming languages, software language engineering, domain-specific programming languages, program transformation, syntax definition, and parsing. With his students he has designed and implemented the Spoofax language workbench, as well as many domain-specific languages, including DSLs for syntax definition (SDF2, SDF3), program transformation (Stratego), static semantics (NaBL, Statix), dynamic semantics (DynSem), software deployment (Nix), web application development (WebDSL), and mobile phone applications (mobl). In the language designer’s workbench project he is pursuing high-level declarative language definition that serves for language implementation and verification.</bio>
        <homepage_url>http://eelcovisser.org</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
        <person_id>eelcovisser</person_id>
      </person>
      <person>
        <role>OOPSLA Review Committee Chair in Organizing Committee, Committee Member in Steering Committee</role>
        <sort_key>3</sort_key>
        <first_name>David</first_name>
        <last_name>Grove</last_name>
        <affiliation>IBM Research</affiliation>
        <bio>I am a Distinguished Research Staff Member at the IBM T.J. Watson Research Center. I joined IBM Research in 1998 after completing my PhD at the University of Washington. I am a software systems researcher, working primarily on problems in programming language implementation and scalable runtime systems.
I have contributed to a number of technical topics in programming language design and implementation including the analysis and optimization of object-oriented languages, virtual machine design and implementation, scalable runtime systems, Just-In-Time compilation, online feedback-directed optimization, and garbage collection.</bio>
        <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-groved</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/davidgrove/5524049e-7d0a-4799-ad8c-93e1e76a77ec/small.jpg</picture_url>
        <person_id>davidgrove</person_id>
      </person>
      <person>
        <role>Onward! Papers Chair in Organizing Committee, Committee Member in Steering Committee</role>
        <sort_key>4</sort_key>
        <first_name>Stephen</first_name>
        <last_name>Kell</last_name>
        <affiliation>University of Kent</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.kent.ac.uk/people/staff/srk21</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/stephenkell/53088184-3e8c-4a2c-b34f-b2a290cff411/small.jpg</picture_url>
        <person_id>stephenkell</person_id>
      </person>
      <person>
        <role>Onward! Essays Chair in Organizing Committee</role>
        <sort_key>5</sort_key>
        <first_name>Didier</first_name>
        <last_name>Verna</last_name>
        <affiliation>EPITA / LRDE</affiliation>
        <bio>Dr. Didier Verna has a Ph.D. in Computer Science and is currently working as an assistant professor for EPITA, a private Computer Science university located in Paris. He gives or has given lectures on Operating Systems, Computer Graphics, Object-Oriented, Functional Programming and Typesetting. His main research interests are multi-paradigm approaches to genericity and performance.
Didier Verna is the president of the European Lisp Symposium steering committee and serves as a program committee member in various conferences (International Lisp Conference, European Lisp Symposium, Dynamic Languages Symposium, ACM Symposium on Applied Computing, Context-Oriented Programming workshop etc. ).
Didier Verna is also quite involved in free software: he was one of the core maintainers of XEmacs for more than 15 years, a contributor to Gnus and BBDB, and an occasional contributor to other Free Software projects (the GNU Autotools most notably; he was one of the technical reviewers for the “Goat Book”). He is the author of several LaTeX packages and Common Lisp libraries.
All of this is in fact half-true: two days a week, Didier Verna drops his scientific hat and wears the semi-professional Jazz musician one instead. He also is a certified Aikido teacher, and gives coaching sessions on the theme “Aikido and Conflict Management” for large companies.</bio>
        <homepage_url>https://www.lrde.epita.fr/~didier</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/didierverna/854d6aef-85b1-4d6e-a0e3-fa0dc86e3927/small.jpg</picture_url>
        <person_id>didierverna</person_id>
      </person>
      <person>
        <role>Local Arrangements Chair in Organizing Committee</role>
        <sort_key>6</sort_key>
        <first_name>Ravi</first_name>
        <last_name>Chugh</last_name>
        <affiliation>University of Chicago</affiliation>
        <bio>I am an Assistant Professor at the University of Chicago. I enjoy developing and deploying programming language technology — type systems, synthesis algorithms, and other program analysis techniques — for applications in software engineering and human-computer interaction.</bio>
        <homepage_url>http://people.cs.uchicago.edu/~rchugh</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/ravichugh/ea931b20-b1e1-4e07-b209-ba0b568e315d/small.jpg</picture_url>
        <person_id>ravichugh</person_id>
      </person>
      <person>
        <role>Rebase Co-chair in Organizing Committee</role>
        <sort_key>7</sort_key>
        <first_name>Satish</first_name>
        <last_name>Chandra</last_name>
        <affiliation>Facebook, USA</affiliation>
        <bio>Satish Chandra obtained a PhD from the University of Wisconsin-Madison in 1997, and a B.Tech from the Indian Institute of Technology-Kanpur in 1991, both in computer science. From 1997 to 2002, he was a member of technical staff at Bell Laboratories, where his research focused on program analysis, domain-specific languages, and data-communication protocols. From 2002 to 2013, he was a research staff member at IBM Research, where his research focused on bug finding and verification, software synthesis, and test automation. His work on bug finding shipped in IBM’s Java static analysis product, and his work on test automation was adopted in IBM’s testing services offering. From 2013 to 2016, he worked at Samsung Research America, where he led the advanced programming tools research team. His work on memory profiling of web apps was included in Samsung’s Tizen IDE. In 2016, he started working at Facebook. He is an ACM Distinguished Scientist.</bio>
        <homepage_url>https://sites.google.com/site/schandraacmorg/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/satishchandra/6f67adc9-cd3d-4d0b-ad13-5bb13fd21834/small.jpg</picture_url>
        <person_id>satishchandra</person_id>
      </person>
      <person>
        <role>Rebase Co-chair in Organizing Committee</role>
        <sort_key>8</sort_key>
        <first_name>Yu David</first_name>
        <last_name>Liu</last_name>
        <affiliation>State University of New York (SUNY) Binghamton</affiliation>
        <bio>I am a Professor at State University of New York (SUNY) at Binghamton. I am interested in programming languages, computer systems, and software engineering. My current research focuses are energy-aware programming languages, data-intensive software, programming unmanned aerial vehicles, and type systems. I received my Ph.D. in Computer Science from the Johns Hopkins University, in 2007.</bio>
        <homepage_url>http://www.cs.binghamton.edu/~davidl</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/yudavidliu/1da5367f-6c86-4df7-859d-ca63bc2a178b/small.jpg</picture_url>
        <person_id>yudavidliu</person_id>
      </person>
      <person>
        <role>PLMW Co-Chair in Organizing Committee</role>
        <sort_key>9</sort_key>
        <first_name>Karim</first_name>
        <last_name>Ali</last_name>
        <affiliation>University of Alberta</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://karimali.ca</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/karimali/460ecc0b-764d-462b-a93e-66a3270d72ef/small.jpg</picture_url>
        <person_id>karimali</person_id>
      </person>
      <person>
        <role>PLMW Co-Chair in Organizing Committee</role>
        <sort_key>10</sort_key>
        <first_name>Jonathan</first_name>
        <last_name>Bell</last_name>
        <affiliation>Northeastern University</affiliation>
        <bio>Jon is an Assistant Professor directing research in Software Engineering and Software Systems at Northeastern University. His research makes it easier for developers to create reliable and secure software by improving software testing and program analysis. Jon’s work on accelerating software testing has been recognized with an ACM SIGSOFT Distinguished Paper Award (ICSE ’14 – Unit Test Virtualization with VMVM), and was the basis for an industrial collaboration with Electric Cloud. His program analysis research has resulted in several widely adopted runtime systems for the JVM, including the Phosphor taint tracking system (OOPSLA ’14) and CROCHET checkpoint/rollback tool (ECOOP ’18). His research has been funded by the NSA and the NSF, and he is the recipient of the NSF CAREER award. At George Mason, Jon taught courses in distributed systems, web development, and program analysis. His teaching at GMU has been recognized with a departmental award. Jon serves on a variety of program committees and was recently co-chair of the PLDI 2020 Artifact Evaluation Committee. As part of his efforts to broaden the participation of underrepresented groups in computing, Jon co-organizes the PL/SE mentoring workshop at SPLASH (in 2017, 2018, 2019 and 2020).</bio>
        <homepage_url>http://jonbell.net/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/jonathanbell/1ef3641d-0ed6-4021-aab6-b13b53962e3d/small.jpg</picture_url>
        <person_id>jonathanbell</person_id>
      </person>
      <person>
        <role>PLMW Co-Chair in Organizing Committee</role>
        <sort_key>11</sort_key>
        <first_name>Malavika</first_name>
        <last_name>Samak</last_name>
        <affiliation>CSAIL, MIT</affiliation>
        <bio>I am a Postdoctoral Associate working at CSAIL, MIT. I received my PhD from the Department of Computer Science and Automation, IISc Bangalore and was supported by a Google India PhD fellowship. For my doctoral dissertation, I designed and implemented techniques to address the problem of automatically synthesizing clients for detecting concurrency bugs in multithreaded libraries. My research interests are in software engineering and programming languages.</bio>
        <homepage_url>https://sites.google.com/site/malavikasamak/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/malavikasamak/ce059484-133f-4009-8f2d-de4df3abb83f/small.jpg</picture_url>
        <person_id>malavikasamak</person_id>
      </person>
      <person>
        <role>Workshops Co-Chair in Organizing Committee</role>
        <sort_key>12</sort_key>
        <first_name>Mehdi</first_name>
        <last_name>Bagherzadeh</last_name>
        <affiliation>Oakland University</affiliation>
        <bio>Assistant Professor, Department of Computer Science and Engineering</bio>
        <homepage_url>https://mbagherz.bitbucket.io/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/mehdibagherzadeh/95dc6f53-51a0-4bf1-b822-7bbe8c4d223a/small.jpg</picture_url>
        <person_id>mehdibagherzadeh</person_id>
      </person>
      <person>
        <role>Workshops Co-Chair in Organizing Committee</role>
        <sort_key>13</sort_key>
        <first_name>Neville</first_name>
        <last_name>Grech</last_name>
        <affiliation>University of Athens, Greece</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.nevillegrech.com</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/nevillegrech/e0405613-3240-4ef2-a51f-cb7536870dc5/small.jpg</picture_url>
        <person_id>nevillegrech</person_id>
      </person>
      <person>
        <role>Workshops Co-Chair in Organizing Committee</role>
        <sort_key>14</sort_key>
        <first_name>Ali</first_name>
        <last_name>Jannesari</last_name>
        <affiliation>Iowa State University</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://www.eecs.berkeley.edu/~jannesari/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/alijannesari/bc7c4a53-b541-49d8-a2c3-04e4a5f18047/small.jpg</picture_url>
        <person_id>alijannesari</person_id>
      </person>
      <person>
        <role>Student Research Competition Co-Chair in Organizing Committee</role>
        <sort_key>15</sort_key>
        <first_name>Sasa</first_name>
        <last_name>Misailovic</last_name>
        <affiliation>University of Illinois at Urbana-Champaign</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://misailo.cs.illinois.edu/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/sasamisailovic/6e3299c7-e0f5-4e78-a5f3-7ea49e488545/small.jpg</picture_url>
        <person_id>sasamisailovic</person_id>
      </person>
      <person>
        <role>Student Research Competition Co-Chair in Organizing Committee</role>
        <sort_key>16</sort_key>
        <first_name>Julia</first_name>
        <last_name>Rubin</last_name>
        <affiliation>University of British Columbia, Canada</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.ece.ubc.ca/~mjulia/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/juliarubin/5846079d-0c90-4d9a-8f16-eef07002e37d/small.jpg</picture_url>
        <person_id>juliarubin</person_id>
      </person>
      <person>
        <role>Publicity Chair in Organizing Committee</role>
        <sort_key>17</sort_key>
        <first_name>Hitesh</first_name>
        <last_name>Sajnani</last_name>
        <affiliation>Microsoft </affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.ics.uci.edu/~hsajnani/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/hiteshsajnani/01055225-912e-4ea5-865b-e5e0e01767c2/small.jpg</picture_url>
        <person_id>hiteshsajnani</person_id>
      </person>
      <person>
        <role>Web Chair in Organizing Committee</role>
        <sort_key>18</sort_key>
        <first_name>Rangeet</first_name>
        <last_name>Pan</last_name>
        <affiliation>Iowa State University, USA</affiliation>
        <bio>Rangeet Pan is a Ph.D. student at Iowa State University. His research interests include program analysis, machine learning, and software engineering. He has published works at ESEC/FSE and ICSE.</bio>
        <homepage_url>https://rangeetpanisu.web.app/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/rangeetpan/3f0551cd-7e73-4053-bb36-66f8d05daae5/small.jpg</picture_url>
        <person_id>rangeetpan</person_id>
      </person>
      <person>
        <role>Student Volunteer Co-Chair in Organizing Committee</role>
        <sort_key>19</sort_key>
        <first_name>Robert</first_name>
        <last_name>Dyer</last_name>
        <affiliation>University of Nebraska - Lincoln</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://go.unl.edu/rdyer</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/robertdyer/774d6fd8-9a08-4c37-9113-f0bc0c5fb833/small.jpg</picture_url>
        <person_id>robertdyer</person_id>
      </person>
      <person>
        <role>Student Volunteer Co-Chair in Organizing Committee</role>
        <sort_key>20</sort_key>
        <first_name>Samantha Syeda</first_name>
        <last_name>Khairunnesa</last_name>
        <affiliation>Iowa State University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://web.cs.iastate.edu/~sammy/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/samanthasyedakhairunnesa/23aa8334-ebf0-4967-b8ab-6d4cbf1509c5/small.jpg</picture_url>
        <person_id>samanthasyedakhairunnesa</person_id>
      </person>
      <person>
        <role>Sponsorship Chair in Organizing Committee</role>
        <sort_key>21</sort_key>
        <first_name>Ganesha</first_name>
        <last_name>Upadhyaya</last_name>
        <affiliation>Harmony.one</affiliation>
        <bio>I am currently a Research Engineer at Harmony.one, Mountain View, CA. I work on blockchain network, protocol, and smart contract verification. Previously, I was a Senior Staff Researcher at Futurewei Technologies (Huawei R&amp;amp;D), Champaign, IL, where I worked on researching and developing compiler, runtime, and frameworks for Huawei’s mobile, cloud, and IoT solutions. In addition, impactful software engineering research has always been my passion.</bio>
        <homepage_url>http://web.cs.iastate.edu/~ganeshau/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/ganeshaupadhyaya/e4cda76a-77e7-4064-a67e-a85da0616702/small.jpg</picture_url>
        <person_id>ganeshaupadhyaya</person_id>
      </person>
      <person>
        <role>Poster Co-Chair in Organizing Committee</role>
        <sort_key>22</sort_key>
        <first_name>Christos</first_name>
        <last_name>Dimoulas</last_name>
        <affiliation>PLT @ Northwestern University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://users.eecs.northwestern.edu/~chrdimo/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/christosdimoulas1/b0a0a408-c992-49cf-99f4-39e30fe9ce1d/small.jpg</picture_url>
        <person_id>christosdimoulas1</person_id>
      </person>
      <person>
        <role>Poster Co-Chair in Organizing Committee</role>
        <sort_key>23</sort_key>
        <first_name>Murali</first_name>
        <last_name>Krishna Ramanathan</last_name>
        <affiliation>Uber Technologies Inc.</affiliation>
        <bio>Murali Krishna Ramanathan is a Programming Systems Research Scientist at Uber Technologies Inc. Previously, he was affiliated with IISc, Bangalore and Coverity Inc. He has designed and implemented several novel program analysis tools for detecting software bugs. He received his PhD in Computer Science from Purdue University.</bio>
        <homepage_url>https://sites.google.com/view/mkramanathan/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/muralikrishnaramanathan/52304999-046a-4d35-a2ed-9eb9ca2db709/small.jpg</picture_url>
        <person_id>muralikrishnaramanathan</person_id>
      </person>
      <person>
        <role>Publications Chair in Organizing Committee</role>
        <sort_key>24</sort_key>
        <first_name>Saba</first_name>
        <last_name>Alimadadi</last_name>
        <affiliation>Simon Fraser University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://ece.ubc.ca/~saba/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/sabaalimadadi/fb15cf5f-b2f9-4ff5-84d1-1b5aa9be2378/small.jpg</picture_url>
        <person_id>sabaalimadadi</person_id>
      </person>
      <person>
        <role>SPLASH-E Co-Chair in Organizing Committee</role>
        <sort_key>25</sort_key>
        <first_name>Elisa</first_name>
        <last_name>Baniassad</last_name>
        <affiliation>University of British Columbia</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.ubc.ca/~ebani</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/elisabaniassad/ebb453ca-88ce-4678-823e-82b113c14751/small.jpg</picture_url>
        <person_id>elisabaniassad</person_id>
      </person>
      <person>
        <role>SPLASH-E Co-Chair in Organizing Committee</role>
        <sort_key>26</sort_key>
        <first_name>Charlie</first_name>
        <last_name>Curtsinger</last_name>
        <affiliation>Grinnell College</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://ccurtsinger.net</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/charliecurtsinger/e779a4c9-ade3-4073-b660-866046d6c953/small.jpg</picture_url>
        <person_id>charliecurtsinger</person_id>
      </person>
      <person>
        <role>Artifact Evaluation Chair in Organizing Committee</role>
        <sort_key>27</sort_key>
        <first_name>Colin</first_name>
        <last_name>Gordon</last_name>
        <affiliation>Drexel University</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://cs.drexel.edu/~csgordon/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/colingordon/d990db47-1ece-4016-bce5-b764428bd0ee/small.jpg</picture_url>
        <person_id>colingordon</person_id>
      </person>
      <person>
        <role>Artifact Evaluation Chair in Organizing Committee</role>
        <sort_key>28</sort_key>
        <first_name>Anders</first_name>
        <last_name>Møller</last_name>
        <affiliation>Aarhus University</affiliation>
        <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
        <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
        <person_id>andersmoller</person_id>
      </person>
      <person>
        <role>Accessibility Chair in Organizing Committee</role>
        <sort_key>29</sort_key>
        <first_name>Henrique</first_name>
        <last_name>Rebelo</last_name>
        <affiliation>Universidade Federal de Pernambuco</affiliation>
        <bio>My chief [and long-term] research interest is at improving the productivity of programmers by enabling them to write programs that, as much as possible, look like their design [and design constraints]. I believe that programs that clearly capture the design structure and interfaces they implement are more configurable, fun to develop and easier to maintain.
In pursuit of this goal, my research has been focused in programming language design and implementation, including software engineering, tools and related issues.
I have worked massively in the area of design by contract (DbC) and aspect-oriented programming (AOP). In the former, I have contributed extensively to the implementation of the JML specification language and its [RAC] compiler. In the latter, more recently, I’m excited to have started the next generation of aspect-oriented programming, as outlined in my SBLP 2017 talk. In this context, I’m leading the development of aspect-oriented programming reloaded project, which includes the AspectJML programming language and its Online IDE. AspectJML is [now] a general-purpose aspect-oriented extension to Java. It supports programming in Java, JML, AspectJ, AspectJML, or a mixin of all that. Hence, some of my current research in the Software Productivity Group is AOP[Reloaded]/AspectJML related.</bio>
        <homepage_url>http://www.cin.ufpe.br/~hemr</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/henriquerebelo/a08e4c59-858e-41a6-aba3-e751248dd721/small.jpg</picture_url>
        <person_id>henriquerebelo</person_id>
      </person>
      <person>
        <role>Accessibility Chair in Organizing Committee</role>
        <sort_key>30</sort_key>
        <first_name>Sumon</first_name>
        <last_name>Biswas</last_name>
        <affiliation>Iowa State University, USA</affiliation>
        <bio>Sumon Biswas is a Ph.D. student of Computer&amp;nbsp;Science department at Iowa State University and Research Assistant at Laboratory of Software Design at ISU under the supervision of Hridesh Rajan. His research interests are in the blend of Data Science, Software Engineering, and Program Analysis. He has worked on large scale data science program analysis using the Boa framework. He worked on building Python language support for Boa to analyze machine learning programs.&amp;nbsp;Currently, he is&amp;nbsp;working in the&amp;nbsp;D4 (Dependable Data-Driven Discovery) project and focusing on increasing the dependability of data-driven software. Specifically, he is conducting research on improving the fairness of machine learning models.</bio>
        <homepage_url>http://www.cs.iastate.edu/~sumon/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/sumonbiswas/1f6429a0-dded-4481-9f4f-ba26909d837d/small.jpg</picture_url>
        <person_id>sumonbiswas</person_id>
      </person>
      <person>
        <role>AV Co-Chair in Organizing Committee</role>
        <sort_key>31</sort_key>
        <first_name>Benjamin</first_name>
        <last_name>Chung</last_name>
        <affiliation>Northeastern University</affiliation>
        <bio>undefined</bio>
        <picture_url>https://2020.splashcon.org/getProfileImage/benjaminchung/30978af0-bcee-4c1e-9dd1-f2588ea14f38/small.jpg</picture_url>
        <person_id>benjaminchung</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>32</sort_key>
        <first_name>Jonathan</first_name>
        <last_name>Aldrich</last_name>
        <affiliation>Carnegie Mellon University</affiliation>
        <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech.
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
        <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
        <person_id>jonathanaldrich</person_id>
      </person>
      <person>
        <role>Doctoral Symposium Co-Chair in Organizing Committee</role>
        <sort_key>33</sort_key>
        <first_name>Yvonne</first_name>
        <last_name>Coady</last_name>
        <affiliation>University of Victoria</affiliation>
        <bio>undefined</bio>
        <picture_url>https://2020.splashcon.org/getProfileImage/yvonnecoady/7b532c8e-0c31-445d-b943-ad956a6f5722/small.jpg</picture_url>
        <person_id>yvonnecoady</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>34</sort_key>
        <first_name>Elisa</first_name>
        <last_name>Gonzalez Boix</last_name>
        <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://soft.vub.ac.be/~egonzale</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/elisagonzalezboix/8e8a61c4-366e-49b5-a861-7dfbc98ee129/small.jpg</picture_url>
        <person_id>elisagonzalezboix</person_id>
      </person>
      <person>
        <role>Doctoral Symposium Co-Chair in Organizing Committee</role>
        <sort_key>35</sort_key>
        <first_name>Matthias</first_name>
        <last_name>Hauswirth</last_name>
        <affiliation>Università della Svizzera italiana</affiliation>
        <bio>I am an Associate-Professor at the USI (Università della Svizzera italiana) in Lugano, Switzerland.
At USI I am heading Luce, the Lugano Computing Education research lab (http://luce.inf.usi.ch/) where we study how people learn to program and how to improve that learning process. I am a member of the program committee of the Swiss national program to train existing high school teachers to teach the new mandatory informatics course (https://www3.unifr.ch/gyminf/) and I am co-directing a similar state-wide program in Ticino.
As part of my lab’s work on conceptual change in learning to program, we contribute to the growing repository of programming misconceptions at (https://progmiscon.org). Amongst other things, that repository maps misconceptions to features of specific programming languages, with links to the corresponding sections of the official language specifications.</bio>
        <homepage_url>http://www.inf.usi.ch/faculty/hauswirth/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/matthiashauswirth/2f29d37f-4c84-49d3-a27d-7e3909177c4c/small.jpg</picture_url>
        <person_id>matthiashauswirth</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>36</sort_key>
        <first_name>Hidehiko</first_name>
        <last_name>Masuhara</last_name>
        <affiliation>Tokyo Institute of Technology</affiliation>
        <bio>Hidehiko Masuhara is a Professor of Mathematical and Computing Science, Tokyo Institute of Technology since April 2013. He received his B.S., M.S., and Ph.D. in Computer Science from Department of Information Science, University of Tokyo in 1992, 1994, and 1999, respectively, and served as an assistant professor, lecturer, and associate professor at Graphics and Computer Science, Graduate School of Arts and Sciences, University of Tokyo from 1995 until 2013.</bio>
        <homepage_url>http://prg.is.titech.ac.jp/people/masuhara/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/hidehikomasuhara/3ea94269-6fb5-4c6d-8d6f-0435717377d6/small.jpg</picture_url>
        <person_id>hidehikomasuhara</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>37</sort_key>
        <first_name>Gail</first_name>
        <last_name>Murphy</last_name>
        <affiliation>University of British Columbia</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://blogs.ubc.ca/gailcmurphy/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/gailmurphy/73d0b02f-de45-4e07-83cc-8b24f293ff8a/small.jpg</picture_url>
        <person_id>gailmurphy</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>38</sort_key>
        <first_name>Jens</first_name>
        <last_name>Palsberg</last_name>
        <affiliation>University of California, Los Angeles</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.ucla.edu/~palsberg</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/jenspalsberg/9e470c6a-532d-472c-9fea-253b7fa22c7c/small.jpg</picture_url>
        <person_id>jenspalsberg</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>39</sort_key>
        <first_name>Benjamin C.</first_name>
        <last_name>Pierce</last_name>
        <affiliation>University of Pennsylvania</affiliation>
        <bio>Benjamin Pierce is Henry Salvatori Professor of Computer and Information Science at the University of Pennsylvania and a Fellow of the ACM. His research interests include programming languages, type systems, language-based security, computer-assisted formal verification, differential privacy, and synchronization technologies. He is the author of the widely used graduate textbooks Types and Programming Languages and Software Foundations. He has served as co-Editor in Chief of the Journal of Functional Programming, as Managing Editor for Logical Methods in Computer Science, and as editorial board member of Mathematical Structures in Computer Science, Formal Aspects of Computing, and ACM Transactions on Programming Languages and Systems. He is also the lead designer of the popular Unison file synchronizer and co-developer of the Clowdr virtual conference platform.</bio>
        <homepage_url>http://www.cis.upenn.edu/~bcpierce/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/benjamincpierce/f2ee6f41-5bf7-4a0d-9b8d-71de6a666b1b/small.jpg</picture_url>
        <person_id>benjamincpierce</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>40</sort_key>
        <first_name>Yannis</first_name>
        <last_name>Smaragdakis</last_name>
        <affiliation>University of Athens, Greece</affiliation>
        <bio>Research Interests: programming languages and software engineering

 Program analysis (static analysis, test generation, invariant inference, symbolic execution)
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming)
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality)
        </bio>
        <homepage_url>http://smaragd.org/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
        <person_id>yannissmaragdakis</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>41</sort_key>
        <first_name>Manu</first_name>
        <last_name>Sridharan</last_name>
        <affiliation>University of California Riverside</affiliation>
        <bio>I work on developing tools and techniques to make large-scale software more reliable, performant, secure, and maintainable. For more details, see my homepage.</bio>
        <homepage_url>http://manu.sridharan.net</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/manusridharan/00859147-2155-45a9-9a48-7565ce5356ac/small.jpg</picture_url>
        <person_id>manusridharan</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>42</sort_key>
        <first_name>Emina</first_name>
        <last_name>Torlak</last_name>
        <affiliation>University of Washington</affiliation>
        <bio>Emina Torlak is an Associate Professor at the University of Washington, working at the intersection of programming languages, formal methods, and software engineering. She received her Bachelors (2003), Masters (2004), and Ph.D. (2009) degrees from MIT, and subsequently worked at IBM Research, LogicBlox, and as a research scientist at U.C. Berkeley. Her research focuses on developing automated tools and programming models for computer-aided design, verification, and synthesis of software. She is the creator of the Kodkod constraint solver, which has been used in over 70 academic and industrial tools for software engineering. Emina has applied her expertise to a broad range of problems, from verification of memory-consistency models to generation of test data for decision support applications. Her current work on the Rosette solver-aided language integrates constraint solvers into programming languages to support computer-aided verification, debugging, and synthesis of code, making programming a collaboration between humans and machines.</bio>
        <homepage_url>https://homes.cs.washington.edu/~emina/index.html</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/eminatorlak/b48dd8a1-4bf6-4d29-b6e3-fb0e9ea9ce8e/small.jpg</picture_url>
        <person_id>eminatorlak</person_id>
      </person>
      <person>
        <role>Virtualization Co-Chair in Organizing Committee, Committee Member in Steering Committee</role>
        <sort_key>43</sort_key>
        <first_name>Jan</first_name>
        <last_name>Vitek</last_name>
        <affiliation>Northeastern University</affiliation>
        <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
        <homepage_url>http://janvitek.org</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
        <person_id>janvitek</person_id>
      </person>
      <person>
        <role>Virtualization Co-Chair in Organizing Committee</role>
        <sort_key>44</sort_key>
        <first_name>Steve</first_name>
        <last_name>Blackburn</last_name>
        <affiliation>Australian National University</affiliation>
        <bio>My research interests are centered on the challenge of making software run faster and more power-efficiently on modern hardware. My primary interests include: microarchitectural support for managed languages, fast and efficient garbage collection, and the design and implementation of virtual machines. As a backdrop to this I have a longstanding interest in role of sound methodology and infrastructure in successful research innovation.</bio>
        <homepage_url>http://users.cecs.anu.edu.au/~steveb/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/steveblackburn/1deee732-405d-4403-a974-a418751399c2/small.jpg</picture_url>
        <person_id>steveblackburn</person_id>
      </person>
      <person>
        <role>Virtualization Co-Chair in Organizing Committee</role>
        <sort_key>45</sort_key>
        <first_name>Alex</first_name>
        <last_name>Potanin</last_name>
        <affiliation>Victoria University of Wellington</affiliation>
        <bio>I am an Associate Professor in the School of Engineering and Computer Science at Victoria University of Wellington, New Zealand.
I am originally from Moscow, Russia with a background in Mathematics. I have completed my PhD in programming languages in 2006 and took up a job as a Lecturer in Software Engineering at Victoria University of Wellington. During my studies, I took short breaks to work as a Visiting Researcher at Purdue University, and Software Engineer at two Wellington start-ups. I spent 2013 on sabbatical at Carnegie Mellon University in Pittsburgh, PA, USA. I spent winter 2019/2020 on sabbatical at Kyoto University in Japan.</bio>
        <homepage_url>http://homepages.ecs.vuw.ac.nz/~alex/</homepage_url>
        <picture_url>https://2020.splashcon.org/getProfileImage/alexpotanin/614f887b-90a3-4626-b67d-fa63309b44c8/small.jpg</picture_url>
        <person_id>alexpotanin</person_id>
      </person>
    </persons>
  </event_details>
  <subevent>
    <subevent_id>a230b722-cd7c-4562-95b5-983ebd19a315</subevent_id>
    <title>SPLASH Opening: Opening Session</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-opening</url>
    <url_link_display>Opening</url_link_display>
    <tracks>
      <track>Opening</track>
    </tracks>
    <timeslot>
      <slot_id>3b848cda-7fa8-4d77-8660-6f54fbd15346</slot_id>
      <title>Session: SPLASH Opening - Opening Session</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>19:00</start_time>
      <end_time>19:20</end_time>
      <tracks>
        <track>Opening</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>18639678-bac3-4f14-a1a2-51544f55e4c8</slot_id>
      <event_id>e341c0d1-a77b-4aa1-ae9b-83ec123e28da</event_id>
      <title>Opening Session</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>19:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>Opening</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d78113ab-97dd-41c1-83b0-8677be8860aa</subevent_id>
    <title>SPLASH Closing: Dinner in Delhi</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-closing</url>
    <url_link_display>Closing</url_link_display>
    <tracks>
      <track>Closing</track>
    </tracks>
    <timeslot>
      <slot_id>930a0b81-bb59-4105-b54f-1a37d3eb3268</slot_id>
      <title>Session: SPLASH Closing - Dinner in Delhi</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>06:20</start_time>
      <end_time>07:00</end_time>
      <tracks>
        <track>Closing</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4bc13b93-9dd7-46b8-be83-4405227d3e22</slot_id>
      <event_id>92603177-a865-4385-bf31-8163713f6a01</event_id>
      <title>Closing Session</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>06:20</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>07:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Closing</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>52106b2a-4ab0-4edb-bd8e-fb7fa00874c2</subevent_id>
    <title>SPLASH Awards: Cocktails in New York</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-awards</url>
    <url_link_display>Awards</url_link_display>
    <tracks>
      <track>Awards</track>
    </tracks>
    <timeslot>
      <slot_id>623d4907-f0dd-4269-89ca-2599df741a21</slot_id>
      <title>Session: SPLASH Awards - Cocktails in New York</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>20:20</start_time>
      <end_time>21:00</end_time>
      <tracks>
        <track>Awards</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bf6c01df-5131-4de1-b096-18b058028feb</slot_id>
      <event_id>c0fd419e-0940-4fad-8e84-7f72a9339b79</event_id>
      <title>Awards Session</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>21:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Awards</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5ed1c620-e47a-420b-8a1a-1e1367eba0fb</subevent_id>
    <title>SPLASH Closing: Cocktails in Rio</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-closing</url>
    <url_link_display>Closing</url_link_display>
    <tracks>
      <track>Closing</track>
    </tracks>
    <timeslot>
      <slot_id>b3da7777-e280-4636-99dd-627ff7be211a</slot_id>
      <title>Session: SPLASH Closing - Cocktails in Rio</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>18:20</start_time>
      <end_time>19:00</end_time>
      <tracks>
        <track>Closing</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cc83c20a-0218-4712-a36e-0475125bca5d</slot_id>
      <event_id>92603177-a865-4385-bf31-8163713f6a01</event_id>
      <title>Closing Session</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>18:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Closing</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ecc5f801-3fb3-4129-8cfa-65f4bfcb2de0</subevent_id>
    <title>SPLASH Opening: Opening Session</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-opening</url>
    <url_link_display>Opening</url_link_display>
    <tracks>
      <track>Opening</track>
    </tracks>
    <timeslot>
      <slot_id>e0f57124-cf86-4a5e-b499-e1f5293a4dcb</slot_id>
      <title>Session: SPLASH Opening - Opening Session</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>07:00</start_time>
      <end_time>07:20</end_time>
      <tracks>
        <track>Opening</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>094be895-e53c-49f2-9aa0-4fc27aacf310</slot_id>
      <event_id>e341c0d1-a77b-4aa1-ae9b-83ec123e28da</event_id>
      <title>Opening Session</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>07:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>Opening</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4f01ad42-8c1d-4085-9af5-1e9c023e423f</subevent_id>
    <title>SPLASH Awards: Breakfast in Chicago</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-awards</url>
    <url_link_display>Awards</url_link_display>
    <tracks>
      <track>Awards</track>
    </tracks>
    <timeslot>
      <slot_id>9dd152e8-694a-4a4d-9f30-286d8606a6b6</slot_id>
      <title>Session: SPLASH Awards - Breakfast in Chicago</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>08:20</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>Awards</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2e95fb9c-7b37-433c-b8f4-4f324d5e9cdc</slot_id>
      <event_id>c0fd419e-0940-4fad-8e84-7f72a9339b79</event_id>
      <title>Awards Session</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>09:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Awards</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>34e939f5-5272-46b6-b6cf-d397c3fe31b1</subevent_id>
    <title>SPLASH Posters: Breakfast in Chicago</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot>
      <slot_id>ec350c6e-2734-4e9b-a6c2-da851f5a98e8</slot_id>
      <title>Session: SPLASH Posters - Breakfast in Chicago</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>08:00</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1c16fec3-2d9f-431a-9a2d-19eb55e3f889</slot_id>
      <event_id>b8f58045-ec84-4259-9cc4-e6b968d9b5d7</event_id>
      <title>Posters Session</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>08:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e2f1a7ee-178d-4983-8ba5-a27faf08e0bd</subevent_id>
    <title>SPLASH PLMW: Breakfast in Seattle (PLMW AMA)</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-PLMW</url>
    <url_link_display>PL Mentoring Workshop (PLMW)</url_link_display>
    <tracks>
      <track>PL Mentoring Workshop (PLMW)</track>
    </tracks>
    <timeslot>
      <slot_id>9b75d59c-eda3-4cd7-a155-d4ace3cfcfba</slot_id>
      <title>Session: SPLASH PLMW - Breakfast in Seattle (PLMW AMA)</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>10:20</start_time>
      <end_time>11:00</end_time>
      <tracks>
        <track>PL Mentoring Workshop (PLMW)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8f989f96-eb67-4548-bdc5-e89873244f71</slot_id>
      <event_id>8b95f21f-5136-4d54-bda4-beccb3419c21</event_id>
      <title>Ask Me Anything: Amal Ahmed</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>11:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Amal</first_name>
          <last_name>Ahmed</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/amal/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/amalahmed/301fd92b-d4ae-4998-8f6b-82cf081da653/small.jpg</picture_url>
          <person_id>amalahmed</person_id>
        </person>
      </persons>
      <tracks>
        <track>PL Mentoring Workshop (PLMW)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>37aa4d5f-b391-4a54-8516-78288c6660db</subevent_id>
    <title>SPLASH CARES: CARES</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-cares</url>
    <url_link_display>CARES</url_link_display>
    <tracks>
      <track>CARES</track>
    </tracks>
    <timeslot>
      <slot_id>7b3eb383-55b7-4219-87a8-86a8aa84a883</slot_id>
      <title>Session: SPLASH CARES - CARES</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>07:40</start_time>
      <end_time>08:20</end_time>
      <tracks>
        <track>CARES</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a1306d10-f5a6-4121-af88-6362911d880c</slot_id>
      <event_id>0cbcc236-94a2-4e98-ba56-8caba12a4fe1</event_id>
      <title>CARES Session</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>07:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>08:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>CARES</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>aa856e66-ab45-467f-985f-db44466251f8</subevent_id>
    <title>SPLASH CARES: CARES</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-cares</url>
    <url_link_display>CARES</url_link_display>
    <tracks>
      <track>CARES</track>
    </tracks>
    <timeslot>
      <slot_id>6aec9d7b-4b7f-4422-81e5-f81f46ef83b5</slot_id>
      <title>Session: SPLASH CARES - CARES</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>17:40</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>CARES</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8315a7ff-4907-48d1-885b-6f465dace393</slot_id>
      <event_id>16711022-670f-4545-8452-b2a55fb6a9bd</event_id>
      <title>CARES Session</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>17:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>18:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>CARES</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4f8f270a-5c80-4884-9a07-d2d8712fced2</subevent_id>
    <title>SPLASH PLMW: Breakfast in Wellington (PLMW AMA)</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-PLMW</url>
    <url_link_display>PL Mentoring Workshop (PLMW)</url_link_display>
    <tracks>
      <track>PL Mentoring Workshop (PLMW)</track>
    </tracks>
    <timeslot>
      <slot_id>83db2cc1-7427-44b9-ac5f-5bf15ba089ff</slot_id>
      <title>Session: SPLASH PLMW - Breakfast in Wellington (PLMW AMA)</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>12:20</start_time>
      <end_time>13:00</end_time>
      <tracks>
        <track>PL Mentoring Workshop (PLMW)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d95dd281-5dae-4e9a-b63b-267c829d4001</slot_id>
      <event_id>17cce97b-92ae-40a1-9368-bd7e69a0addf</event_id>
      <title>Ask Me Anything: Sriram Rajamani</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>13:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Sriram</first_name>
          <last_name>Rajamani</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Sriram Rajamani is Distinguished Scientist and Managing Director of Microsoft Research India. His research interests are in designing, building and analyzing computer systems in a principled manner. Over the years he has worked on various topics including Hardware and Software Verification, Type Systems, Language Design, Distributed Systems, Security and Privacy. His current research interest is in combining Program Synthesis and Machine Learning. Together with Tom Ball, he was awarded the CAV 2011 Award for “contributions to software model checking, specifically the development of the SLAM/SDV software model checker that successfully demonstrated computer-aided verification techniques on real programs.” Sriram was elected ACM Fellow in 2015 for contributions to software analysis and defect detection. Recently, Sriram has been elected Fellow of Indian National Academy of Engineering. Sriram has a PhD from UC Berkeley, MS from University of Virginia and BEng from College of Engineering, Guindy, all with specialization in Computer Science. Sriram was general chair for POPL 2015 in India, and was program Co-Chair for CAV 2005. He co-founded the Mysore Park Series, and the ISEC conference series in India. He serves on the CACM editorial board as co-chair for special regional sections, to bring computing innovations from around the world to CACM.</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/sriram/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sriramrajamani/85dbb2f3-41e7-493b-af72-d9a3338eea4e/small.jpg</picture_url>
          <person_id>sriramrajamani</person_id>
        </person>
      </persons>
      <tracks>
        <track>PL Mentoring Workshop (PLMW)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>57fc5662-6451-422d-9555-1d94c527b6cf</subevent_id>
    <title>SPLASH Posters: Cocktails in New York</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot>
      <slot_id>32e34ca8-de21-44cf-86cf-98a310a43ab2</slot_id>
      <title>Session: SPLASH Posters - Cocktails in New York</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>20:00</start_time>
      <end_time>21:00</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8873a58e-38b8-4b3f-9aab-5ded1177c9a7</slot_id>
      <event_id>b8f58045-ec84-4259-9cc4-e6b968d9b5d7</event_id>
      <title>Posters Session</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>20:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>248dc002-b6d1-44dc-b381-67ca8162ef0a</subevent_id>
    <title>SPLASH CARES: CARES</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-cares</url>
    <url_link_display>CARES</url_link_display>
    <tracks>
      <track>CARES</track>
    </tracks>
    <timeslot>
      <slot_id>2a772d09-5f18-49a3-b501-54826db33505</slot_id>
      <title>Session: SPLASH CARES - CARES</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>05:40</start_time>
      <end_time>06:20</end_time>
      <tracks>
        <track>CARES</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1cfab0c7-e4ad-40fb-af51-ac9865df4927</slot_id>
      <event_id>16711022-670f-4545-8452-b2a55fb6a9bd</event_id>
      <title>CARES Session</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>05:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>06:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>CARES</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>549be437-7fd3-4009-94d6-e11d91dff10a</subevent_id>
    <title>SPLASH Student Research Competition: Cocktails in New York</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-SRC</url>
    <url_link_display>Student Research Competition</url_link_display>
    <tracks>
      <track>Student Research Competition</track>
    </tracks>
    <timeslot>
      <slot_id>badcc3b3-97e4-463a-9412-d5497a9b5985</slot_id>
      <title>Session: SPLASH Student Research Competition - Cocktails in New York</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>20:20</start_time>
      <end_time>21:00</end_time>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5768473b-6b95-4de1-8a16-c222b7f37b83</slot_id>
      <event_id>f61bee32-c3d8-4485-b7f7-38b8d4e32e47</event_id>
      <title>Student Research Competition</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>21:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ca484429-765a-4fa5-970d-d241d20dbd0c</subevent_id>
    <title>SPLASH Posters: Lunch in Tokyo</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot>
      <slot_id>7ea9b925-486b-4a28-a1c7-13d8f917903d</slot_id>
      <title>Session: SPLASH Posters - Lunch in Tokyo</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>22:00</start_time>
      <end_time>23:00</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f44680e3-06df-4d82-bce7-c160916df2fb</slot_id>
      <event_id>0700fbef-2f1e-4f98-be1c-d77ca186fb7a</event_id>
      <title>Posters Session</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>22:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>713f6012-32c3-404b-be18-03a28e3a1d2b</subevent_id>
    <title>SPLASH PLMW: Lunch in Tokyo (PLMW AMA)</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-PLMW</url>
    <url_link_display>PL Mentoring Workshop (PLMW)</url_link_display>
    <tracks>
      <track>PL Mentoring Workshop (PLMW)</track>
    </tracks>
    <timeslot>
      <slot_id>69875270-4c91-4a03-b58c-80c57fadff7e</slot_id>
      <title>Session: SPLASH PLMW - Lunch in Tokyo (PLMW AMA)</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>22:20</start_time>
      <end_time>23:00</end_time>
      <tracks>
        <track>PL Mentoring Workshop (PLMW)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c4a0e097-0904-40b1-8c2d-904796905b57</slot_id>
      <event_id>8b95f21f-5136-4d54-bda4-beccb3419c21</event_id>
      <title>Ask Me Anything: Amal Ahmed</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>23:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Amal</first_name>
          <last_name>Ahmed</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/amal/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/amalahmed/301fd92b-d4ae-4998-8f6b-82cf081da653/small.jpg</picture_url>
          <person_id>amalahmed</person_id>
        </person>
      </persons>
      <tracks>
        <track>PL Mentoring Workshop (PLMW)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>28f21542-bfcb-4715-a6b5-1f9f298a71d9</subevent_id>
    <title>SPLASH PLMW: Breakfast in Paris (PLMW AMA)</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-PLMW</url>
    <url_link_display>PL Mentoring Workshop (PLMW)</url_link_display>
    <tracks>
      <track>PL Mentoring Workshop (PLMW)</track>
    </tracks>
    <timeslot>
      <slot_id>fd47df49-efcd-43a3-aaab-1d91daf74683</slot_id>
      <title>Session: SPLASH PLMW - Breakfast in Paris (PLMW AMA)</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>00:20</start_time>
      <end_time>01:00</end_time>
      <tracks>
        <track>PL Mentoring Workshop (PLMW)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ddc635b7-00a4-4656-b095-0e23a3539aaf</slot_id>
      <event_id>17cce97b-92ae-40a1-9368-bd7e69a0addf</event_id>
      <title>Ask Me Anything: Sriram Rajamani</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>01:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Sriram</first_name>
          <last_name>Rajamani</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Sriram Rajamani is Distinguished Scientist and Managing Director of Microsoft Research India. His research interests are in designing, building and analyzing computer systems in a principled manner. Over the years he has worked on various topics including Hardware and Software Verification, Type Systems, Language Design, Distributed Systems, Security and Privacy. His current research interest is in combining Program Synthesis and Machine Learning. Together with Tom Ball, he was awarded the CAV 2011 Award for “contributions to software model checking, specifically the development of the SLAM/SDV software model checker that successfully demonstrated computer-aided verification techniques on real programs.” Sriram was elected ACM Fellow in 2015 for contributions to software analysis and defect detection. Recently, Sriram has been elected Fellow of Indian National Academy of Engineering. Sriram has a PhD from UC Berkeley, MS from University of Virginia and BEng from College of Engineering, Guindy, all with specialization in Computer Science. Sriram was general chair for POPL 2015 in India, and was program Co-Chair for CAV 2005. He co-founded the Mysore Park Series, and the ISEC conference series in India. He serves on the CACM editorial board as co-chair for special regional sections, to bring computing innovations from around the world to CACM.</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/sriram/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sriramrajamani/85dbb2f3-41e7-493b-af72-d9a3338eea4e/small.jpg</picture_url>
          <person_id>sriramrajamani</person_id>
        </person>
      </persons>
      <tracks>
        <track>PL Mentoring Workshop (PLMW)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>df3ebcbc-8089-48d7-bffb-7bbba47fbaa1</subevent_id>
    <title>SPLASH Student Research Competition: Breakfast in Chicago</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-SRC</url>
    <url_link_display>Student Research Competition</url_link_display>
    <tracks>
      <track>Student Research Competition</track>
    </tracks>
    <timeslot>
      <slot_id>536cb29b-cc93-40c3-822e-a39a35c6e09c</slot_id>
      <title>Session: SPLASH Student Research Competition - Breakfast in Chicago</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>08:20</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3a81e4d5-6471-4832-a354-be75b5723c5b</slot_id>
      <event_id>a9e3d4ea-adaf-4e67-a431-fcf11578554b</event_id>
      <title>Student Research Competition</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>09:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>760301b3-d775-4558-8a5f-ee56cef5db76</subevent_id>
    <title>SPLASH CARES: CARES</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-cares</url>
    <url_link_display>CARES</url_link_display>
    <tracks>
      <track>CARES</track>
    </tracks>
    <timeslot>
      <slot_id>f2b5bde1-a6b3-44fa-9040-7f3f97a3eab6</slot_id>
      <title>Session: SPLASH CARES - CARES</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>19:40</start_time>
      <end_time>20:20</end_time>
      <tracks>
        <track>CARES</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>035df7fa-5556-4af1-ba71-116422fbe628</slot_id>
      <event_id>0cbcc236-94a2-4e98-ba56-8caba12a4fe1</event_id>
      <title>CARES Session</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>19:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>20:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>CARES</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>42b9230b-424c-40ec-8c81-1f548578c01a</subevent_id>
    <title>SPLASH Posters: Breakfast in Seattle</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot>
      <slot_id>b43c2194-38e8-407a-8965-de23900263b9</slot_id>
      <title>Session: SPLASH Posters - Breakfast in Seattle</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>10:00</start_time>
      <end_time>11:00</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cce6885f-b0f8-46e9-9096-ee3c0ad0d46f</slot_id>
      <event_id>0700fbef-2f1e-4f98-be1c-d77ca186fb7a</event_id>
      <title>Posters Session</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b57a9d65-8015-498c-b92b-bf681d32cadf</subevent_id>
    <title>SPLASH Student Research Competition: Cocktails in New York</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-SRC</url>
    <url_link_display>Student Research Competition</url_link_display>
    <tracks>
      <track>Student Research Competition</track>
    </tracks>
    <timeslot>
      <slot_id>880733c8-d6a2-4ffa-b107-584f1a586e5d</slot_id>
      <title>Session: SPLASH Student Research Competition - Cocktails in New York</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>20:20</start_time>
      <end_time>21:00</end_time>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e351d725-289e-46dd-8767-5becfd02ff37</slot_id>
      <event_id>a9e3d4ea-adaf-4e67-a431-fcf11578554b</event_id>
      <title>Student Research Competition</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>21:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8eb9db46-f46f-461b-beba-5cd98110a814</subevent_id>
    <title>SPLASH Student Research Competition: Breakfast in Chicago</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-SRC</url>
    <url_link_display>Student Research Competition</url_link_display>
    <tracks>
      <track>Student Research Competition</track>
    </tracks>
    <timeslot>
      <slot_id>86007b86-6881-4fde-8245-d39d9eb1ca4c</slot_id>
      <title>Session: SPLASH Student Research Competition - Breakfast in Chicago</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>08:20</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2dee0242-ffb2-4c55-a397-b4410ddc6a15</slot_id>
      <event_id>f61bee32-c3d8-4485-b7f7-38b8d4e32e47</event_id>
      <title>Student Research Competition</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>09:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>656d623f-d252-4a6e-9935-127c1c0a3a22</subevent_id>
    <title>SPLASH Onward! Papers: T-2-Onward</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
      <track>Onward! Essays</track>
    </tracks>
    <timeslot>
      <slot_id>7f0dd32e-839a-42b5-bc95-81efa9ab9abf</slot_id>
      <title>Session: SPLASH Onward! Papers - T-2-Onward</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>21:00</start_time>
      <end_time>22:20</end_time>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1ac2fe82-b842-434f-a4c2-67f8fbeae8cd</slot_id>
      <event_id>61a0b3ff-079e-4f32-b965-6212b38b01cc</event_id>
      <title>Discussion of Aviation Software Oversight Improvement</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>21:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>22:00</end_time>
      <description>The certification of US aviation software is described and critiqued. Flight critical software certification and regulation need external academic review and intervention. Industry is driven to generate profits over prioritizing concerns for public safety and has failed at developing adequately proven methods of certifying that flight critical software is safe to deploy.
Disclaimer: The opinions expressed in this work are the views of the author and do not reflect the official policy or position of any agency of the U.S. government.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marc</first_name>
          <last_name>Ronell</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>marcronell</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>65d0abdc-ac53-4a5d-a4d5-70740108fd5b</slot_id>
      <event_id>f5df0dfc-f912-43a8-ab3d-e57ff4e3846c</event_id>
      <title>A Case Study in Language-Based Security: Building an I/O Library for Wyvern</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>22:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>22:20</end_time>
      <description>As the impact of vulnerabilities increases in practice, it is imperative for programming languages to include security as a first-class design consideration. While a number of security-related language features have been proposed to address this need, in many cases, we do not know enough about whether it is practical and useful to build software systems in languages with these features.
In this paper, we begin to investigate this question, using a case study methodology. The setting of our case study is Wyvern, a recently designed language we selected because it incorporates three advanced security-related features: capability safety for enforcing the principle of least privilege, an effect system for tracking the secure use of resources, and a language extension feature that mitigates command injection. In our case study, we built a small standard I/O library, seeking to use the new language features to create a library that is less vulnerable to misuse and can serve as a building block for more secure programs, compared to conventional I/O library designs. Our study suggests that these features are indeed practicable and useful, and thus potentially promising for inclusion in other future language designs. It also sheds light on the value and cost of these features and suggests directions for future research on security-focused language design.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jennifer</first_name>
          <last_name>Fish</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>jenniferfish</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Darya</first_name>
          <last_name>Melicher</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://scholar.google.com/citations?user=KoIZBqwAAAAJ</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/daryamelicher/dd1aba2a-1ed3-43a6-ae6e-b9905a5a8bc2/small.jpg</picture_url>
          <person_id>daryamelicher</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech.
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>71ecd6c4-e3af-40a2-a2ae-32bf17e964d5</slot_id>
      <event_id>6cc1e9be-46b1-4962-9d3d-2920b847aea7</event_id>
      <title>Example-based Live Programming for Everyone: Building Language-agnostic Tools for Live Programming With LSP and GraalVM</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>21:20</end_time>
      <description>Our community has explored various approaches to improve the programming experience. Although many of them, such as Example-based Live Programming (ELP), have shown to be effective, they are still not widespread in conventional programming environments. A reason for that is the effort required to provide sophisticated tools that rely on run-time information. To target multiple language ecosystems, it is often necessary to implement the same concepts, but for different languages and runtimes. Two emerging technologies present an opportunity to reduce this effort significantly: the Language Server Protocol (LSP) and language implementation frameworks such as GraalVM’s Truffle. In this paper, we show how an ELP system can be built in a language-agnostic way by leveraging these two technologies. Based on our approach, we implemented the Babylonian Programming system, an ELP system that has previously only been implemented for exploratory ecosystems. Our system, on the other hand, brings ELP for all languages supported by the GraalVM to Visual Studio Code (VS Code). Moreover, we outline what a language-agnostic infrastructure needs to provide and how the LSP could be extended to support ELP also independently from programming environments. Further, we demonstrate how our approach enables the use of ELP in the context of polyglot programming. We illustrate the consequences of our approach by discussing its advantages and limitations and by comparing the features of our system to other ELP systems. Moreover, we give an outlook of how tools that rely on run-time information could be built in the future. This in turn might motivate future tool builders and researchers to consider implementing more tools in a language-agnostic way from the start to make them available to a broader audience.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fabio</first_name>
          <last_name>Niephaus</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://fniephaus.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/fabioniephaus/44d2c4cc-3f4f-42d2-8496-ca7e59905dd3/small.jpg</picture_url>
          <person_id>fabioniephaus</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Rein</last_name>
          <affiliation>Hasso Plattner Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.patrickrein.de</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/patrickrein/0538cdc6-52aa-408d-9042-80e24d2f8260/small.jpg</picture_url>
          <person_id>patrickrein</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jakob</first_name>
          <last_name>Edding</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>jakobedding</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jonas</first_name>
          <last_name>Hering</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>jonashering</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Bastian</first_name>
          <last_name>König</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>bastiankonig</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Kolya</first_name>
          <last_name>Opahle</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>kolyaopahle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Nico</first_name>
          <last_name>Scordialo</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>nicoscordialo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Robert</first_name>
          <last_name>Hirschfeld</last_name>
          <affiliation>Hasso-Plattner-Institut (HPI), Germany</affiliation>
          <bio>Robert Hirschfeld is a Professor of Computer Science at the Hasso Plattner Institute at the University of Potsdam, Germany. There he founded and leads the Software Architecture Group which is concerned with fundamental elements and structures of software. Methods and tools are developed for improving the comprehension and design of complex and interesting systems.
Robert is interested in programming experiences and small system kernels. With his group he is working on dynamic programming languages, development tools, and runtime environments to make interactive programming more approachable. His preferred environment for exploring ideas is Squeak/Smalltalk.
He served as a visiting professor at the Tokyo Institute of Technology (東京工業大学) and The University of Tokyo (東京大学), Japan.
Robert was a senior researcher with DoCoMo Euro-Labs, the European research facility of NTT DoCoMo Japan, where he worked on infrastructure components for next generation mobile communication systems with a focus on dynamic service adaptation and context-oriented programming.
Prior to joining DoCoMo Euro-Labs, he was a principal engineer at Windward Solutions in Sunnyvale, California, where he designed and implemented distributed object systems, consulted in the area of object database technologies, and developed innovative software products and applications.
Robert received a Ph.D. in Computer Science from the Ilmenau University of Technology, Germany.</bio>
          <homepage_url>http://www.hirschfeld.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/roberthirschfeld/994ef4df-a890-4f16-bc1b-73b117dab33c/small.jpg</picture_url>
          <person_id>roberthirschfeld</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a2e23d50-867d-44bb-914a-c709be7ed08b</slot_id>
      <event_id>71f0486c-4cb8-4129-bf78-31b62f01a30a</event_id>
      <title>End-User Software Customization by Direct Manipulation of Tabular Data</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>21:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>21:40</end_time>
      <description>Customizing software should be as easy as using it. But most customization methods require a dramatic shift from using a GUI to writing customization scripts in a programming language.
We introduce data-driven customization, a new way for end users to extend software by direct manipulation without doing traditional programming. We augment existing user interfaces with a table view showing the structured data inside the application. When users edit the table, their changes are reflected in the original UI. This simple model accommodates a spreadsheet formula language and custom data editing widgets, providing enough power to implement a variety of useful extensions.
We illustrate the approach with Wildcard, a browser extension that implements data-driven customization on the web using web scraping. Through concrete examples, we show that this paradigm can support useful extensions to many real websites, and we share reflections from our experiences using the tool.
Finally, we share our broader vision for data-driven customization: a future where end users have greater access to the data inside their applications, and better tools for flexibly making use of that data in the context of everyday software usage.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Geoffrey</first_name>
          <last_name>Litt</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>geoffreylitt1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Jackson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/dnj/</homepage_url>
          <person_id>danieljackson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Millis</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>tylermillis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jessica</first_name>
          <last_name>Quaye</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>jessicaquaye</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>999fdb4e-af41-43a7-9c20-6c1d9e7b3b4c</subevent_id>
    <title>SPLASH Onward! Papers: T-3-Onward</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
      <track>Onward! Essays</track>
    </tracks>
    <timeslot>
      <slot_id>76251e2e-e500-47ff-9ba5-1834f76fe27f</slot_id>
      <title>Session: SPLASH Onward! Papers - T-3-Onward</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2efe4521-aba0-47f1-978a-b4f2955701be</slot_id>
      <event_id>c7a92e3e-e35f-4c15-9cd3-ea11f7016ac0</event_id>
      <title>Putting the Semantics into Semantic Versioning</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>12:00</end_time>
      <description>The long-standing aspiration for software reuse has made astonishing strides in the past few years. Many modern software development ecosystems now come with rich sets of publicly-available components contributed by the community. Downstream developers can leverage these upstream components, boosting their productivity.
However, components evolve at their own pace. This imposes obligations on and yields benefits for downstream developers, especially since changes can be breaking, requiring additional downstream work to adapt to. Upgrading too late leaves downstream vulnerable to security issues and missing out on useful improvements; upgrading too early results in excess work. Semantic versioning has been proposed as an elegant mechanism to communicate levels of compatibility, enabling downstream developers to automate dependency upgrades. However, there is evidence suggesting that this approach faces problems, and is only slowly being adopted.
While it is questionable whether a version number can adequately characterize version compatibility in general, we argue that developers would greatly benefit from tools such as semantic version calculators to help them upgrade safely. The time is now for the research community to develop such tools: large component ecosystems exist and are accessible, component interactions have become observable through automated builds, and recent research advances in program analysis have made the development of relevant tools feasible. In particular, verified contracts (both traditional and lightweight) are a promising input to semantic versioning calculators, which can suggest whether an upgrade is likely to be safe.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jens</first_name>
          <last_name>Dietrich</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>I am an Associate Professor in the School of Engineering and Advanced Technology (SEAT) at the Turitea (Palmerston North) Campus of Massey University. I have a Master in Mathematics and a PhD in Computer Science from the University of Leipzig. I have worked for a couple of years in industry as consultant in Germany, Namibia, Switzerland and the UK, and returned in 2003 to academia. My research interests are in the areas of software componentry, evolution and static analysis.</bio>
          <homepage_url>https://ecs.wgtn.ac.nz/Main/JensDietrich</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jensdietrich/ab54c290-4f44-4d77-9842-cdc18922d7b4/small.jpg</picture_url>
          <person_id>jensdietrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Lam</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://patricklam.ca</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/patricklam/d94f6246-8d4e-4896-a263-379eb20a9b24/small.jpg</picture_url>
          <person_id>patricklam</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Pearce</last_name>
          <affiliation>Victoria University of Wellington, New Zealand</affiliation>
          <bio>David (@whileydave) graduated with a PhD from Imperial College London in 2005, and took up a lecturer position at Victoria University of Wellington, NZ. David’s PhD thesis was on efficient algorithms for pointer analysis of C, and his techniques have since been incorporated into GCC. His interests are in programming languages, compilers and static analysis.
Since 2009, he has been developing the Whiley Programming Language (whiley.org) which is designed specifically to simplify program verification. Prior to that, David developed the Java Compiler Kit (JKit), which is an open source Java Compiler aimed at simplifying static analysis.
David has previously interned at Bell Labs, New Jersey, where he worked on compilers for FPGAs; and also at IBM Hursely, UK, where he worked with the AspectJ development team on profiling systems.</bio>
          <homepage_url>http://homepages.ecs.vuw.ac.nz/~djp/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidpearce/22bf61c2-1912-4f75-a0a6-fc77ea16dd34/small.jpg</picture_url>
          <person_id>davidpearce</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>809ef1b3-44de-4c15-8ea6-4146d587913d</slot_id>
      <event_id>538dbb83-bda8-4f57-a308-5f47c726d7b8</event_id>
      <title>How (Not) To Write Java Pointer Analyses After 2020</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>11:20</end_time>
      <description>Despite being a very old discipline, pointer analysis still attracts several research papers every year in premier programming language venues. While a major goal of contemporary pointer analysis research is to improve its efficiency without sacrificing precision, we also see works that introduce novel ways of solving the problem itself. What does this mean? Research in this area is not going to die soon.
I too have been writing pointer analyses of various kinds, specially for object-oriented languages such as Java. While some standard ways of writing such analyses are clear, I have realized that there are an umpteen number of nooks and pitfalls that make the task difficult and error prone. In particular, there are several misconceptions and undocumented practices, being aware of which would save significant research time. On the other hand, there are lessons from my own research that might go a long way in writing correct, precise and efficient pointer analyses, faster. This paper summarizes some such learnings, with a hope to help readers beat the state-of-the-art in (Java) pointer analysis, as they move into their research careers beyond 2020.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manas</first_name>
          <last_name>Thakur</last_name>
          <affiliation>IIT Mandi</affiliation>
          <bio>Assistant Professor at Indian Institute of Technology Mandi, India.</bio>
          <homepage_url>https://manas.gitlab.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manasthakur/c8d83ff4-14f0-46ad-beb5-2e2a35b13ebf/small.jpg</picture_url>
          <person_id>manasthakur</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bf7b3639-5b9d-41ff-a7d8-5cab4ea5a91f</slot_id>
      <event_id>734f329a-291e-4cc1-aee1-a79175158f11</event_id>
      <title>The Wonderful Wizard of LoC: Paying Attention to the Man Behind the Curtain of Line-of-Code Metrics</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>11:40</end_time>
      <description>Lines-of-code metrics are commonly reported in PL, SE, and Systems papers. This convention has several different, often contradictory, goals, including demonstrating the “hardness” of a problem, and demonstrating the “easiness” of a problem. In many cases, the reporting of loc metrics is done not with a clearly communicated intention, but instead in an automatic, checkbox-ticking, manner.
In this paper we investigate the uses of code metrics in PL, SE, and System papers. We consider the different goals that reporting metrics aims to achieve, several various domains wherein metrics are relevant, and various alternative metrics and their pros and cons for the different goals and domains. We argue that communicating claims about research software is usually best achieved not by reporting quantitative metrics, but by reporting the qualitative experience of researchers, and propose guidelines for the cases when quantitative metrics are appropriate.
We end with a case study of the one area in which lines of code are not the default measurement—code produced by papers’ solutions—and identify how measurements offered are used to support an explicit claim about the algorithm. Inspired by this positive example, we call for other cogent measures to be developed to support other claims authors wish to make.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kalev</first_name>
          <last_name>Alpernas</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.tau.ac.il/~kalevalp/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/kalevalpernas/05430004-6682-4918-b6b0-8b3398cb9428/small.jpg</picture_url>
          <person_id>kalevalpernas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yotam</first_name>
          <last_name>Feldman</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/research/yotam.feldman/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yotamfeldman/ed864714-e66c-4ec1-a171-8c2ac69d62a1/small.jpg</picture_url>
          <person_id>yotamfeldman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ea928827-ea52-43b4-831b-fb0dfa3318a7</slot_id>
      <event_id>49dcbe04-cb78-487b-8021-c2b2cca6e30e</event_id>
      <title>Demystifying Dependence</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>12:20</end_time>
      <description>Programmers are told “depend on interfaces, not implementations.” But, given a program, is it possible even to assess objectively whether such advice has been followed?
Programmers frequently talk in ways like this about dependence, but the very term, like many used in software engineering, has hitherto eluded precise definition. In this work, we resolve a variety of confusions about dependence, and present a formal definition unifying multiple varieties of software dependence, grounded in Halpern and Pearl’s theory of actual causation. This definition is parameterized by the formal system characterizing the property of interest, and by constraints on “reasonable changes” to the program. By picking different choices of formal system, one can specialize our definition to characterize dynamic dependence (slicing), static dependence (correctness), and dependence of performance properties. Overall, our work provides a path to making conversations about software dependence fully objective, and might serve as a basis for future work automatically checking forms of dependence which were previously too abstract or high-level to be candidates for tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>James</first_name>
          <last_name>Koppel</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>www.jameskoppel.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jameskoppel/285bb202-88a1-4b77-bf13-bd39911247ef/small.jpg</picture_url>
          <person_id>jameskoppel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Jackson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/dnj/</homepage_url>
          <person_id>danieljackson</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>826f0c2f-a247-44cc-b223-b407a4f70172</subevent_id>
    <title>SPLASH Onward! Papers: T-3-Onward</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
      <track>Onward! Essays</track>
    </tracks>
    <timeslot>
      <slot_id>bf9c6f0b-e49d-4cd8-a336-e6199fe17af4</slot_id>
      <title>Session: SPLASH Onward! Papers - T-3-Onward</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1cf875f1-2f8c-4433-87e6-12e82682c447</slot_id>
      <event_id>49dcbe04-cb78-487b-8021-c2b2cca6e30e</event_id>
      <title>Demystifying Dependence</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>00:20</end_time>
      <description>Programmers are told “depend on interfaces, not implementations.” But, given a program, is it possible even to assess objectively whether such advice has been followed?
Programmers frequently talk in ways like this about dependence, but the very term, like many used in software engineering, has hitherto eluded precise definition. In this work, we resolve a variety of confusions about dependence, and present a formal definition unifying multiple varieties of software dependence, grounded in Halpern and Pearl’s theory of actual causation. This definition is parameterized by the formal system characterizing the property of interest, and by constraints on “reasonable changes” to the program. By picking different choices of formal system, one can specialize our definition to characterize dynamic dependence (slicing), static dependence (correctness), and dependence of performance properties. Overall, our work provides a path to making conversations about software dependence fully objective, and might serve as a basis for future work automatically checking forms of dependence which were previously too abstract or high-level to be candidates for tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>James</first_name>
          <last_name>Koppel</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>www.jameskoppel.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jameskoppel/285bb202-88a1-4b77-bf13-bd39911247ef/small.jpg</picture_url>
          <person_id>jameskoppel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Jackson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/dnj/</homepage_url>
          <person_id>danieljackson</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7cca4f99-750a-4e30-a8b8-a27293445775</slot_id>
      <event_id>538dbb83-bda8-4f57-a308-5f47c726d7b8</event_id>
      <title>How (Not) To Write Java Pointer Analyses After 2020</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>23:20</end_time>
      <description>Despite being a very old discipline, pointer analysis still attracts several research papers every year in premier programming language venues. While a major goal of contemporary pointer analysis research is to improve its efficiency without sacrificing precision, we also see works that introduce novel ways of solving the problem itself. What does this mean? Research in this area is not going to die soon.
I too have been writing pointer analyses of various kinds, specially for object-oriented languages such as Java. While some standard ways of writing such analyses are clear, I have realized that there are an umpteen number of nooks and pitfalls that make the task difficult and error prone. In particular, there are several misconceptions and undocumented practices, being aware of which would save significant research time. On the other hand, there are lessons from my own research that might go a long way in writing correct, precise and efficient pointer analyses, faster. This paper summarizes some such learnings, with a hope to help readers beat the state-of-the-art in (Java) pointer analysis, as they move into their research careers beyond 2020.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manas</first_name>
          <last_name>Thakur</last_name>
          <affiliation>IIT Mandi</affiliation>
          <bio>Assistant Professor at Indian Institute of Technology Mandi, India.</bio>
          <homepage_url>https://manas.gitlab.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manasthakur/c8d83ff4-14f0-46ad-beb5-2e2a35b13ebf/small.jpg</picture_url>
          <person_id>manasthakur</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c5b3e868-576f-405f-bb04-d817a3561853</slot_id>
      <event_id>734f329a-291e-4cc1-aee1-a79175158f11</event_id>
      <title>The Wonderful Wizard of LoC: Paying Attention to the Man Behind the Curtain of Line-of-Code Metrics</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>23:40</end_time>
      <description>Lines-of-code metrics are commonly reported in PL, SE, and Systems papers. This convention has several different, often contradictory, goals, including demonstrating the “hardness” of a problem, and demonstrating the “easiness” of a problem. In many cases, the reporting of loc metrics is done not with a clearly communicated intention, but instead in an automatic, checkbox-ticking, manner.
In this paper we investigate the uses of code metrics in PL, SE, and System papers. We consider the different goals that reporting metrics aims to achieve, several various domains wherein metrics are relevant, and various alternative metrics and their pros and cons for the different goals and domains. We argue that communicating claims about research software is usually best achieved not by reporting quantitative metrics, but by reporting the qualitative experience of researchers, and propose guidelines for the cases when quantitative metrics are appropriate.
We end with a case study of the one area in which lines of code are not the default measurement—code produced by papers’ solutions—and identify how measurements offered are used to support an explicit claim about the algorithm. Inspired by this positive example, we call for other cogent measures to be developed to support other claims authors wish to make.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kalev</first_name>
          <last_name>Alpernas</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.tau.ac.il/~kalevalp/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/kalevalpernas/05430004-6682-4918-b6b0-8b3398cb9428/small.jpg</picture_url>
          <person_id>kalevalpernas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yotam</first_name>
          <last_name>Feldman</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/research/yotam.feldman/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yotamfeldman/ed864714-e66c-4ec1-a171-8c2ac69d62a1/small.jpg</picture_url>
          <person_id>yotamfeldman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ddc26d91-ac58-461f-b4ab-617613ea11a6</slot_id>
      <event_id>c7a92e3e-e35f-4c15-9cd3-ea11f7016ac0</event_id>
      <title>Putting the Semantics into Semantic Versioning</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>00:00</end_time>
      <description>The long-standing aspiration for software reuse has made astonishing strides in the past few years. Many modern software development ecosystems now come with rich sets of publicly-available components contributed by the community. Downstream developers can leverage these upstream components, boosting their productivity.
However, components evolve at their own pace. This imposes obligations on and yields benefits for downstream developers, especially since changes can be breaking, requiring additional downstream work to adapt to. Upgrading too late leaves downstream vulnerable to security issues and missing out on useful improvements; upgrading too early results in excess work. Semantic versioning has been proposed as an elegant mechanism to communicate levels of compatibility, enabling downstream developers to automate dependency upgrades. However, there is evidence suggesting that this approach faces problems, and is only slowly being adopted.
While it is questionable whether a version number can adequately characterize version compatibility in general, we argue that developers would greatly benefit from tools such as semantic version calculators to help them upgrade safely. The time is now for the research community to develop such tools: large component ecosystems exist and are accessible, component interactions have become observable through automated builds, and recent research advances in program analysis have made the development of relevant tools feasible. In particular, verified contracts (both traditional and lightweight) are a promising input to semantic versioning calculators, which can suggest whether an upgrade is likely to be safe.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jens</first_name>
          <last_name>Dietrich</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>I am an Associate Professor in the School of Engineering and Advanced Technology (SEAT) at the Turitea (Palmerston North) Campus of Massey University. I have a Master in Mathematics and a PhD in Computer Science from the University of Leipzig. I have worked for a couple of years in industry as consultant in Germany, Namibia, Switzerland and the UK, and returned in 2003 to academia. My research interests are in the areas of software componentry, evolution and static analysis.</bio>
          <homepage_url>https://ecs.wgtn.ac.nz/Main/JensDietrich</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jensdietrich/ab54c290-4f44-4d77-9842-cdc18922d7b4/small.jpg</picture_url>
          <person_id>jensdietrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Lam</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://patricklam.ca</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/patricklam/d94f6246-8d4e-4896-a263-379eb20a9b24/small.jpg</picture_url>
          <person_id>patricklam</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Pearce</last_name>
          <affiliation>Victoria University of Wellington, New Zealand</affiliation>
          <bio>David (@whileydave) graduated with a PhD from Imperial College London in 2005, and took up a lecturer position at Victoria University of Wellington, NZ. David’s PhD thesis was on efficient algorithms for pointer analysis of C, and his techniques have since been incorporated into GCC. His interests are in programming languages, compilers and static analysis.
Since 2009, he has been developing the Whiley Programming Language (whiley.org) which is designed specifically to simplify program verification. Prior to that, David developed the Java Compiler Kit (JKit), which is an open source Java Compiler aimed at simplifying static analysis.
David has previously interned at Bell Labs, New Jersey, where he worked on compilers for FPGAs; and also at IBM Hursely, UK, where he worked with the AspectJ development team on profiling systems.</bio>
          <homepage_url>http://homepages.ecs.vuw.ac.nz/~djp/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidpearce/22bf61c2-1912-4f75-a0a6-fc77ea16dd34/small.jpg</picture_url>
          <person_id>davidpearce</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d2e88b59-4a10-4cdc-b081-2ffd9655c4f6</subevent_id>
    <title>SPLASH Onward! Papers: T-2-Onward</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
      <track>Onward! Essays</track>
    </tracks>
    <timeslot>
      <slot_id>22f6c68e-4ff2-4a08-b80e-cc8da6a9a274</slot_id>
      <title>Session: SPLASH Onward! Papers - T-2-Onward</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0a8381ee-b72f-4944-a709-78625ade2338</slot_id>
      <event_id>71f0486c-4cb8-4129-bf78-31b62f01a30a</event_id>
      <title>End-User Software Customization by Direct Manipulation of Tabular Data</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>09:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>09:40</end_time>
      <description>Customizing software should be as easy as using it. But most customization methods require a dramatic shift from using a GUI to writing customization scripts in a programming language.
We introduce data-driven customization, a new way for end users to extend software by direct manipulation without doing traditional programming. We augment existing user interfaces with a table view showing the structured data inside the application. When users edit the table, their changes are reflected in the original UI. This simple model accommodates a spreadsheet formula language and custom data editing widgets, providing enough power to implement a variety of useful extensions.
We illustrate the approach with Wildcard, a browser extension that implements data-driven customization on the web using web scraping. Through concrete examples, we show that this paradigm can support useful extensions to many real websites, and we share reflections from our experiences using the tool.
Finally, we share our broader vision for data-driven customization: a future where end users have greater access to the data inside their applications, and better tools for flexibly making use of that data in the context of everyday software usage.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Geoffrey</first_name>
          <last_name>Litt</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>geoffreylitt1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Jackson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/dnj/</homepage_url>
          <person_id>danieljackson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Millis</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>tylermillis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jessica</first_name>
          <last_name>Quaye</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>jessicaquaye</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1abe9e3b-34f7-4814-8248-b58d0f57ec45</slot_id>
      <event_id>6cc1e9be-46b1-4962-9d3d-2920b847aea7</event_id>
      <title>Example-based Live Programming for Everyone: Building Language-agnostic Tools for Live Programming With LSP and GraalVM</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>09:20</end_time>
      <description>Our community has explored various approaches to improve the programming experience. Although many of them, such as Example-based Live Programming (ELP), have shown to be effective, they are still not widespread in conventional programming environments. A reason for that is the effort required to provide sophisticated tools that rely on run-time information. To target multiple language ecosystems, it is often necessary to implement the same concepts, but for different languages and runtimes. Two emerging technologies present an opportunity to reduce this effort significantly: the Language Server Protocol (LSP) and language implementation frameworks such as GraalVM’s Truffle. In this paper, we show how an ELP system can be built in a language-agnostic way by leveraging these two technologies. Based on our approach, we implemented the Babylonian Programming system, an ELP system that has previously only been implemented for exploratory ecosystems. Our system, on the other hand, brings ELP for all languages supported by the GraalVM to Visual Studio Code (VS Code). Moreover, we outline what a language-agnostic infrastructure needs to provide and how the LSP could be extended to support ELP also independently from programming environments. Further, we demonstrate how our approach enables the use of ELP in the context of polyglot programming. We illustrate the consequences of our approach by discussing its advantages and limitations and by comparing the features of our system to other ELP systems. Moreover, we give an outlook of how tools that rely on run-time information could be built in the future. This in turn might motivate future tool builders and researchers to consider implementing more tools in a language-agnostic way from the start to make them available to a broader audience.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fabio</first_name>
          <last_name>Niephaus</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://fniephaus.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/fabioniephaus/44d2c4cc-3f4f-42d2-8496-ca7e59905dd3/small.jpg</picture_url>
          <person_id>fabioniephaus</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Rein</last_name>
          <affiliation>Hasso Plattner Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.patrickrein.de</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/patrickrein/0538cdc6-52aa-408d-9042-80e24d2f8260/small.jpg</picture_url>
          <person_id>patrickrein</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jakob</first_name>
          <last_name>Edding</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>jakobedding</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jonas</first_name>
          <last_name>Hering</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>jonashering</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Bastian</first_name>
          <last_name>König</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>bastiankonig</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Kolya</first_name>
          <last_name>Opahle</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>kolyaopahle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Nico</first_name>
          <last_name>Scordialo</last_name>
          <affiliation>Hasso Plattner Institute, University of Potsdam</affiliation>
          <bio>undefined</bio>
          <person_id>nicoscordialo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Robert</first_name>
          <last_name>Hirschfeld</last_name>
          <affiliation>Hasso-Plattner-Institut (HPI), Germany</affiliation>
          <bio>Robert Hirschfeld is a Professor of Computer Science at the Hasso Plattner Institute at the University of Potsdam, Germany. There he founded and leads the Software Architecture Group which is concerned with fundamental elements and structures of software. Methods and tools are developed for improving the comprehension and design of complex and interesting systems.
Robert is interested in programming experiences and small system kernels. With his group he is working on dynamic programming languages, development tools, and runtime environments to make interactive programming more approachable. His preferred environment for exploring ideas is Squeak/Smalltalk.
He served as a visiting professor at the Tokyo Institute of Technology (東京工業大学) and The University of Tokyo (東京大学), Japan.
Robert was a senior researcher with DoCoMo Euro-Labs, the European research facility of NTT DoCoMo Japan, where he worked on infrastructure components for next generation mobile communication systems with a focus on dynamic service adaptation and context-oriented programming.
Prior to joining DoCoMo Euro-Labs, he was a principal engineer at Windward Solutions in Sunnyvale, California, where he designed and implemented distributed object systems, consulted in the area of object database technologies, and developed innovative software products and applications.
Robert received a Ph.D. in Computer Science from the Ilmenau University of Technology, Germany.</bio>
          <homepage_url>http://www.hirschfeld.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/roberthirschfeld/994ef4df-a890-4f16-bc1b-73b117dab33c/small.jpg</picture_url>
          <person_id>roberthirschfeld</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1df791d7-3361-4555-b145-469145d3cd4e</slot_id>
      <event_id>61a0b3ff-079e-4f32-b965-6212b38b01cc</event_id>
      <title>Discussion of Aviation Software Oversight Improvement</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>10:00</end_time>
      <description>The certification of US aviation software is described and critiqued. Flight critical software certification and regulation need external academic review and intervention. Industry is driven to generate profits over prioritizing concerns for public safety and has failed at developing adequately proven methods of certifying that flight critical software is safe to deploy.
Disclaimer: The opinions expressed in this work are the views of the author and do not reflect the official policy or position of any agency of the U.S. government.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marc</first_name>
          <last_name>Ronell</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>marcronell</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>49ff881c-c9cf-48f1-b80d-e960c1d4293f</slot_id>
      <event_id>f5df0dfc-f912-43a8-ab3d-e57ff4e3846c</event_id>
      <title>A Case Study in Language-Based Security: Building an I/O Library for Wyvern</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>10:20</end_time>
      <description>As the impact of vulnerabilities increases in practice, it is imperative for programming languages to include security as a first-class design consideration. While a number of security-related language features have been proposed to address this need, in many cases, we do not know enough about whether it is practical and useful to build software systems in languages with these features.
In this paper, we begin to investigate this question, using a case study methodology. The setting of our case study is Wyvern, a recently designed language we selected because it incorporates three advanced security-related features: capability safety for enforcing the principle of least privilege, an effect system for tracking the secure use of resources, and a language extension feature that mitigates command injection. In our case study, we built a small standard I/O library, seeking to use the new language features to create a library that is less vulnerable to misuse and can serve as a building block for more secure programs, compared to conventional I/O library designs. Our study suggests that these features are indeed practicable and useful, and thus potentially promising for inclusion in other future language designs. It also sheds light on the value and cost of these features and suggests directions for future research on security-focused language design.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jennifer</first_name>
          <last_name>Fish</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>jenniferfish</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Darya</first_name>
          <last_name>Melicher</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://scholar.google.com/citations?user=KoIZBqwAAAAJ</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/daryamelicher/dd1aba2a-1ed3-43a6-ae6e-b9905a5a8bc2/small.jpg</picture_url>
          <person_id>daryamelicher</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech.
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5eb6a36d-e8c2-4d9b-bf81-042bbdf4db58</subevent_id>
    <title>SPLASH Onward! Essays: T-4-Onward</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-Onward-Essays</url>
    <url_link_display>Onward! Essays</url_link_display>
    <tracks>
      <track>Onward! Essays</track>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot>
      <slot_id>447b6f18-b1d0-4ce3-904f-d4a6ca2c785e</slot_id>
      <title>Session: SPLASH Onward! Essays - T-4-Onward</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>13:00</start_time>
      <end_time>14:00</end_time>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3232081f-0e24-444a-a99e-00a1e33730fe</slot_id>
      <event_id>185d56d8-71e8-445f-8ca3-ecfe421bd8c0</event_id>
      <title>Intrepydd: Performance, Productivity and Portability for Data Science Application Kernels</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:40</end_time>
      <description>Major simultaneous disruptions are now under way in both hardware and software. In hardware, ``extreme heterogeneity'' has become critical to sustaining cost and performance improvements after Moore’s Law, but poses productivity and portability challenges for developers. In software, the rise of large-scale data science is driven by developers who come from diverse backgrounds and, moreover, who demand the rapid prototyping and interactive-notebook capabilities of high-productivity languages like Python.
We introduce the Intrepydd programming system, which enables data scientists to write application {\em kernels} with high performance, productivity, and portability on current and future hardware. Intrepydd is based on Python, though the approach can be applied to other base languages as well. To deliver high performance, the Intrepydd toolchain uses ahead-of-time (AOT) compilation and high-level compiler optimizations of Intrepydd kernels. Intrepydd achieves portability by its ability to compile kernels in different modes for execution on different hardware platforms, and for invocation from Python or C++ main programs.
An empirical evaluation shows significant performance improvements relative to Python, and the suitability of Intrepydd for mapping on to post-Moore accelerators and architectures with relative ease. In summary, we believe that Intrepydd represents a new direction of ``Discipline-Aware Languages'' (DiALs), which brings us closer to the holy grail of obtaining productivity and portability with higher performance than current Python-like languages, and with more generality than current domain-specific languages and libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tong</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>tongzhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jun</first_name>
          <last_name>Shirako</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>junshirako1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anirudh</first_name>
          <last_name>Jain</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>anirudhjain</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sriseshan</first_name>
          <last_name>Srikanth</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>sriseshansrikanth</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Conte</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>thomasconte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Richard</first_name>
          <last_name>Vuduc</last_name>
          <affiliation>Georgia Tech</affiliation>
          <bio>See website</bio>
          <homepage_url>https://vuduc.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/richardvuduc/18a7667a-ab20-4ff4-b4ea-8f1f95f6abff/small.jpg</picture_url>
          <person_id>richardvuduc</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Vivek</first_name>
          <last_name>Sarkar</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>Vivek Sarkar is Chair of the School of Computer Science and the Stephen Fleming Chair for Telecommunications in the College of Computing at Georgia Institute of Technology. He conducts research in multiple aspects of programmability and productivity in parallel computing, including programming languages, compilers, runtime systems, and debuggers for parallel, heterogeneous, and high-performance computer systems.
Sarkar started his career in IBM Research after obtaining his Ph.D. from Stanford University, supervised by John Hennessy. His research projects at IBM include the PTRAN automatic parallelization system led by Fran Allen, the ASTI optimizer for IBM’s XL Fortran product compilers, the open-source Jikes Research Virtual Machine for the Java language, and the X10 programming language developed in the DARPA HPCS program. He was a member of the IBM Academy of Technology during 1995-2007. After moving to academia, Sarkar has mentored over 30 Ph.D. students and postdoctoral researchers in the Habanero Extreme Scale Software Research Laboratory, first at Rice University since 2007, and now at Georgia Tech since 2017. Researchers in his lab have developed the Habanero-C/C++ and Habanero-Java programming systems for parallel, heterogeneous, and distributed platforms. While at Rice, Sarkar was the E.D. Butcher Chair in Engineering, served as Chair of the Department of Computer Science, created a new sophomore-level course on the fundamentals of parallel programming, as well as a three-course Coursera specialization on parallel, concurrent, and distributed programming.
Sarkar is an ACM Fellow and an IEEE Fellow. He has been serving as a member of the US Department of Energy’s Advanced Scientific Computing Advisory Committee (ASCAC) since 2009, and on CRA’s Board of Directors since 2015. He is also the recipient of the 2020 ACM-IEEE CS Ken Kennedy Award.</bio>
          <homepage_url>http://vsarkar.cc.gatech.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/viveksarkar1/a34d5fee-4238-404c-a8b1-6de976f74890/small.jpg</picture_url>
          <person_id>viveksarkar1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>951bf7e8-ea42-4188-9ce2-41cfefbe58a7</slot_id>
      <event_id>2f305d32-0104-451e-9df8-c32c270e49fd</event_id>
      <title>A principled approach to REPL interpreters</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>14:00</end_time>
      <description>Read-eval-print-loops (REPLs) allow programmers to test out snippets of code, explore APIs, or even incrementally construct code, and get immediate feedback on their actions. However, even though many languages provide a REPL, the relation between the language \textit{sec} and what is accepted at the REPL prompt is not always well-defined. Furthermore, implementing a REPL for new languages, such as DSLs, may incur significant language engineering cost.
In this paper we survey the domain of REPLs and investigate the (formal) principles underlying REPLs. We identify and define the class of \textit{sequential} languages, which admit a sound REPL implementation based on a definitional interpreter, and present design guidelines for extending existing language implementations to support REPL-style interfaces (including computational notebooks). The obtained REPLs can then be generically turned into an \textit{exploring} interpreter, to allow exploration of the user’s interaction.
The approach is illustrated using three case studies, based on MiniJava, QL (a DSL for questionnaires), and eFLINT (a DSL for normative rules). We expect sequential languages, and the consequent design principles, to be stepping stones towards a better understanding of the essence of REPLs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>L. Thomas</first_name>
          <last_name>van Binsbergen</last_name>
          <affiliation>Centrum Wiskunde &amp; Informatica</affiliation>
          <bio>Thomas van Binsbergen is designing and implementing domain-specific languages for the formal specification of norms from a variety of sources such as laws, regulations, policies, contracts and codes of conduct. The resulting formalizations are used in policy-enhanced, distributed software architectures for data sharing. By ensuring compliance with the formalized norms, such systems reduce the risk of violating regulations and add value by increasing the trust in sharing activities.
The SSPDDP project is a collaboration between the knowledge institutes UvA, CWI and VU and the industrial partners ABN AMRO, ING and KLM to develop secure and scalable techniques for policy-enforced data sharing. The project investigates fundamental research questions to develop future-proof, cryptographic solutions to secure and trustworthy data sharing, automatic policy enforcement in distributed systems and bringing the aforementioned data sharing methods to scale. Besides being academically relevant, the outcomes of these investigations suggest a principled, sound and pragmatic mode of operation that can add value to the industry partners in several ways.
In the past, Van Binsbergen has developed modular techniques for describing the semantics of programming languages as part of the PLanCompS project with Peter Mosses and parser combinators for generalised top-down parsing with Adrian Johnstone and Elizabeth Scott. The results are described in his PhD thesis titled “Executable Formal Specification of Programming Languages with Reusable Components” (http://ltvanbinsbergen.nl/thesis/thesis.pdf).
Keywords: modular language definition, domain-specific languages, formal specification, modelling languages, policy-enhanced data-sharing, generalised top-down parsing, declarative programming, purely functional programming, I-MSOS, FunCons, attribute grammars, computer science education</bio>
          <homepage_url>http://ltvanbinsbergen.nl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lthomasvanbinsbergen/b276e9a4-2229-45a7-ae0f-e25fb729b0e6/small.jpg</picture_url>
          <person_id>lthomasvanbinsbergen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mauricio</first_name>
          <last_name>Verano Merino</last_name>
          <affiliation>Technische Universiteit Eindhoven</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/mauricioveranomerino/e4a3ec56-b66f-4885-9989-c4a230e08446/small.jpg</picture_url>
          <person_id>mauricioveranomerino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pierre</first_name>
          <last_name>Jeanjean</last_name>
          <affiliation>Inria, Univ Rennes, CNRS, IRISA</affiliation>
          <bio>undefined</bio>
          <person_id>pierrejeanjean</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tijs</first_name>
          <last_name>van der Storm</last_name>
          <affiliation>CWI &amp; University of Groningen, Netherlands</affiliation>
          <bio>Tijs van der Storm is senior researcher in the Software Analysis and Transformation (SWAT) group at Centrum Wiskunde &amp;amp; Informatica (CWI) in Amsterdam, and full professor in Software Engineering at the University of Groningen in Groningen. His research focuses on improving programmer experience through new and better software languages and developing the tools and techniques to engineer them in a modular and interactive fashion.</bio>
          <homepage_url>http://www.cwi.nl/~storm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tijsvanderstorm/1c2fdfb2-3ce0-4e75-91af-35d9a48f56c5/small.jpg</picture_url>
          <person_id>tijsvanderstorm</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Toulouse and Inria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Barais</last_name>
          <affiliation>(Univ Rennes, Inria, IRISA)</affiliation>
          <bio>undefined</bio>
          <person_id>olivierbarais1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>af3dad57-a64e-486c-a822-c55ea57d23e1</slot_id>
      <event_id>de7f53dd-f844-4b70-b3c5-5ce2c614266b</event_id>
      <title>Notes on Notebooks: Is Jupyter the Bringer of Jollity?</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:20</end_time>
      <description>As the interactive computational notebook becomes a more prominent code development medium, we examine advantages and disadvantages of this particular source code format. We formally specify the structure of a coding notebook layout. We describe complexities in notebook programming; some of these are incidental whereas others may be inherent complexities. We outline how we envisage research and development might proceed to advance the cause of notebook programming.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Singer</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~jsinger</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeremysinger/14db1542-37ba-4e0e-b338-e3a952991f1a/small.jpg</picture_url>
          <person_id>jeremysinger</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>67c1bc95-3294-484c-9036-525131de9cea</subevent_id>
    <title>SPLASH Onward! Essays: T-4-Onward</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-Onward-Essays</url>
    <url_link_display>Onward! Essays</url_link_display>
    <tracks>
      <track>Onward! Essays</track>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot>
      <slot_id>bc56fe49-591e-4e9e-98d9-59f038d491ed</slot_id>
      <title>Session: SPLASH Onward! Essays - T-4-Onward</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>01:00</start_time>
      <end_time>02:00</end_time>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>00372e53-0551-49e0-af32-774fa48df6b3</slot_id>
      <event_id>185d56d8-71e8-445f-8ca3-ecfe421bd8c0</event_id>
      <title>Intrepydd: Performance, Productivity and Portability for Data Science Application Kernels</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:40</end_time>
      <description>Major simultaneous disruptions are now under way in both hardware and software. In hardware, ``extreme heterogeneity'' has become critical to sustaining cost and performance improvements after Moore’s Law, but poses productivity and portability challenges for developers. In software, the rise of large-scale data science is driven by developers who come from diverse backgrounds and, moreover, who demand the rapid prototyping and interactive-notebook capabilities of high-productivity languages like Python.
We introduce the Intrepydd programming system, which enables data scientists to write application {\em kernels} with high performance, productivity, and portability on current and future hardware. Intrepydd is based on Python, though the approach can be applied to other base languages as well. To deliver high performance, the Intrepydd toolchain uses ahead-of-time (AOT) compilation and high-level compiler optimizations of Intrepydd kernels. Intrepydd achieves portability by its ability to compile kernels in different modes for execution on different hardware platforms, and for invocation from Python or C++ main programs.
An empirical evaluation shows significant performance improvements relative to Python, and the suitability of Intrepydd for mapping on to post-Moore accelerators and architectures with relative ease. In summary, we believe that Intrepydd represents a new direction of ``Discipline-Aware Languages'' (DiALs), which brings us closer to the holy grail of obtaining productivity and portability with higher performance than current Python-like languages, and with more generality than current domain-specific languages and libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tong</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>tongzhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jun</first_name>
          <last_name>Shirako</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>junshirako1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anirudh</first_name>
          <last_name>Jain</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>anirudhjain</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sriseshan</first_name>
          <last_name>Srikanth</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>sriseshansrikanth</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Conte</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>thomasconte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Richard</first_name>
          <last_name>Vuduc</last_name>
          <affiliation>Georgia Tech</affiliation>
          <bio>See website</bio>
          <homepage_url>https://vuduc.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/richardvuduc/18a7667a-ab20-4ff4-b4ea-8f1f95f6abff/small.jpg</picture_url>
          <person_id>richardvuduc</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Vivek</first_name>
          <last_name>Sarkar</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>Vivek Sarkar is Chair of the School of Computer Science and the Stephen Fleming Chair for Telecommunications in the College of Computing at Georgia Institute of Technology. He conducts research in multiple aspects of programmability and productivity in parallel computing, including programming languages, compilers, runtime systems, and debuggers for parallel, heterogeneous, and high-performance computer systems.
Sarkar started his career in IBM Research after obtaining his Ph.D. from Stanford University, supervised by John Hennessy. His research projects at IBM include the PTRAN automatic parallelization system led by Fran Allen, the ASTI optimizer for IBM’s XL Fortran product compilers, the open-source Jikes Research Virtual Machine for the Java language, and the X10 programming language developed in the DARPA HPCS program. He was a member of the IBM Academy of Technology during 1995-2007. After moving to academia, Sarkar has mentored over 30 Ph.D. students and postdoctoral researchers in the Habanero Extreme Scale Software Research Laboratory, first at Rice University since 2007, and now at Georgia Tech since 2017. Researchers in his lab have developed the Habanero-C/C++ and Habanero-Java programming systems for parallel, heterogeneous, and distributed platforms. While at Rice, Sarkar was the E.D. Butcher Chair in Engineering, served as Chair of the Department of Computer Science, created a new sophomore-level course on the fundamentals of parallel programming, as well as a three-course Coursera specialization on parallel, concurrent, and distributed programming.
Sarkar is an ACM Fellow and an IEEE Fellow. He has been serving as a member of the US Department of Energy’s Advanced Scientific Computing Advisory Committee (ASCAC) since 2009, and on CRA’s Board of Directors since 2015. He is also the recipient of the 2020 ACM-IEEE CS Ken Kennedy Award.</bio>
          <homepage_url>http://vsarkar.cc.gatech.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/viveksarkar1/a34d5fee-4238-404c-a8b1-6de976f74890/small.jpg</picture_url>
          <person_id>viveksarkar1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2e5f96d2-0379-43f9-bf66-7dd4e161653e</slot_id>
      <event_id>de7f53dd-f844-4b70-b3c5-5ce2c614266b</event_id>
      <title>Notes on Notebooks: Is Jupyter the Bringer of Jollity?</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:20</end_time>
      <description>As the interactive computational notebook becomes a more prominent code development medium, we examine advantages and disadvantages of this particular source code format. We formally specify the structure of a coding notebook layout. We describe complexities in notebook programming; some of these are incidental whereas others may be inherent complexities. We outline how we envisage research and development might proceed to advance the cause of notebook programming.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Singer</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~jsinger</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeremysinger/14db1542-37ba-4e0e-b338-e3a952991f1a/small.jpg</picture_url>
          <person_id>jeremysinger</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4f56dca4-18c1-409a-a08e-fa841557f754</slot_id>
      <event_id>2f305d32-0104-451e-9df8-c32c270e49fd</event_id>
      <title>A principled approach to REPL interpreters</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>02:00</end_time>
      <description>Read-eval-print-loops (REPLs) allow programmers to test out snippets of code, explore APIs, or even incrementally construct code, and get immediate feedback on their actions. However, even though many languages provide a REPL, the relation between the language \textit{sec} and what is accepted at the REPL prompt is not always well-defined. Furthermore, implementing a REPL for new languages, such as DSLs, may incur significant language engineering cost.
In this paper we survey the domain of REPLs and investigate the (formal) principles underlying REPLs. We identify and define the class of \textit{sequential} languages, which admit a sound REPL implementation based on a definitional interpreter, and present design guidelines for extending existing language implementations to support REPL-style interfaces (including computational notebooks). The obtained REPLs can then be generically turned into an \textit{exploring} interpreter, to allow exploration of the user’s interaction.
The approach is illustrated using three case studies, based on MiniJava, QL (a DSL for questionnaires), and eFLINT (a DSL for normative rules). We expect sequential languages, and the consequent design principles, to be stepping stones towards a better understanding of the essence of REPLs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>L. Thomas</first_name>
          <last_name>van Binsbergen</last_name>
          <affiliation>Centrum Wiskunde &amp; Informatica</affiliation>
          <bio>Thomas van Binsbergen is designing and implementing domain-specific languages for the formal specification of norms from a variety of sources such as laws, regulations, policies, contracts and codes of conduct. The resulting formalizations are used in policy-enhanced, distributed software architectures for data sharing. By ensuring compliance with the formalized norms, such systems reduce the risk of violating regulations and add value by increasing the trust in sharing activities.
The SSPDDP project is a collaboration between the knowledge institutes UvA, CWI and VU and the industrial partners ABN AMRO, ING and KLM to develop secure and scalable techniques for policy-enforced data sharing. The project investigates fundamental research questions to develop future-proof, cryptographic solutions to secure and trustworthy data sharing, automatic policy enforcement in distributed systems and bringing the aforementioned data sharing methods to scale. Besides being academically relevant, the outcomes of these investigations suggest a principled, sound and pragmatic mode of operation that can add value to the industry partners in several ways.
In the past, Van Binsbergen has developed modular techniques for describing the semantics of programming languages as part of the PLanCompS project with Peter Mosses and parser combinators for generalised top-down parsing with Adrian Johnstone and Elizabeth Scott. The results are described in his PhD thesis titled “Executable Formal Specification of Programming Languages with Reusable Components” (http://ltvanbinsbergen.nl/thesis/thesis.pdf).
Keywords: modular language definition, domain-specific languages, formal specification, modelling languages, policy-enhanced data-sharing, generalised top-down parsing, declarative programming, purely functional programming, I-MSOS, FunCons, attribute grammars, computer science education</bio>
          <homepage_url>http://ltvanbinsbergen.nl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lthomasvanbinsbergen/b276e9a4-2229-45a7-ae0f-e25fb729b0e6/small.jpg</picture_url>
          <person_id>lthomasvanbinsbergen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mauricio</first_name>
          <last_name>Verano Merino</last_name>
          <affiliation>Technische Universiteit Eindhoven</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/mauricioveranomerino/e4a3ec56-b66f-4885-9989-c4a230e08446/small.jpg</picture_url>
          <person_id>mauricioveranomerino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pierre</first_name>
          <last_name>Jeanjean</last_name>
          <affiliation>Inria, Univ Rennes, CNRS, IRISA</affiliation>
          <bio>undefined</bio>
          <person_id>pierrejeanjean</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tijs</first_name>
          <last_name>van der Storm</last_name>
          <affiliation>CWI &amp; University of Groningen, Netherlands</affiliation>
          <bio>Tijs van der Storm is senior researcher in the Software Analysis and Transformation (SWAT) group at Centrum Wiskunde &amp;amp; Informatica (CWI) in Amsterdam, and full professor in Software Engineering at the University of Groningen in Groningen. His research focuses on improving programmer experience through new and better software languages and developing the tools and techniques to engineer them in a modular and interactive fashion.</bio>
          <homepage_url>http://www.cwi.nl/~storm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tijsvanderstorm/1c2fdfb2-3ce0-4e75-91af-35d9a48f56c5/small.jpg</picture_url>
          <person_id>tijsvanderstorm</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Toulouse and Inria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Barais</last_name>
          <affiliation>(Univ Rennes, Inria, IRISA)</affiliation>
          <bio>undefined</bio>
          <person_id>olivierbarais1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f207ecc9-7191-4c50-8b4b-6b45bd0b70da</subevent_id>
    <title>SPLASH Onward! Essays: T-5-Onward</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-Onward-Essays</url>
    <url_link_display>Onward! Essays</url_link_display>
    <tracks>
      <track>Onward! Essays</track>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot>
      <slot_id>1840cc92-5aa9-4766-98b2-4f4fba40b1be</slot_id>
      <title>Session: SPLASH Onward! Essays - T-5-Onward</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>03:00</start_time>
      <end_time>04:00</end_time>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3aad3423-4d23-431e-a0dc-e4b365c98b17</slot_id>
      <event_id>bd1659e4-ca0c-498d-a2c0-478c6c8c8f1d</event_id>
      <title>Natural Language Theory Meets Programming Language Theory: An Interdisciplinary Framework for Programming Language Evaluation</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>03:20</end_time>
      <description>Programming languages researchers make a variety of different kinds of claims about the design of languages and related tools and calculi. Each type of claim requires different kinds of reasons and evidence to justify. Claims regarding the aesthetics or elegance of a design, or its effects on people, are especially tricky to justify because they are less strictly defined and are subject to change depending on the exact audience. In this essay, we take an interdisciplinary approach to this problem by drawing on the fields of argument theory and rhetorical analysis to argue that programming languages researchers can provide reasons for their claims about effects on people by providing descriptions of specific features of their systems that support their claim. In order to demonstrate this framework, we show several examples of how this is already being practiced in some programming languages research, and conclude by calling for authors to provide descriptive evidence to bolster such claims and to frame and strengthen other evaluation methods such as user studies.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stefan K.</first_name>
          <last_name>Muller</last_name>
          <affiliation>Illinois Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~smuller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stefankmuller/db0c31ad-55ec-4010-948d-d405e6483cde/small.jpg</picture_url>
          <person_id>stefankmuller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hannah</first_name>
          <last_name>Ringler</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>hannahringler</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4ebab62c-13da-43bf-b7d6-ea0749d72575</slot_id>
      <event_id>c542014b-18d7-4287-87c7-d9a630060cef</event_id>
      <title>Analogy-Making as a Core Primitive in the Software Engineering Toolbox</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>04:00</end_time>
      <description>An analogy is an identification of structural similarities and correspondences between two objects. Computational models of analogy making have been studied extensively in the field of cognitive science to better understand high-level human cognition. For instance, Melanie Mitchell and Douglas Hofstadter sought to better understand high-level perception by developing the Copycat algorithm for completing analogies between letter sequences. In this paper, we argue that analogy making should be seen as a core primitive in software engineering. We motivate this argument by showing how complex software engineering problems such as program understanding and source-code transformation learning can be reduced to an instance of the analogy-making problem. We demonstrate this idea using Sifter, a new analogy-making algorithm suitable for software engineering applications that adapts and extends ideas from Copycat. In particular, Sifter reduces analogy-making to searching for a sequence of update rule applications. Sifter uses a novel representation for mathematical structures capable of effectively representing the wide variety of information embedded in software. We conclude by listing major areas of future work for Sifter and analogy-making in software engineering.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Sotoudeh</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://masot.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthewsotoudeh/32b819f5-05ef-4b0a-8a19-d59eed661278/small.jpg</picture_url>
          <person_id>matthewsotoudeh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aditya V.</first_name>
          <last_name>Thakur</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://thakur.cs.ucdavis.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adityavthakur/89eb0287-7273-4261-b8a5-47ccfc8799b0/small.jpg</picture_url>
          <person_id>adityavthakur</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f64b5bf0-1bae-4bc7-919f-c8b02be99fbc</slot_id>
      <event_id>c93c5c4d-1a3f-4cef-b393-3e7e6bd8b067</event_id>
      <title>Software design as story telling -- Reflecting on the work of Italo Calvino</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>03:40</end_time>
      <description>What do software writers have in common with other professional writers? What can we software developers learn from professional writers? This paper proposes a reflection on such topics using as a reference the book “Six Memos for the Next Millennium”, a posthumous work by the Italian novelist, editor, and literary critic Italo Calvino. A comparison is drawn between such work and the current principles ruling how software should be written and developed, and a claim is made that this is an area worth further exploration.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paolo</first_name>
          <last_name>Ciancarini</last_name>
          <affiliation>University of Bologna</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.unibo.it/~cianca/</homepage_url>
          <person_id>paolociancarini</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sergey</first_name>
          <last_name>Masyagin</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>sergeymasyagin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Giancarlo</first_name>
          <last_name>Succi</last_name>
          <affiliation>Innopolis University</affiliation>
          <bio>undefined</bio>
          <person_id>giancarlosucci</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>754af2bd-aa31-46ca-81b4-9a3eecc5dbe2</subevent_id>
    <title>SPLASH Onward! Essays: T-5-Onward</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-Onward-Essays</url>
    <url_link_display>Onward! Essays</url_link_display>
    <tracks>
      <track>Onward! Essays</track>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot>
      <slot_id>c84b5d6a-de77-43cc-b22b-daf4a293d9b9</slot_id>
      <title>Session: SPLASH Onward! Essays - T-5-Onward</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>15:00</start_time>
      <end_time>16:00</end_time>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8ee8b3b5-2a92-4df8-a405-f4727d7c8233</slot_id>
      <event_id>c93c5c4d-1a3f-4cef-b393-3e7e6bd8b067</event_id>
      <title>Software design as story telling -- Reflecting on the work of Italo Calvino</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>15:40</end_time>
      <description>What do software writers have in common with other professional writers? What can we software developers learn from professional writers? This paper proposes a reflection on such topics using as a reference the book “Six Memos for the Next Millennium”, a posthumous work by the Italian novelist, editor, and literary critic Italo Calvino. A comparison is drawn between such work and the current principles ruling how software should be written and developed, and a claim is made that this is an area worth further exploration.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paolo</first_name>
          <last_name>Ciancarini</last_name>
          <affiliation>University of Bologna</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.unibo.it/~cianca/</homepage_url>
          <person_id>paolociancarini</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sergey</first_name>
          <last_name>Masyagin</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>sergeymasyagin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Giancarlo</first_name>
          <last_name>Succi</last_name>
          <affiliation>Innopolis University</affiliation>
          <bio>undefined</bio>
          <person_id>giancarlosucci</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bf390b0c-6836-472a-a895-0648f3974d90</slot_id>
      <event_id>bd1659e4-ca0c-498d-a2c0-478c6c8c8f1d</event_id>
      <title>Natural Language Theory Meets Programming Language Theory: An Interdisciplinary Framework for Programming Language Evaluation</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>15:20</end_time>
      <description>Programming languages researchers make a variety of different kinds of claims about the design of languages and related tools and calculi. Each type of claim requires different kinds of reasons and evidence to justify. Claims regarding the aesthetics or elegance of a design, or its effects on people, are especially tricky to justify because they are less strictly defined and are subject to change depending on the exact audience. In this essay, we take an interdisciplinary approach to this problem by drawing on the fields of argument theory and rhetorical analysis to argue that programming languages researchers can provide reasons for their claims about effects on people by providing descriptions of specific features of their systems that support their claim. In order to demonstrate this framework, we show several examples of how this is already being practiced in some programming languages research, and conclude by calling for authors to provide descriptive evidence to bolster such claims and to frame and strengthen other evaluation methods such as user studies.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stefan K.</first_name>
          <last_name>Muller</last_name>
          <affiliation>Illinois Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~smuller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stefankmuller/db0c31ad-55ec-4010-948d-d405e6483cde/small.jpg</picture_url>
          <person_id>stefankmuller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hannah</first_name>
          <last_name>Ringler</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>hannahringler</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c8e99fb3-34b3-40c4-a283-3970090dc95e</slot_id>
      <event_id>c542014b-18d7-4287-87c7-d9a630060cef</event_id>
      <title>Analogy-Making as a Core Primitive in the Software Engineering Toolbox</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>16:00</end_time>
      <description>An analogy is an identification of structural similarities and correspondences between two objects. Computational models of analogy making have been studied extensively in the field of cognitive science to better understand high-level human cognition. For instance, Melanie Mitchell and Douglas Hofstadter sought to better understand high-level perception by developing the Copycat algorithm for completing analogies between letter sequences. In this paper, we argue that analogy making should be seen as a core primitive in software engineering. We motivate this argument by showing how complex software engineering problems such as program understanding and source-code transformation learning can be reduced to an instance of the analogy-making problem. We demonstrate this idea using Sifter, a new analogy-making algorithm suitable for software engineering applications that adapts and extends ideas from Copycat. In particular, Sifter reduces analogy-making to searching for a sequence of update rule applications. Sifter uses a novel representation for mathematical structures capable of effectively representing the wide variety of information embedded in software. We conclude by listing major areas of future work for Sifter and analogy-making in software engineering.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Sotoudeh</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://masot.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthewsotoudeh/32b819f5-05ef-4b0a-8a19-d59eed661278/small.jpg</picture_url>
          <person_id>matthewsotoudeh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aditya V.</first_name>
          <last_name>Thakur</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://thakur.cs.ucdavis.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adityavthakur/89eb0287-7273-4261-b8a5-47ccfc8799b0/small.jpg</picture_url>
          <person_id>adityavthakur</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b745c7af-cb33-45ec-b30b-8f9f08beb8f5</subevent_id>
    <title>SLE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/17</date>
    <url>https://conf.researchr.org/home/sle-2020</url>
    <url_link_display>SLE (Software Language Engineering) 2020</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>e496920b-83f0-4ce8-ac14-54791928a8e2</slot_id>
      <title>Session: SLE - </title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>03:00</start_time>
      <end_time>03:40</end_time>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>97ccf6b1-5407-475a-a859-6fae61c10e61</slot_id>
      <event_id>1e1d3614-e96a-428d-afe4-b54c8c8e1473</event_id>
      <title>A semantic framework for PEGs</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>03:20</end_time>
      <description>Parsing expression grammars (PEGs) are a recognition-based formalism which allows to describe the syntactical and the lexical elements of a language. The main difference between context-free grammars (CFGs) and PEGs relies on the interpretation of the choice operator: while the CFGs’ unordered choice e | e’ is interpreted as the union of the languages recognized by e and e’, the PEGs’ prioritized choice e/e’ discards e’ if e succeeds. Such subtle, but important difference, changes the language recognized and yields more efficient parsing algorithms. This paper proposes a rewriting logic semantics for PEGs. We start with a rewriting theory giving meaning to the usual constructs in PEGs. Later, we show that cuts, a mechanism for controlling backtracks in PEGs, finds also a natural representation in our framework. We generalize such mechanism, allowing for both local and global cuts with a precise, unified and formal semantics. Hence, our work strives at better understanding and controlling backtracks in parsers for PEGs. The semantics we propose is executable and, besides being a parser with modest efficiency, it can be used as a playground to test different optimization ideas. More importantly, it is a mathematical tool that can be used for different analyses. For instance, using symbolic techniques, it is possible to use our specification as a derivative parser that generates, in a compact way, all the strings of a fixed length recognized by a grammar.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sergio</first_name>
          <last_name>Queiroz de Medeiros</last_name>
          <affiliation>Universidade Federal do Rio Grande do Norte</affiliation>
          <bio>undefined</bio>
          <person_id>sergioqueirozdemedeiros</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Carlos</first_name>
          <last_name>Olarte</last_name>
          <affiliation>Federal University of Rio Grande do Norte, Brazil</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.google.com/site/carlosolarte/</homepage_url>
          <person_id>carlosolarte</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ee383e5f-8da7-4c15-ab5d-154033e08279</slot_id>
      <event_id>404708eb-bcbb-481f-b5ef-b48d662575be</event_id>
      <title>Untangling mechanized proofs</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>03:40</end_time>
      <description>Proof assistants like Coq, Lean, or HOL4 rely heavily on stateful meta-programs called scripts to assemble proofs. Unlike pen-and-paper proofs, proof scripts only describe the steps to take (induct on $x$, apply a theorem, …), not the states that these steps lead to; as a result, plain proof scripts are essentially incomprehensible without the assistance of an interactive user interface able to run the script and show the corresponding proof states.
Until now, the standard process to communicate a proof without forcing readers to execute its script was to manually copy-paste intermediate proof states into the script, as source code comments — a tedious and error-prone exercise. Additional prose (such as for a book or tutorial) was likewise embedded in comments, preserving executability at the cost of a mediocre text-editing experience.
This paper describes a new approach to the development and dissemination of literate proof scripts, with a focus on the Coq proof assistant. Specifically, we describe two contributions: a compiler that interleaves Coq’s output with the original proof script to produce interactive webpages that are complete, self-contained presentations of Coq proofs; and a new literate programming toolkit that allows authors to switch seamlessly between prose- and code-oriented views of the same sources, by translating back and forth between reStructuredText documents and literate Coq source files. In combination, these tools offer a new way to write, communicate, and preserve proofs, combining the flexibility of procedural proof scripts and the intelligibility of declarative proofs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Clément</first_name>
          <last_name>Pit-Claudel</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pit-claudel.fr/clement/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/clementpitclaudel/4a4c3ccf-6680-4f0b-a87f-056c4d081fc2/small.jpg</picture_url>
          <person_id>clementpitclaudel</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>034c8431-850f-4d8f-bd2b-a702454f9fd0</subevent_id>
    <title>SLE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/16</date>
    <url>https://conf.researchr.org/home/sle-2020</url>
    <url_link_display>SLE (Software Language Engineering) 2020</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>9d65fce7-f05a-4f64-bf5c-c3b131211d45</slot_id>
      <title>Session: SLE - </title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0ed16ebb-9aca-4027-8a45-361f336679cc</slot_id>
      <event_id>96904519-a65b-454a-beea-44c4b59c05c4</event_id>
      <title>Example-Driven Software Language Engineering</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:40</end_time>
      <description>Language workbenches–tools to define software languages together with their IDEs–are designed to simplify language engineering and implementation: they free language engineers from many meticulous tasks, but oftentimes have a very steep learning curve even for experienced software professionals. With the assumption that meta-definitions are one of the key factors that make language engineering hindered, we introduce an example-driven approach to language definition. We describe in this paper our vision of a web-based tool aimed at beginner language engineers, and list possible requirements for such a tool. A language is defined by giving examples of code written in it using illustrative syntax definition. These examples are then annotated to specify different concerns of language definition–abstract syntax, typing rules, validation rules, formatting rules, and dynamic semantics.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mikhail</first_name>
          <last_name>Barash</last_name>
          <affiliation>University of Bergen, Norway</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://dsl-course.org/mikbar/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mikhailbarash/d876d731-3779-4e11-8aee-de2bcef5e938/small.jpg</picture_url>
          <person_id>mikhailbarash</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>306af139-9ebc-4b69-b9a7-4ad06e4f4f2b</slot_id>
      <event_id>606ec49c-4792-4253-89ec-4010e21d70de</event_id>
      <title>A Precedence-Driven Approach for Concurrent Model Synchronization Scenarios using Triple Graph Grammars</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:20</end_time>
      <description>Concurrent model synchronization is the task of restoring consistency between two correlated models after they have been changed concurrently and independently. To determine whether such concurrent model changes conflict with each other and to resolve these conflicts taking domain- or user-specific preferences into account is highly challenging. In this paper, we present a framework for concurrent model synchronization algorithms based on Triple Graph Grammars (TGGs). TGGs specify the consistency of correlated models using grammar rules; these rules can be used to derive different consistency restoration operations. Using TGGs, we infer a causal dependency relation for model elements that enables us to detect conflicts non-invasively. Different kinds of conflicts are detected first and resolved by the subsequent conflict resolution process. Users configure the overall synchronization process by orchestrating the application of consistency restoration fragments according to several conflict resolution strategies to achieve individual synchronization goals. As proof of concept, we have implemented this framework in the model transformation tool eMoflon. Our initial evaluation shows that the runtime of our presented approach scales with the size of model changes and conflicts, rather than model size.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lars</first_name>
          <last_name>Fritsche</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>larsfritsche1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jens</first_name>
          <last_name>Kosiol</last_name>
          <affiliation>Philipps-Universität Marburg</affiliation>
          <bio>undefined</bio>
          <person_id>jenskosiol1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Adrian</first_name>
          <last_name>Möller</last_name>
          <affiliation>Technical University of Darmstadt</affiliation>
          <bio>undefined</bio>
          <person_id>adrianmoller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Andy</first_name>
          <last_name>Schürr</last_name>
          <affiliation>TU Darmstadt</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/andyschurr/b3c83371-9583-4f5a-b3ca-1240bf1f9bda/small.jpg</picture_url>
          <person_id>andyschurr</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Gabriele</first_name>
          <last_name>Taentzer</last_name>
          <affiliation>Universität Marburg</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.uni-marburg.de/fb12/swt/gabi-taentzer</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gabrieletaentzer/c2ef5fee-d409-4762-87a4-ad92dda7413b/small.jpg</picture_url>
          <person_id>gabrieletaentzer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>48548dc2-5b97-494d-8455-9a407a09343d</slot_id>
      <event_id>0579642d-68a8-476d-85c0-4a8d1667dd31</event_id>
      <title>Behavior Trees in Action: A Study of Robotics Applications</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>00:00</end_time>
      <description>An autonomous robot system combines skills to form increasingly complex behaviors called missions. While skills are often programmed at a relatively low level of abstraction, their coordination is architecturally separated and expressed in higher-level languages or frameworks. Recently, the language of Behavior Trees gained attention among roboticists for this reason. Originally designed for computer games to model autonomous actors, Behavior Trees offer an extensible tree-based representation of missions. However, even though, several implementations of the language are in use, little is known about its usage and scope in the real world. How do behavior trees relate to traditional languages for describing behavior? How are behavior-tree concepts used in applications? What are the benefits of using them?
We present a study of the key language concepts and their use in real-world robotic applications. We identify behavior tree languages and compare their semantics to the most well-known behavior modeling languages: state and activity diagrams. We mine open source repositories for robotics applications that use the language, and analyze this usage. We find that Behavior Trees are a pragmatic language, not fully specified, allowing projects to extend it even for just one model. Behavior trees clearly resemble the models-at-runtime paradigm. We contribute a dataset of real-world behavior models, hoping to inspire the community to use and further develop this language, associated tools, and analysis techniques.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Razan</first_name>
          <last_name>Ghzouli</last_name>
          <affiliation>Chalmers | University of Gothenburg</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://orcid.org/0000-0002-5428-8113</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/razanghzouli/4a1d42cd-e90e-427e-8686-f823139700f3/small.jpg</picture_url>
          <person_id>razanghzouli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thorsten</first_name>
          <last_name>Berger</last_name>
          <affiliation>Chalmers University of Technology, Sweden / University of Gothenburg, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.chalmers.se/~bergert</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/thorstenberger/d2f325bb-820f-49b8-985d-e62ac888dedd/small.jpg</picture_url>
          <person_id>thorstenberger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Einar</first_name>
          <last_name>Broch Johnsen</last_name>
          <affiliation>University of Oslo</affiliation>
          <bio>undefined</bio>
          <person_id>einarbrochjohnsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Swaib</first_name>
          <last_name>Dragule</last_name>
          <affiliation>Chalmers | University of Gothenburg</affiliation>
          <bio>undefined</bio>
          <person_id>swaibdragule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Andrzej</first_name>
          <last_name>Wąsowski</last_name>
          <affiliation>IT University of Copenhagen, Denmark</affiliation>
          <bio>MSc Eng from Warsaw University of Technology (2000) PhD from IT University of Copenhagen (2005)
Interested in developing repeatable software engineering methods, supported by innovative tools and technology, to solve domain specific problems (safety critical systems, industry automation, robotics, legacy systems, and personal data protection).</bio>
          <homepage_url>http://www.itu.dk/people/wasowski</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andrzejwasowski/36304e96-b840-4d13-933d-7f422b4a3ddc/small.jpg</picture_url>
          <person_id>andrzejwasowski</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f7a8fee3-9466-46ae-bd37-5bbdaf96d23d</slot_id>
      <event_id>8418bc21-ddd2-4ae2-aef7-57450c6d8922</event_id>
      <title>A Search-Based and Fault-Tolerant Approach to Concurrent Model Synchronisation</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>00:20</end_time>
      <description>In collaboration scenarios, we often encounter situations in which semantically interrelated models are changed concurrently. Concurrent model synchronization denotes the task of keeping these models consistent by propagating changes between them. This is challenging as changes can contradict each other and thus be in conflict. A problem with current synchronisation approaches is that they are often nondeterministic, i.e., the order in which changes are propagated is essential for the result. Furthermore, a common limitation is that the involved models must have been in a consistent state at some point, and that the applied changes are at least valid for the domain in which they were made. We propose a hybrid approach based on Triple Graph Grammars (TGGs) and Integer Linear Programming (ILP) to overcome these issues: TGGs are a grammar-based means that supplies us with a superset of possible synchronization solutions, forming a search space from which an optimum solution incorporating user-defined preferences can be chosen by ILP. Therefore, the proposed method combines configurability by comprising expert knowledge via TGGs with the flexible input handling of search-based techniques: By accepting arbitrary graph structures as input models, the approach is tolerant towards errors induced during the modelling process, i.e., it can cope with input models which do not conform to their metamodel or which cannot be generated by the TGG at hand. The approach is implemented in the model transformation tool eMoflon and evaluated regarding scalability for growing model sizes and an increasing number of changes.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nils</first_name>
          <last_name>Weidmann</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>nilsweidmann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lars</first_name>
          <last_name>Fritsche</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>larsfritsche1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anthony</first_name>
          <last_name>Anjorin</last_name>
          <affiliation>Paderborn University, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/anthonyanjorin1/158aeedd-1bac-498b-9521-79557507e112/small.jpg</picture_url>
          <person_id>anthonyanjorin1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b8e0bfbd-d0b9-4eb9-88ba-5ecfc10649c2</subevent_id>
    <title>SLE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/16</date>
    <url>https://conf.researchr.org/home/sle-2020</url>
    <url_link_display>SLE (Software Language Engineering) 2020</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>2199a116-6bde-44cc-a995-9a1d3a820cf6</slot_id>
      <title>Session: SLE - </title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>15:00</start_time>
      <end_time>15:40</end_time>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>68c255ec-e48d-43e5-96e9-23bf9be2b4ba</slot_id>
      <event_id>1e1d3614-e96a-428d-afe4-b54c8c8e1473</event_id>
      <title>A semantic framework for PEGs</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>15:20</end_time>
      <description>Parsing expression grammars (PEGs) are a recognition-based formalism which allows to describe the syntactical and the lexical elements of a language. The main difference between context-free grammars (CFGs) and PEGs relies on the interpretation of the choice operator: while the CFGs’ unordered choice e | e’ is interpreted as the union of the languages recognized by e and e’, the PEGs’ prioritized choice e/e’ discards e’ if e succeeds. Such subtle, but important difference, changes the language recognized and yields more efficient parsing algorithms. This paper proposes a rewriting logic semantics for PEGs. We start with a rewriting theory giving meaning to the usual constructs in PEGs. Later, we show that cuts, a mechanism for controlling backtracks in PEGs, finds also a natural representation in our framework. We generalize such mechanism, allowing for both local and global cuts with a precise, unified and formal semantics. Hence, our work strives at better understanding and controlling backtracks in parsers for PEGs. The semantics we propose is executable and, besides being a parser with modest efficiency, it can be used as a playground to test different optimization ideas. More importantly, it is a mathematical tool that can be used for different analyses. For instance, using symbolic techniques, it is possible to use our specification as a derivative parser that generates, in a compact way, all the strings of a fixed length recognized by a grammar.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sergio</first_name>
          <last_name>Queiroz de Medeiros</last_name>
          <affiliation>Universidade Federal do Rio Grande do Norte</affiliation>
          <bio>undefined</bio>
          <person_id>sergioqueirozdemedeiros</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Carlos</first_name>
          <last_name>Olarte</last_name>
          <affiliation>Federal University of Rio Grande do Norte, Brazil</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.google.com/site/carlosolarte/</homepage_url>
          <person_id>carlosolarte</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>82d4554d-892c-4a74-a804-8d16c1be9cd3</slot_id>
      <event_id>404708eb-bcbb-481f-b5ef-b48d662575be</event_id>
      <title>Untangling mechanized proofs</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>15:40</end_time>
      <description>Proof assistants like Coq, Lean, or HOL4 rely heavily on stateful meta-programs called scripts to assemble proofs. Unlike pen-and-paper proofs, proof scripts only describe the steps to take (induct on $x$, apply a theorem, …), not the states that these steps lead to; as a result, plain proof scripts are essentially incomprehensible without the assistance of an interactive user interface able to run the script and show the corresponding proof states.
Until now, the standard process to communicate a proof without forcing readers to execute its script was to manually copy-paste intermediate proof states into the script, as source code comments — a tedious and error-prone exercise. Additional prose (such as for a book or tutorial) was likewise embedded in comments, preserving executability at the cost of a mediocre text-editing experience.
This paper describes a new approach to the development and dissemination of literate proof scripts, with a focus on the Coq proof assistant. Specifically, we describe two contributions: a compiler that interleaves Coq’s output with the original proof script to produce interactive webpages that are complete, self-contained presentations of Coq proofs; and a new literate programming toolkit that allows authors to switch seamlessly between prose- and code-oriented views of the same sources, by translating back and forth between reStructuredText documents and literate Coq source files. In combination, these tools offer a new way to write, communicate, and preserve proofs, combining the flexibility of procedural proof scripts and the intelligibility of declarative proofs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Clément</first_name>
          <last_name>Pit-Claudel</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pit-claudel.fr/clement/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/clementpitclaudel/4a4c3ccf-6680-4f0b-a87f-056c4d081fc2/small.jpg</picture_url>
          <person_id>clementpitclaudel</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e041af99-08d3-42ef-af05-be388fbee6f4</subevent_id>
    <title>SLE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/16</date>
    <url>https://conf.researchr.org/home/sle-2020</url>
    <url_link_display>SLE (Software Language Engineering) 2020</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>2a9fb29c-5ede-4b70-9bf9-87bb0482824f</slot_id>
      <title>Session: SLE - </title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>06d3687e-3b7f-46d0-b06f-918d847f0325</slot_id>
      <event_id>bee221c2-518e-4f38-a9b4-996285b8693f</event_id>
      <title>Test Case Generation from Context-Free Grammars Using Generalized Traversal of LR-Automata</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>13:20</end_time>
      <description>Test case generation from context-free grammars typically uses the grammar’s production rules to directly construct words that cover specific sets of derivations. Here, we investigate test case generation by traversing graphs derived from the LR-automata corresponding to the grammars. We develop a new algorithm that generates positive test cases by covering all edges between pairs of directly connected states in a two-phase breadth-first path search. The algorithm iterates over all edges stemming from shift/reduce and reduce/reduce conflicts, using a technique similar to the stack duplication used in GLR parsing. We then extend our algorithm to generate negative (i.e., syntactically invalid) test cases, by applying different edge mutation operations during the extraction of test cases from paths.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christoff</first_name>
          <last_name>Rossouw</last_name>
          <affiliation>Stellenbosch University</affiliation>
          <bio>undefined</bio>
          <person_id>christoffrossouw</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bernd</first_name>
          <last_name>Fischer</last_name>
          <affiliation>Stellenbosch University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.sun.ac.za/~bfischer/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/berndfischer/b51999f4-390c-48d9-be54-f3d1ceab7ff8/small.jpg</picture_url>
          <person_id>berndfischer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>36aeb701-df11-43fd-9cfa-4feb05ae807d</slot_id>
      <event_id>4e74b197-d3c2-4abe-92e1-faaed4180310</event_id>
      <title>Featherweight Swift: A Core Calculus for Swift’s Type System</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>14:20</end_time>
      <description>Swift is a modern general-purpose programming language, designed to be a replacement for C-based languages. Although primarily directed at the development of mobile and desktop applications for Apple’s operating systems, Swift’s adoption has been growing steadily in other domains, ranging from server-side web development to machine learning. This success can be partly attributed to a rich type system that enables the design of safe, fast, and expressive programming interfaces. It does so by advocating for a typing discipline based on interfaces, so that code can be written in terms of type requirements rather than properties of a specific implementation. Unfortunately, this richness comes at the cost of complexity, setting a high entry barrier to exploit Swift’s full potential. Furthermore, existing documentation typically only relies on examples, leaving new users with little help to build a deeper understanding of the underlying rules and mechanisms.
This paper aims to tackle this issue by laying out the foundations for a formal framework to reason about Swift’s type system. We introduce Featherweight Swift, a minimal language reminiscent to the lambda calculus, in which all features not essential to describe Swift’s typing rules are dismissed. Featherweight Swift features classes and protocol inheritance, supports retroactive modeling, and emulates Swift’s overriding mechanisms. Yet its formalization fits on a few pages. We present Featherweight Swift’s syntax and semantics. We then elaborate on the usability of our framework to reason about Swift’s features, future extensions, and implementation by discussing a bug in Swift’s compiler, discovered throughout the design of our calculus.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dimitri</first_name>
          <last_name>Racordon</last_name>
          <affiliation>University of Geneva, Centre Universitaire d'Informatique, Geneva, Switzerland</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/dimitriracordon/23c16a97-1d4c-47e1-9270-89755cace04c/small.jpg</picture_url>
          <person_id>dimitriracordon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Didier</first_name>
          <last_name>Buchs</last_name>
          <affiliation>University of Geneva, Centre Universitaire d'Informatique, Geneva, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>didierbuchs</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4ca852ea-7c9c-4d21-8b67-00cce7c0bb2d</slot_id>
      <event_id>b729c3ab-2dd0-40dc-a295-f2f0e47d41fa</event_id>
      <title>Tool Demo: A Gamified Interactive Feedback System for Grammar Development</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>14:00</end_time>
      <description>We describe gtutr, an interactive feedback system designed to assist students in developing context-free grammars and corresponding ANTLR parsers. It intelligently controls students’ access to a large test suite for the target language. After each submission, gtutr analyzes any failing tests and uses the Needleman-Wunsch sequence alignment algorithm over the tests’ rule traces to identify and eliminate similar failing tests. This reduces the redundancy in the feedback that is given to the student and prevents them from being overloaded. gtutr uses gamification to encourage independent problem solving by students: it gives as little information as possible, and students need to prompt the system for further details such as failing tests similar to or different from already seen tests, or even for hints about rules that are the most likely to contain faults. The system visualizes test outcomes over multiple submissions, helping students to keep track of the effects of their changes as their grammar development progresses. gtutr also tracks the students’ information requests and uses this to attenuate marks following an instructor-set penalty schema.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chelsea</first_name>
          <last_name>Barraball</last_name>
          <affiliation>Stellenbosch University</affiliation>
          <bio>undefined</bio>
          <person_id>chelseabarraball</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Moeketsi</first_name>
          <last_name>Raselimo</last_name>
          <affiliation>Stellenbosch University</affiliation>
          <bio>undefined</bio>
          <person_id>moeketsiraselimo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bernd</first_name>
          <last_name>Fischer</last_name>
          <affiliation>Stellenbosch University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.sun.ac.za/~bfischer/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/berndfischer/b51999f4-390c-48d9-be54-f3d1ceab7ff8/small.jpg</picture_url>
          <person_id>berndfischer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>718be37b-8f56-4cea-ba0e-6211cbedfd86</slot_id>
      <event_id>01e48462-0a2e-4222-8656-48d10e93dac1</event_id>
      <title>Grammar-based Testing for Little Languages: An Experience Report with Student Compilers</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>13:40</end_time>
      <description>We report on our experience in using various grammar-based test suite generation methods to test 61 single-pass compilers that undergraduate students submitted for the practical project of a computer architecture course.
We show that (1) all test suites constructed systematically following different grammar coverage criteria fall far behind the instructor’s test suite in achieved code coverage, in the number of triggered semantic errors, and in detected failures and crashes; (2) a medium-sized positive random test suite triggers more crashes than the instructor’s test suite, but achieves lower code coverage and triggers fewer non-crashing errors; and (3) a combination of the systematic and random test suites performs as well or better than the instructor’s test suite in all aspects and identifies errors or crashes in every single submission.
We then develop a light-weight extension of the basic grammar-based testing framework to capture contextual constraints, by encoding scoping and typing information as ``semantic mark-up tokens'' in the grammar rules. These mark-up tokens are interpreted by a small generic core engine when the tests are printed, and tests with a syntactic structure that cannot be completed into a valid program by choosing appropriate identifiers are discarded. We formalize individual error models by overwriting individual mark-up tokens,and generate tests that are guaranteed to break specific contextual properties of the language. We show that a fully automatically generated random test suite with 15 error models achieves roughly the same coverage as the instructor’s test suite, and outperforms it in the number of detected failures and crashes; moreover, all failing tests indicate real errors, and we have detected errors in the instructor’s reference implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Phillip</first_name>
          <last_name>van Heerden</last_name>
          <affiliation>Stellenbosch University</affiliation>
          <bio>undefined</bio>
          <person_id>phillipvanheerden</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Moeketsi</first_name>
          <last_name>Raselimo</last_name>
          <affiliation>Stellenbosch University</affiliation>
          <bio>undefined</bio>
          <person_id>moeketsiraselimo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Konstantinos (Kostis)</first_name>
          <last_name>Sagonas</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/kostissagonas/4dd586b1-8ffe-446f-a179-dad1b81db63a/small.jpg</picture_url>
          <person_id>kostissagonas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Bernd</first_name>
          <last_name>Fischer</last_name>
          <affiliation>Stellenbosch University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.sun.ac.za/~bfischer/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/berndfischer/b51999f4-390c-48d9-be54-f3d1ceab7ff8/small.jpg</picture_url>
          <person_id>berndfischer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>25f6c367-a0e4-4ad8-af0d-d8b3a35ee997</subevent_id>
    <title>SLE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/16</date>
    <url>https://conf.researchr.org/home/sle-2020</url>
    <url_link_display>SLE (Software Language Engineering) 2020</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>25dd4c5b-be21-4183-b2a5-6196cf276b86</slot_id>
      <title>Session: SLE - </title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>08eded9f-a693-4f57-b125-026c3e730b8c</slot_id>
      <event_id>8418bc21-ddd2-4ae2-aef7-57450c6d8922</event_id>
      <title>A Search-Based and Fault-Tolerant Approach to Concurrent Model Synchronisation</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>12:20</end_time>
      <description>In collaboration scenarios, we often encounter situations in which semantically interrelated models are changed concurrently. Concurrent model synchronization denotes the task of keeping these models consistent by propagating changes between them. This is challenging as changes can contradict each other and thus be in conflict. A problem with current synchronisation approaches is that they are often nondeterministic, i.e., the order in which changes are propagated is essential for the result. Furthermore, a common limitation is that the involved models must have been in a consistent state at some point, and that the applied changes are at least valid for the domain in which they were made. We propose a hybrid approach based on Triple Graph Grammars (TGGs) and Integer Linear Programming (ILP) to overcome these issues: TGGs are a grammar-based means that supplies us with a superset of possible synchronization solutions, forming a search space from which an optimum solution incorporating user-defined preferences can be chosen by ILP. Therefore, the proposed method combines configurability by comprising expert knowledge via TGGs with the flexible input handling of search-based techniques: By accepting arbitrary graph structures as input models, the approach is tolerant towards errors induced during the modelling process, i.e., it can cope with input models which do not conform to their metamodel or which cannot be generated by the TGG at hand. The approach is implemented in the model transformation tool eMoflon and evaluated regarding scalability for growing model sizes and an increasing number of changes.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nils</first_name>
          <last_name>Weidmann</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>nilsweidmann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lars</first_name>
          <last_name>Fritsche</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>larsfritsche1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anthony</first_name>
          <last_name>Anjorin</last_name>
          <affiliation>Paderborn University, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/anthonyanjorin1/158aeedd-1bac-498b-9521-79557507e112/small.jpg</picture_url>
          <person_id>anthonyanjorin1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1ff4d0b0-d384-452e-9d6b-2db75e8925c7</slot_id>
      <event_id>0579642d-68a8-476d-85c0-4a8d1667dd31</event_id>
      <title>Behavior Trees in Action: A Study of Robotics Applications</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>12:00</end_time>
      <description>An autonomous robot system combines skills to form increasingly complex behaviors called missions. While skills are often programmed at a relatively low level of abstraction, their coordination is architecturally separated and expressed in higher-level languages or frameworks. Recently, the language of Behavior Trees gained attention among roboticists for this reason. Originally designed for computer games to model autonomous actors, Behavior Trees offer an extensible tree-based representation of missions. However, even though, several implementations of the language are in use, little is known about its usage and scope in the real world. How do behavior trees relate to traditional languages for describing behavior? How are behavior-tree concepts used in applications? What are the benefits of using them?
We present a study of the key language concepts and their use in real-world robotic applications. We identify behavior tree languages and compare their semantics to the most well-known behavior modeling languages: state and activity diagrams. We mine open source repositories for robotics applications that use the language, and analyze this usage. We find that Behavior Trees are a pragmatic language, not fully specified, allowing projects to extend it even for just one model. Behavior trees clearly resemble the models-at-runtime paradigm. We contribute a dataset of real-world behavior models, hoping to inspire the community to use and further develop this language, associated tools, and analysis techniques.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Razan</first_name>
          <last_name>Ghzouli</last_name>
          <affiliation>Chalmers | University of Gothenburg</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://orcid.org/0000-0002-5428-8113</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/razanghzouli/4a1d42cd-e90e-427e-8686-f823139700f3/small.jpg</picture_url>
          <person_id>razanghzouli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thorsten</first_name>
          <last_name>Berger</last_name>
          <affiliation>Chalmers University of Technology, Sweden / University of Gothenburg, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.chalmers.se/~bergert</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/thorstenberger/d2f325bb-820f-49b8-985d-e62ac888dedd/small.jpg</picture_url>
          <person_id>thorstenberger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Einar</first_name>
          <last_name>Broch Johnsen</last_name>
          <affiliation>University of Oslo</affiliation>
          <bio>undefined</bio>
          <person_id>einarbrochjohnsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Swaib</first_name>
          <last_name>Dragule</last_name>
          <affiliation>Chalmers | University of Gothenburg</affiliation>
          <bio>undefined</bio>
          <person_id>swaibdragule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Andrzej</first_name>
          <last_name>Wąsowski</last_name>
          <affiliation>IT University of Copenhagen, Denmark</affiliation>
          <bio>MSc Eng from Warsaw University of Technology (2000) PhD from IT University of Copenhagen (2005)
Interested in developing repeatable software engineering methods, supported by innovative tools and technology, to solve domain specific problems (safety critical systems, industry automation, robotics, legacy systems, and personal data protection).</bio>
          <homepage_url>http://www.itu.dk/people/wasowski</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andrzejwasowski/36304e96-b840-4d13-933d-7f422b4a3ddc/small.jpg</picture_url>
          <person_id>andrzejwasowski</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>93feb3a2-bc6a-4851-ac84-ba18ada31b88</slot_id>
      <event_id>96904519-a65b-454a-beea-44c4b59c05c4</event_id>
      <title>Example-Driven Software Language Engineering</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:40</end_time>
      <description>Language workbenches–tools to define software languages together with their IDEs–are designed to simplify language engineering and implementation: they free language engineers from many meticulous tasks, but oftentimes have a very steep learning curve even for experienced software professionals. With the assumption that meta-definitions are one of the key factors that make language engineering hindered, we introduce an example-driven approach to language definition. We describe in this paper our vision of a web-based tool aimed at beginner language engineers, and list possible requirements for such a tool. A language is defined by giving examples of code written in it using illustrative syntax definition. These examples are then annotated to specify different concerns of language definition–abstract syntax, typing rules, validation rules, formatting rules, and dynamic semantics.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mikhail</first_name>
          <last_name>Barash</last_name>
          <affiliation>University of Bergen, Norway</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://dsl-course.org/mikbar/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mikhailbarash/d876d731-3779-4e11-8aee-de2bcef5e938/small.jpg</picture_url>
          <person_id>mikhailbarash</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ac6407d5-2f67-43af-a45f-1a36618840fe</slot_id>
      <event_id>606ec49c-4792-4253-89ec-4010e21d70de</event_id>
      <title>A Precedence-Driven Approach for Concurrent Model Synchronization Scenarios using Triple Graph Grammars</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:20</end_time>
      <description>Concurrent model synchronization is the task of restoring consistency between two correlated models after they have been changed concurrently and independently. To determine whether such concurrent model changes conflict with each other and to resolve these conflicts taking domain- or user-specific preferences into account is highly challenging. In this paper, we present a framework for concurrent model synchronization algorithms based on Triple Graph Grammars (TGGs). TGGs specify the consistency of correlated models using grammar rules; these rules can be used to derive different consistency restoration operations. Using TGGs, we infer a causal dependency relation for model elements that enables us to detect conflicts non-invasively. Different kinds of conflicts are detected first and resolved by the subsequent conflict resolution process. Users configure the overall synchronization process by orchestrating the application of consistency restoration fragments according to several conflict resolution strategies to achieve individual synchronization goals. As proof of concept, we have implemented this framework in the model transformation tool eMoflon. Our initial evaluation shows that the runtime of our presented approach scales with the size of model changes and conflicts, rather than model size.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lars</first_name>
          <last_name>Fritsche</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>larsfritsche1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jens</first_name>
          <last_name>Kosiol</last_name>
          <affiliation>Philipps-Universität Marburg</affiliation>
          <bio>undefined</bio>
          <person_id>jenskosiol1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Adrian</first_name>
          <last_name>Möller</last_name>
          <affiliation>Technical University of Darmstadt</affiliation>
          <bio>undefined</bio>
          <person_id>adrianmoller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Andy</first_name>
          <last_name>Schürr</last_name>
          <affiliation>TU Darmstadt</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/andyschurr/b3c83371-9583-4f5a-b3ca-1240bf1f9bda/small.jpg</picture_url>
          <person_id>andyschurr</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Gabriele</first_name>
          <last_name>Taentzer</last_name>
          <affiliation>Universität Marburg</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.uni-marburg.de/fb12/swt/gabi-taentzer</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gabrieletaentzer/c2ef5fee-d409-4762-87a4-ad92dda7413b/small.jpg</picture_url>
          <person_id>gabrieletaentzer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7905b151-d2f6-4457-87d3-7346e353bf9f</subevent_id>
    <title>SLE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/17</date>
    <url>https://conf.researchr.org/home/sle-2020</url>
    <url_link_display>SLE (Software Language Engineering) 2020</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>ab5b4802-9f35-4f2a-a712-0d11bb61cdc7</slot_id>
      <title>Session: SLE - </title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a8b4b4ab-b9be-489b-8e16-9df281665d8c</slot_id>
      <event_id>01e48462-0a2e-4222-8656-48d10e93dac1</event_id>
      <title>Grammar-based Testing for Little Languages: An Experience Report with Student Compilers</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>01:40</end_time>
      <description>We report on our experience in using various grammar-based test suite generation methods to test 61 single-pass compilers that undergraduate students submitted for the practical project of a computer architecture course.
We show that (1) all test suites constructed systematically following different grammar coverage criteria fall far behind the instructor’s test suite in achieved code coverage, in the number of triggered semantic errors, and in detected failures and crashes; (2) a medium-sized positive random test suite triggers more crashes than the instructor’s test suite, but achieves lower code coverage and triggers fewer non-crashing errors; and (3) a combination of the systematic and random test suites performs as well or better than the instructor’s test suite in all aspects and identifies errors or crashes in every single submission.
We then develop a light-weight extension of the basic grammar-based testing framework to capture contextual constraints, by encoding scoping and typing information as ``semantic mark-up tokens'' in the grammar rules. These mark-up tokens are interpreted by a small generic core engine when the tests are printed, and tests with a syntactic structure that cannot be completed into a valid program by choosing appropriate identifiers are discarded. We formalize individual error models by overwriting individual mark-up tokens,and generate tests that are guaranteed to break specific contextual properties of the language. We show that a fully automatically generated random test suite with 15 error models achieves roughly the same coverage as the instructor’s test suite, and outperforms it in the number of detected failures and crashes; moreover, all failing tests indicate real errors, and we have detected errors in the instructor’s reference implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Phillip</first_name>
          <last_name>van Heerden</last_name>
          <affiliation>Stellenbosch University</affiliation>
          <bio>undefined</bio>
          <person_id>phillipvanheerden</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Moeketsi</first_name>
          <last_name>Raselimo</last_name>
          <affiliation>Stellenbosch University</affiliation>
          <bio>undefined</bio>
          <person_id>moeketsiraselimo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Konstantinos (Kostis)</first_name>
          <last_name>Sagonas</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/kostissagonas/4dd586b1-8ffe-446f-a179-dad1b81db63a/small.jpg</picture_url>
          <person_id>kostissagonas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Bernd</first_name>
          <last_name>Fischer</last_name>
          <affiliation>Stellenbosch University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.sun.ac.za/~bfischer/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/berndfischer/b51999f4-390c-48d9-be54-f3d1ceab7ff8/small.jpg</picture_url>
          <person_id>berndfischer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bc5f86a9-b34b-4908-817a-173422d97159</slot_id>
      <event_id>b729c3ab-2dd0-40dc-a295-f2f0e47d41fa</event_id>
      <title>Tool Demo: A Gamified Interactive Feedback System for Grammar Development</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>02:00</end_time>
      <description>We describe gtutr, an interactive feedback system designed to assist students in developing context-free grammars and corresponding ANTLR parsers. It intelligently controls students’ access to a large test suite for the target language. After each submission, gtutr analyzes any failing tests and uses the Needleman-Wunsch sequence alignment algorithm over the tests’ rule traces to identify and eliminate similar failing tests. This reduces the redundancy in the feedback that is given to the student and prevents them from being overloaded. gtutr uses gamification to encourage independent problem solving by students: it gives as little information as possible, and students need to prompt the system for further details such as failing tests similar to or different from already seen tests, or even for hints about rules that are the most likely to contain faults. The system visualizes test outcomes over multiple submissions, helping students to keep track of the effects of their changes as their grammar development progresses. gtutr also tracks the students’ information requests and uses this to attenuate marks following an instructor-set penalty schema.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chelsea</first_name>
          <last_name>Barraball</last_name>
          <affiliation>Stellenbosch University</affiliation>
          <bio>undefined</bio>
          <person_id>chelseabarraball</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Moeketsi</first_name>
          <last_name>Raselimo</last_name>
          <affiliation>Stellenbosch University</affiliation>
          <bio>undefined</bio>
          <person_id>moeketsiraselimo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bernd</first_name>
          <last_name>Fischer</last_name>
          <affiliation>Stellenbosch University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.sun.ac.za/~bfischer/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/berndfischer/b51999f4-390c-48d9-be54-f3d1ceab7ff8/small.jpg</picture_url>
          <person_id>berndfischer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c08205b5-d47b-4724-8ade-82776d75d6cf</slot_id>
      <event_id>4e74b197-d3c2-4abe-92e1-faaed4180310</event_id>
      <title>Featherweight Swift: A Core Calculus for Swift’s Type System</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>02:20</end_time>
      <description>Swift is a modern general-purpose programming language, designed to be a replacement for C-based languages. Although primarily directed at the development of mobile and desktop applications for Apple’s operating systems, Swift’s adoption has been growing steadily in other domains, ranging from server-side web development to machine learning. This success can be partly attributed to a rich type system that enables the design of safe, fast, and expressive programming interfaces. It does so by advocating for a typing discipline based on interfaces, so that code can be written in terms of type requirements rather than properties of a specific implementation. Unfortunately, this richness comes at the cost of complexity, setting a high entry barrier to exploit Swift’s full potential. Furthermore, existing documentation typically only relies on examples, leaving new users with little help to build a deeper understanding of the underlying rules and mechanisms.
This paper aims to tackle this issue by laying out the foundations for a formal framework to reason about Swift’s type system. We introduce Featherweight Swift, a minimal language reminiscent to the lambda calculus, in which all features not essential to describe Swift’s typing rules are dismissed. Featherweight Swift features classes and protocol inheritance, supports retroactive modeling, and emulates Swift’s overriding mechanisms. Yet its formalization fits on a few pages. We present Featherweight Swift’s syntax and semantics. We then elaborate on the usability of our framework to reason about Swift’s features, future extensions, and implementation by discussing a bug in Swift’s compiler, discovered throughout the design of our calculus.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dimitri</first_name>
          <last_name>Racordon</last_name>
          <affiliation>University of Geneva, Centre Universitaire d'Informatique, Geneva, Switzerland</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/dimitriracordon/23c16a97-1d4c-47e1-9270-89755cace04c/small.jpg</picture_url>
          <person_id>dimitriracordon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Didier</first_name>
          <last_name>Buchs</last_name>
          <affiliation>University of Geneva, Centre Universitaire d'Informatique, Geneva, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>didierbuchs</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d513fec9-067f-49f6-9454-682efb07f149</slot_id>
      <event_id>bee221c2-518e-4f38-a9b4-996285b8693f</event_id>
      <title>Test Case Generation from Context-Free Grammars Using Generalized Traversal of LR-Automata</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>01:20</end_time>
      <description>Test case generation from context-free grammars typically uses the grammar’s production rules to directly construct words that cover specific sets of derivations. Here, we investigate test case generation by traversing graphs derived from the LR-automata corresponding to the grammars. We develop a new algorithm that generates positive test cases by covering all edges between pairs of directly connected states in a two-phase breadth-first path search. The algorithm iterates over all edges stemming from shift/reduce and reduce/reduce conflicts, using a technique similar to the stack duplication used in GLR parsing. We then extend our algorithm to generate negative (i.e., syntactically invalid) test cases, by applying different edge mutation operations during the extraction of test cases from paths.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christoff</first_name>
          <last_name>Rossouw</last_name>
          <affiliation>Stellenbosch University</affiliation>
          <bio>undefined</bio>
          <person_id>christoffrossouw</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bernd</first_name>
          <last_name>Fischer</last_name>
          <affiliation>Stellenbosch University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.sun.ac.za/~bfischer/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/berndfischer/b51999f4-390c-48d9-be54-f3d1ceab7ff8/small.jpg</picture_url>
          <person_id>berndfischer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>be85a0e9-8c1b-4f55-bde3-0b2e0afac1cc</subevent_id>
    <title>SPLASH Keynotes: S</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>5f9f92fa-5e48-46f1-887c-a26b9c581986</slot_id>
      <title>Session: SPLASH Keynotes - S</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>19:20</start_time>
      <end_time>20:40</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3f629580-500b-4082-ad17-53b871f536f9</slot_id>
      <event_id>a5f428b0-d93e-412f-a7d4-36adba3203c1</event_id>
      <title>Fitzcarraldo — or How to Hack Academia to Build Stuff</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>19:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>20:40</end_time>
      <description>What does a movie about a monomaniacal quest to build an opera house in the Amazon Basin has to do with science? Programming language research is at a crossroads. While formal language techniques are advancing steadily, the transfer of ideas to practice is much slower. Applied research is based on experimentation which is becoming prohibitively onerous. To evaluate any novel idea requires dealing with the complex language ecosystems of the day. Even the simplest innovation may take years of work to try out. Without a realistic evaluation, papers are rejected, and underlying hypotheses remain untested. Academic researchers are in a particularly precarious position. On the one hand, they must compete with industrial R&amp;amp;D teams with massively more resources, and on the other hand, they are beholden to an incentive system that rewards copious publication rates at select conferences. How can we build stuff that matters in such an environment? Are we doomed to failure? In this talk I argue that trying to build stuff is the necessary starting point, failure is expected and should be embraced, as, without it, we are not working on anything that matters. Based on my experience it is possible to navigate the academic system and come up with ideas that occasionally matter.
This talk is given by the recipient of the Dahl Nygaard Senior prize.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>eabe7236-c150-48bb-8409-7d5c24794427</subevent_id>
    <title>SPLASH Keynotes: W</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>622169a6-26f7-47ce-a4ca-37dd03d39c59</slot_id>
      <title>Session: SPLASH Keynotes - W</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d7369bc9-e0dc-49a7-add9-56eb88b344fb</slot_id>
      <event_id>524d2a59-9a05-498f-879b-750d10430c79</event_id>
      <title>Models and Programs: Better Together</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>10:20</end_time>
      <description>Over the past decade, we have seen ubiquitous adoption of Machine Learning (ML) models across many different application domains. In this talk, we explore the connections between ML models and programs, and argue that there are significant advantages in combining ML models with programmatic representations. We present results from our work across different Machine Learning approaches in support of this hypothesis, including Supervised Learning, Bayesian Learning, and Reinforcement Learning. In each case, we show advantages in constructing human readable and interpretable programmatic representations of ML models, and in combining tools and techniques from program analysis and program synthesis with machine learning. We conclude with opportunities in using programming language techniques to make ML models efficient, robust, interpretable, and verifiable.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Sriram</first_name>
          <last_name>Rajamani</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Sriram Rajamani is Distinguished Scientist and Managing Director of Microsoft Research India. His research interests are in designing, building and analyzing computer systems in a principled manner. Over the years he has worked on various topics including Hardware and Software Verification, Type Systems, Language Design, Distributed Systems, Security and Privacy. His current research interest is in combining Program Synthesis and Machine Learning. Together with Tom Ball, he was awarded the CAV 2011 Award for “contributions to software model checking, specifically the development of the SLAM/SDV software model checker that successfully demonstrated computer-aided verification techniques on real programs.” Sriram was elected ACM Fellow in 2015 for contributions to software analysis and defect detection. Recently, Sriram has been elected Fellow of Indian National Academy of Engineering. Sriram has a PhD from UC Berkeley, MS from University of Virginia and BEng from College of Engineering, Guindy, all with specialization in Computer Science. Sriram was general chair for POPL 2015 in India, and was program Co-Chair for CAV 2005. He co-founded the Mysore Park Series, and the ISEC conference series in India. He serves on the CACM editorial board as co-chair for special regional sections, to bring computing innovations from around the world to CACM.</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/sriram/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sriramrajamani/85dbb2f3-41e7-493b-af72-d9a3338eea4e/small.jpg</picture_url>
          <person_id>sriramrajamani</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1cd0c692-fba3-49a0-9132-ecff862e1b04</subevent_id>
    <title>SPLASH Keynotes: T</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>9d400dfc-ade8-42ec-8d5f-de93b8ce0e0c</slot_id>
      <title>Session: SPLASH Keynotes - T</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>19:00</start_time>
      <end_time>20:20</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5410aa9a-4256-46d1-8f83-72b488706446</slot_id>
      <event_id>d9dc8414-a9f1-4c0d-8f5f-a8619dba3298</event_id>
      <title>Testing Deep Neural Networks</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>20:20</end_time>
      <description>The reliability of software that has a Deep Neural Network (DNN) as a component is urgently important today given the increasing number of critical applications being deployed with DNNs. The need for reliability raises a need for rigorous testing of the safety and trustworthiness of these systems. In the last few years, there have been a number of research efforts focused on testing DNNs. However, the test generation techniques proposed so far lack a check to determine whether the test inputs they are generating are valid, and thus invalid inputs are produced. To illustrate this situation, we explored three recent DNN testing techniques. Using deep generative model based input validation, we show that all the three techniques generate significant number of invalid test inputs. We further analyzed the test coverage achieved by the test inputs generated by the DNN testing techniques and showed how invalid test inputs can falsely inflate test coverage metrics. To overcome the inclusion of invalid inputs in testing, we propose a technique to incorporate the valid input space of the DNN model under test in the test generation process. Our technique uses a deep generative model-based algorithm to generate only valid inputs. Results of our empirical studies show that our technique is effective in eliminating invalid tests and boosting the number of valid test inputs generated.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Mary</first_name>
          <last_name>Lou Soffa</last_name>
          <affiliation>University of Virginia</affiliation>
          <bio>Mary Lou Ehnot Soffa is the Owen R. Cheatham Professor of Sciences at the Computer Science Department at the University of Virginia. From 2004 to 2012, she served as the Department Chair at UVA.&amp;nbsp; From 1977 to 2004, she was a Professor of Computer Science at the University of Pittsburgh and also served as the Dean of Graduate Studies in the College of Arts and Sciences from 1991 to 1996. Her research interests include optimizing compilers, virtual execution environments, software testing, program analysis, software security,&amp;nbsp; and software systems for multi-core architectures.&amp;nbsp; She has published over 175 articles and&amp;nbsp; has directed 32 Ph.D. students to completion, half of whom are women.&amp;nbsp; Mary Lou is both&amp;nbsp; an IEEE Fellow and&amp;nbsp; an ACM Fellow. She&amp;nbsp; received the Anita Borg Technical Leadership Award, the Ken Kennedy Award and the Computing Research Association (CRA) Nico Habermann Award.</bio>
          <homepage_url>http://www.cs.virginia.edu/~soffa</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/marylousoffa/40ba6646-fc3d-49d6-937a-c663f01f3942/small.jpg</picture_url>
          <person_id>marylousoffa</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ad16110e-1ba7-4dca-8cfb-17d68d6f5943</subevent_id>
    <title>SPLASH Keynotes: F</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>cef981a6-517a-4855-9161-df5ee9cda560</slot_id>
      <title>Session: SPLASH Keynotes - F</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3fffe650-d3ce-4dd7-9e02-fc4e926a5265</slot_id>
      <event_id>82b7b87c-7cf9-4eb4-b576-e5df43418f5e</event_id>
      <title>Onward! Keynote</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>18:20</end_time>
      <description>Coming soon.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Brittany</first_name>
          <last_name>Johnson</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://brittjay.me</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brittanyjohnson/f29629ed-a67c-4a97-b992-c4e7a8dc8227/small.jpg</picture_url>
          <person_id>brittanyjohnson</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d2d2d500-9881-4de9-8227-88aca395b599</subevent_id>
    <title>SPLASH Keynotes: M</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>aff4a4fd-bedd-4aed-a046-9c3f1f6502d4</slot_id>
      <title>Session: SPLASH Keynotes - M</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2124306f-4801-478c-8b45-c74b16b934c0</slot_id>
      <event_id>48b85f95-7161-4225-83e8-da63006ee69c</event_id>
      <title>Catching More Bugs with Fewer False Alarms</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>10:20</end_time>
      <description>The line between high-assurance and general-purpose software is increasingly blurred, as nowadays nearly any insecure or buggy software can have severe economic consequences. When developers release software, it is critical that there be as few defects (and vulnerabilities) as possible. To check the quality of their code, developers typically write and run test cases, and some may also use static analyses that inspect their code. Yet code is still released with bugs and critical vulnerabilities: testing can not prove the absence of defects, and static analyses often overwhelm developers with false positive reports, making them difficult for the average developer to use. I argue that new dynamic program analyses can act as a force multiplier for developers’ test suites: increasing the number of defects that tests can find without burdening developers with false positive reports. In this talk, I will describe some of my recent work building dynamic analysis systems for taint tracking and checkpointing of JVM-based systems, along with several examples of how these analyses can be integrated with developer-written tests to improve the reliability and fault finding power of those tests.
This talk is given by the recipient of the Dahl Nygaard Junior prize.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Bell</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Jon is an Assistant Professor directing research in Software Engineering and Software Systems at Northeastern University. His research makes it easier for developers to create reliable and secure software by improving software testing and program analysis. Jon’s work on accelerating software testing has been recognized with an ACM SIGSOFT Distinguished Paper Award (ICSE ’14 – Unit Test Virtualization with VMVM), and was the basis for an industrial collaboration with Electric Cloud. His program analysis research has resulted in several widely adopted runtime systems for the JVM, including the Phosphor taint tracking system (OOPSLA ’14) and CROCHET checkpoint/rollback tool (ECOOP ’18). His research has been funded by the NSA and the NSF, and he is the recipient of the NSF CAREER award. At George Mason, Jon taught courses in distributed systems, web development, and program analysis. His teaching at GMU has been recognized with a departmental award. Jon serves on a variety of program committees and was recently co-chair of the PLDI 2020 Artifact Evaluation Committee. As part of his efforts to broaden the participation of underrepresented groups in computing, Jon co-organizes the PL/SE mentoring workshop at SPLASH (in 2017, 2018, 2019 and 2020).</bio>
          <homepage_url>http://jonbell.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanbell/1ef3641d-0ed6-4021-aab6-b13b53962e3d/small.jpg</picture_url>
          <person_id>jonathanbell</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b74572a3-95d1-41a7-982e-9e2d01dc8ef5</subevent_id>
    <title>SPLASH Keynotes: R</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>9970eaef-2167-4135-8666-3e849884b75f</slot_id>
      <title>Session: SPLASH Keynotes - R</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>19:00</start_time>
      <end_time>20:20</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cb7b9dbf-7f9c-4bc1-a1db-73139f05dcc8</slot_id>
      <event_id>f92281cc-89bc-4c25-a94f-18dd4bb6f87f</event_id>
      <title>Why Digital Agriculture is Fertile Ground for Software Systems Research</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>20:20</end_time>
      <description>In this talk, I will try to make a case that more computer systems researchers, including those working on programming languages and software systems, should look for new research opportunities in the field of Digital Agriculture. I will start by describing briefly several examples of broad computing challenges in this field. I will then drill deeper into a few specific examples of past or ongoing software systems projects, both from our research and that of other research groups, where new research was needed to solve important digital agriculture challenges. I will briefly discuss a wide range of federal funding opportunities available for collaborative research spanning Computer Science and many different aspects of agriculture. The key observation is that digital agriculture raises difficult and interesting research challenges for Computer Science researchers in general, and software systems researchers in particular.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Vikram S.</first_name>
          <last_name>Adve</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>Vikram Adve is the Donald B. Gillies Professor of Computer Science at the University of Illinois at Urbana-Champaign and a Professor in Electrical and Computer Engineering. He is a Co-founder and Co-Director of the Center for Digital Agriculture and leads AIFARMS, a $20M National Artificial Intelligence Research Institute funded by NIFA and NSF. Adve’s research interests lie in developing and using compiler techniques to improve the performance, programmability and reliability of computer systems. Adve and his Ph.D. student, Chris Lattner, co-designed the LLVM Compiler Infrastructure, which enables a novel approach to “lifelong compilation” of programs in a wide range of general-purpose programming languages. For example, most mobile apps for the iPhone, iPad, Apple Watch and Apple TV are shipped by developers to Apple in the LLVM compiler representation called “LLVM bitcode” and then compiled and specialized for the various end-user devices. LLVM is widely used in industry today, ranging from mobile devices (e.g., iOS and Android) to supercomputers (e.g., at NVIDIA, Cray, IBM and Intel) to data centers (e.g., at Google). Adve, Lattner and Evan Cheng received the ACM Software System Award in 2012 for co-developing LLVM. Adve has won a ten-year-retrospective Most Influential Paper award at CGO 2004, and distinguished paper awards at several conferences including PLDI 2005, SOSP 2007 and ICSE 2011. He has served as the Associate Editor for the ACM Transactions on Programming Languages and Systems, and co-chaired the Program Committees for ASPLOS 2010, VEE 2008, and LCPC 2007. One of Adve’s Ph.D. students, Robert Bocchino, won the 2010 ACM SIGPLAN Outstanding Dissertation Award and another student, John Criswell, won Honorable Mentions for both the 2014 ACM SIGOPS Dissertation Award and the 2014 ACM Doctoral Dissertation Award. Adve is a Fellow of the ACM and was named a University Scholar at the University of Illinois in 2015. He served as Interim Head of the Computer Science Department from 2017 to 2019.</bio>
          <homepage_url>http://vikram.cs.illinois.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vikramadve/a99a9248-20e3-4738-9200-173c353c5fcb/small.jpg</picture_url>
          <person_id>vikramadve</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>17c79bfd-eaa8-4fbd-bd79-2bd74a37b002</subevent_id>
    <title>SPLASH Keynotes: M</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>6736f291-7c9f-4565-b8cb-b766bbe9b118</slot_id>
      <title>Session: SPLASH Keynotes - M</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>21:00</start_time>
      <end_time>22:20</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5ffd6ef4-f021-4a93-890b-ae1e8c9cd6c8</slot_id>
      <event_id>48b85f95-7161-4225-83e8-da63006ee69c</event_id>
      <title>Catching More Bugs with Fewer False Alarms</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>22:20</end_time>
      <description>The line between high-assurance and general-purpose software is increasingly blurred, as nowadays nearly any insecure or buggy software can have severe economic consequences. When developers release software, it is critical that there be as few defects (and vulnerabilities) as possible. To check the quality of their code, developers typically write and run test cases, and some may also use static analyses that inspect their code. Yet code is still released with bugs and critical vulnerabilities: testing can not prove the absence of defects, and static analyses often overwhelm developers with false positive reports, making them difficult for the average developer to use. I argue that new dynamic program analyses can act as a force multiplier for developers’ test suites: increasing the number of defects that tests can find without burdening developers with false positive reports. In this talk, I will describe some of my recent work building dynamic analysis systems for taint tracking and checkpointing of JVM-based systems, along with several examples of how these analyses can be integrated with developer-written tests to improve the reliability and fault finding power of those tests.
This talk is given by the recipient of the Dahl Nygaard Junior prize.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Bell</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Jon is an Assistant Professor directing research in Software Engineering and Software Systems at Northeastern University. His research makes it easier for developers to create reliable and secure software by improving software testing and program analysis. Jon’s work on accelerating software testing has been recognized with an ACM SIGSOFT Distinguished Paper Award (ICSE ’14 – Unit Test Virtualization with VMVM), and was the basis for an industrial collaboration with Electric Cloud. His program analysis research has resulted in several widely adopted runtime systems for the JVM, including the Phosphor taint tracking system (OOPSLA ’14) and CROCHET checkpoint/rollback tool (ECOOP ’18). His research has been funded by the NSA and the NSF, and he is the recipient of the NSF CAREER award. At George Mason, Jon taught courses in distributed systems, web development, and program analysis. His teaching at GMU has been recognized with a departmental award. Jon serves on a variety of program committees and was recently co-chair of the PLDI 2020 Artifact Evaluation Committee. As part of his efforts to broaden the participation of underrepresented groups in computing, Jon co-organizes the PL/SE mentoring workshop at SPLASH (in 2017, 2018, 2019 and 2020).</bio>
          <homepage_url>http://jonbell.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanbell/1ef3641d-0ed6-4021-aab6-b13b53962e3d/small.jpg</picture_url>
          <person_id>jonathanbell</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a5158b9d-2145-45a9-94e1-46104667ee3c</subevent_id>
    <title>SPLASH Keynotes: S</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>9c34d67b-301a-4ed8-bedb-ad867d606bb3</slot_id>
      <title>Session: SPLASH Keynotes - S</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>07:20</start_time>
      <end_time>08:40</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bde0f112-ddc4-4beb-af9c-07d84d408c35</slot_id>
      <event_id>a5f428b0-d93e-412f-a7d4-36adba3203c1</event_id>
      <title>Fitzcarraldo — or How to Hack Academia to Build Stuff</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>07:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>08:40</end_time>
      <description>What does a movie about a monomaniacal quest to build an opera house in the Amazon Basin has to do with science? Programming language research is at a crossroads. While formal language techniques are advancing steadily, the transfer of ideas to practice is much slower. Applied research is based on experimentation which is becoming prohibitively onerous. To evaluate any novel idea requires dealing with the complex language ecosystems of the day. Even the simplest innovation may take years of work to try out. Without a realistic evaluation, papers are rejected, and underlying hypotheses remain untested. Academic researchers are in a particularly precarious position. On the one hand, they must compete with industrial R&amp;amp;D teams with massively more resources, and on the other hand, they are beholden to an incentive system that rewards copious publication rates at select conferences. How can we build stuff that matters in such an environment? Are we doomed to failure? In this talk I argue that trying to build stuff is the necessary starting point, failure is expected and should be embraced, as, without it, we are not working on anything that matters. Based on my experience it is possible to navigate the academic system and come up with ideas that occasionally matter.
This talk is given by the recipient of the Dahl Nygaard Senior prize.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>489d5c0e-7f24-40c3-bd23-7fc717422246</subevent_id>
    <title>SPLASH Keynotes: W</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>8ed6fc7d-cb9c-4434-a445-af59ca18cf4f</slot_id>
      <title>Session: SPLASH Keynotes - W</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>21:00</start_time>
      <end_time>22:20</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ab61fe80-20f5-4202-933b-00648b3a1b7f</slot_id>
      <event_id>524d2a59-9a05-498f-879b-750d10430c79</event_id>
      <title>Models and Programs: Better Together</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>22:20</end_time>
      <description>Over the past decade, we have seen ubiquitous adoption of Machine Learning (ML) models across many different application domains. In this talk, we explore the connections between ML models and programs, and argue that there are significant advantages in combining ML models with programmatic representations. We present results from our work across different Machine Learning approaches in support of this hypothesis, including Supervised Learning, Bayesian Learning, and Reinforcement Learning. In each case, we show advantages in constructing human readable and interpretable programmatic representations of ML models, and in combining tools and techniques from program analysis and program synthesis with machine learning. We conclude with opportunities in using programming language techniques to make ML models efficient, robust, interpretable, and verifiable.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Sriram</first_name>
          <last_name>Rajamani</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Sriram Rajamani is Distinguished Scientist and Managing Director of Microsoft Research India. His research interests are in designing, building and analyzing computer systems in a principled manner. Over the years he has worked on various topics including Hardware and Software Verification, Type Systems, Language Design, Distributed Systems, Security and Privacy. His current research interest is in combining Program Synthesis and Machine Learning. Together with Tom Ball, he was awarded the CAV 2011 Award for “contributions to software model checking, specifically the development of the SLAM/SDV software model checker that successfully demonstrated computer-aided verification techniques on real programs.” Sriram was elected ACM Fellow in 2015 for contributions to software analysis and defect detection. Recently, Sriram has been elected Fellow of Indian National Academy of Engineering. Sriram has a PhD from UC Berkeley, MS from University of Virginia and BEng from College of Engineering, Guindy, all with specialization in Computer Science. Sriram was general chair for POPL 2015 in India, and was program Co-Chair for CAV 2005. He co-founded the Mysore Park Series, and the ISEC conference series in India. He serves on the CACM editorial board as co-chair for special regional sections, to bring computing innovations from around the world to CACM.</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/sriram/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sriramrajamani/85dbb2f3-41e7-493b-af72-d9a3338eea4e/small.jpg</picture_url>
          <person_id>sriramrajamani</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>cf72f105-5a07-4e32-9ad6-63560feb3883</subevent_id>
    <title>SPLASH Keynotes: R</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>6ef37ff2-e0f1-47f7-aafa-a4260b2084ab</slot_id>
      <title>Session: SPLASH Keynotes - R</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>07:00</start_time>
      <end_time>08:20</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>51acb071-0fd1-46b3-b96b-af479bc68e29</slot_id>
      <event_id>f92281cc-89bc-4c25-a94f-18dd4bb6f87f</event_id>
      <title>Why Digital Agriculture is Fertile Ground for Software Systems Research</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>08:20</end_time>
      <description>In this talk, I will try to make a case that more computer systems researchers, including those working on programming languages and software systems, should look for new research opportunities in the field of Digital Agriculture. I will start by describing briefly several examples of broad computing challenges in this field. I will then drill deeper into a few specific examples of past or ongoing software systems projects, both from our research and that of other research groups, where new research was needed to solve important digital agriculture challenges. I will briefly discuss a wide range of federal funding opportunities available for collaborative research spanning Computer Science and many different aspects of agriculture. The key observation is that digital agriculture raises difficult and interesting research challenges for Computer Science researchers in general, and software systems researchers in particular.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Vikram S.</first_name>
          <last_name>Adve</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>Vikram Adve is the Donald B. Gillies Professor of Computer Science at the University of Illinois at Urbana-Champaign and a Professor in Electrical and Computer Engineering. He is a Co-founder and Co-Director of the Center for Digital Agriculture and leads AIFARMS, a $20M National Artificial Intelligence Research Institute funded by NIFA and NSF. Adve’s research interests lie in developing and using compiler techniques to improve the performance, programmability and reliability of computer systems. Adve and his Ph.D. student, Chris Lattner, co-designed the LLVM Compiler Infrastructure, which enables a novel approach to “lifelong compilation” of programs in a wide range of general-purpose programming languages. For example, most mobile apps for the iPhone, iPad, Apple Watch and Apple TV are shipped by developers to Apple in the LLVM compiler representation called “LLVM bitcode” and then compiled and specialized for the various end-user devices. LLVM is widely used in industry today, ranging from mobile devices (e.g., iOS and Android) to supercomputers (e.g., at NVIDIA, Cray, IBM and Intel) to data centers (e.g., at Google). Adve, Lattner and Evan Cheng received the ACM Software System Award in 2012 for co-developing LLVM. Adve has won a ten-year-retrospective Most Influential Paper award at CGO 2004, and distinguished paper awards at several conferences including PLDI 2005, SOSP 2007 and ICSE 2011. He has served as the Associate Editor for the ACM Transactions on Programming Languages and Systems, and co-chaired the Program Committees for ASPLOS 2010, VEE 2008, and LCPC 2007. One of Adve’s Ph.D. students, Robert Bocchino, won the 2010 ACM SIGPLAN Outstanding Dissertation Award and another student, John Criswell, won Honorable Mentions for both the 2014 ACM SIGOPS Dissertation Award and the 2014 ACM Doctoral Dissertation Award. Adve is a Fellow of the ACM and was named a University Scholar at the University of Illinois in 2015. He served as Interim Head of the Computer Science Department from 2017 to 2019.</bio>
          <homepage_url>http://vikram.cs.illinois.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vikramadve/a99a9248-20e3-4738-9200-173c353c5fcb/small.jpg</picture_url>
          <person_id>vikramadve</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d9e93da5-aa31-453c-bfaa-4db6ce80f7bc</subevent_id>
    <title>SPLASH Keynotes: T</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>70b51a47-9cfa-4d0b-8f8e-89c409a29164</slot_id>
      <title>Session: SPLASH Keynotes - T</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>07:00</start_time>
      <end_time>08:20</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6e91ccd5-704d-45e4-a55b-c074850498c1</slot_id>
      <event_id>d9dc8414-a9f1-4c0d-8f5f-a8619dba3298</event_id>
      <title>Testing Deep Neural Networks</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>08:20</end_time>
      <description>The reliability of software that has a Deep Neural Network (DNN) as a component is urgently important today given the increasing number of critical applications being deployed with DNNs. The need for reliability raises a need for rigorous testing of the safety and trustworthiness of these systems. In the last few years, there have been a number of research efforts focused on testing DNNs. However, the test generation techniques proposed so far lack a check to determine whether the test inputs they are generating are valid, and thus invalid inputs are produced. To illustrate this situation, we explored three recent DNN testing techniques. Using deep generative model based input validation, we show that all the three techniques generate significant number of invalid test inputs. We further analyzed the test coverage achieved by the test inputs generated by the DNN testing techniques and showed how invalid test inputs can falsely inflate test coverage metrics. To overcome the inclusion of invalid inputs in testing, we propose a technique to incorporate the valid input space of the DNN model under test in the test generation process. Our technique uses a deep generative model-based algorithm to generate only valid inputs. Results of our empirical studies show that our technique is effective in eliminating invalid tests and boosting the number of valid test inputs generated.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Mary</first_name>
          <last_name>Lou Soffa</last_name>
          <affiliation>University of Virginia</affiliation>
          <bio>Mary Lou Ehnot Soffa is the Owen R. Cheatham Professor of Sciences at the Computer Science Department at the University of Virginia. From 2004 to 2012, she served as the Department Chair at UVA.&amp;nbsp; From 1977 to 2004, she was a Professor of Computer Science at the University of Pittsburgh and also served as the Dean of Graduate Studies in the College of Arts and Sciences from 1991 to 1996. Her research interests include optimizing compilers, virtual execution environments, software testing, program analysis, software security,&amp;nbsp; and software systems for multi-core architectures.&amp;nbsp; She has published over 175 articles and&amp;nbsp; has directed 32 Ph.D. students to completion, half of whom are women.&amp;nbsp; Mary Lou is both&amp;nbsp; an IEEE Fellow and&amp;nbsp; an ACM Fellow. She&amp;nbsp; received the Anita Borg Technical Leadership Award, the Ken Kennedy Award and the Computing Research Association (CRA) Nico Habermann Award.</bio>
          <homepage_url>http://www.cs.virginia.edu/~soffa</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/marylousoffa/40ba6646-fc3d-49d6-937a-c663f01f3942/small.jpg</picture_url>
          <person_id>marylousoffa</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>aa933de0-b7be-4679-951e-064a37c0c76f</subevent_id>
    <title>SPLASH Keynotes: F</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>0549fd29-95dd-43c5-b529-09083703c6c6</slot_id>
      <title>Session: SPLASH Keynotes - F</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>23317518-977d-4bd3-b559-1371718c0031</slot_id>
      <event_id>82b7b87c-7cf9-4eb4-b576-e5df43418f5e</event_id>
      <title>Onward! Keynote</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>06:20</end_time>
      <description>Coming soon.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Brittany</first_name>
          <last_name>Johnson</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://brittjay.me</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brittanyjohnson/f29629ed-a67c-4a97-b992-c4e7a8dc8227/small.jpg</picture_url>
          <person_id>brittanyjohnson</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>041fba4f-f5a3-4e86-90f0-200d2c3c2b06</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/15</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>9b7f0fcf-b9e8-4881-b431-09bceb693f22</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>22477a3d-2625-4c61-9d3b-9945828f38d4</slot_id>
      <event_id>77baa9ff-0f71-458a-b6de-9cff6f8a7642</event_id>
      <title>Principles and Patterns of JastAdd-style Reference Attribute Grammars</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>14:20</end_time>
      <description>Reference attribute grammars (RAGs) have reached a level of maturity where they are supported by several tools, and have gained traction in both academic and industrial language tool development. However, despite a lot of accumulated knowledge of how to best develop RAGs in practice, there is limited support to guide practitioners.
In this paper, we address this issue by focusing on one RAG tool, JastAdd, and by defining principles and patterns for development of RAGs with this tool. We evaluate the proposed principles and patterns empirically using focus groups with a mix of beginners and experienced users from both academia and industry. The results indicate that the principles and patterns capture the practice of developing JastAdd RAGs well, help practitioners to become aware of useful patterns, and provide a common language to more efficiently reason about the practice of developing JastAdd RAGs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Niklas</first_name>
          <last_name>Fors</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.lth.se/niklas_fors</homepage_url>
          <person_id>niklasfors</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Emma</first_name>
          <last_name>Söderberg</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/emmasoderberg/7abc495e-ac1f-4cae-9f68-15a869dcb648/small.jpg</picture_url>
          <person_id>emmasoderberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Görel</first_name>
          <last_name>Hedin</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/gorelhedin1/889e8014-52c5-4f2f-949a-0f92539b1e59/small.jpg</picture_url>
          <person_id>gorelhedin1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5bcdeb7d-95d0-4a17-abc4-0e44ea5e0d57</slot_id>
      <event_id>4752652a-8405-4b5e-90da-50c7de7fada9</event_id>
      <title>Multi-Stage Programming in the Large with Staged Classes</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>13:20</end_time>
      <description>Multi-stage programming (MSP) holds great promise, allowing the reliable generation of specialized, partially-evaluated code with static type- and scope-safety guarantees. Yet, we argue that MSP has not reached its full potential yet, as it has been traditionally limited to generating expressions, and has lacked principled facilities for generating modular programs and data structures. In that sense, we argue that MSP has been reserved for programming “in the small,” focused on generating efficient kernels of computation on the scale of single function bodies. We present a novel technique called staged classes, which extends MSP with the ability to manipulate class definitions as first-class constructs. This lets programmers use MSP “in the large,” on the level of applications, rather than mere functions. This way, applications can be designed in an abstract and modular way without runtime cost, as staged classes guarantee the removal of all staging-time abstractions, resulting in the generation of efficient specialized modules and data structures. We describe the design of a prototype relational database system in Scala, which uses several stages of runtime compilation to maximize the efficiency of query execution and data storage. We also show that staged classes can be used for defining type- and scope-safe implementations of type providers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lionel</first_name>
          <last_name>Parreaux</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.epfl.ch/lionel.parreaux/?lang=en</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lionelparreaux/292d178a-af9d-419f-9e04-8a4672226fd5/small.jpg</picture_url>
          <person_id>lionelparreaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Amir</first_name>
          <last_name>Shaikhha</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <person_id>amirshaikhha</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>71848002-bf0d-4f39-ae47-abd73320dabb</slot_id>
      <event_id>0547992f-d9b7-49e0-b616-0dc25b5ef4a9</event_id>
      <title>Software Language Engineers' Worst Nightmare</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>13:40</end_time>
      <description>Many techniques in software language engineering get their first validation by being prototyped to work on one particular language such as Java, Scala, Scheme, or ML, or a subset of such a language. Claims of their generalisability, as well as discussion on potential threats to their external validity, are often based on authors’ ad hoc understanding of the world outside their usual comfort zone. To facilitate and simplify such discussions by providing a solid measurable ground, we propose a language called µCobol [the name is intentionally changed to avoid deanonymisation during the paper review period, which was specifically designed to contain features that turn processing legacy programming languages such as COBOL, FORTRAN, PL/I, REXX, CLIST, and 4GLs, into such a challenge. The language is minimal by design so that it can help to quickly find weaknesses in frameworks making them inapplicable to dealing with legacy software. However, applying new techniques of software language engineering and reverse engineering to such a small language will not be too tedious and overwhelming. µCobol was designed in collaboration with industrial compiler developers by systematically traversing features of several second, third and fourth generation languages to identify the core culprits in making development of compiler for legacy languages difficult.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vadim</first_name>
          <last_name>Zaytsev</last_name>
          <affiliation>University of Twente, The Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://grammarware.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vadimzaytsev/fe6c221f-75d5-4fbc-ac41-be9c99349b5d/small.jpg</picture_url>
          <person_id>vadimzaytsev</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>91217aa5-b689-49f8-9542-04728b000d7c</slot_id>
      <event_id>2959d666-0f62-48cd-88fd-eb2adec902b9</event_id>
      <title>Reorganizing queries with grouping</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>14:00</end_time>
      <description>Language-integrated query has attracted much attention from researchers and engineers. It enables one to write a database query with high-level abstractions, which makes it possible to compose, iterate, and reuse queries in a sophisticated way. Cheney et al. proposed a two-level language for this purpose, and succeeded in generating efficient queries by program transformation. Recently Okura et al. extended their language to cover grouping (GROUP BY) and aggregate functions in SQL. They decompose a query with grouping into a combination of small primitives and applies Cheney et al.’s translation to eliminate nested data structures. It works, but still has a problem; excessively large queries may sometimes be generated due to decomposition.
This paper proposes a solution for this problem to complete the picture. Our key idea is re-organization of nested control structures. While Okura et al.’s decomposed form is useful while a query is being transformed by Cheney et al.’s transformation, it is not optimal when SQL queries are generated. We propose an algorithm to unify (or fuse) nested control structures while keeping the absence of nested data structures. An important issue is to avoid correlated subqueries, and our algorithm eliminates them as much as possible. We have applied our technique to various example queries, and conducted performance measurements, which shows the usefulness of our work.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rui</first_name>
          <last_name>Okura</last_name>
          <affiliation>University of Tsukuba</affiliation>
          <bio>undefined</bio>
          <person_id>ruiokura</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yukiyoshi</first_name>
          <last_name>Kameyama</last_name>
          <affiliation>University of Tsukuba, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tsukuba.ac.jp/~kam/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yukiyoshikameyama/a7ae9aee-0992-4ddf-ae1d-6fee59d9e814/small.jpg</picture_url>
          <person_id>yukiyoshikameyama</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d73f0e92-2474-4728-a5fa-ccbe3eb0a032</subevent_id>
    <title>GPCE: GPCE/SLE Opening</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/15</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
    </tracks>
    <timeslot>
      <slot_id>bcac1561-0316-4e2e-9841-c176e63d3980</slot_id>
      <title>Session: GPCE - GPCE/SLE Opening</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>21:00</start_time>
      <end_time>21:40</end_time>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a12e44d0-227a-4e5d-b405-df9ec6c9afd3</slot_id>
      <event_id>bb9db12e-2afb-4297-aede-22b724436e5a</event_id>
      <title>GPCE/SLE Opening</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:40</end_time>
      <description>undefined</description>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a6e74c7d-e757-4163-94cf-25c2824d0b12</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/15</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>020c3f9a-4a59-4505-ae56-99e5030d08e8</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>09:40</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1e03b49d-b637-4022-97aa-d6b9c5be28c1</slot_id>
      <event_id>4609d389-c96c-41b0-9d37-2e67d40eb626</event_id>
      <title>Gradually Typing Strategies</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>10:20</end_time>
      <description>The Stratego language supports program transformation by means of term rewriting with programmable rewriting strategies. Stratego’s traversal primitives support concise definition of generic tree traversals. Stratego is a dynamically typed language because its features cannot be captured fully by a static type system. While dynamic typing makes for a flexible programming model, it also leads to unintended type errors, code that is harder to maintain, and missed opportunities for optimization.
In this paper, we introduce a gradual type system for Stratego that combines the flexibility of dynamically typed generic programming, where needed, with the safety of statically declared and enforced types, where possible. To make sure that statically typed code cannot go wrong, all access to statically typed code from dynamically typed code is protected by dynamic type checks (casts). The type system is backwards compatible such that types can be introduced incrementally to existing Stratego programs. We formally define a type system for Core Gradual Stratego, discuss its implementation in a new type checker for Stratego, and present an evaluation of its impact on Stratego programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jeff</first_name>
          <last_name>Smits</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>I am a PhD student in the Programming Languages Research Group at Delft University of Technology. I have various research interests around language design and compiler technology. I’ve worked on declarative specification of data-flow analysis, practical incremental compilation for existing languages, and gradual types. I’ve designed FlowSpec, a domain-specific language for the specification of data-flow analysis. For incremental compilation I’ve taken apart the compiler of the Stratego term transformation language, and reassembled it as an incremental compiler. I’m currently working on introducing a gradual type system to Stratego. FlowSpec and Stratego are part of the Spoofax Language Workbench. I am supervised by Eelco Visser.</bio>
          <homepage_url>https://www.jeffsmits.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeffsmits/1298c3fc-d485-44ed-b451-af24ac2f3b7e/small.jpg</picture_url>
          <person_id>jeffsmits</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science at Delft University of Technology. He received a master’s and doctorate in computer science from the University of Amsterdam in 1993 and 1997, respectively. Previously he served as postdoc at the Oregon Graduate Institute, as Assistant Professor at Utrecht University, and as Associate Professor at TU Delft.
His research interests include programming languages, software language engineering, domain-specific programming languages, program transformation, syntax definition, and parsing. With his students he has designed and implemented the Spoofax language workbench, as well as many domain-specific languages, including DSLs for syntax definition (SDF2, SDF3), program transformation (Stratego), static semantics (NaBL, Statix), dynamic semantics (DynSem), software deployment (Nix), web application development (WebDSL), and mobile phone applications (mobl). In the language designer’s workbench project he is pursuing high-level declarative language definition that serves for language implementation and verification.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5b662b98-0c65-4c16-85b8-fd8916a9684b</slot_id>
      <event_id>db2ef237-4d82-43ee-ae90-0249136f777e</event_id>
      <title>Modeling Black-Box Components with Probabilistic Synthesis</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>10:00</end_time>
      <description>This paper is concerned with synthesizing programs based on \emph{black-box} oracles: we are interested in the case where there exists an executable implementation of a component or library, but its internal structure is unknown. We are just provided with its API or function signature, and aim to synthesize a program with equivalent behavior.
To attack this problem, we detail Presyn: a program synthesizer designed for flexible interoperation with existing programs and compiler toolchains. By first generating input-output pairs based on a function signature, Presyn uses high-level imperative control-flow structures and a pair of cooperating predictive models to efficiently narrow the space of potential programs. These models can be trained effectively on small corpora of synthesized examples.
We evaluate Presyn against four leading program synthesizers on a collection of 112 synthesis benchmarks collated from previous studies and real-world software libraries. We show that Presyn is able to synthesize a wider range of programs than each of them with less human input. We present two case studies: accelerator library porting and detection of duplicated library reimplementations that demonstrate the applicability of our approach on real world code and software engineering problems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bruce</first_name>
          <last_name>Collie</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>brucecollie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jackson</first_name>
          <last_name>Woodruff</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>jacksonwoodruff</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>O'Boyle</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>michaeloboyle</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>acc4b2ec-ef14-4a4e-bcf6-8c620d3ba3da</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/15</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>4d308d93-9bc2-4ba1-b672-0e302a6ac641</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>123db14b-432f-4546-98f3-555108e94627</slot_id>
      <event_id>72c19935-2e93-485f-b44c-07eaf52f87ca</event_id>
      <title>Block-Based Syntax from Context-Free Grammars</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>15:40</end_time>
      <description>Block-based programming systems employ a jigsaw metaphor to write programs. They are popular in the domain of programming education (e.g., Scratch), but also used as programming interface for end-users in other domains, such as arts, robotics, and configuration management. In particular, block-based interfaces promise a convenient interface for domain-specific languages (DSLs) for domain experts who might lack a traditional programming education. However, building a block-based environment for a DSL from scratch requires significant effort. This paper presents an approach to engineer block-based language interfaces by reusing existing language artifacts. In particular, we present Kogi, a tool for deriving block-based environments from context-free grammars. We identify and define the abstract structure for describing block-based environments. Kogi transforms a context-free grammar into this structure, which is then generated to a block-based environment based on Google Blockly. The approach is illustrated with four case studies, a DSL for state machines, Sonification Blocks (a DSL for sound synthesis), Pico (a simple programming language), and QL (a DSL for questionnaires). The results show that usable block-based environments can be derived from context-free grammars, and with an order of magnitude reduction in effort.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mauricio</first_name>
          <last_name>Verano Merino</last_name>
          <affiliation>Technische Universiteit Eindhoven</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/mauricioveranomerino/e4a3ec56-b66f-4885-9989-c4a230e08446/small.jpg</picture_url>
          <person_id>mauricioveranomerino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tijs</first_name>
          <last_name>van der Storm</last_name>
          <affiliation>CWI &amp; University of Groningen, Netherlands</affiliation>
          <bio>Tijs van der Storm is senior researcher in the Software Analysis and Transformation (SWAT) group at Centrum Wiskunde &amp;amp; Informatica (CWI) in Amsterdam, and full professor in Software Engineering at the University of Groningen in Groningen. His research focuses on improving programmer experience through new and better software languages and developing the tools and techniques to engineer them in a modular and interactive fashion.</bio>
          <homepage_url>http://www.cwi.nl/~storm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tijsvanderstorm/1c2fdfb2-3ce0-4e75-91af-35d9a48f56c5/small.jpg</picture_url>
          <person_id>tijsvanderstorm</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>379fc491-f1ee-4f69-a8ed-83a208d6a7ce</slot_id>
      <event_id>7d0ca593-ff13-49f0-9525-bf519bd5fda8</event_id>
      <title>Extrinsically Typed Operational Semantics for Functional Languages</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>16:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>16:20</end_time>
      <description>The research line on intrinsic typing has demonstrated that the type soundness of languages can be derived from type checking their implementation in a host language with strong meta-theoretic properties. In this paper, we take a different perspective in type checking language definitions for their soundness.
We present an extrinsic type system in which types are used to classify parts of the operational semantics of a language, and to model a common language design organization.
The resulting typing discipline guarantees that the language at hand is automatically type sound.
A benefit of extrinsic typing is that, thanks to the use of types to model language design, our type checker has a high-level view on the language being analyzed and can report messages using the same jargon of language designers.
We have implemented our type system in the lang-n-check tool, and we have applied it to derive the type soundness of several functional languages, including those with recursive types, polymorphism, exceptions, lists, sums, and several common types and operators.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matteo</first_name>
          <last_name>Cimini</last_name>
          <affiliation>University of Massachusetts Lowell</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cimini.info</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matteocimini/2ceb8176-9ce7-4024-a7f2-6bf8c93a1f00/small.jpg</picture_url>
          <person_id>matteocimini</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dale</first_name>
          <last_name>Miler</last_name>
          <affiliation>INRIA Saclay and LIX</affiliation>
          <bio>Dale Miller received his PhD in Mathematics in 1983 from Carnegie Mellon University. He has been a professor at the University of Pennsylvania and Ecole Polytechnique (France) and Department Head in Computer Science and Engineering at Pennsylvania State University. He has held visiting positions at the universities of Aix-Marseille, Sienna, Genoa, Pisa, and Edinburgh. He is currently Director of Research (classe exceptionnelle) at Inria Saclay where he was the Scientific Leader of the Parsifal team for 12 years.
Miller was a two-term editor-in-chief of the ACM Transactions on Computational Logic. He is a member of editorial board of the Journal of Automated Reasoning. He is the General Chair for LICS until 2021. In 2014 he was a PC chair for CSL and LICS. He was awarded an ERC Advanced Grant in 2011 and the LICS Test-of-Time awards in 2011 and 2014 for papers written in 1991 and 1994.</bio>
          <homepage_url>http://www.lix.polytechnique.fr/Labo/Dale.Miller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/dalemiler/feea0ac3-4b48-4ddb-a086-40503abc9417/small.jpg</picture_url>
          <person_id>dalemiler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jeremy G.</first_name>
          <last_name>Siek</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>Jeremy Siek is a Professor at Indiana University Bloomington. Jeremy’s areas of research include programming language design, type systems, mechanized theorem proving using proof assistants, and optimizing compilers. Jeremy’s Ph.D. thesis explored foundations for constrained templates, aka the “concepts” proposal for C++. Prior to that, Jeremy developed the Boost Graph Library, a C++ generic library for graph algorithms and data structures. Jeremy post-doc’d at Rice University where he developed the idea of gradual typing: a type system that integrates both dynamic and static typing in the same programming language. Jeremy is currently working on several open questions regarding gradual typing. Is the polymorphic blame calculus really parametric? How should gradual typing be combined with other features such as dependent types? What is the formal criteria for gradually typed languages? Is it possible to create a high-performance implementation of a gradually-typed languages? In 2009 Jeremy received the NSF CAREER award to fund his project: “Bridging the Gap Between Prototyping and Production”. In 2010 and again in 2015, Jeremy was awarded a Distinguished Visiting Fellowship from the Scottish Informatics &amp;amp; Computer Science Alliance.</bio>
          <homepage_url>http://homes.soic.indiana.edu/jsiek/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeremysiek/4365edf9-715f-46e0-8867-4ea5fb6341ad/small.jpg</picture_url>
          <person_id>jeremysiek</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>45b46dcf-d3bd-4f4b-9d6f-a2af6e7235fa</slot_id>
      <event_id>01597700-9cb9-405f-8faa-012932634461</event_id>
      <title>Manipulating GUI Structures Declaratively</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>15:20</end_time>
      <description>GUIs often contain structures that are incidental, not properly manipulatable through well-defined APIs. For example, modifying a list of items in a GUI’s model may require extraneous bookkeeping operations in the view, such as adding and removing event handlers, and updating the menu structure. Observing GUIs in practice alludes to that programmers may find it difficult or tedious to implement complete and convenient sets of operations for manipulating various structures: useful operations for adding, inserting, swapping, or reordering elements are often missing, inconsistent, or limited. This paper introduces a DSL for programming operations that manipulate such incidental structures. The programmer specifies structures via relations between elements, concretely by defining methods that unestablish and establish a relation. This gives the programmer an ability to describe structural transformations via rules that control which relations should hold before and after a rule is applied. The API for structure manipulation is generated from these rules. Our DSL can give an abstract view on ad-hoc structures, making it easier to provide the necessary set of operations for their convenient manipulation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Knut Anders</first_name>
          <last_name>Stokke</last_name>
          <affiliation>University of Bergen, Norway</affiliation>
          <bio>undefined</bio>
          <person_id>knutandersstokke</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mikhail</first_name>
          <last_name>Barash</last_name>
          <affiliation>University of Bergen, Norway</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://dsl-course.org/mikbar/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mikhailbarash/d876d731-3779-4e11-8aee-de2bcef5e938/small.jpg</picture_url>
          <person_id>mikhailbarash</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jaakko</first_name>
          <last_name>Järvi</last_name>
          <affiliation>University of Bergen</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://parasol.tamu.edu/~jarvi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jaakkojarvi/2baa5bc6-a9c0-42a0-a4ca-f7f878dd3381/small.jpg</picture_url>
          <person_id>jaakkojarvi</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a7186f42-0f28-4d45-84f0-34ae12cfb071</slot_id>
      <event_id>a26c3bc5-002a-4c10-8600-68b7c2ad453c</event_id>
      <title>PReGO: a Generative Methodology for Satisfying Real-Time Requirements on COTS-based Systems - Definition and Experience Report</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>16:00</end_time>
      <description>Satisfying real-time requirements in cyber-physical systemsis challenging as timing behaviour depends on the applica-tion software, the embedded hardware, as well as the exe-cution environment. This challenge is exacerbated as real-world, industrial systems often use unpredictable hardwareand software libraries or operating systems with timing haz-ards and proprietary device drivers. All these issues limitor entirely prevent the application of established real-timeanalysis techniques.
This paper describes PReGO, a partially generative method-ology for satisfying real-time requirements in industrial usecases developed without real-time techniques in mind. Weapply our methodology to a Search &amp;amp; Rescue applicationrunning on a fixed-wing drone with COTS components, in-cluding a NVIDIA Jetson board and a stock Ubuntu/Linux.We empirically evaluate the impact of each integration stepand demonstrate the effectiveness of our methodology inmeeting real-time application requirements in terms of dead-line misses and energy consumption.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Rouxel</last_name>
          <affiliation>University of Amsterdam</affiliation>
          <bio>undefined</bio>
          <person_id>benjaminrouxel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ulrik</first_name>
          <last_name>Schultz</last_name>
          <affiliation>University of Southern Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mmmi.sdu.dk/~ups</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ulrikschultz/102a6087-5b8d-48ec-b10d-8c3b6ab5b193/small.jpg</picture_url>
          <person_id>ulrikschultz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benny</first_name>
          <last_name>Akesson</last_name>
          <affiliation>University of Amsterdam, Netherlands and TNO, the Netherlands Organisation</affiliation>
          <bio>undefined</bio>
          <person_id>bennyakesson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jesper</first_name>
          <last_name>Holst</last_name>
          <affiliation>Sky-Watch, Danemark</affiliation>
          <bio>undefined</bio>
          <person_id>jesperholst</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ole</first_name>
          <last_name>Jorgensen</last_name>
          <affiliation>Sky-Watch, Danemark</affiliation>
          <bio>undefined</bio>
          <person_id>olejorgensen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Clemens</first_name>
          <last_name>Grelck</last_name>
          <affiliation>University of Amsterdam</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://staff.fnwi.uva.nl/c.u.grelck/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/clemensgrelck/09259ddd-cfb8-4f7b-882a-e3c3d2a4c3bd/small.jpg</picture_url>
          <person_id>clemensgrelck</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>aa0329c8-7ac5-4509-be60-0f719436b401</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/16</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>f5324ca0-21f7-41c6-83a1-e6514cb3425a</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>07:00</start_time>
      <end_time>08:20</end_time>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4993d388-408f-4527-96d3-934cf6ec27da</slot_id>
      <event_id>c70da96c-88b3-41a8-acaf-9b1776c8dd25</event_id>
      <title>A Domain-Specific Language for Filtering in Application Level Gateways</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>07:20</end_time>
      <description>Application-level packet filtering is a technique for network access control in which an “application-level gateway” intercepts network packages at the application level (e.g., HTTP, FTP), scans them for security cooncerns and optionally logs, rewrites or discards them. Existing application-level filters express their filtering rules in general-purpose languages, which limits the correctness guarantees available for them.
We present the first declarative language for application-level network filtering, developed at [COMPANY]. Our DSL uses security assertions to express properties that packets must have to be allowed through the network (e.g., “IMAP packet contains no executable attachment” or “SQL reply contains only explicitly permitted columns”), along with remedies that either reject or rewrite undesirable packets.
We have designed the language around the needs of network filter developers, with a focus on correctness: our language can statically verify several properties of filter programs, such as well-formedness of the outcome, confluence, and termination, with the help of an off-the-shelf SMT solver.
Our initial results show that the language is sufficiently expressive for a variety of network protocols, closely maps to the application domain, is usable by network filter engineers, and provides strong correctness guarantees.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hampus</first_name>
          <last_name>Balldin</last_name>
          <affiliation>Advenica AB, Malmö</affiliation>
          <bio>undefined</bio>
          <person_id>hampusballdin1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Reichenbach</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/christophreichenbach/04687677-a813-459e-8929-d1e4a32627c6/small.jpg</picture_url>
          <person_id>christophreichenbach</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>77eecf80-0780-4f1c-89a1-140522380bda</slot_id>
      <event_id>bf859d8b-5d82-4d81-92fe-9bffb332dc89</event_id>
      <title>Towards the Optical Character Recognition of DSLs</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>07:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>07:40</end_time>
      <description>OCR engines aim to identify and extract text strings fromdocuments or images. While current efforts focus mostly inmainstream languages, there is little support for program-ming or domain-specific languages (DSLs). In this paper, wepresent our vision about the current state of OCL recognitionfor DSLs and its challenges. We discuss some strategies toimprove the OCR quality applied to DSL textual expressionsby leveraging DSL specifications and domain data. To bettersupport our ideas we present the preliminary results of anempirical study and outline a research roadmap.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jorge</first_name>
          <last_name>Perianez Pascual</last_name>
          <affiliation>Universidad de Extremadura</affiliation>
          <bio>undefined</bio>
          <person_id>jorgeperianezpascual</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roberto</first_name>
          <last_name>Rodriguez-Echeverria</last_name>
          <affiliation>Universidad de Extremadura</affiliation>
          <bio>undefined</bio>
          <person_id>robertorodriguezecheverria</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Loli</first_name>
          <last_name>Burgueño</last_name>
          <affiliation>Open University of Catalonia &amp; CEA LIST</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/loliburgueno1/0bb3ad38-66ab-4323-a2cf-a83e634bf3e0/small.jpg</picture_url>
          <person_id>loliburgueno1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jordi</first_name>
          <last_name>Cabot</last_name>
          <affiliation>ICREA - UOC</affiliation>
          <bio>I’m an ICREA Research Professor at Internet Interdisciplinary Institute, a Research center of the Open University of Catalonia (UOC) where I’m leading the SOM Research Lab.
Previously, I’ve been a faculty member at the École des Mines de Nantes and team leader of the AtlanMod Research group on an Inria International Chair and worked in Barcelona (Technical University of Catalonia ), Toronto (University of Toronto) and Milano (Politecnico di Milano).
My research falls into the broad area of systems and software engineering, especially promoting the rigorous use of software models and engineering principles in all software engineering tasks while keeping an eye on the most unpredictable element in any project: the people involved in it.</bio>
          <homepage_url>http://jordicabot.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jordicabot/5f53d1be-4d39-4b8b-a4f0-8d2167c2f3cd/small.jpg</picture_url>
          <person_id>jordicabot</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>88aec252-611a-4b17-919e-dbe5a2f0748a</slot_id>
      <event_id>c3bbe292-ed84-4022-87c1-1c8489a199ff</event_id>
      <title>Annotating Executable DSLs with Energy Estimation Formulas</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>08:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>08:20</end_time>
      <description>Reducing the energy consumption of a complex, especially cyber-physical, system is a cross-cutting concern through the system layers, and typically requires long feedback loops between experts in several engineering disciplines. Having an immediate automatic estimation of the global system consumption at design-time would significantly accelerate this process, but cross-layer tools are missing in several domains.
Executable domain-specific modeling languages (xDSLs) can be used to design several layers of the system under development in an integrated view. By including the behavioral specification for software and physical components of the system, they are an effective source artifact for cross-layer energy estimation.
In this paper we propose EEL, a language for annotating xDSL primitives with energy-related properties, i.e. how their execution would contribute to the energy consumption on a specific runtime platform. Given an xDSL, energy specialists create EEL models of that xDSL for each considered runtime platform. The models are used at design time, to predict the energy consumption of the real systems. This avoids the need of energetic analysis by deployment and measurement on all runtime platforms, that is slow and expensive.
We augment an existing language workbench for xDSLs with an editor for EEL models and a component that computes energy-consumption estimations during model editing. The evaluation shows that EEL can be used to represent estimation models from literature, and provide useful predictions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thibault</first_name>
          <last_name>Béziers la Fosse</last_name>
          <affiliation>IMT Atlantique, ICAM</affiliation>
          <bio>undefined</bio>
          <person_id>thibaultbezierslafosse</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Massimo</first_name>
          <last_name>Tisi</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>massimotisi2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jean-Marie</first_name>
          <last_name>Mottu</last_name>
          <affiliation>Université de Nantes, LS2N, IMT Atlantique</affiliation>
          <bio>undefined</bio>
          <person_id>jeanmariemottu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gerson</first_name>
          <last_name>Sunyé</last_name>
          <affiliation>Université de Nantes, LS2N</affiliation>
          <bio>undefined</bio>
          <person_id>gersonsunye1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8cc9ff47-9a4f-4519-8e7e-7d026f9f541f</slot_id>
      <event_id>e4746088-06d2-4fa5-811e-53df9aff9450</event_id>
      <title>eFLINT: A Domain-Specific Language for Executable Norm Specifications</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>07:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>08:00</end_time>
      <description>Software systems that share potentially sensitive data are subjected to laws, regulations, policies and/or contracts. The monitoring, control and enforcement processes applied to these systems are currently to a large extent manual, which we rather automate by embedding the processes as dedicated and adaptable software services in order to improve efficiency and effectiveness. This approach requires such regulatory services to be closely aligned with a formal description of the relevant norms.
This paper presents eFLINT, a domain-specific language developed for formalizing norms. The theoretical foundations of the language are found in transition systems and in Hohfeld’s framework of legal fundamental conceptions. The language can be used to formalize norms from a large variety of sources. The resulting specifications are executable and support several forms of reasoning such as automatic case assessment, manual exploration and simulation. Moreover, the specifications can be used to develop regulatory services for several types of monitoring, control and enforcement. The language is explained through an example, formalizing articles 6(1)(a) and 16 of the General Data Protection Regulation (GDPR). A prototype implementation and formal definition of eFLINT are provided as supplementary material.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>L. Thomas</first_name>
          <last_name>van Binsbergen</last_name>
          <affiliation>Centrum Wiskunde &amp; Informatica</affiliation>
          <bio>Thomas van Binsbergen is designing and implementing domain-specific languages for the formal specification of norms from a variety of sources such as laws, regulations, policies, contracts and codes of conduct. The resulting formalizations are used in policy-enhanced, distributed software architectures for data sharing. By ensuring compliance with the formalized norms, such systems reduce the risk of violating regulations and add value by increasing the trust in sharing activities.
The SSPDDP project is a collaboration between the knowledge institutes UvA, CWI and VU and the industrial partners ABN AMRO, ING and KLM to develop secure and scalable techniques for policy-enforced data sharing. The project investigates fundamental research questions to develop future-proof, cryptographic solutions to secure and trustworthy data sharing, automatic policy enforcement in distributed systems and bringing the aforementioned data sharing methods to scale. Besides being academically relevant, the outcomes of these investigations suggest a principled, sound and pragmatic mode of operation that can add value to the industry partners in several ways.
In the past, Van Binsbergen has developed modular techniques for describing the semantics of programming languages as part of the PLanCompS project with Peter Mosses and parser combinators for generalised top-down parsing with Adrian Johnstone and Elizabeth Scott. The results are described in his PhD thesis titled “Executable Formal Specification of Programming Languages with Reusable Components” (http://ltvanbinsbergen.nl/thesis/thesis.pdf).
Keywords: modular language definition, domain-specific languages, formal specification, modelling languages, policy-enhanced data-sharing, generalised top-down parsing, declarative programming, purely functional programming, I-MSOS, FunCons, attribute grammars, computer science education</bio>
          <homepage_url>http://ltvanbinsbergen.nl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lthomasvanbinsbergen/b276e9a4-2229-45a7-ae0f-e25fb729b0e6/small.jpg</picture_url>
          <person_id>lthomasvanbinsbergen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lu-Chi</first_name>
          <last_name>Liu</last_name>
          <affiliation>University of Amsterdam</affiliation>
          <bio>undefined</bio>
          <person_id>luchiliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Robert</first_name>
          <last_name>van Doesburg</last_name>
          <affiliation>Leibniz Institute, University of Amsterdam / TNO</affiliation>
          <bio>undefined</bio>
          <person_id>robertvandoesburg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tom</first_name>
          <last_name>van Engers</last_name>
          <affiliation>Leibniz Institute, University of Amsterdam / TNO</affiliation>
          <bio>undefined</bio>
          <person_id>tomvanengers</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b52613d4-9f8f-4243-bf00-86a342a74493</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/16</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>72a5dec9-7dde-4145-965d-e8e9f8977411</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0a719586-086e-4902-b9fe-50efcb3ad8fc</slot_id>
      <event_id>2959d666-0f62-48cd-88fd-eb2adec902b9</event_id>
      <title>Reorganizing queries with grouping</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>02:00</end_time>
      <description>Language-integrated query has attracted much attention from researchers and engineers. It enables one to write a database query with high-level abstractions, which makes it possible to compose, iterate, and reuse queries in a sophisticated way. Cheney et al. proposed a two-level language for this purpose, and succeeded in generating efficient queries by program transformation. Recently Okura et al. extended their language to cover grouping (GROUP BY) and aggregate functions in SQL. They decompose a query with grouping into a combination of small primitives and applies Cheney et al.’s translation to eliminate nested data structures. It works, but still has a problem; excessively large queries may sometimes be generated due to decomposition.
This paper proposes a solution for this problem to complete the picture. Our key idea is re-organization of nested control structures. While Okura et al.’s decomposed form is useful while a query is being transformed by Cheney et al.’s transformation, it is not optimal when SQL queries are generated. We propose an algorithm to unify (or fuse) nested control structures while keeping the absence of nested data structures. An important issue is to avoid correlated subqueries, and our algorithm eliminates them as much as possible. We have applied our technique to various example queries, and conducted performance measurements, which shows the usefulness of our work.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rui</first_name>
          <last_name>Okura</last_name>
          <affiliation>University of Tsukuba</affiliation>
          <bio>undefined</bio>
          <person_id>ruiokura</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yukiyoshi</first_name>
          <last_name>Kameyama</last_name>
          <affiliation>University of Tsukuba, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tsukuba.ac.jp/~kam/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yukiyoshikameyama/a7ae9aee-0992-4ddf-ae1d-6fee59d9e814/small.jpg</picture_url>
          <person_id>yukiyoshikameyama</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>16c173be-953e-4683-b8a8-faacc647609e</slot_id>
      <event_id>77baa9ff-0f71-458a-b6de-9cff6f8a7642</event_id>
      <title>Principles and Patterns of JastAdd-style Reference Attribute Grammars</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>02:20</end_time>
      <description>Reference attribute grammars (RAGs) have reached a level of maturity where they are supported by several tools, and have gained traction in both academic and industrial language tool development. However, despite a lot of accumulated knowledge of how to best develop RAGs in practice, there is limited support to guide practitioners.
In this paper, we address this issue by focusing on one RAG tool, JastAdd, and by defining principles and patterns for development of RAGs with this tool. We evaluate the proposed principles and patterns empirically using focus groups with a mix of beginners and experienced users from both academia and industry. The results indicate that the principles and patterns capture the practice of developing JastAdd RAGs well, help practitioners to become aware of useful patterns, and provide a common language to more efficiently reason about the practice of developing JastAdd RAGs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Niklas</first_name>
          <last_name>Fors</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.lth.se/niklas_fors</homepage_url>
          <person_id>niklasfors</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Emma</first_name>
          <last_name>Söderberg</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/emmasoderberg/7abc495e-ac1f-4cae-9f68-15a869dcb648/small.jpg</picture_url>
          <person_id>emmasoderberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Görel</first_name>
          <last_name>Hedin</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/gorelhedin1/889e8014-52c5-4f2f-949a-0f92539b1e59/small.jpg</picture_url>
          <person_id>gorelhedin1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9fb2eec4-df84-4a5b-99da-1e0f31883a6e</slot_id>
      <event_id>4752652a-8405-4b5e-90da-50c7de7fada9</event_id>
      <title>Multi-Stage Programming in the Large with Staged Classes</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>01:20</end_time>
      <description>Multi-stage programming (MSP) holds great promise, allowing the reliable generation of specialized, partially-evaluated code with static type- and scope-safety guarantees. Yet, we argue that MSP has not reached its full potential yet, as it has been traditionally limited to generating expressions, and has lacked principled facilities for generating modular programs and data structures. In that sense, we argue that MSP has been reserved for programming “in the small,” focused on generating efficient kernels of computation on the scale of single function bodies. We present a novel technique called staged classes, which extends MSP with the ability to manipulate class definitions as first-class constructs. This lets programmers use MSP “in the large,” on the level of applications, rather than mere functions. This way, applications can be designed in an abstract and modular way without runtime cost, as staged classes guarantee the removal of all staging-time abstractions, resulting in the generation of efficient specialized modules and data structures. We describe the design of a prototype relational database system in Scala, which uses several stages of runtime compilation to maximize the efficiency of query execution and data storage. We also show that staged classes can be used for defining type- and scope-safe implementations of type providers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lionel</first_name>
          <last_name>Parreaux</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.epfl.ch/lionel.parreaux/?lang=en</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lionelparreaux/292d178a-af9d-419f-9e04-8a4672226fd5/small.jpg</picture_url>
          <person_id>lionelparreaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Amir</first_name>
          <last_name>Shaikhha</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <person_id>amirshaikhha</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b5b5e353-1c24-46fb-900a-c6ea6c8b1bda</slot_id>
      <event_id>0547992f-d9b7-49e0-b616-0dc25b5ef4a9</event_id>
      <title>Software Language Engineers' Worst Nightmare</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>01:40</end_time>
      <description>Many techniques in software language engineering get their first validation by being prototyped to work on one particular language such as Java, Scala, Scheme, or ML, or a subset of such a language. Claims of their generalisability, as well as discussion on potential threats to their external validity, are often based on authors’ ad hoc understanding of the world outside their usual comfort zone. To facilitate and simplify such discussions by providing a solid measurable ground, we propose a language called µCobol [the name is intentionally changed to avoid deanonymisation during the paper review period, which was specifically designed to contain features that turn processing legacy programming languages such as COBOL, FORTRAN, PL/I, REXX, CLIST, and 4GLs, into such a challenge. The language is minimal by design so that it can help to quickly find weaknesses in frameworks making them inapplicable to dealing with legacy software. However, applying new techniques of software language engineering and reverse engineering to such a small language will not be too tedious and overwhelming. µCobol was designed in collaboration with industrial compiler developers by systematically traversing features of several second, third and fourth generation languages to identify the core culprits in making development of compiler for legacy languages difficult.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vadim</first_name>
          <last_name>Zaytsev</last_name>
          <affiliation>University of Twente, The Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://grammarware.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vadimzaytsev/fe6c221f-75d5-4fbc-ac41-be9c99349b5d/small.jpg</picture_url>
          <person_id>vadimzaytsev</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>264c908a-d666-4d99-9e5b-15e6cc2a14a7</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/15</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>5941b78e-f178-4b2d-b751-f8a81d94b601</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c4615725-b1b1-4229-9c78-d7b4ed9470e7</slot_id>
      <event_id>0634bf8c-79e0-4f7f-afaa-210b311fcbf3</event_id>
      <title>Modular and distributed IDE</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>11:40</end_time>
      <description>Integrated Development Environments (IDEs) are indispensable companions to programming languages. They are increasingly turning towards Web-based infrastructure. The rise of a protocol such as the Language Server Protocol (LSP) that standardizes the protocol used between a language-agnostic IDE and a language server that provides language services like auto completion, go to definition, find all references, compilation, etc. has allowed the emergence of high quality generic Web components to build the IDE part that runs in the browser. However, the multitude of heterogeneous language services offered within an IDE are requiring different computing capacities and response times to guarantee a user-friendly experience with the IDE. The monolithic distribution of all language services prevent to leverage on the available execution platforms (e.g., local platform, application server, cloud), and to offer a tailored distribution that optimizes the user experience and the overall performance of the language services. In contrast with the current approaches that provide IDEs in the form of a monolithic client-server architecture, we explore in this paper the modularization of all language services to support their individual deployment and dynamic adaptation within an IDE. We also study the performance impact to distribute the language services across the available execution platforms. We evaluate our approach on four EMF-based languages and demonstrate the benefit of a custom distribution of the various language services.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fabien</first_name>
          <last_name>Coulon</last_name>
          <affiliation>University of Toulouse / Obeo</affiliation>
          <bio>undefined</bio>
          <person_id>fabiencoulon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alex</first_name>
          <last_name>Auvolat</last_name>
          <affiliation>University of Rennes, Inria, CNRS, IRISA</affiliation>
          <bio>undefined</bio>
          <person_id>alexauvolat</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Toulouse and Inria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yerom-David</first_name>
          <last_name>Bromberg</last_name>
          <affiliation>University of Rennes, Inria, CNRS, IRISA</affiliation>
          <bio>undefined</bio>
          <person_id>yeromdavidbromberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>François</first_name>
          <last_name>Taïni</last_name>
          <affiliation>University of Rennes, Inria, CNRS, IRISA</affiliation>
          <bio>undefined</bio>
          <person_id>francoistaini</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Barais</last_name>
          <affiliation>(Univ Rennes, Inria, IRISA)</affiliation>
          <bio>undefined</bio>
          <person_id>olivierbarais1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Noël</first_name>
          <last_name>Plouzeau</last_name>
          <affiliation>University of Rennes, Inria, CNRS, IRISA</affiliation>
          <bio>undefined</bio>
          <person_id>noelplouzeau</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e5fd6677-5483-4c3c-8c19-39d3ea9c186f</slot_id>
      <event_id>404bc9e9-77ae-4014-95e6-150008d75fce</event_id>
      <title>Correctness-by-Construction for Feature-Oriented Software Product Lines</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>12:00</end_time>
      <description>\emph{Software product lines} are increasingly used to handle the growing demand of custom-tailored software variants. They provide systematic reuse of software and other artifacts paired with variability mechanisms in the code to implement whole product families rather than single software products. A common domain of application for product lines are safety-critical systems, which require \emph{behavioral correctness} to omit dangerous situations in-field. While most approaches in academia concentrate on post-hoc verification for product lines, we argue that a stepwise approach to create correct programs may be beneficial for the developer to manage the growing variability. \emph{Correctness-by-construction} is such a stepwise approach to create programs using a set of small, tractable refinement rules that guarantee the correctness of the program with regard to its specification. In this paper, we propose the first approach to develop correct-by-construction software product lines using feature-oriented programming. First, we extend correctness-by-construction by two refinement rules for variation points in the code. Second, we give a proof for the soundness of the proposed rules. Third, we implement our technique in a tool called VarCorC and show the applicability of the tool by conducting two case studies.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tabea</first_name>
          <last_name>Bordis</last_name>
          <affiliation>TU Braunschweig</affiliation>
          <bio>undefined</bio>
          <person_id>tabeabordis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Runge</last_name>
          <affiliation>TU Braunschweig</affiliation>
          <bio>undefined</bio>
          <person_id>tobiasrunge</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ina</first_name>
          <last_name>Schaefer</last_name>
          <affiliation>Technische Universität Braunschweig</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.tu-braunschweig.de/isf/team/schaefer</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/inaschaefer/49ab41dc-9f8c-4f0f-b786-43b70d25d96d/small.jpg</picture_url>
          <person_id>inaschaefer</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>eaa1f0b5-42e0-4f3e-ba22-0a24964746b2</slot_id>
      <event_id>677f497e-d633-4e7c-9fa6-3eb6bdc8a827</event_id>
      <title>Automated Variability Injection for Graphical Modelling Languages</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>11:20</end_time>
      <description>Model-based development approaches, such as Model-Driven Engineering (MDE), heavily rely on the use of modelling languages to achieve and automate software development tasks. To enable the definition of model variants (e.g., supporting the compact description of system families), one solution is to combine MDE with Software Product Lines. However, this is technically costly as it requires adapting many MDE artefacts associated to the modelling language – especially the meta-models and graphical environments.
To alleviate this situation, we propose a method for the automated injection of variability into graphical modelling languages. Given the meta-model and graphical environment of a particular language, our approach permits configuring the allowed model variability, and the graphical environment is automatically adapted to enable creating models with variability. Our solution is implemented atop the Eclipse Modeling Framework and Sirius, and synthesizes adapted graphical editors integrated with FeatureIDE.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Antonio</first_name>
          <last_name>Garmendia</last_name>
          <affiliation>JKU Linz</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.se.jku.at/antonio-garmendia/</homepage_url>
          <person_id>antoniogarmendia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Wimmer</last_name>
          <affiliation>Johannes Kepler University Linz</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.se.jku.at/manuel-wimmer/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelwimmer/debab079-8b78-46af-8f24-2ce08001b86f/small.jpg</picture_url>
          <person_id>manuelwimmer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Esther</first_name>
          <last_name>Guerra</last_name>
          <affiliation>Universidad Autonoma de Madrid</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/estherguerra/e25b23e7-460a-487a-ac4f-bd6326e36ac7/small.jpg</picture_url>
          <person_id>estherguerra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Elena</first_name>
          <last_name>Gómez-Martínez</last_name>
          <affiliation>Universidad Autonoma de Madrid</affiliation>
          <bio>undefined</bio>
          <person_id>elenagomezmartinez</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Juan</first_name>
          <last_name>de Lara</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arantxa.ii.uam.es/~jlara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juandelara/36b5a702-1b04-48b9-8849-869aa603a88d/small.jpg</picture_url>
          <person_id>juandelara</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>eb2aa814-cfe3-496f-8b07-06ac80dd5502</slot_id>
      <event_id>c32f3297-945e-48d1-95da-9f3daec1ec11</event_id>
      <title>A Family of Languages for Trustworthy Agent-Based Simulation</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>12:20</end_time>
      <description>Simulation is a key tool in the scientist’s toolkit to enable understanding of complex system behaviour. Agent-based simulation is one form of simulation that has seen applications across different sciences from biology to health, economics, and urban sciences. However, engineering agent-based simulations such that they are robust, efficient, maintainable, and reliable as well as trusted by domain experts is very challenging. Most recently, this has come to public attention in the context of agent-based simulations of the COVID-19 pandemic.
In this paper, we develop a vision of how a family of domain-specific languages could help construct agent-based simulations more systematically and, by following a systematic engineering process, improve their robustness, efficiency, and maintainability as well as increasing transparency and traceability from the original domain understanding to the simulation implementation and back to the simulation results and conclusions. This family consists of three categories of languages for modelling domain knowledge, experimental requirements, and experimental results, each at hierarchically increasing abstraction levels from the simulation platform, via a generic agent-modelling language to modelling languages specific to the problem domain. We discuss the vision in detail and illustrate it with a motivating example.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Steffen</first_name>
          <last_name>Zschaler</last_name>
          <affiliation>King's College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.steffen-zschaler.de/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/steffenzschaler/aeac85bf-ae27-4394-b79a-4569c1138728/small.jpg</picture_url>
          <person_id>steffenzschaler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fiona</first_name>
          <last_name>Polack</last_name>
          <affiliation>Keele University</affiliation>
          <bio>undefined</bio>
          <person_id>fionapolack</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>124519e2-fe5f-4d5d-9e22-7d3145e91a4e</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/16</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>5593a36c-7f7e-4030-8ebc-4c5459a40bd0</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>19:00</start_time>
      <end_time>20:20</end_time>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4b2d6eb1-f862-4fd4-a55b-f7368f34e5be</slot_id>
      <event_id>c3bbe292-ed84-4022-87c1-1c8489a199ff</event_id>
      <title>Annotating Executable DSLs with Energy Estimation Formulas</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>20:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>20:20</end_time>
      <description>Reducing the energy consumption of a complex, especially cyber-physical, system is a cross-cutting concern through the system layers, and typically requires long feedback loops between experts in several engineering disciplines. Having an immediate automatic estimation of the global system consumption at design-time would significantly accelerate this process, but cross-layer tools are missing in several domains.
Executable domain-specific modeling languages (xDSLs) can be used to design several layers of the system under development in an integrated view. By including the behavioral specification for software and physical components of the system, they are an effective source artifact for cross-layer energy estimation.
In this paper we propose EEL, a language for annotating xDSL primitives with energy-related properties, i.e. how their execution would contribute to the energy consumption on a specific runtime platform. Given an xDSL, energy specialists create EEL models of that xDSL for each considered runtime platform. The models are used at design time, to predict the energy consumption of the real systems. This avoids the need of energetic analysis by deployment and measurement on all runtime platforms, that is slow and expensive.
We augment an existing language workbench for xDSLs with an editor for EEL models and a component that computes energy-consumption estimations during model editing. The evaluation shows that EEL can be used to represent estimation models from literature, and provide useful predictions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thibault</first_name>
          <last_name>Béziers la Fosse</last_name>
          <affiliation>IMT Atlantique, ICAM</affiliation>
          <bio>undefined</bio>
          <person_id>thibaultbezierslafosse</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Massimo</first_name>
          <last_name>Tisi</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>massimotisi2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jean-Marie</first_name>
          <last_name>Mottu</last_name>
          <affiliation>Université de Nantes, LS2N, IMT Atlantique</affiliation>
          <bio>undefined</bio>
          <person_id>jeanmariemottu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gerson</first_name>
          <last_name>Sunyé</last_name>
          <affiliation>Université de Nantes, LS2N</affiliation>
          <bio>undefined</bio>
          <person_id>gersonsunye1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8662863c-ab2c-4cbe-b5b7-151c440adcc3</slot_id>
      <event_id>bf859d8b-5d82-4d81-92fe-9bffb332dc89</event_id>
      <title>Towards the Optical Character Recognition of DSLs</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>19:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>19:40</end_time>
      <description>OCR engines aim to identify and extract text strings fromdocuments or images. While current efforts focus mostly inmainstream languages, there is little support for program-ming or domain-specific languages (DSLs). In this paper, wepresent our vision about the current state of OCL recognitionfor DSLs and its challenges. We discuss some strategies toimprove the OCR quality applied to DSL textual expressionsby leveraging DSL specifications and domain data. To bettersupport our ideas we present the preliminary results of anempirical study and outline a research roadmap.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jorge</first_name>
          <last_name>Perianez Pascual</last_name>
          <affiliation>Universidad de Extremadura</affiliation>
          <bio>undefined</bio>
          <person_id>jorgeperianezpascual</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roberto</first_name>
          <last_name>Rodriguez-Echeverria</last_name>
          <affiliation>Universidad de Extremadura</affiliation>
          <bio>undefined</bio>
          <person_id>robertorodriguezecheverria</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Loli</first_name>
          <last_name>Burgueño</last_name>
          <affiliation>Open University of Catalonia &amp; CEA LIST</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/loliburgueno1/0bb3ad38-66ab-4323-a2cf-a83e634bf3e0/small.jpg</picture_url>
          <person_id>loliburgueno1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jordi</first_name>
          <last_name>Cabot</last_name>
          <affiliation>ICREA - UOC</affiliation>
          <bio>I’m an ICREA Research Professor at Internet Interdisciplinary Institute, a Research center of the Open University of Catalonia (UOC) where I’m leading the SOM Research Lab.
Previously, I’ve been a faculty member at the École des Mines de Nantes and team leader of the AtlanMod Research group on an Inria International Chair and worked in Barcelona (Technical University of Catalonia ), Toronto (University of Toronto) and Milano (Politecnico di Milano).
My research falls into the broad area of systems and software engineering, especially promoting the rigorous use of software models and engineering principles in all software engineering tasks while keeping an eye on the most unpredictable element in any project: the people involved in it.</bio>
          <homepage_url>http://jordicabot.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jordicabot/5f53d1be-4d39-4b8b-a4f0-8d2167c2f3cd/small.jpg</picture_url>
          <person_id>jordicabot</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9180f1b1-ee1e-45be-bdf9-73441bbbd246</slot_id>
      <event_id>c70da96c-88b3-41a8-acaf-9b1776c8dd25</event_id>
      <title>A Domain-Specific Language for Filtering in Application Level Gateways</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>19:20</end_time>
      <description>Application-level packet filtering is a technique for network access control in which an “application-level gateway” intercepts network packages at the application level (e.g., HTTP, FTP), scans them for security cooncerns and optionally logs, rewrites or discards them. Existing application-level filters express their filtering rules in general-purpose languages, which limits the correctness guarantees available for them.
We present the first declarative language for application-level network filtering, developed at [COMPANY]. Our DSL uses security assertions to express properties that packets must have to be allowed through the network (e.g., “IMAP packet contains no executable attachment” or “SQL reply contains only explicitly permitted columns”), along with remedies that either reject or rewrite undesirable packets.
We have designed the language around the needs of network filter developers, with a focus on correctness: our language can statically verify several properties of filter programs, such as well-formedness of the outcome, confluence, and termination, with the help of an off-the-shelf SMT solver.
Our initial results show that the language is sufficiently expressive for a variety of network protocols, closely maps to the application domain, is usable by network filter engineers, and provides strong correctness guarantees.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hampus</first_name>
          <last_name>Balldin</last_name>
          <affiliation>Advenica AB, Malmö</affiliation>
          <bio>undefined</bio>
          <person_id>hampusballdin1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Reichenbach</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/christophreichenbach/04687677-a813-459e-8929-d1e4a32627c6/small.jpg</picture_url>
          <person_id>christophreichenbach</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f8c871a6-27a9-4b3f-b798-c80a781a923c</slot_id>
      <event_id>e4746088-06d2-4fa5-811e-53df9aff9450</event_id>
      <title>eFLINT: A Domain-Specific Language for Executable Norm Specifications</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>19:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>20:00</end_time>
      <description>Software systems that share potentially sensitive data are subjected to laws, regulations, policies and/or contracts. The monitoring, control and enforcement processes applied to these systems are currently to a large extent manual, which we rather automate by embedding the processes as dedicated and adaptable software services in order to improve efficiency and effectiveness. This approach requires such regulatory services to be closely aligned with a formal description of the relevant norms.
This paper presents eFLINT, a domain-specific language developed for formalizing norms. The theoretical foundations of the language are found in transition systems and in Hohfeld’s framework of legal fundamental conceptions. The language can be used to formalize norms from a large variety of sources. The resulting specifications are executable and support several forms of reasoning such as automatic case assessment, manual exploration and simulation. Moreover, the specifications can be used to develop regulatory services for several types of monitoring, control and enforcement. The language is explained through an example, formalizing articles 6(1)(a) and 16 of the General Data Protection Regulation (GDPR). A prototype implementation and formal definition of eFLINT are provided as supplementary material.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>L. Thomas</first_name>
          <last_name>van Binsbergen</last_name>
          <affiliation>Centrum Wiskunde &amp; Informatica</affiliation>
          <bio>Thomas van Binsbergen is designing and implementing domain-specific languages for the formal specification of norms from a variety of sources such as laws, regulations, policies, contracts and codes of conduct. The resulting formalizations are used in policy-enhanced, distributed software architectures for data sharing. By ensuring compliance with the formalized norms, such systems reduce the risk of violating regulations and add value by increasing the trust in sharing activities.
The SSPDDP project is a collaboration between the knowledge institutes UvA, CWI and VU and the industrial partners ABN AMRO, ING and KLM to develop secure and scalable techniques for policy-enforced data sharing. The project investigates fundamental research questions to develop future-proof, cryptographic solutions to secure and trustworthy data sharing, automatic policy enforcement in distributed systems and bringing the aforementioned data sharing methods to scale. Besides being academically relevant, the outcomes of these investigations suggest a principled, sound and pragmatic mode of operation that can add value to the industry partners in several ways.
In the past, Van Binsbergen has developed modular techniques for describing the semantics of programming languages as part of the PLanCompS project with Peter Mosses and parser combinators for generalised top-down parsing with Adrian Johnstone and Elizabeth Scott. The results are described in his PhD thesis titled “Executable Formal Specification of Programming Languages with Reusable Components” (http://ltvanbinsbergen.nl/thesis/thesis.pdf).
Keywords: modular language definition, domain-specific languages, formal specification, modelling languages, policy-enhanced data-sharing, generalised top-down parsing, declarative programming, purely functional programming, I-MSOS, FunCons, attribute grammars, computer science education</bio>
          <homepage_url>http://ltvanbinsbergen.nl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lthomasvanbinsbergen/b276e9a4-2229-45a7-ae0f-e25fb729b0e6/small.jpg</picture_url>
          <person_id>lthomasvanbinsbergen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lu-Chi</first_name>
          <last_name>Liu</last_name>
          <affiliation>University of Amsterdam</affiliation>
          <bio>undefined</bio>
          <person_id>luchiliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Robert</first_name>
          <last_name>van Doesburg</last_name>
          <affiliation>Leibniz Institute, University of Amsterdam / TNO</affiliation>
          <bio>undefined</bio>
          <person_id>robertvandoesburg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tom</first_name>
          <last_name>van Engers</last_name>
          <affiliation>Leibniz Institute, University of Amsterdam / TNO</affiliation>
          <bio>undefined</bio>
          <person_id>tomvanengers</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9c9dcaa6-1ec0-45f4-9dd2-266ec80052a7</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/15</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>de4aec03-7d1d-4638-a6b1-5f408c6045d2</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>21:40</start_time>
      <end_time>22:20</end_time>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6a551cf0-8d27-4836-8b1f-24590c56a55a</slot_id>
      <event_id>4609d389-c96c-41b0-9d37-2e67d40eb626</event_id>
      <title>Gradually Typing Strategies</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>22:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>22:20</end_time>
      <description>The Stratego language supports program transformation by means of term rewriting with programmable rewriting strategies. Stratego’s traversal primitives support concise definition of generic tree traversals. Stratego is a dynamically typed language because its features cannot be captured fully by a static type system. While dynamic typing makes for a flexible programming model, it also leads to unintended type errors, code that is harder to maintain, and missed opportunities for optimization.
In this paper, we introduce a gradual type system for Stratego that combines the flexibility of dynamically typed generic programming, where needed, with the safety of statically declared and enforced types, where possible. To make sure that statically typed code cannot go wrong, all access to statically typed code from dynamically typed code is protected by dynamic type checks (casts). The type system is backwards compatible such that types can be introduced incrementally to existing Stratego programs. We formally define a type system for Core Gradual Stratego, discuss its implementation in a new type checker for Stratego, and present an evaluation of its impact on Stratego programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jeff</first_name>
          <last_name>Smits</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>I am a PhD student in the Programming Languages Research Group at Delft University of Technology. I have various research interests around language design and compiler technology. I’ve worked on declarative specification of data-flow analysis, practical incremental compilation for existing languages, and gradual types. I’ve designed FlowSpec, a domain-specific language for the specification of data-flow analysis. For incremental compilation I’ve taken apart the compiler of the Stratego term transformation language, and reassembled it as an incremental compiler. I’m currently working on introducing a gradual type system to Stratego. FlowSpec and Stratego are part of the Spoofax Language Workbench. I am supervised by Eelco Visser.</bio>
          <homepage_url>https://www.jeffsmits.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeffsmits/1298c3fc-d485-44ed-b451-af24ac2f3b7e/small.jpg</picture_url>
          <person_id>jeffsmits</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science at Delft University of Technology. He received a master’s and doctorate in computer science from the University of Amsterdam in 1993 and 1997, respectively. Previously he served as postdoc at the Oregon Graduate Institute, as Assistant Professor at Utrecht University, and as Associate Professor at TU Delft.
His research interests include programming languages, software language engineering, domain-specific programming languages, program transformation, syntax definition, and parsing. With his students he has designed and implemented the Spoofax language workbench, as well as many domain-specific languages, including DSLs for syntax definition (SDF2, SDF3), program transformation (Stratego), static semantics (NaBL, Statix), dynamic semantics (DynSem), software deployment (Nix), web application development (WebDSL), and mobile phone applications (mobl). In the language designer’s workbench project he is pursuing high-level declarative language definition that serves for language implementation and verification.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>788d9b22-2205-4e1b-af97-edfe69dbbac3</slot_id>
      <event_id>db2ef237-4d82-43ee-ae90-0249136f777e</event_id>
      <title>Modeling Black-Box Components with Probabilistic Synthesis</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>21:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>22:00</end_time>
      <description>This paper is concerned with synthesizing programs based on \emph{black-box} oracles: we are interested in the case where there exists an executable implementation of a component or library, but its internal structure is unknown. We are just provided with its API or function signature, and aim to synthesize a program with equivalent behavior.
To attack this problem, we detail Presyn: a program synthesizer designed for flexible interoperation with existing programs and compiler toolchains. By first generating input-output pairs based on a function signature, Presyn uses high-level imperative control-flow structures and a pair of cooperating predictive models to efficiently narrow the space of potential programs. These models can be trained effectively on small corpora of synthesized examples.
We evaluate Presyn against four leading program synthesizers on a collection of 112 synthesis benchmarks collated from previous studies and real-world software libraries. We show that Presyn is able to synthesize a wider range of programs than each of them with less human input. We present two case studies: accelerator library porting and detection of duplicated library reimplementations that demonstrate the applicability of our approach on real world code and software engineering problems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bruce</first_name>
          <last_name>Collie</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>brucecollie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jackson</first_name>
          <last_name>Woodruff</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>jacksonwoodruff</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>O'Boyle</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>michaeloboyle</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>664c26fd-3069-4e8c-aacf-cf6a761e5aa3</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/16</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>a961f95c-6670-4d66-b44f-2c125af39ab6</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>207f0df4-d851-4794-9809-f7070cd9603c</slot_id>
      <event_id>741d1273-956c-4747-a5a6-305b9f8931c5</event_id>
      <title>VarSem: Declarative Expression and Automated Inference of Variable Usage Semantics</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>05:20</end_time>
      <description>Programmers declare variables to serve specific implementation purposes that we refer to as \emph{variable usage semantics (VUS)}. Understanding VUS is required for various software engineering tasks, including program comprehension, code audits, and vulnerability detection. To help programmers understand VUS, we present a new program analysis that infers a variable’s usage semantics from its textual and context information (e.g., symbolic name, type, scope, information flow). To support this analysis, we introduce VarSem, a domain-specific language, in which a variable’s semantic category is expressed as a set of declarative rules. VarSem’s execution determines which program variables belong to a given semantic category. VarSem translates high-level declarative rules into low-level program analysis techniques, including natural language processing and data flow, and provides a highly extensible architecture for specifying new rules and analysis techniques. We evaluate VarSem with eight real-world systems to identify their personally identifiable information variables. The evaluation results show that VarSem infers variable semantics with satisfying accuracy/precision and passable recall, thus potentially benefiting both software and security engineers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yin</first_name>
          <last_name>Liu</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.google.com/vt.edu/yinl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yinliu/1bc32554-be71-4a23-8aab-f60279fd51d1/small.jpg</picture_url>
          <person_id>yinliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eli</first_name>
          <last_name>Tilevich</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.vt.edu/~tilevich</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elitilevich/10b9c85c-8a75-4acb-a0fe-e00c91dd0bb6/small.jpg</picture_url>
          <person_id>elitilevich</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4c50a730-8db7-4c7f-9b3d-bc8ace73431e</slot_id>
      <event_id>78bc2344-dbc5-4255-89ef-7567e0b7e707</event_id>
      <title>Monadification of Attribute Grammars</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>05:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>05:40</end_time>
      <description>This paper describes a monadification process for attribute grammars that allows attribute equations to be written more concisely, closer to the style of inference rules used in typing specifications and structural operational semantics. Inference rules specifying, for example, a typing relation typically only consider expressions that can be typed. In contrast, well-defined attribute grammars explicitly determine attribute values for any syntax tree, including untypable ones. The monadification approach lets one represent, for example, types as monadic optional/maybe values, but write non-monadic equations over the value inside the monad that only specify the rules for a correct typing, leading to more concise specifications. The missing failure cases are handled by a rewriting process that inserts monadic return, bind, and failure operations to produce a well-defined attribute grammar that handles trees with type errors. A new pattern-matching expression captures much of the nondeterministic nature of inference rules by combining values of all matching clauses when the monadic type is a monoid. Typing and evaluation relations are given for the original and rewritten equations. The rewriting satisfies certain correctness properties: it is total and preserves types and the rewritten equations produce monadic values that correspond to the non-monadic values produced by the original equations. A prototype modification of the Silver attribute grammar system illustrates the benefits with examples such as typing and non-deterministic evaluation of the simply-typed lambda calculus with Booleans, and type inference in Caml Light.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dawn</first_name>
          <last_name>Michaelson</last_name>
          <affiliation>University of Minnesota</affiliation>
          <bio>undefined</bio>
          <person_id>dawnmichaelson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eric</first_name>
          <last_name>Van Wyk</last_name>
          <affiliation>University of Minnesota, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umn.edu/~evw</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ericvanwyk/3e91ebed-d1c2-4d28-a408-dddc41b5affc/small.jpg</picture_url>
          <person_id>ericvanwyk</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>80f65d7a-d8d4-42fe-b6cd-79301697e2e2</slot_id>
      <event_id>134617c3-cba5-44b3-9faf-25e0db401d75</event_id>
      <title>Fluid Quotes: Metaprogramming across Abstraction Boundaries with Dependent Types</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>05:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>06:00</end_time>
      <description>Object-oriented programming, functional programming, and metaprogramming each offer a unique axis of abstraction that enables modular code. Macros, a common technique for metaprogramming, capture ASTs as quotes to let users manipulate them in the host language. However, macros are often at odds with other programming techniques since they can only process code written at the call-site and cannot analyze code behind abstraction boundaries such as variables and methods. Furthermore, the quotes generated for macro expansion only exist at compile-time and cannot be passed around in user code. Multi-stage programming treats quotes as runtime values to address this problem, but introduces the cost of running the compiler when splicing quotes. This forces developers to choose between low runtime overhead and modularity. What if we could have the best of both worlds? We introduce fluid quotes, a new technique that uses dependent types to let users pass quotes through abstraction boundaries in runtime code while splicing them ahead-of-time. This technique enables new metaprogramming capabilities by eliminating the traditional requirement of co-locating parameter expressions with call-sites. Fluid quotes capture not only source code but also associated runtime values to ensure correctness. In addition, they can be composed into larger expressions without any macro code. We demonstrate the capabilities of fluid quotes through two specific applications: optimizing data processing pipelines and making language integrated queries more flexible.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shadaj</first_name>
          <last_name>Laddad</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://shadaj.me</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shadajladdad/d64c98bb-f1a7-4627-8ce4-f30e39b4d77d/small.jpg</picture_url>
          <person_id>shadajladdad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Koushik</first_name>
          <last_name>Sen</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>Koushik Sen is a professor in the Department of Electrical Engineering and Computer Sciences at the University of California, Berkeley. His research interest lies in Software Engineering, Programming Languages, and Formal methods. He is interested in developing software tools and methodologies that improve programmer productivity and software quality. He holds a B.Tech from Indian Institute of Technology, Kanpur, and M.S. and Ph.D. in CS from University of Illinois at Urbana-Champaign.</bio>
          <homepage_url>https://people.eecs.berkeley.edu/~ksen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/koushiksen/9f417f8a-40b9-40a7-866c-9c44cd81859a/small.jpg</picture_url>
          <person_id>koushiksen</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e5da275a-e1c5-4d36-b5c7-c671cb519b31</slot_id>
      <event_id>36eaec1d-fd68-4a11-9fa8-9e7691962e35</event_id>
      <title>Strategic Tree Rewriting in Attribute Grammars</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>06:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>06:20</end_time>
      <description>This paper presents strategy attributes, a seamless integration of strategic term rewriting into attribute grammars. Strategy attributes are specified using rewrite rules with strategies that control their application. The rules can reference contextual information held in attributes on the syntax trees being rewritten. This use of attribute values leads to rewriting on decorated trees instead of undecorated terms. As trees are rewritten, attribute values are (lazily) computed on the new trees to ensure they are correct with respect to their defining equations. Attributes and strategic rewriting can each be used where they are most appropriate, thus avoiding the more cumbersome aspects of each.
Strategy attributes are essentially higher-order attributes for which the defining equations are automatically generated from the attributes’ strategy expressions. They are thus compatible with other attribute grammar features such as reference attributes, forwarding, and attribute flow analyses for well-definedness. A conservative static analysis checks if a strategy is intended to always succeed or to be partial, thus simplify its translation and use.
Several applications of strategy attributes are demonstrated, including optimizing a simple expression language, evaluation of the lambda calculus, and in the optimization of strategy attribute translations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lucas</first_name>
          <last_name>Kramer</last_name>
          <affiliation>University of Minnesota</affiliation>
          <bio>undefined</bio>
          <person_id>lucaskramer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eric</first_name>
          <last_name>Van Wyk</last_name>
          <affiliation>University of Minnesota, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umn.edu/~evw</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ericvanwyk/3e91ebed-d1c2-4d28-a408-dddc41b5affc/small.jpg</picture_url>
          <person_id>ericvanwyk</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5559a118-f82e-4091-a701-a397b9534e85</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/16</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>200ddb06-968f-451f-a12d-d35c5b766e3c</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>06612259-050a-4c28-8882-fbac40746d9a</slot_id>
      <event_id>72c19935-2e93-485f-b44c-07eaf52f87ca</event_id>
      <title>Block-Based Syntax from Context-Free Grammars</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>03:40</end_time>
      <description>Block-based programming systems employ a jigsaw metaphor to write programs. They are popular in the domain of programming education (e.g., Scratch), but also used as programming interface for end-users in other domains, such as arts, robotics, and configuration management. In particular, block-based interfaces promise a convenient interface for domain-specific languages (DSLs) for domain experts who might lack a traditional programming education. However, building a block-based environment for a DSL from scratch requires significant effort. This paper presents an approach to engineer block-based language interfaces by reusing existing language artifacts. In particular, we present Kogi, a tool for deriving block-based environments from context-free grammars. We identify and define the abstract structure for describing block-based environments. Kogi transforms a context-free grammar into this structure, which is then generated to a block-based environment based on Google Blockly. The approach is illustrated with four case studies, a DSL for state machines, Sonification Blocks (a DSL for sound synthesis), Pico (a simple programming language), and QL (a DSL for questionnaires). The results show that usable block-based environments can be derived from context-free grammars, and with an order of magnitude reduction in effort.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mauricio</first_name>
          <last_name>Verano Merino</last_name>
          <affiliation>Technische Universiteit Eindhoven</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/mauricioveranomerino/e4a3ec56-b66f-4885-9989-c4a230e08446/small.jpg</picture_url>
          <person_id>mauricioveranomerino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tijs</first_name>
          <last_name>van der Storm</last_name>
          <affiliation>CWI &amp; University of Groningen, Netherlands</affiliation>
          <bio>Tijs van der Storm is senior researcher in the Software Analysis and Transformation (SWAT) group at Centrum Wiskunde &amp;amp; Informatica (CWI) in Amsterdam, and full professor in Software Engineering at the University of Groningen in Groningen. His research focuses on improving programmer experience through new and better software languages and developing the tools and techniques to engineer them in a modular and interactive fashion.</bio>
          <homepage_url>http://www.cwi.nl/~storm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tijsvanderstorm/1c2fdfb2-3ce0-4e75-91af-35d9a48f56c5/small.jpg</picture_url>
          <person_id>tijsvanderstorm</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>64eddf6f-9426-4c7c-b787-b8564add5dea</slot_id>
      <event_id>01597700-9cb9-405f-8faa-012932634461</event_id>
      <title>Manipulating GUI Structures Declaratively</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>03:20</end_time>
      <description>GUIs often contain structures that are incidental, not properly manipulatable through well-defined APIs. For example, modifying a list of items in a GUI’s model may require extraneous bookkeeping operations in the view, such as adding and removing event handlers, and updating the menu structure. Observing GUIs in practice alludes to that programmers may find it difficult or tedious to implement complete and convenient sets of operations for manipulating various structures: useful operations for adding, inserting, swapping, or reordering elements are often missing, inconsistent, or limited. This paper introduces a DSL for programming operations that manipulate such incidental structures. The programmer specifies structures via relations between elements, concretely by defining methods that unestablish and establish a relation. This gives the programmer an ability to describe structural transformations via rules that control which relations should hold before and after a rule is applied. The API for structure manipulation is generated from these rules. Our DSL can give an abstract view on ad-hoc structures, making it easier to provide the necessary set of operations for their convenient manipulation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Knut Anders</first_name>
          <last_name>Stokke</last_name>
          <affiliation>University of Bergen, Norway</affiliation>
          <bio>undefined</bio>
          <person_id>knutandersstokke</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mikhail</first_name>
          <last_name>Barash</last_name>
          <affiliation>University of Bergen, Norway</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://dsl-course.org/mikbar/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mikhailbarash/d876d731-3779-4e11-8aee-de2bcef5e938/small.jpg</picture_url>
          <person_id>mikhailbarash</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jaakko</first_name>
          <last_name>Järvi</last_name>
          <affiliation>University of Bergen</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://parasol.tamu.edu/~jarvi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jaakkojarvi/2baa5bc6-a9c0-42a0-a4ca-f7f878dd3381/small.jpg</picture_url>
          <person_id>jaakkojarvi</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7e10df27-e113-4ba8-8beb-da1715680deb</slot_id>
      <event_id>7d0ca593-ff13-49f0-9525-bf519bd5fda8</event_id>
      <title>Extrinsically Typed Operational Semantics for Functional Languages</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>04:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>04:20</end_time>
      <description>The research line on intrinsic typing has demonstrated that the type soundness of languages can be derived from type checking their implementation in a host language with strong meta-theoretic properties. In this paper, we take a different perspective in type checking language definitions for their soundness.
We present an extrinsic type system in which types are used to classify parts of the operational semantics of a language, and to model a common language design organization.
The resulting typing discipline guarantees that the language at hand is automatically type sound.
A benefit of extrinsic typing is that, thanks to the use of types to model language design, our type checker has a high-level view on the language being analyzed and can report messages using the same jargon of language designers.
We have implemented our type system in the lang-n-check tool, and we have applied it to derive the type soundness of several functional languages, including those with recursive types, polymorphism, exceptions, lists, sums, and several common types and operators.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matteo</first_name>
          <last_name>Cimini</last_name>
          <affiliation>University of Massachusetts Lowell</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cimini.info</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matteocimini/2ceb8176-9ce7-4024-a7f2-6bf8c93a1f00/small.jpg</picture_url>
          <person_id>matteocimini</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dale</first_name>
          <last_name>Miler</last_name>
          <affiliation>INRIA Saclay and LIX</affiliation>
          <bio>Dale Miller received his PhD in Mathematics in 1983 from Carnegie Mellon University. He has been a professor at the University of Pennsylvania and Ecole Polytechnique (France) and Department Head in Computer Science and Engineering at Pennsylvania State University. He has held visiting positions at the universities of Aix-Marseille, Sienna, Genoa, Pisa, and Edinburgh. He is currently Director of Research (classe exceptionnelle) at Inria Saclay where he was the Scientific Leader of the Parsifal team for 12 years.
Miller was a two-term editor-in-chief of the ACM Transactions on Computational Logic. He is a member of editorial board of the Journal of Automated Reasoning. He is the General Chair for LICS until 2021. In 2014 he was a PC chair for CSL and LICS. He was awarded an ERC Advanced Grant in 2011 and the LICS Test-of-Time awards in 2011 and 2014 for papers written in 1991 and 1994.</bio>
          <homepage_url>http://www.lix.polytechnique.fr/Labo/Dale.Miller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/dalemiler/feea0ac3-4b48-4ddb-a086-40503abc9417/small.jpg</picture_url>
          <person_id>dalemiler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jeremy G.</first_name>
          <last_name>Siek</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>Jeremy Siek is a Professor at Indiana University Bloomington. Jeremy’s areas of research include programming language design, type systems, mechanized theorem proving using proof assistants, and optimizing compilers. Jeremy’s Ph.D. thesis explored foundations for constrained templates, aka the “concepts” proposal for C++. Prior to that, Jeremy developed the Boost Graph Library, a C++ generic library for graph algorithms and data structures. Jeremy post-doc’d at Rice University where he developed the idea of gradual typing: a type system that integrates both dynamic and static typing in the same programming language. Jeremy is currently working on several open questions regarding gradual typing. Is the polymorphic blame calculus really parametric? How should gradual typing be combined with other features such as dependent types? What is the formal criteria for gradually typed languages? Is it possible to create a high-performance implementation of a gradually-typed languages? In 2009 Jeremy received the NSF CAREER award to fund his project: “Bridging the Gap Between Prototyping and Production”. In 2010 and again in 2015, Jeremy was awarded a Distinguished Visiting Fellowship from the Scottish Informatics &amp;amp; Computer Science Alliance.</bio>
          <homepage_url>http://homes.soic.indiana.edu/jsiek/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeremysiek/4365edf9-715f-46e0-8867-4ea5fb6341ad/small.jpg</picture_url>
          <person_id>jeremysiek</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f907cc2e-1020-4241-9c4d-94e6b29f380e</slot_id>
      <event_id>a26c3bc5-002a-4c10-8600-68b7c2ad453c</event_id>
      <title>PReGO: a Generative Methodology for Satisfying Real-Time Requirements on COTS-based Systems - Definition and Experience Report</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>04:00</end_time>
      <description>Satisfying real-time requirements in cyber-physical systemsis challenging as timing behaviour depends on the applica-tion software, the embedded hardware, as well as the exe-cution environment. This challenge is exacerbated as real-world, industrial systems often use unpredictable hardwareand software libraries or operating systems with timing haz-ards and proprietary device drivers. All these issues limitor entirely prevent the application of established real-timeanalysis techniques.
This paper describes PReGO, a partially generative method-ology for satisfying real-time requirements in industrial usecases developed without real-time techniques in mind. Weapply our methodology to a Search &amp;amp; Rescue applicationrunning on a fixed-wing drone with COTS components, in-cluding a NVIDIA Jetson board and a stock Ubuntu/Linux.We empirically evaluate the impact of each integration stepand demonstrate the effectiveness of our methodology inmeeting real-time application requirements in terms of dead-line misses and energy consumption.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Rouxel</last_name>
          <affiliation>University of Amsterdam</affiliation>
          <bio>undefined</bio>
          <person_id>benjaminrouxel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ulrik</first_name>
          <last_name>Schultz</last_name>
          <affiliation>University of Southern Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mmmi.sdu.dk/~ups</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ulrikschultz/102a6087-5b8d-48ec-b10d-8c3b6ab5b193/small.jpg</picture_url>
          <person_id>ulrikschultz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benny</first_name>
          <last_name>Akesson</last_name>
          <affiliation>University of Amsterdam, Netherlands and TNO, the Netherlands Organisation</affiliation>
          <bio>undefined</bio>
          <person_id>bennyakesson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jesper</first_name>
          <last_name>Holst</last_name>
          <affiliation>Sky-Watch, Danemark</affiliation>
          <bio>undefined</bio>
          <person_id>jesperholst</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ole</first_name>
          <last_name>Jorgensen</last_name>
          <affiliation>Sky-Watch, Danemark</affiliation>
          <bio>undefined</bio>
          <person_id>olejorgensen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Clemens</first_name>
          <last_name>Grelck</last_name>
          <affiliation>University of Amsterdam</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://staff.fnwi.uva.nl/c.u.grelck/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/clemensgrelck/09259ddd-cfb8-4f7b-882a-e3c3d2a4c3bd/small.jpg</picture_url>
          <person_id>clemensgrelck</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d8d0e4cf-ff54-47e3-bb37-b9972b2a86e1</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/15</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>3644edbd-2cdb-4f6f-a600-ba6d0aa9772a</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0fc2a1c9-532d-42a6-ba07-7f7ac3a53c8e</slot_id>
      <event_id>78bc2344-dbc5-4255-89ef-7567e0b7e707</event_id>
      <title>Monadification of Attribute Grammars</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>17:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>17:40</end_time>
      <description>This paper describes a monadification process for attribute grammars that allows attribute equations to be written more concisely, closer to the style of inference rules used in typing specifications and structural operational semantics. Inference rules specifying, for example, a typing relation typically only consider expressions that can be typed. In contrast, well-defined attribute grammars explicitly determine attribute values for any syntax tree, including untypable ones. The monadification approach lets one represent, for example, types as monadic optional/maybe values, but write non-monadic equations over the value inside the monad that only specify the rules for a correct typing, leading to more concise specifications. The missing failure cases are handled by a rewriting process that inserts monadic return, bind, and failure operations to produce a well-defined attribute grammar that handles trees with type errors. A new pattern-matching expression captures much of the nondeterministic nature of inference rules by combining values of all matching clauses when the monadic type is a monoid. Typing and evaluation relations are given for the original and rewritten equations. The rewriting satisfies certain correctness properties: it is total and preserves types and the rewritten equations produce monadic values that correspond to the non-monadic values produced by the original equations. A prototype modification of the Silver attribute grammar system illustrates the benefits with examples such as typing and non-deterministic evaluation of the simply-typed lambda calculus with Booleans, and type inference in Caml Light.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dawn</first_name>
          <last_name>Michaelson</last_name>
          <affiliation>University of Minnesota</affiliation>
          <bio>undefined</bio>
          <person_id>dawnmichaelson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eric</first_name>
          <last_name>Van Wyk</last_name>
          <affiliation>University of Minnesota, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umn.edu/~evw</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ericvanwyk/3e91ebed-d1c2-4d28-a408-dddc41b5affc/small.jpg</picture_url>
          <person_id>ericvanwyk</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cdfa16ae-14bb-465f-8a3d-82f9168a3880</slot_id>
      <event_id>36eaec1d-fd68-4a11-9fa8-9e7691962e35</event_id>
      <title>Strategic Tree Rewriting in Attribute Grammars</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>18:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>18:20</end_time>
      <description>This paper presents strategy attributes, a seamless integration of strategic term rewriting into attribute grammars. Strategy attributes are specified using rewrite rules with strategies that control their application. The rules can reference contextual information held in attributes on the syntax trees being rewritten. This use of attribute values leads to rewriting on decorated trees instead of undecorated terms. As trees are rewritten, attribute values are (lazily) computed on the new trees to ensure they are correct with respect to their defining equations. Attributes and strategic rewriting can each be used where they are most appropriate, thus avoiding the more cumbersome aspects of each.
Strategy attributes are essentially higher-order attributes for which the defining equations are automatically generated from the attributes’ strategy expressions. They are thus compatible with other attribute grammar features such as reference attributes, forwarding, and attribute flow analyses for well-definedness. A conservative static analysis checks if a strategy is intended to always succeed or to be partial, thus simplify its translation and use.
Several applications of strategy attributes are demonstrated, including optimizing a simple expression language, evaluation of the lambda calculus, and in the optimization of strategy attribute translations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lucas</first_name>
          <last_name>Kramer</last_name>
          <affiliation>University of Minnesota</affiliation>
          <bio>undefined</bio>
          <person_id>lucaskramer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eric</first_name>
          <last_name>Van Wyk</last_name>
          <affiliation>University of Minnesota, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umn.edu/~evw</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ericvanwyk/3e91ebed-d1c2-4d28-a408-dddc41b5affc/small.jpg</picture_url>
          <person_id>ericvanwyk</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d43f39b2-f280-4127-a2fc-1fc74080ccef</slot_id>
      <event_id>134617c3-cba5-44b3-9faf-25e0db401d75</event_id>
      <title>Fluid Quotes: Metaprogramming across Abstraction Boundaries with Dependent Types</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>17:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>18:00</end_time>
      <description>Object-oriented programming, functional programming, and metaprogramming each offer a unique axis of abstraction that enables modular code. Macros, a common technique for metaprogramming, capture ASTs as quotes to let users manipulate them in the host language. However, macros are often at odds with other programming techniques since they can only process code written at the call-site and cannot analyze code behind abstraction boundaries such as variables and methods. Furthermore, the quotes generated for macro expansion only exist at compile-time and cannot be passed around in user code. Multi-stage programming treats quotes as runtime values to address this problem, but introduces the cost of running the compiler when splicing quotes. This forces developers to choose between low runtime overhead and modularity. What if we could have the best of both worlds? We introduce fluid quotes, a new technique that uses dependent types to let users pass quotes through abstraction boundaries in runtime code while splicing them ahead-of-time. This technique enables new metaprogramming capabilities by eliminating the traditional requirement of co-locating parameter expressions with call-sites. Fluid quotes capture not only source code but also associated runtime values to ensure correctness. In addition, they can be composed into larger expressions without any macro code. We demonstrate the capabilities of fluid quotes through two specific applications: optimizing data processing pipelines and making language integrated queries more flexible.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shadaj</first_name>
          <last_name>Laddad</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://shadaj.me</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shadajladdad/d64c98bb-f1a7-4627-8ce4-f30e39b4d77d/small.jpg</picture_url>
          <person_id>shadajladdad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Koushik</first_name>
          <last_name>Sen</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>Koushik Sen is a professor in the Department of Electrical Engineering and Computer Sciences at the University of California, Berkeley. His research interest lies in Software Engineering, Programming Languages, and Formal methods. He is interested in developing software tools and methodologies that improve programmer productivity and software quality. He holds a B.Tech from Indian Institute of Technology, Kanpur, and M.S. and Ph.D. in CS from University of Illinois at Urbana-Champaign.</bio>
          <homepage_url>https://people.eecs.berkeley.edu/~ksen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/koushiksen/9f417f8a-40b9-40a7-866c-9c44cd81859a/small.jpg</picture_url>
          <person_id>koushiksen</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>db3bf9ba-bc9e-4ee5-ab22-00032f163bef</slot_id>
      <event_id>741d1273-956c-4747-a5a6-305b9f8931c5</event_id>
      <title>VarSem: Declarative Expression and Automated Inference of Variable Usage Semantics</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>17:20</end_time>
      <description>Programmers declare variables to serve specific implementation purposes that we refer to as \emph{variable usage semantics (VUS)}. Understanding VUS is required for various software engineering tasks, including program comprehension, code audits, and vulnerability detection. To help programmers understand VUS, we present a new program analysis that infers a variable’s usage semantics from its textual and context information (e.g., symbolic name, type, scope, information flow). To support this analysis, we introduce VarSem, a domain-specific language, in which a variable’s semantic category is expressed as a set of declarative rules. VarSem’s execution determines which program variables belong to a given semantic category. VarSem translates high-level declarative rules into low-level program analysis techniques, including natural language processing and data flow, and provides a highly extensible architecture for specifying new rules and analysis techniques. We evaluate VarSem with eight real-world systems to identify their personally identifiable information variables. The evaluation results show that VarSem infers variable semantics with satisfying accuracy/precision and passable recall, thus potentially benefiting both software and security engineers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yin</first_name>
          <last_name>Liu</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.google.com/vt.edu/yinl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yinliu/1bc32554-be71-4a23-8aab-f60279fd51d1/small.jpg</picture_url>
          <person_id>yinliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eli</first_name>
          <last_name>Tilevich</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.vt.edu/~tilevich</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elitilevich/10b9c85c-8a75-4acb-a0fe-e00c91dd0bb6/small.jpg</picture_url>
          <person_id>elitilevich</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ed04a9db-4792-4985-af9c-7edd1bac90b2</subevent_id>
    <title>GPCE: GPCE/SLE Opening</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/15</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
    </tracks>
    <timeslot>
      <slot_id>13b9dbc0-2460-4852-879d-33b0be6943bf</slot_id>
      <title>Session: GPCE - GPCE/SLE Opening</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>09:00</start_time>
      <end_time>09:40</end_time>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7886e846-c700-4d5d-a958-cc3ce28ef7cf</slot_id>
      <event_id>bb9db12e-2afb-4297-aede-22b724436e5a</event_id>
      <title>GPCE/SLE Opening</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:40</end_time>
      <description>undefined</description>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e23ee914-1a30-456f-bdab-f3b5ddef2680</subevent_id>
    <title>GPCE: </title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/15</date>
    <url>https://conf.researchr.org/home/gpce-2020</url>
    <url_link_display>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2020</track>
    </tracks>
    <timeslot>
      <slot_id>b4f8a033-a808-4fb0-868f-b28b7e04aca2</slot_id>
      <title>Session: GPCE - </title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9e82d3d0-9778-4409-bef3-3f636e4b0da6</slot_id>
      <event_id>0634bf8c-79e0-4f7f-afaa-210b311fcbf3</event_id>
      <title>Modular and distributed IDE</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>23:40</end_time>
      <description>Integrated Development Environments (IDEs) are indispensable companions to programming languages. They are increasingly turning towards Web-based infrastructure. The rise of a protocol such as the Language Server Protocol (LSP) that standardizes the protocol used between a language-agnostic IDE and a language server that provides language services like auto completion, go to definition, find all references, compilation, etc. has allowed the emergence of high quality generic Web components to build the IDE part that runs in the browser. However, the multitude of heterogeneous language services offered within an IDE are requiring different computing capacities and response times to guarantee a user-friendly experience with the IDE. The monolithic distribution of all language services prevent to leverage on the available execution platforms (e.g., local platform, application server, cloud), and to offer a tailored distribution that optimizes the user experience and the overall performance of the language services. In contrast with the current approaches that provide IDEs in the form of a monolithic client-server architecture, we explore in this paper the modularization of all language services to support their individual deployment and dynamic adaptation within an IDE. We also study the performance impact to distribute the language services across the available execution platforms. We evaluate our approach on four EMF-based languages and demonstrate the benefit of a custom distribution of the various language services.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fabien</first_name>
          <last_name>Coulon</last_name>
          <affiliation>University of Toulouse / Obeo</affiliation>
          <bio>undefined</bio>
          <person_id>fabiencoulon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alex</first_name>
          <last_name>Auvolat</last_name>
          <affiliation>University of Rennes, Inria, CNRS, IRISA</affiliation>
          <bio>undefined</bio>
          <person_id>alexauvolat</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Toulouse and Inria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yerom-David</first_name>
          <last_name>Bromberg</last_name>
          <affiliation>University of Rennes, Inria, CNRS, IRISA</affiliation>
          <bio>undefined</bio>
          <person_id>yeromdavidbromberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>François</first_name>
          <last_name>Taïni</last_name>
          <affiliation>University of Rennes, Inria, CNRS, IRISA</affiliation>
          <bio>undefined</bio>
          <person_id>francoistaini</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Barais</last_name>
          <affiliation>(Univ Rennes, Inria, IRISA)</affiliation>
          <bio>undefined</bio>
          <person_id>olivierbarais1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Noël</first_name>
          <last_name>Plouzeau</last_name>
          <affiliation>University of Rennes, Inria, CNRS, IRISA</affiliation>
          <bio>undefined</bio>
          <person_id>noelplouzeau</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d79f7ea3-54e9-4214-ab6d-eb9b60137825</slot_id>
      <event_id>677f497e-d633-4e7c-9fa6-3eb6bdc8a827</event_id>
      <title>Automated Variability Injection for Graphical Modelling Languages</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>23:20</end_time>
      <description>Model-based development approaches, such as Model-Driven Engineering (MDE), heavily rely on the use of modelling languages to achieve and automate software development tasks. To enable the definition of model variants (e.g., supporting the compact description of system families), one solution is to combine MDE with Software Product Lines. However, this is technically costly as it requires adapting many MDE artefacts associated to the modelling language – especially the meta-models and graphical environments.
To alleviate this situation, we propose a method for the automated injection of variability into graphical modelling languages. Given the meta-model and graphical environment of a particular language, our approach permits configuring the allowed model variability, and the graphical environment is automatically adapted to enable creating models with variability. Our solution is implemented atop the Eclipse Modeling Framework and Sirius, and synthesizes adapted graphical editors integrated with FeatureIDE.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Antonio</first_name>
          <last_name>Garmendia</last_name>
          <affiliation>JKU Linz</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.se.jku.at/antonio-garmendia/</homepage_url>
          <person_id>antoniogarmendia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Wimmer</last_name>
          <affiliation>Johannes Kepler University Linz</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.se.jku.at/manuel-wimmer/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelwimmer/debab079-8b78-46af-8f24-2ce08001b86f/small.jpg</picture_url>
          <person_id>manuelwimmer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Esther</first_name>
          <last_name>Guerra</last_name>
          <affiliation>Universidad Autonoma de Madrid</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/estherguerra/e25b23e7-460a-487a-ac4f-bd6326e36ac7/small.jpg</picture_url>
          <person_id>estherguerra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Elena</first_name>
          <last_name>Gómez-Martínez</last_name>
          <affiliation>Universidad Autonoma de Madrid</affiliation>
          <bio>undefined</bio>
          <person_id>elenagomezmartinez</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Juan</first_name>
          <last_name>de Lara</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arantxa.ii.uam.es/~jlara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juandelara/36b5a702-1b04-48b9-8849-869aa603a88d/small.jpg</picture_url>
          <person_id>juandelara</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d8e941eb-b662-487e-b4be-e639415e1c25</slot_id>
      <event_id>c32f3297-945e-48d1-95da-9f3daec1ec11</event_id>
      <title>A Family of Languages for Trustworthy Agent-Based Simulation</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>00:20</end_time>
      <description>Simulation is a key tool in the scientist’s toolkit to enable understanding of complex system behaviour. Agent-based simulation is one form of simulation that has seen applications across different sciences from biology to health, economics, and urban sciences. However, engineering agent-based simulations such that they are robust, efficient, maintainable, and reliable as well as trusted by domain experts is very challenging. Most recently, this has come to public attention in the context of agent-based simulations of the COVID-19 pandemic.
In this paper, we develop a vision of how a family of domain-specific languages could help construct agent-based simulations more systematically and, by following a systematic engineering process, improve their robustness, efficiency, and maintainability as well as increasing transparency and traceability from the original domain understanding to the simulation implementation and back to the simulation results and conclusions. This family consists of three categories of languages for modelling domain knowledge, experimental requirements, and experimental results, each at hierarchically increasing abstraction levels from the simulation platform, via a generic agent-modelling language to modelling languages specific to the problem domain. We discuss the vision in detail and illustrate it with a motivating example.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Steffen</first_name>
          <last_name>Zschaler</last_name>
          <affiliation>King's College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.steffen-zschaler.de/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/steffenzschaler/aeac85bf-ae27-4394-b79a-4569c1138728/small.jpg</picture_url>
          <person_id>steffenzschaler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fiona</first_name>
          <last_name>Polack</last_name>
          <affiliation>Keele University</affiliation>
          <bio>undefined</bio>
          <person_id>fionapolack</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>edcafea1-d711-4105-a1d1-ad7bbde769df</slot_id>
      <event_id>404bc9e9-77ae-4014-95e6-150008d75fce</event_id>
      <title>Correctness-by-Construction for Feature-Oriented Software Product Lines</title>
      <room>Online | SPLASH</room>
      <date>2020/11/15</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>00:00</end_time>
      <description>\emph{Software product lines} are increasingly used to handle the growing demand of custom-tailored software variants. They provide systematic reuse of software and other artifacts paired with variability mechanisms in the code to implement whole product families rather than single software products. A common domain of application for product lines are safety-critical systems, which require \emph{behavioral correctness} to omit dangerous situations in-field. While most approaches in academia concentrate on post-hoc verification for product lines, we argue that a stepwise approach to create correct programs may be beneficial for the developer to manage the growing variability. \emph{Correctness-by-construction} is such a stepwise approach to create programs using a set of small, tractable refinement rules that guarantee the correctness of the program with regard to its specification. In this paper, we propose the first approach to develop correct-by-construction software product lines using feature-oriented programming. First, we extend correctness-by-construction by two refinement rules for variation points in the code. Second, we give a proof for the soundness of the proposed rules. Third, we implement our technique in a tool called VarCorC and show the applicability of the tool by conducting two case studies.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tabea</first_name>
          <last_name>Bordis</last_name>
          <affiliation>TU Braunschweig</affiliation>
          <bio>undefined</bio>
          <person_id>tabeabordis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Runge</last_name>
          <affiliation>TU Braunschweig</affiliation>
          <bio>undefined</bio>
          <person_id>tobiasrunge</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ina</first_name>
          <last_name>Schaefer</last_name>
          <affiliation>Technische Universität Braunschweig</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.tu-braunschweig.de/isf/team/schaefer</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/inaschaefer/49ab41dc-9f8c-4f0f-b786-43b70d25d96d/small.jpg</picture_url>
          <person_id>inaschaefer</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2020 - 19th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2f0f8934-4a75-4f18-b5cd-167e29274e2c</subevent_id>
    <title>ECOOP Research Papers: S-3</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/15</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>8e8df2d3-039d-461a-b9f0-9ac7dfab5755</slot_id>
      <title>Session: ECOOP Research Papers - S-3</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>157fb7bc-e75f-4fb9-896e-0088e6e289ba</slot_id>
      <event_id>a6b2d038-de0e-4dba-afec-21ca56a42e47</event_id>
      <title>Sound regular corecursion in coFJ</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>23:40</end_time>
      <description>The aim of the paper is to provide solid foundations for a programming paradigm natively supporting the creation and manipulation of cyclic data structures. To this end, we describe coFJ, a Java-like calculus where objects can be \emph{infinite} and methods are equipped with a \emph{codefinition} (an alternative body). We provide an abstract semantics of the calculus based on the framework of \emph{inference systems with corules}. In coFJ with this semantics, FJ recursive methods on finite objects can be extended to infinite objects as well, and behave as desired by the programmer, by specifying a codefinition. In the meantime, we describe an operational semantics which can be directly implemented in a programming language, and prove the soundness of such semantics with respect to the abstract one.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Davide</first_name>
          <last_name>Ancona</last_name>
          <affiliation>DIBRIS, University of Genova, Italy</affiliation>
          <bio>Davide Ancona (PhD in Computer Science, University of Pisa, 1998) is Associate Professor at the University of Genova. His main research interests include type systems, object-oriented programming, coinduction methods for programming languages, modules and components, software reuse and maintenance, multi-agent systems, and behavioral types. He is author of more than 70 publications. He is the secretary of the executive board of AITO, Association Internationale pour les Technologies Objets (since Jan 2013, previously Vice-President since Jan 2012), and member of the editorial board of the ACM/SIGAPP Applied Computing Review (ACR), Scientific Programming (Hindawi), and Open Computer Science. He has been guest editor of special issues of Science of Computer Programming and Journal of Object Technology. In 2009 he received, together with G. Lagorio, the best paper prize at ECOOP. He has participated to several national and European projects and has been PC member of several workshops and conferences: WOOD’04, Bytecode 2008, ESOP 2008, DLS 2009, 2010 and 2013, FOOL 2010, RP 2011 and 2012, ECOOP 2013 and 2014, POPL 2015 (ERC), OOPSLA 2016 (ERC), TASE 2016, FTfJP 2016. He has been involved in the organization of several scientific events: organizing chair of ECOOP 2009, program co-chair of FTfJP06 and of OOPS special track at SAC from 2004 through 2017, co-chair of CILC 2015 and VORTEX 2016.</bio>
          <homepage_url>http://www.disi.unige.it/person/AnconaD/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davideancona/50b3fc2f-1782-4ca1-91a5-6718f42ba51b/small.jpg</picture_url>
          <person_id>davideancona</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pietro</first_name>
          <last_name>Barbieri</last_name>
          <affiliation>Università di Genova</affiliation>
          <bio>undefined</bio>
          <person_id>pietrobarbieri</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Dagnino</last_name>
          <affiliation>DIBRIS, University of Genova, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.dibris.unige.it/en/dagnino-francesco</homepage_url>
          <person_id>francescodagnino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Elena</first_name>
          <last_name>Zucca</last_name>
          <affiliation>University of Genova</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.disi.unige.it/person/ZuccaE/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elenazucca/31be5390-fc85-4134-90af-718c3b50c4a3/small.jpg</picture_url>
          <person_id>elenazucca</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4b317c64-c032-4a77-ac76-c7a7c05af3b8</slot_id>
      <event_id>51bcdb71-4f23-4307-a4b8-8565ca1fb7ab</event_id>
      <title>Flow-Sensitive Type-Based Heap Cloning</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>23:20</end_time>
      <description>Flow-sensitive pointer analysis promises more precise results than its flow-insensitive counterpart by respecting program control-flow. However, existing heap abstractions for C/C++ flow-sensitive pointer analysis model the heap by creating one heap object per memory allocation. Two runtime heap objects which originate from the same allocation site are imprecisely modeled using one abstract object, which makes them share the same imprecise points-to sets and thus reduces the benefit of analysing heap objects flow-sensitively. On the other hand, equipping flow-sensitive analysis with context-sensitivity where an abstract heap object is created (cloned) per calling context can yield a more precise heap modeling for flow-sensitive analysis, but at the cost of uncontrollable analysis overhead when analysing larger programs.
This paper presents TypeClone, a new type-based heap model for flow-sensitive analysis. Our key insight is to differentiate concrete heap objects lazily using the type information at their use sites (e.g., accessed via pointer dereferencing) within the program control-flow. The novelty of TypeClone lies in its lazy heap cloning: an untyped abstract heap object created at an allocation site is killed and replaced with a new (cloned) object uniquely identified by the type information at its use site for flow-sensitive points-to propagation. This yields more precise points-to relations for each program point through well-typed objects where necessary. Thus, heap cloning can be performed within a flow-sensitive analysis without the need for context-sensitivity. Moreover, we extend TypeClone to support new kinds of strong updates for heap objects to filter out imprecise points-to relations at object use sites for programs conforming to the strict aliasing rules based on the standard C/C++ specification. Our method is neither strictly superior nor inferior to context-sensitive heap cloning, but rather, represents a new dimension that achieves a sweet spot between precision and efficiency. Our experimental results also confirm that TypeClone is more precise than flow-sensitive pointer analysis by increasing the percentage of no-alias queries by 12% on average.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohamad</first_name>
          <last_name>Barbar</last_name>
          <affiliation>University of Technology, Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>mohamadbarbar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yulei</first_name>
          <last_name>Sui</last_name>
          <affiliation>University of Technology Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuleisui.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yuleisui/e6ce6e88-3cd8-4595-9c61-a8da6f7319f6/small.jpg</picture_url>
          <person_id>yuleisui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Shiping</first_name>
          <last_name>Chen</last_name>
          <affiliation>Data61 at CSIRO, Australia / UNSW, Australia</affiliation>
          <bio>Dr. Shiping Chen is a principal research scientist in CSIRO Data61. He also holds an conjoint A/Professor title with the University of New Suouth Wales (UNSW) and the University of Sydney through teaching and supervising PhD students. He has been working on distributed systems for over 20 years with focus on performance and security. He has published 150+ research papers in these research areas. He is actively involved in computing research community through publications, journal editorship and conference TPC services, including WWW, EDOC, ICSOC and IEEE ICWS/SCC/CLOUD. His current research interests include application security, blockchain and service-oriented trusted collaboration. He is a senior member of the IEEE.</bio>
          <homepage_url>https://www.cse.unsw.edu.au/~z9195738/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shipingchen/820fa36a-2dfb-43c7-996f-98306efc746b/small.jpg</picture_url>
          <person_id>shipingchen</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d3f58031-0f4f-4e20-b72a-4d67b8e68440</slot_id>
      <event_id>fca401c6-2be9-4344-9688-7495c67214c0</event_id>
      <title>Value Partitioning: A Lightweight Approach to Relational Static Analysis for JavaScript</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>00:00</end_time>
      <description>In static analysis of modern JavaScript libraries, relational analysis at key locations is critical to provide sound and useful results. Prior work addresses this challenge by the use of various forms of trace partitioning and syntactic patterns, which is fragile and does not scale well, or by incorporating complex backwards analysis.
In this paper, we propose a new lightweight variant of trace partitioning named value partitioning that refines individual abstract values instead of entire abstract states. We describe how this approach can effectively capture important relational properties involving dynamic property accesses, functions with free variables, and predicate functions.
We extend an existing JavaScript analyzer with value partitioning and demonstrate experimentally that it is a simple, precise, and efficient alternative to the existing approaches for analyzing widely used JavaScript libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Benjamin Barslev</first_name>
          <last_name>Nielsen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/benjaminbarslevnielsen/7c6acacc-eb83-4ad2-8f27-d9a7ce64e58e/small.jpg</picture_url>
          <person_id>benjaminbarslevnielsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anders</first_name>
          <last_name>Møller</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
          <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
          <person_id>andersmoller</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e9555e5a-4700-47b5-a06f-c0a4a4f39fab</slot_id>
      <event_id>b3bfaad5-f792-4abe-beec-b2c3543839eb</event_id>
      <title>Row and Bounded Polymorphism via Disjoint Polymorphism</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>00:20</end_time>
      <description>Polymorphism and subtyping are important features in mainstream OO languages. The most common way to integrate the two is via F&amp;lt;: style bounded quantification. A closely related mechanism is row polymorphism, which provides an alternative to subtyping, while still enabling many of the same applications. Yet another approach is to have type systems with intersection types and polymorphism. A recent addition to this design space are calculi with disjoint intersection types and disjoint polymorphism. With all these alternatives it is natural to wonder how they are related.
This paper provides an answer to this question. We show that disjoint polymorphism can recover forms of both row polymorphism and bounded polymorphism, while retaining key desirable properties, such as type-safety and decidability. Furthermore, we identify the extra power of disjoint polymorphism which enables additional features that cannot be easily encoded in calculi with row polymorphism or bounded quantification alone. Ultimately we expect that our work is useful to inform language designers about the expressive power of those common features, and to simplify implementations and metatheory of feature-rich languages with polymorphism and subtyping.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ningning</first_name>
          <last_name>Xie</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://xnning.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ningningxie/99787204-daa9-484a-bea5-4b2b88551687/small.jpg</picture_url>
          <person_id>ningningxie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>The University of Hong Kong, Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xuan</first_name>
          <last_name>Bi</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <person_id>xuanbi1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>803c0f1f-3664-4e56-bbcb-17e7c53e7a8c</subevent_id>
    <title>ECOOP Research Papers: S-2</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/15</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>2bd94b7b-8665-49ba-b486-24c3226f5375</slot_id>
      <title>Session: ECOOP Research Papers - S-2</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2bf84a91-f362-4e4f-8628-d08472689ea6</slot_id>
      <event_id>938f9252-3dc5-4325-a133-eb25a1ebd488</event_id>
      <title>Perfect is the Enemy of Good: Best-Effort Program Synthesis</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>10:20</end_time>
      <description>Program synthesis promises to help software developers with everyday tasks by generating code snippets automatically from input-output examples and other high-level specifications. The conventional wisdom is that a synthesizer must always satisfy the specification exactly. We conjecture that this all-or-nothing paradigm stands in the way of adopting program synthesis as a developer tool: in practice, the user-written specification often contains errors or is simply too hard for the synthesizer to solve within a reasonable time; in these cases, the user is left with a single over-fitted result or, more often then not, no result at all. In this paper we propose a new program synthesis paradigm we call \emph{best-effort program synthesis}, where the synthesizer returns a ranked list of partially-valid results, i.e., programs that satisfy some part of the specification.
To support this paradigm, we develop \emph{best-effort enumeration}, a new synthesis algorithm that extends a popular program enumeration technique with the ability to accumulate and return multiple partially-valid results with minimal overhead. We implement this algorithm in a tool called Bester, and evaluate it on $79$ synthesis benchmarks from the literature. Contrary to the conventional wisdom, our evaluation shows that Bester returns useful results even when the specification is flawed or too hard: i) for all benchmarks with an error in the specification, the top three Bester results contain the correct solution, and ii) for most hard benchmarks, the top three results contain non-trivial \emph{fragments} of the correct solution. We also performed a small user study, which confirms our intuition that partially-valid results are useful: the study shows that programmers use the output of the synthesizer for comprehension and often incorporate it into their solutions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>58c9938b-ba5c-452c-a79d-6065c9017c76</slot_id>
      <event_id>b1086991-0f35-4b4b-b7a4-78b902ec9ab5</event_id>
      <title>Blame for Null</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>10:00</end_time>
      <description>Multiple modern programming languages, including Kotlin, Scala, Swift, and C#, have type systems where nullability is explicitly specified in the types. All of the above also need to interoperate with languages where types remain implicitly nullable, like Java. This leads to runtime errors that can manifest in subtle ways. In this paper, we show how to reason about the presence and provenance of such nullability errors using the concept of blame from gradual typing. Specifically, we introduce a calculus LambdaNull, where some terms are typed as implicitly nullable and others as explicitly nullable. Just like in the original blame calculus of Wadler and Findler, interactions between both kinds of terms are mediated by casts with attached blame labels, which indicate the origin of errors. On top of LambdaNull, we then define a second calculus, StratifiedLambdaNull, which closely models the interoperability between languages with implicit nullability and languages with explicit nullability, such as Java and Scala. Our main result is a theorem that states that nullability errors in StratifiedLambdaNull can always be blamed on terms with less-precise typing; that is, terms typed as implicitly nullable. By analogy, this would mean that NullPointerExceptions in combined Java/Scala programs are always the result of unsoundness in the Java type system. We summarize our result with the slogan explicitly nullable programs can’t be blamed. All our results are formalized in the Coq proof assistant.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abel</first_name>
          <last_name>Nieto</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://abeln.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/abelnieto/88adb2b6-4aa2-4cc1-af2b-5a23289e9794/small.jpg</picture_url>
          <person_id>abelnieto</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marianna</first_name>
          <last_name>Rapoport</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mrapoport.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mariannarapoport/7f9f1bbc-f804-49b4-b350-26210268c55b/small.jpg</picture_url>
          <person_id>mariannarapoport</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gregor</first_name>
          <last_name>Richards</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://the.gregor.institute/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gregorrichards/bd8bf252-24c9-4721-a495-c06a6949a332/small.jpg</picture_url>
          <person_id>gregorrichards</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>93a6c2bd-a2d6-4f98-9e4d-bc480a389ee9</slot_id>
      <event_id>e5b5bb01-82ec-490b-a4e5-e62389f99279</event_id>
      <title>Abstracting gradual references</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:20</end_time>
      <description>Gradual typing is an effective approach to integrate static and dynamic typing, which supports the smooth transition between both extremes via the imprecision of type annotations. Gradual typing has been applied in many scenarios such as objects, subtyping, effects, ownership, typestates, information-flow typing, parametric polymorphism, etc. In particular, the combination of gradual typing and mutable references has been explored by different authors, giving rise to four different semantics—invariant, guarded, monotonic and permissive references. These semantics were specially crafted to reflect different design decisions with respect to precision and efficiency tradeoffs. Since then, progress has been made in the formulation of methodologies to systematically derive gradual counterparts of statically-typed languages, but these have not been applied to study mutable references.
In this article, we explore how the Abstracting Gradual Typing (AGT) methodology, which has been shown to be effective in a variety of settings, applies to mutable references. Starting from a standard statically-typed language with references, we systematically derive with AGT a novel gradual language, called λREF˜. We establish the properties of λREF˜; in particular, it is the first gradual language with mutable references that is proven to satisfy the gradual guarantee. We then compare λREF˜ with the main four existing approaches to gradual references, and show that the application of AGT does justify one of the proposed semantics: we formally prove that the treatment of references in λREF˜ corresponds to the guarded semantics, by presenting a bisimilation with the coercion semantics of Herman et al. In the process, we uncover that any direct application of AGT yields a gradual language that is not space-efficient. We consequently adjust the dynamic semantics of λREF˜ to recover space efficiency. We then show how to extend λREF˜ to support both monotonic and permissive references as well. Finally, we provide the first proof of the dynamic gradual guarantee for monotonic references. As a result, this paper sheds further light on the design space of gradual languages with mutable references and contributes to deepening the understanding of the AGT methodology.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matías</first_name>
          <last_name>Toro</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/matiastoro/65656fe4-15fe-4af6-9a50-7f28cdc25fdb/small.jpg</picture_url>
          <person_id>matiastoro</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
          <person_id>etanter</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b69d84b9-73ff-46bc-96ac-abe82540ccd2</slot_id>
      <event_id>7a123832-31e7-4cda-8509-cfeef5dacfe3</event_id>
      <title>Don't Panic! Better, Fewer, Syntax Errors for LR Parsers</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>09:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:40</end_time>
      <description>Syntax errors are generally easy to fix for humans, but not for parsers, in general, and LR parsers, in particular. Traditional `panic mode’ error recovery, though easy to implement and applicable to any grammar, often leads to a cascading chain of errors that drown out the original. More advanced error recovery techniques suffer less from this problem but have seen little practical use because their typical performance was seen as poor, their worst case unbounded, and the repairs they reported arbitrary. In this paper we introduce an algorithm and implementation that addresses these issues. First, we report the complete set of minimum cost repair sequences for a given location, allowing programmers to select the one that best fits their intention. Second, on a corpus of 200,000 real-world syntactically invalid Java programs, we are able to repair 98.38% ± 0.018% of files within a cut-off of 0.5s. Finally, we use the existence of the complete set of minimum cost repair sequences to reduce one of the most frustrating consequences of error reporting: the cascading error problem. Across our corpus, we report 435,823.0 ± 478.0 error locations to the user, while the panic mode algorithm reports 981,628.0 ± 0.0 error locations: in other words, we reduce the cascading error problem by well over half.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lukas</first_name>
          <last_name>Diekmann</last_name>
          <affiliation>King's College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://lukasdiekmann.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lukasdiekmann/a00dd8d1-84fa-4f67-9b77-d5994819208f/small.jpg</picture_url>
          <person_id>lukasdiekmann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Laurence</first_name>
          <last_name>Tratt</last_name>
          <affiliation>King's College London</affiliation>
          <bio>Programmer / researcher.</bio>
          <homepage_url>http://tratt.net/laurie/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/laurencetratt/f715fc31-2c46-4e48-9a13-d715343fdd4d/small.jpg</picture_url>
          <person_id>laurencetratt</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e9bdff7e-a978-4958-b50d-6c1b91895935</subevent_id>
    <title>ECOOP Research Papers: S-5</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/15</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>fabe0dbb-fbbf-4ffe-b09d-5d2fb7bc7d27</slot_id>
      <title>Session: ECOOP Research Papers - S-5</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>10c4644e-4d00-49bb-b129-f75e2f831273</slot_id>
      <event_id>e3347e1a-7339-425c-a4dd-24bd3b8bcf82</event_id>
      <title>Owicki-Gries Reasoning for C11 RAR</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>16:00</end_time>
      <description>Owicki-Gries reasoning for concurrent programs uses Hoare logic together with an interference freedom rule for concurrency. In this paper, we develop a new proof calculus for the C11 RAR memory model (a fragment of C11 with both relaxed and release-acquire accesses) that allows all Owicki-Gries proof rules for compound statements, including non-interference, to remain unchanged. Our proof method features novel assertions specifying thread-specific views on the state of programs. This is combined with a set of Hoare logic rules that describe how these assertions are affected by atomic program steps. We demonstrate the utility of our proof calculus by verifying a number of standard C11 litmus tests and Peterson’s algorithm adapted for C11. Our proof calculus and its application to program verification have been fully mechanised in the theorem prover</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sadegh</first_name>
          <last_name>Dalvandi</last_name>
          <affiliation>University of Surrey</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dalvandi.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mohammadsadeghdalvandi/c22dc5e6-1b7d-4d4b-bc5d-0c19608c2c89/small.jpg</picture_url>
          <person_id>mohammadsadeghdalvandi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Doherty</last_name>
          <affiliation>University of Sheffield</affiliation>
          <bio>undefined</bio>
          <person_id>simondoherty</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brijesh</first_name>
          <last_name>Dongol</last_name>
          <affiliation>University of Surrey</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/brijeshdongol/1a40f0ae-7a59-4232-b09e-a69a66272c0f/small.jpg</picture_url>
          <person_id>brijeshdongol</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Heike</first_name>
          <last_name>Wehrheim</last_name>
          <affiliation>Paderborn University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.uni-paderborn.de/en/person/573/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/heikewehrheim/77537d51-60d9-4a1d-8187-78047b1f330c/small.jpg</picture_url>
          <person_id>heikewehrheim</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>877f1613-9768-4bf7-8850-eb99519daa18</slot_id>
      <event_id>a0edda4b-941b-497b-904d-4736318de222</event_id>
      <title>Test-Case Reduction via Test-Case Generation: Insights From the Hypothesis Reducer</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>16:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>16:20</end_time>
      <description>We describe internal test case reduction, the method of test case reduction employed by the widely-used Hypothesis property-based testing tool for Python. The key idea of internal test-case reduction is that instead of applying test-case reduction externally to generated test cases, we apply it internally, to the sequence of random choices made during generation, so that a test case is reduced by continually re-generating smaller and simpler test cases that continue to trigger some property of interest in the system under test (e.g. a failure). This allows for fully generic test-case reduction without any user intervention and without the need to write a specific test case reducer for a particular application domain. It also significantly mitigates the test-case validity problem of test-case reduction by ensuring that any reduced test case is one that could in principle have been generated. We describe the rationale behind this approach, explain how it is implemented in Hypothesis in practice, and present an extensive evaluation comparing its effectiveness to that of several other test case reducers, including C-Reduce, Picire and the TSTL reducer, on applications including Python auto-formatting, C compilers, and the SymPy symbolic math library. Our hope is that these insights into the reduction mechanism employed by Hypothesis will be useful to researchers interested in randomized testing and test case reduction, as the crux of the approach is fully generic and should be applicable to any random generator of test cases.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>R. MacIver</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidrmaciver/d5f97248-0c54-4660-b99e-00f052f29fa9/small.jpg</picture_url>
          <person_id>davidrmaciver</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alastair</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c5a34823-4913-4378-8d04-3f6a11e707c6</slot_id>
      <event_id>91001d71-626c-479e-b98d-9569a3dda1f7</event_id>
      <title>Putting Randomized Compiler Testing into Production</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>15:40</end_time>
      <description>We describe our experience over the last 15 months on a compiler testing technology transfer project: taking the GraphicsFuzz research project on randomized metamorphic testing of graphics shader compilers, and building the necessary tooling around it to provide a highly automated process for improving the Khronos Vulkan Conformance Test Suite (CTS) with test cases that expose fuzzer-found compiler bugs, or that plug gaps in test coverage. We present this tooling for test automation—gfauto—in detail, as well as our use of differential coverage and test case reduction as a method for automatically synthesising tests that fill coverage gaps. We explain the value that GraphicsFuzz has provided in automatically testing the ecosystem of tools for transforming, optimizing and validating Vulkan shaders, and the challenges brought by testing a tool ecosystem rather than a single tool. We discuss practical issues associated with putting automated metamorphic testing into production, and provide illustrative examples of bugs found during our work.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alastair</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hugues</first_name>
          <last_name>Evrard</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <person_id>huguesevrard1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Paul</first_name>
          <last_name>Thomson</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <person_id>paulthomson1</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c67c3de3-2891-414e-ae1f-905a86d3f115</slot_id>
      <event_id>4bcfde8b-6df2-40b4-9db4-798cf823616a</event_id>
      <title>Model-View-Update-Communicate: Session Types meet the Elm Architecture</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>15:20</end_time>
      <description>Session types are a type discipline for communication channel endpoints which allow conformance to protocols to be checked statically. Safely implementing session types requires linearity, usually in the form of a linear type system. Unfortunately, linear typing is difficult to integrate with graphical user interfaces (GUIs), and to date most programs using session types are command line applications.
In this paper, we propose the first principled integration of session typing and GUI development by building upon the Model-View-Update (MVU) architecture, pioneered by the Elm programming language. We introduce λMVU, the first formal model of the MVU architecture, and prove it sound. By extending λMVU with commands as found in Elm, along with linearity and model transitions, we show the first formal integration of session typing and GUI programming. We implement our approach in the Links web programming language, and show examples including a two-factor authentication workflow and multi-room chat server.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Simon</first_name>
          <last_name>Fowler</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>I’m currently a Research Associate on the STARDUST project at the University of Glasgow School of Computing Science.
My research interests centre around typed functional programming languages, in particular functional approaches to concurrency, web programming, and data management.</bio>
          <homepage_url>http://www.simonjf.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/simonfowler/8da87b62-b333-4c60-ac4a-27594510d4b1/small.jpg</picture_url>
          <person_id>simonfowler</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bf0421ef-63e6-479e-b999-23d2e43bd1cf</subevent_id>
    <title>ECOOP Research Papers: M-4</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>fcbc7e93-8e15-4dc9-a346-33647a7727d6</slot_id>
      <title>Session: ECOOP Research Papers - M-4</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>14ea580a-4cbf-4d4b-8629-1b4764dcfe0f</slot_id>
      <event_id>97ef5573-0f58-46e1-9fe7-f39f45954cbf</event_id>
      <title>Designing with Static Capabilities and Effects</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>01:20</end_time>
      <description>Capabilities (whether object or reference capabilities) are fundamentally tools to restrict effects. Thus static capabilities (object or reference) and effect systems take different technical machinery to the same core problem of statically restricting or reasoning about effects in programs. Any time two approaches can in principle address the same sets of problems, it becomes important to understand the trade-offs between the approaches, how these trade-offs might interact with the problem at hand.
Experts who have worked in these areas tend to find the trade-offs somewhat obvious, having considered them in context before. However, this kind of design discussion is often written down only implicitly as comparison between two approaches for a specific program reasoning problem, rather than as a discussion of general trade-offs between general classes of techniques. As a result, it is not uncommon to set out to solve a problem with one technique, only to find the other better-suited.
We discuss the trade-offs between static capabilities (specifically reference capabilities) and effect systems, articulating the challenges each approach tends to have in isolation, and how these are sometimes mitigated. We also put our discussion in context, by appealing to examples of how these trade-offs were considered in the course of developing prior systems in the area. Along the way, we highlight how seemingly-minor aspects of type systems – weakening/framing and the mere existence of type contexts – play a subtle role in the efficacy of these systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Colin</first_name>
          <last_name>Gordon</last_name>
          <affiliation>Drexel University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.drexel.edu/~csgordon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/colingordon/d990db47-1ece-4016-bce5-b764428bd0ee/small.jpg</picture_url>
          <person_id>colingordon</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>56adf6f8-881b-48c1-b331-e8bb014f65ff</slot_id>
      <event_id>075e145e-0c8a-47bf-97d2-fd7ed28f0228</event_id>
      <title>Safe, Flexible Aliasing with Deferred Borrows</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>02:00</end_time>
      <description>t.b.a</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chris</first_name>
          <last_name>Fallin</last_name>
          <affiliation>Mozilla</affiliation>
          <bio>undefined</bio>
          <person_id>chrisfallin</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>883db172-d543-47a7-bd1b-2b71c04adb23</slot_id>
      <event_id>fc6c077e-91cb-4f4f-89be-ffca400b2979</event_id>
      <title>Static Analysis of Shape in TensorFlow Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>02:20</end_time>
      <description>Machine learning has been widely adopted in diverse science and engineering domains, aided by reusable libraries and quick development patterns. The TensorFlow library is probably the best-known representative of this trend and most users employ the Python API to its powerful back-end. TensorFlow programs are susceptible to several systematic errors, especially in the dynamic typing setting of Python. We present a static analysis that tracks the shapes of tensors across Python library calls and warns of several possible mismatches. The key technical aspects are a close modeling of library semantics with respect to tensor shape, and an identification of violations and error-prone patterns. Our analysis is powerful enough to statically detect (with 100% precision) 11 of the 14 shape-related TensorFlow bugs in the recent Zhang et al. empirical study—an independent slice of real-world bugs that also includes semantic violations not statically detectable.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sifis</first_name>
          <last_name>Lagouvardos</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/sifislagouvardos/7bff730b-e719-4f0c-935c-245291f18d9d/small.jpg</picture_url>
          <person_id>sifislagouvardos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Julian</first_name>
          <last_name>Dolby</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-dolby</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juliandolby/092667c4-6e51-4476-8ef0-58b41ce9014d/small.jpg</picture_url>
          <person_id>juliandolby</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Neville</first_name>
          <last_name>Grech</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.nevillegrech.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nevillegrech/e0405613-3240-4ef2-a51f-cb7536870dc5/small.jpg</picture_url>
          <person_id>nevillegrech</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Anastasios</first_name>
          <last_name>Antoniadis</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>I am a PhD student at the Department of Informatics and Telecommunications at University of Athens. I started my PhD on October 2016 under the supervision of professor Yannis Smaragdakis and I am a member of the programming languages and software technologies research group of the department—PLaST.
My main research area is static points-to analysis of Java programs. In particular, my focus is on large-scale Java applications, such as Java EE applications and static analysis scalability under highly precise context-sensitivity.
In the past I worked as a research assistant at Oracle Labs Australia in 2019 for 5 months. I was also an intern at CERN for a year in 2012-2013.</bio>
          <homepage_url>https://anantoni.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anastasiosantoniadis/fb0f10eb-be87-449a-bb29-3879c99c4bf2/small.jpg</picture_url>
          <person_id>anastasiosantoniadis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>Research Interests: programming languages and software engineering

 Program analysis (static analysis, test generation, invariant inference, symbolic execution)
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming)
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality)
          </bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
          <person_id>yannissmaragdakis</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ddd6be82-685b-43e6-8bb5-c9c20bfa1dc4</slot_id>
      <event_id>0e16ed75-4dc8-4d08-a503-c23f55e52859</event_id>
      <title>A Trusted Infrastructure for Symbolic Analysis of Event-Driven Web Applications</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>01:40</end_time>
      <description>We introduce a trusted infrastructure for symbolic analysis of modern event-driven Web applications. This infrastructure consists of reference implementations of the DOM Core Level 1 and UI Events, JavaScript Promises, and the JavaScript async/await APIs, all underpinned by a simple Core Event Semantics that is sufficiently expressive to describe the event models underlying all these APIs. Our reference implementations are trustworthy in that they follow the API respective standards line-by-line and they are thoroughly tested against the appropriate official test-suites, passing all the applicable tests. Using the Core Events Semantics and the reference implementations, we develop JaVerT.Click, a symbolic execution tool for JavaScript that, for the first time, supports reasoning about JavaScript programs that use some (possibly all) these APIs. Using JaVerT.Click, we perform comprehensive symbolic testing of the events module of Cash, a widely-used jQuery alternative, creating a symbolic test suite with 100% line coverage, establishing bounded correctness of several essential properties of the module, and discovering two subtle, previously unknown bugs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gabriela</first_name>
          <last_name>Sampaio</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~gcs817/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gabrielasampaio/48fe961f-74cb-4bbc-b693-f8afcab7dd2d/small.jpg</picture_url>
          <person_id>gabrielasampaio</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>José</first_name>
          <last_name>Fragoso Santos</last_name>
          <affiliation>INESC-ID/Instituto Superior Técnico, Portugal </affiliation>
          <bio>undefined</bio>
          <homepage_url>http://j3fsantos.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/josesantos/601111d4-5a07-4e79-8f6a-8af72ebd6f95/small.jpg</picture_url>
          <person_id>josesantos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Petar</first_name>
          <last_name>Maksimović</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/petarmaksimovic/10dfc861-3a11-48a5-8af6-f58fd86389e3/small.jpg</picture_url>
          <person_id>petarmaksimovic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Philippa</first_name>
          <last_name>Gardner</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Philippa Gardner is a professor in the Department of Computing at Imperial College London and and has a UKRI Established Fellowship from 2018–2023. Her current research focusses on program verification: in particular, reasoning about Web programs (JavaScript and DOM); and reasoning about concurrent programs. She completed her PhD thesis, supervised by Professor Gordon Plotkin FRS at Edinburgh in 1992 and held five years of fellowships at Edinburgh. She moved to Cambridge in 1998 on an EPSRC Advanced Fellowship, hosted by Professor Robin Milner FRS. She obtained a lectureship at Imperial in 2001, and became professor in 2009. She held a Microsoft Research Cambridge/Royal Academy of Engineering Senior Fellowship from 2005 to 2010 at Imperial. Philippa directs the Research Institute on Verified Trustworthy Software Systems (VeTSS), funded by EPSRC, from 2017 to 2022. She chaired the BCS awards committee, 2013-2018, which decides the Lovelace medal (senior) and Roger Needham award (mid-career) for computer science and engineering.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~pg</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippagardner/8031e77a-ebbb-4963-a5de-94895edd7f71/small.jpg</picture_url>
          <person_id>philippagardner</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2a4b049b-7f71-4b55-a33e-152cb3e7f7ac</subevent_id>
    <title>ECOOP Research Papers: S-5</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>ba30e64a-acaa-4c84-a262-550d3a3a518a</slot_id>
      <title>Session: ECOOP Research Papers - S-5</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>19ce1727-9acf-493c-bac4-32573cc02fc2</slot_id>
      <event_id>e3347e1a-7339-425c-a4dd-24bd3b8bcf82</event_id>
      <title>Owicki-Gries Reasoning for C11 RAR</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>04:00</end_time>
      <description>Owicki-Gries reasoning for concurrent programs uses Hoare logic together with an interference freedom rule for concurrency. In this paper, we develop a new proof calculus for the C11 RAR memory model (a fragment of C11 with both relaxed and release-acquire accesses) that allows all Owicki-Gries proof rules for compound statements, including non-interference, to remain unchanged. Our proof method features novel assertions specifying thread-specific views on the state of programs. This is combined with a set of Hoare logic rules that describe how these assertions are affected by atomic program steps. We demonstrate the utility of our proof calculus by verifying a number of standard C11 litmus tests and Peterson’s algorithm adapted for C11. Our proof calculus and its application to program verification have been fully mechanised in the theorem prover</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sadegh</first_name>
          <last_name>Dalvandi</last_name>
          <affiliation>University of Surrey</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dalvandi.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mohammadsadeghdalvandi/c22dc5e6-1b7d-4d4b-bc5d-0c19608c2c89/small.jpg</picture_url>
          <person_id>mohammadsadeghdalvandi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Doherty</last_name>
          <affiliation>University of Sheffield</affiliation>
          <bio>undefined</bio>
          <person_id>simondoherty</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brijesh</first_name>
          <last_name>Dongol</last_name>
          <affiliation>University of Surrey</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/brijeshdongol/1a40f0ae-7a59-4232-b09e-a69a66272c0f/small.jpg</picture_url>
          <person_id>brijeshdongol</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Heike</first_name>
          <last_name>Wehrheim</last_name>
          <affiliation>Paderborn University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.uni-paderborn.de/en/person/573/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/heikewehrheim/77537d51-60d9-4a1d-8187-78047b1f330c/small.jpg</picture_url>
          <person_id>heikewehrheim</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2c211dc2-5e8a-4c78-8af1-4de793946440</slot_id>
      <event_id>91001d71-626c-479e-b98d-9569a3dda1f7</event_id>
      <title>Putting Randomized Compiler Testing into Production</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>03:40</end_time>
      <description>We describe our experience over the last 15 months on a compiler testing technology transfer project: taking the GraphicsFuzz research project on randomized metamorphic testing of graphics shader compilers, and building the necessary tooling around it to provide a highly automated process for improving the Khronos Vulkan Conformance Test Suite (CTS) with test cases that expose fuzzer-found compiler bugs, or that plug gaps in test coverage. We present this tooling for test automation—gfauto—in detail, as well as our use of differential coverage and test case reduction as a method for automatically synthesising tests that fill coverage gaps. We explain the value that GraphicsFuzz has provided in automatically testing the ecosystem of tools for transforming, optimizing and validating Vulkan shaders, and the challenges brought by testing a tool ecosystem rather than a single tool. We discuss practical issues associated with putting automated metamorphic testing into production, and provide illustrative examples of bugs found during our work.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alastair</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hugues</first_name>
          <last_name>Evrard</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <person_id>huguesevrard1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Paul</first_name>
          <last_name>Thomson</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <person_id>paulthomson1</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>615f9fc5-8fe9-4c71-8201-0b83626d6776</slot_id>
      <event_id>4bcfde8b-6df2-40b4-9db4-798cf823616a</event_id>
      <title>Model-View-Update-Communicate: Session Types meet the Elm Architecture</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>03:20</end_time>
      <description>Session types are a type discipline for communication channel endpoints which allow conformance to protocols to be checked statically. Safely implementing session types requires linearity, usually in the form of a linear type system. Unfortunately, linear typing is difficult to integrate with graphical user interfaces (GUIs), and to date most programs using session types are command line applications.
In this paper, we propose the first principled integration of session typing and GUI development by building upon the Model-View-Update (MVU) architecture, pioneered by the Elm programming language. We introduce λMVU, the first formal model of the MVU architecture, and prove it sound. By extending λMVU with commands as found in Elm, along with linearity and model transitions, we show the first formal integration of session typing and GUI programming. We implement our approach in the Links web programming language, and show examples including a two-factor authentication workflow and multi-room chat server.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Simon</first_name>
          <last_name>Fowler</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>I’m currently a Research Associate on the STARDUST project at the University of Glasgow School of Computing Science.
My research interests centre around typed functional programming languages, in particular functional approaches to concurrency, web programming, and data management.</bio>
          <homepage_url>http://www.simonjf.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/simonfowler/8da87b62-b333-4c60-ac4a-27594510d4b1/small.jpg</picture_url>
          <person_id>simonfowler</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>91bc3d43-46d1-4c17-ab96-fef9df455f6d</slot_id>
      <event_id>a0edda4b-941b-497b-904d-4736318de222</event_id>
      <title>Test-Case Reduction via Test-Case Generation: Insights From the Hypothesis Reducer</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>04:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>04:20</end_time>
      <description>We describe internal test case reduction, the method of test case reduction employed by the widely-used Hypothesis property-based testing tool for Python. The key idea of internal test-case reduction is that instead of applying test-case reduction externally to generated test cases, we apply it internally, to the sequence of random choices made during generation, so that a test case is reduced by continually re-generating smaller and simpler test cases that continue to trigger some property of interest in the system under test (e.g. a failure). This allows for fully generic test-case reduction without any user intervention and without the need to write a specific test case reducer for a particular application domain. It also significantly mitigates the test-case validity problem of test-case reduction by ensuring that any reduced test case is one that could in principle have been generated. We describe the rationale behind this approach, explain how it is implemented in Hypothesis in practice, and present an extensive evaluation comparing its effectiveness to that of several other test case reducers, including C-Reduce, Picire and the TSTL reducer, on applications including Python auto-formatting, C compilers, and the SymPy symbolic math library. Our hope is that these insights into the reduction mechanism employed by Hypothesis will be useful to researchers interested in randomized testing and test case reduction, as the crux of the approach is fully generic and should be applicable to any random generator of test cases.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>R. MacIver</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidrmaciver/d5f97248-0c54-4660-b99e-00f052f29fa9/small.jpg</picture_url>
          <person_id>davidrmaciver</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alastair</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0d0881ed-45fe-45df-b354-94cc42dbaf4f</subevent_id>
    <title>ECOOP Research Papers: S-6</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/15</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>8dad22af-f567-46df-bb57-920ca87e3b36</slot_id>
      <title>Session: ECOOP Research Papers - S-6</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>13002b65-4ef8-432f-8372-6f3e06a78669</slot_id>
      <event_id>08eaa378-f2f5-4c5f-b1a8-e9c754b3d384</event_id>
      <title>Reference immutability for DOT</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>17:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>17:40</end_time>
      <description>Reference immutability is a type-based technique for controlling mutation that has been thoroughly studied in Java. We explore how reference immutability interacts with the features of Scala by adding it to the Dependent Object Types (DOT) calculus. Our extension shows how reference immutability can be encoded using existing Scala features such as path-dependent, intersection, and union types. We prove type soundness and the immutability guarantee provided by our calculus.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vlastimil</first_name>
          <last_name>Dort</last_name>
          <affiliation>Charles University</affiliation>
          <bio>undefined</bio>
          <person_id>vlastimildort</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>488ebf27-6d3c-459e-b5f7-83feecd65e63</slot_id>
      <event_id>3198f204-28c6-492a-8457-c51ebcc772f0</event_id>
      <title>Static Race Detection and Mutex Safety and Liveness for Go Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>17:20</end_time>
      <description>Go is a popular concurrent programming language thanks to its ability to efficiently combine concurrency and systems programming. In Go programs, a number of concurrency bugs can be caused by a mixture of data races and communication problems. In this paper, we develop a theory based on behavioural types to statically detect data races and deadlocks in Go programs. We first specify lock safety/liveness and data race properties over a Go program model, using the happens-before relation defined in the Go memory model. We represent these properties of programs in a µ-calculus model of types, and validate them using type-level model-checking. We then extend the framework to account for Go’s channels, and implement a static verification tool which can detect concurrency errors. This is, to the best of our knowledge, the first static verification framework of this kind for the Go language, uniformly analysing concurrency errors caused by a mix of shared memory accesses and asynchronous message-passing communications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julia</first_name>
          <last_name>Gabet</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <person_id>juliagabet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7feba1b3-9075-4aa7-88c0-bcba2ecd9f8b</slot_id>
      <event_id>d4d20ec5-085d-4a47-b76e-d1155d4f08c5</event_id>
      <title>Multiparty Session Programming with Global Protocol Combinators</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>17:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>18:00</end_time>
      <description>Multiparty Session Types (MPST) is a typing discipline for communication protocols. It ensures the absence of communication errors and deadlocks for well-typed communicating processes. The state of the art implementations of the MPST theory rely on (1) runtime linearity checks to ensure correct usage of communication channels and (2) external domain-specific languages for specifying and verifying of multiparty protocols.
To overcome these limitations, we propose a library for programming with global combinators – a set of functions for writing and verifying multiparty protocols in OCaml. Local behaviours for all processes in a protocol are inferred at once from a global combinator. We formalise global combinators and prove a sound realisability of global combinators – a well-typed global combinator derives a set of local types, by which typed endpoint programs can ensure type and communication safety. Our approach enables fully-static verification and implementation of the whole protocol, from the protocol specification to the process implementations, to happen in the same language.
We compare our implementation to untyped and continuation-passing style implementations, and demonstrate its expressiveness by implementing a plethora of protocols. We show our library can interoperate with existing libraries and services, implementing DNS (Domain Name Service) protocol and the OAuth (Open Authentication) protocol.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Keigo</first_name>
          <last_name>Imai</last_name>
          <affiliation>Gifu University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/keigoimai/70b0be2a-fa97-45a6-a037-57682ad05bf9/small.jpg</picture_url>
          <person_id>keigoimai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rumyana</first_name>
          <last_name>Neykova</last_name>
          <affiliation>Brunel University London</affiliation>
          <bio>Rumyana Neykova is a lecturer at Brunel University London, previously completed a PhD degree under the supervision of Prof. Nobuko Yoshida at Imperial College London, where she was also research fellow. Her research interests are in the area of distributed systems and networks, as well as type systems and language design. Her PhD focuses on development and applications of a type theory (called session types) for runtime verification of concurrent and distributed systems.</bio>
          <homepage_url>https://www.brunel.ac.uk/people/rumyana-neykova</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rumyananeykova/66457b0a-8e8b-471e-b278-37d7f4242bcb/small.jpg</picture_url>
          <person_id>rumyananeykova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Shoji</first_name>
          <last_name>Yuen</last_name>
          <affiliation>Nagoya University</affiliation>
          <bio>undefined</bio>
          <person_id>shojiyuen</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>85a7d672-0c77-4ca0-9ca1-5d9b6bbb5fde</slot_id>
      <event_id>30a683a6-c04e-4827-bf2a-38cbfe60cc03</event_id>
      <title>Scala with Explicit Nulls</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>18:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>18:20</end_time>
      <description>The Scala programming language makes all reference types implicitly nullable. This is a problem, because null references do not support most operations that do make sense on regular objects, leading to runtime errors. In this paper, we present a modification to the Scala type system that makes nullability explicit in the types. Specifically, we make reference types non-nullable by default, while still allowing for nullable types via union types. We have implemented this design for explicit nulls as a fork of the Dotty (Scala 3) compiler. We evaluate our scheme by migrating a number of Scala libraries to use explicit nulls. Finally, we give a denotational semantics of type nullification, the interoperability layer between Java and Scala with explicit nulls. We show a soundness theorem stating that, for variants of System F omega that model Java and Scala, nullification preserves elements of ground types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abel</first_name>
          <last_name>Nieto</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://abeln.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/abelnieto/88adb2b6-4aa2-4cc1-af2b-5a23289e9794/small.jpg</picture_url>
          <person_id>abelnieto</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yaoyu</first_name>
          <last_name>Zhao</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>yaoyuzhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Angela</first_name>
          <last_name>Chang</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>angelachang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Justin</first_name>
          <last_name>Pu</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>justinpu</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7b9bf4e4-0439-4e0f-b440-eeb4097947c7</subevent_id>
    <title>ECOOP Research Papers: M-6B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/16</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>9faf8ccb-987b-4a73-a4b6-f17594dafea3</slot_id>
      <title>Session: ECOOP Research Papers - M-6B</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>17:00</start_time>
      <end_time>17:20</end_time>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>68b049f7-0772-4dad-b0b1-36053f0c321f</slot_id>
      <event_id>b5cd4295-3dae-4811-a9a2-cd69e93f5866</event_id>
      <title>Space-Efficient Gradual Typing in Coercion-Passing Style</title>
      <room>Online | SPLASH</room>
      <date>2020/11/16</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>17:20</end_time>
      <description>Herman et al. (2007, 2010) pointed out that the insertion of run-time checks into a gradually typed program could hamper tail-call optimization and, as a result, worsen the space complexity of the program. To address the problem, they proposed a space-efficient coercion calculus, which was subsequently improved by Garcia, et al. (2009) and Siek et al. (2015). The semantics of these calculi involves eager composition of run-time checks expressed by coercions to prevent the size of a term from growing. However, it relies also on a nonstandard reduction rule, which does not seem easy to implement. In fact, no compiler implementation of gradually typed languages fully supports the space-efficient semantics faithfully.
In this paper, we study coercion-passing style, which Herman et al. have already mentioned, as a technique for straightforward space-efficient implementation of gradually typed languages. A program in coercion-passing style passes “the rest of run-time checks” around—just like continuation-passing style (CPS), in which “the rest of computation” has been passed around—and (unlike CPS) composes coercions eagerly. We give a formal coercion-passing translation from $\lambda$S by Siek et al. to $\lambda$S$_1$, which is a new calculus of first-class coercions tailored for coercion-passing style, and prove correctness of the translation. We also implement our coercion-passing style transformation for the Grift compiler developed by Kuhlenschmidt et al. and give an experimental result.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuya</first_name>
          <last_name>Tsuda</last_name>
          <affiliation>Kyoto University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~tsuda/</homepage_url>
          <person_id>yuyatsuda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Igarashi</last_name>
          <affiliation>Kyoto University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/atsushiigarashi/bbac1695-343a-4091-b33c-b7f01dea73da/small.jpg</picture_url>
          <person_id>atsushiigarashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tomoya</first_name>
          <last_name>Tabuchi</last_name>
          <affiliation>Kyoto University</affiliation>
          <bio>undefined</bio>
          <person_id>tomoyatabuchi</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>59a1e61f-ee14-49e5-9396-498776b80b79</subevent_id>
    <title>ECOOP Research Papers: M-3</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>4c965e50-0695-4c45-908b-69f28d95b600</slot_id>
      <title>Session: ECOOP Research Papers - M-3</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3f401f66-d6b6-4df7-bfb2-b0baf826d30a</slot_id>
      <event_id>4bf0a52b-ba6b-417a-97bb-1a2326f941ab</event_id>
      <title>Tackling the Awkward Squad for Reactive Programming: The Actor-Reactor Model</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:20</end_time>
      <description>Reactive programming is a programming paradigm whereby programs are internally represented by a dependency graph, which is used to automatically (re)compute parts of a program whenever its input changes. In practice reactive programming can only be used for some parts of an application: a reactive program is usually embedded in an application that is still written in ordinary imperative languages such as JavaScript or Scala. In this paper we investigate this embedding and we distill “the awkward squad for reactive programming” as 3 concerns that are essential for real-world software development, but that do not fit within reactive programming. They are related to long lasting computations, side-effects, and the coordination between imperative and reactive code. To solve these issues we design a new programming model called the Actor-Reactor Model in which programs are split up in a number of actors and reactors. Actors and reactors enforce a strict separation of imperative and reactive code, and they can be composed via a number of composition operators that make use of data streams. We demonstrate the model via our own implementation in a language called Stella.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sam</first_name>
          <last_name>Van den Vonder</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>PhD candidate at the Software Languages Lab of the Vrije Universiteit Brussel.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/samvandenvonder/2ccd1dd4-a774-4f8b-b2a1-c601a5adc3d5/small.jpg</picture_url>
          <person_id>samvandenvonder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thierry</first_name>
          <last_name>Renaux</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <person_id>thierryrenaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bjarno</first_name>
          <last_name>Oeyen</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/bjarnooeyen/c798be09-5fc6-45f6-9840-071793035cef/small.jpg</picture_url>
          <person_id>bjarnooeyen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Joeri</first_name>
          <last_name>De Koster</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/joeridekoster/2f5765d5-6ed1-4a75-acf1-99a86a994912/small.jpg</picture_url>
          <person_id>joeridekoster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Wolfgang</first_name>
          <last_name>De Meuter</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/soft/users/wdmeuter</homepage_url>
          <person_id>wolfgangdemeuter</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8c5bd46d-68b0-437c-9d06-e20bbfe1f548</slot_id>
      <event_id>c6bed3b0-d795-4378-9f4f-f3f70ea00ede</event_id>
      <title>Data Consistency in Transactional Storage Systems: A Centralised Semantics</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>00:20</end_time>
      <description>We introduce an interleaving operational semantics for describing the client-observable behaviour of atomic transactions on distributed key-value stores. Our semantics builds on abstract states comprising centralised, global key-value stores and partial client views. We provide operational definitions of consistency models for our abstract states which we show to be equivalent to the well known declarative definitions of consistency model on abstract executions. We explore two applications, verifying that the COPS replicated database and the Clock-SI partitioned database satisfy their consistency models using trace refinement, and proving invariant properties of client programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shale</first_name>
          <last_name>Xiong</last_name>
          <affiliation>ARM Research</affiliation>
          <bio>undefined</bio>
          <person_id>shalexiong1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrea</first_name>
          <last_name>Cerone</last_name>
          <affiliation>Football Radar</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/andreacerone1/ed6fc0c4-5ba2-4bdf-bcc7-e202d5b7328e/small.jpg</picture_url>
          <person_id>andreacerone1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Azalea</first_name>
          <last_name>Raad</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.SoundAndComplete.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/azalearaad/180ee602-475f-483f-a01b-ea187c9e8ac1/small.jpg</picture_url>
          <person_id>azalearaad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Philippa</first_name>
          <last_name>Gardner</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Philippa Gardner is a professor in the Department of Computing at Imperial College London and and has a UKRI Established Fellowship from 2018–2023. Her current research focusses on program verification: in particular, reasoning about Web programs (JavaScript and DOM); and reasoning about concurrent programs. She completed her PhD thesis, supervised by Professor Gordon Plotkin FRS at Edinburgh in 1992 and held five years of fellowships at Edinburgh. She moved to Cambridge in 1998 on an EPSRC Advanced Fellowship, hosted by Professor Robin Milner FRS. She obtained a lectureship at Imperial in 2001, and became professor in 2009. She held a Microsoft Research Cambridge/Royal Academy of Engineering Senior Fellowship from 2005 to 2010 at Imperial. Philippa directs the Research Institute on Verified Trustworthy Software Systems (VeTSS), funded by EPSRC, from 2017 to 2022. She chaired the BCS awards committee, 2013-2018, which decides the Lovelace medal (senior) and Roger Needham award (mid-career) for computer science and engineering.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~pg</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippagardner/8031e77a-ebbb-4963-a5de-94895edd7f71/small.jpg</picture_url>
          <person_id>philippagardner</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>defc4802-da3e-4475-9237-e3a73c08ed77</slot_id>
      <event_id>19f2611f-fa87-46d5-b52e-767476c387fb</event_id>
      <title>Lifting Sequential Effects to Control Operators</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:40</end_time>
      <description>Sequential effect systems are a class of effect system that exploits information about program order, rather than discarding it as traditional commutative effect systems do. This extra expressive power allows effect systems to reason about behavior over time, capturing properties such as atomicity, unstructured lock ownership, or even general safety properties. While we now understand the essential denotational (categorical) models fairly well, application of these ideas to real software is hampered by the variety of source level control flow constructs and control operators in real languages.
We address this new problem by appeal to a classic idea: macro-expression of commonly-used programming constructs in terms of control operators. We give an effect system for a subset of Racket’s tagged delimited control operators, as a lifting of an effect system for a language without direct control operators. This gives the first account of sequential effects in the presence of general control operators. Using this system, we also re-derive the sequential effect system rules for control flow constructs previously shown sound directly, and derive sequential effect rules for new constructs not previously studied in the context of source-level sequential effect systems. This offers a way to directly extend source-level support for sequential effect systems to real programming languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Colin</first_name>
          <last_name>Gordon</last_name>
          <affiliation>Drexel University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.drexel.edu/~csgordon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/colingordon/d990db47-1ece-4016-bce5-b764428bd0ee/small.jpg</picture_url>
          <person_id>colingordon</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e18b2415-a4be-41d7-96d7-e30c80c6ad66</slot_id>
      <event_id>2d767f19-3b2e-4257-94c7-e2f1d09b2a18</event_id>
      <title>The Duality of Subtyping</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>00:00</end_time>
      <description>Subtyping is a concept frequently encountered in many programming languages and calculi. Various forms of subtyping exist for different type system features, including intersection types, union types or bounded quantification. Normally these features are designed independently of each other, without exploiting obvious similarities (or dualities) between features. This paper proposes a novel methodology for designing subtyping relations that exploits duality between features. At the core of our methodology is a generalization of subtyping relations, which we call Duotyping. Duotyping is parameterized by the mode of the relation. One of these modes is theusual subtyping, while another mode is supertyping (the dual of subtyping). Using the mode it is possible to generalize the usual rules of subtyping to account not only for the intended behaviour of one particular language construct, but also of its dual. Duotyping brings multiple benefits, including: shorter specifications and implementations, dual features that come essentially for free, as well as new proof techniques for various properties of subtyping. To evaluate a design based on Duotyping against traditional designs, we formalized various calculi with common OOP features (including union types, intersection types and bounded quantification) in Coq in both styles. Our results show that the metatheory when using Duotyping does not come at a significant cost: the metatheory with Duotyping has similar complexity and size compared to the metatheory for traditional designs. However, we discover new features as duals to well-known features. Furthermore, we also show that Duotyping can significantly simplify transitivity proofs for many of the calculi studied by us.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>The University of Hong Kong, Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shaobo</first_name>
          <last_name>Cui</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>shaobocui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Baber</first_name>
          <last_name>Rehman</last_name>
          <affiliation>University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://baberrehman.github.io/</homepage_url>
          <person_id>baberrehman</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ce6c7af4-5e3b-48d2-9f34-27655320d66c</subevent_id>
    <title>ECOOP Research Papers: S-6</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>b41300bc-f71e-4a28-b511-72a8632b562b</slot_id>
      <title>Session: ECOOP Research Papers - S-6</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>106d37c0-f603-4f5d-95c1-d89cc8375946</slot_id>
      <event_id>3198f204-28c6-492a-8457-c51ebcc772f0</event_id>
      <title>Static Race Detection and Mutex Safety and Liveness for Go Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>05:20</end_time>
      <description>Go is a popular concurrent programming language thanks to its ability to efficiently combine concurrency and systems programming. In Go programs, a number of concurrency bugs can be caused by a mixture of data races and communication problems. In this paper, we develop a theory based on behavioural types to statically detect data races and deadlocks in Go programs. We first specify lock safety/liveness and data race properties over a Go program model, using the happens-before relation defined in the Go memory model. We represent these properties of programs in a µ-calculus model of types, and validate them using type-level model-checking. We then extend the framework to account for Go’s channels, and implement a static verification tool which can detect concurrency errors. This is, to the best of our knowledge, the first static verification framework of this kind for the Go language, uniformly analysing concurrency errors caused by a mix of shared memory accesses and asynchronous message-passing communications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julia</first_name>
          <last_name>Gabet</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <person_id>juliagabet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>13b4f9e0-d6ba-4f23-8ba9-e1541089f70a</slot_id>
      <event_id>d4d20ec5-085d-4a47-b76e-d1155d4f08c5</event_id>
      <title>Multiparty Session Programming with Global Protocol Combinators</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>05:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>06:00</end_time>
      <description>Multiparty Session Types (MPST) is a typing discipline for communication protocols. It ensures the absence of communication errors and deadlocks for well-typed communicating processes. The state of the art implementations of the MPST theory rely on (1) runtime linearity checks to ensure correct usage of communication channels and (2) external domain-specific languages for specifying and verifying of multiparty protocols.
To overcome these limitations, we propose a library for programming with global combinators – a set of functions for writing and verifying multiparty protocols in OCaml. Local behaviours for all processes in a protocol are inferred at once from a global combinator. We formalise global combinators and prove a sound realisability of global combinators – a well-typed global combinator derives a set of local types, by which typed endpoint programs can ensure type and communication safety. Our approach enables fully-static verification and implementation of the whole protocol, from the protocol specification to the process implementations, to happen in the same language.
We compare our implementation to untyped and continuation-passing style implementations, and demonstrate its expressiveness by implementing a plethora of protocols. We show our library can interoperate with existing libraries and services, implementing DNS (Domain Name Service) protocol and the OAuth (Open Authentication) protocol.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Keigo</first_name>
          <last_name>Imai</last_name>
          <affiliation>Gifu University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/keigoimai/70b0be2a-fa97-45a6-a037-57682ad05bf9/small.jpg</picture_url>
          <person_id>keigoimai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rumyana</first_name>
          <last_name>Neykova</last_name>
          <affiliation>Brunel University London</affiliation>
          <bio>Rumyana Neykova is a lecturer at Brunel University London, previously completed a PhD degree under the supervision of Prof. Nobuko Yoshida at Imperial College London, where she was also research fellow. Her research interests are in the area of distributed systems and networks, as well as type systems and language design. Her PhD focuses on development and applications of a type theory (called session types) for runtime verification of concurrent and distributed systems.</bio>
          <homepage_url>https://www.brunel.ac.uk/people/rumyana-neykova</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rumyananeykova/66457b0a-8e8b-471e-b278-37d7f4242bcb/small.jpg</picture_url>
          <person_id>rumyananeykova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Shoji</first_name>
          <last_name>Yuen</last_name>
          <affiliation>Nagoya University</affiliation>
          <bio>undefined</bio>
          <person_id>shojiyuen</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1cb3db5b-8e23-4268-9697-8b46e37a10dc</slot_id>
      <event_id>08eaa378-f2f5-4c5f-b1a8-e9c754b3d384</event_id>
      <title>Reference immutability for DOT</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>05:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>05:40</end_time>
      <description>Reference immutability is a type-based technique for controlling mutation that has been thoroughly studied in Java. We explore how reference immutability interacts with the features of Scala by adding it to the Dependent Object Types (DOT) calculus. Our extension shows how reference immutability can be encoded using existing Scala features such as path-dependent, intersection, and union types. We prove type soundness and the immutability guarantee provided by our calculus.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vlastimil</first_name>
          <last_name>Dort</last_name>
          <affiliation>Charles University</affiliation>
          <bio>undefined</bio>
          <person_id>vlastimildort</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>482615e0-5227-4ad9-8bd7-7f6240ba3669</slot_id>
      <event_id>30a683a6-c04e-4827-bf2a-38cbfe60cc03</event_id>
      <title>Scala with Explicit Nulls</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>06:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>06:20</end_time>
      <description>The Scala programming language makes all reference types implicitly nullable. This is a problem, because null references do not support most operations that do make sense on regular objects, leading to runtime errors. In this paper, we present a modification to the Scala type system that makes nullability explicit in the types. Specifically, we make reference types non-nullable by default, while still allowing for nullable types via union types. We have implemented this design for explicit nulls as a fork of the Dotty (Scala 3) compiler. We evaluate our scheme by migrating a number of Scala libraries to use explicit nulls. Finally, we give a denotational semantics of type nullification, the interoperability layer between Java and Scala with explicit nulls. We show a soundness theorem stating that, for variants of System F omega that model Java and Scala, nullification preserves elements of ground types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abel</first_name>
          <last_name>Nieto</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://abeln.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/abelnieto/88adb2b6-4aa2-4cc1-af2b-5a23289e9794/small.jpg</picture_url>
          <person_id>abelnieto</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yaoyu</first_name>
          <last_name>Zhao</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>yaoyuzhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Angela</first_name>
          <last_name>Chang</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>angelachang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Justin</first_name>
          <last_name>Pu</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>justinpu</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8d4ff240-9894-4ee2-8470-74531a6a3000</subevent_id>
    <title>ECOOP Research Papers: M-4</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>29f43eaf-390a-40fd-ba27-8fb675150703</slot_id>
      <title>Session: ECOOP Research Papers - M-4</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1b02ba5a-d4af-4e2c-bba6-d5a74efacba8</slot_id>
      <event_id>0e16ed75-4dc8-4d08-a503-c23f55e52859</event_id>
      <title>A Trusted Infrastructure for Symbolic Analysis of Event-Driven Web Applications</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>13:40</end_time>
      <description>We introduce a trusted infrastructure for symbolic analysis of modern event-driven Web applications. This infrastructure consists of reference implementations of the DOM Core Level 1 and UI Events, JavaScript Promises, and the JavaScript async/await APIs, all underpinned by a simple Core Event Semantics that is sufficiently expressive to describe the event models underlying all these APIs. Our reference implementations are trustworthy in that they follow the API respective standards line-by-line and they are thoroughly tested against the appropriate official test-suites, passing all the applicable tests. Using the Core Events Semantics and the reference implementations, we develop JaVerT.Click, a symbolic execution tool for JavaScript that, for the first time, supports reasoning about JavaScript programs that use some (possibly all) these APIs. Using JaVerT.Click, we perform comprehensive symbolic testing of the events module of Cash, a widely-used jQuery alternative, creating a symbolic test suite with 100% line coverage, establishing bounded correctness of several essential properties of the module, and discovering two subtle, previously unknown bugs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gabriela</first_name>
          <last_name>Sampaio</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~gcs817/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gabrielasampaio/48fe961f-74cb-4bbc-b693-f8afcab7dd2d/small.jpg</picture_url>
          <person_id>gabrielasampaio</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>José</first_name>
          <last_name>Fragoso Santos</last_name>
          <affiliation>INESC-ID/Instituto Superior Técnico, Portugal </affiliation>
          <bio>undefined</bio>
          <homepage_url>http://j3fsantos.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/josesantos/601111d4-5a07-4e79-8f6a-8af72ebd6f95/small.jpg</picture_url>
          <person_id>josesantos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Petar</first_name>
          <last_name>Maksimović</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/petarmaksimovic/10dfc861-3a11-48a5-8af6-f58fd86389e3/small.jpg</picture_url>
          <person_id>petarmaksimovic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Philippa</first_name>
          <last_name>Gardner</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Philippa Gardner is a professor in the Department of Computing at Imperial College London and and has a UKRI Established Fellowship from 2018–2023. Her current research focusses on program verification: in particular, reasoning about Web programs (JavaScript and DOM); and reasoning about concurrent programs. She completed her PhD thesis, supervised by Professor Gordon Plotkin FRS at Edinburgh in 1992 and held five years of fellowships at Edinburgh. She moved to Cambridge in 1998 on an EPSRC Advanced Fellowship, hosted by Professor Robin Milner FRS. She obtained a lectureship at Imperial in 2001, and became professor in 2009. She held a Microsoft Research Cambridge/Royal Academy of Engineering Senior Fellowship from 2005 to 2010 at Imperial. Philippa directs the Research Institute on Verified Trustworthy Software Systems (VeTSS), funded by EPSRC, from 2017 to 2022. She chaired the BCS awards committee, 2013-2018, which decides the Lovelace medal (senior) and Roger Needham award (mid-career) for computer science and engineering.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~pg</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippagardner/8031e77a-ebbb-4963-a5de-94895edd7f71/small.jpg</picture_url>
          <person_id>philippagardner</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>31511112-67dc-4046-bdbd-ae0a7905b587</slot_id>
      <event_id>97ef5573-0f58-46e1-9fe7-f39f45954cbf</event_id>
      <title>Designing with Static Capabilities and Effects</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>13:20</end_time>
      <description>Capabilities (whether object or reference capabilities) are fundamentally tools to restrict effects. Thus static capabilities (object or reference) and effect systems take different technical machinery to the same core problem of statically restricting or reasoning about effects in programs. Any time two approaches can in principle address the same sets of problems, it becomes important to understand the trade-offs between the approaches, how these trade-offs might interact with the problem at hand.
Experts who have worked in these areas tend to find the trade-offs somewhat obvious, having considered them in context before. However, this kind of design discussion is often written down only implicitly as comparison between two approaches for a specific program reasoning problem, rather than as a discussion of general trade-offs between general classes of techniques. As a result, it is not uncommon to set out to solve a problem with one technique, only to find the other better-suited.
We discuss the trade-offs between static capabilities (specifically reference capabilities) and effect systems, articulating the challenges each approach tends to have in isolation, and how these are sometimes mitigated. We also put our discussion in context, by appealing to examples of how these trade-offs were considered in the course of developing prior systems in the area. Along the way, we highlight how seemingly-minor aspects of type systems – weakening/framing and the mere existence of type contexts – play a subtle role in the efficacy of these systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Colin</first_name>
          <last_name>Gordon</last_name>
          <affiliation>Drexel University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.drexel.edu/~csgordon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/colingordon/d990db47-1ece-4016-bce5-b764428bd0ee/small.jpg</picture_url>
          <person_id>colingordon</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4bda5241-e426-4814-8599-1a57bc984cc0</slot_id>
      <event_id>075e145e-0c8a-47bf-97d2-fd7ed28f0228</event_id>
      <title>Safe, Flexible Aliasing with Deferred Borrows</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>14:00</end_time>
      <description>t.b.a</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chris</first_name>
          <last_name>Fallin</last_name>
          <affiliation>Mozilla</affiliation>
          <bio>undefined</bio>
          <person_id>chrisfallin</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>aba8f9ed-ee79-4fb9-8327-9f77d51a764e</slot_id>
      <event_id>fc6c077e-91cb-4f4f-89be-ffca400b2979</event_id>
      <title>Static Analysis of Shape in TensorFlow Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>14:20</end_time>
      <description>Machine learning has been widely adopted in diverse science and engineering domains, aided by reusable libraries and quick development patterns. The TensorFlow library is probably the best-known representative of this trend and most users employ the Python API to its powerful back-end. TensorFlow programs are susceptible to several systematic errors, especially in the dynamic typing setting of Python. We present a static analysis that tracks the shapes of tensors across Python library calls and warns of several possible mismatches. The key technical aspects are a close modeling of library semantics with respect to tensor shape, and an identification of violations and error-prone patterns. Our analysis is powerful enough to statically detect (with 100% precision) 11 of the 14 shape-related TensorFlow bugs in the recent Zhang et al. empirical study—an independent slice of real-world bugs that also includes semantic violations not statically detectable.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sifis</first_name>
          <last_name>Lagouvardos</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/sifislagouvardos/7bff730b-e719-4f0c-935c-245291f18d9d/small.jpg</picture_url>
          <person_id>sifislagouvardos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Julian</first_name>
          <last_name>Dolby</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-dolby</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juliandolby/092667c4-6e51-4476-8ef0-58b41ce9014d/small.jpg</picture_url>
          <person_id>juliandolby</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Neville</first_name>
          <last_name>Grech</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.nevillegrech.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nevillegrech/e0405613-3240-4ef2-a51f-cb7536870dc5/small.jpg</picture_url>
          <person_id>nevillegrech</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Anastasios</first_name>
          <last_name>Antoniadis</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>I am a PhD student at the Department of Informatics and Telecommunications at University of Athens. I started my PhD on October 2016 under the supervision of professor Yannis Smaragdakis and I am a member of the programming languages and software technologies research group of the department—PLaST.
My main research area is static points-to analysis of Java programs. In particular, my focus is on large-scale Java applications, such as Java EE applications and static analysis scalability under highly precise context-sensitivity.
In the past I worked as a research assistant at Oracle Labs Australia in 2019 for 5 months. I was also an intern at CERN for a year in 2012-2013.</bio>
          <homepage_url>https://anantoni.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anastasiosantoniadis/fb0f10eb-be87-449a-bb29-3879c99c4bf2/small.jpg</picture_url>
          <person_id>anastasiosantoniadis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>Research Interests: programming languages and software engineering

 Program analysis (static analysis, test generation, invariant inference, symbolic execution)
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming)
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality)
          </bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
          <person_id>yannissmaragdakis</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0df7ce27-e66c-41fe-82c0-9bcb78fc8a6f</subevent_id>
    <title>ECOOP Research Papers: M-1</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>12a9697e-184b-4fc7-81cf-be54632a7fdb</slot_id>
      <title>Session: ECOOP Research Papers - M-1</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>07:00</start_time>
      <end_time>08:20</end_time>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>00429097-3bb7-479e-8062-2dae10d9b212</slot_id>
      <event_id>fa9502c6-8ae7-4b07-8206-b46b73a9a756</event_id>
      <title>A Semantics for the Essence of React</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>07:20</end_time>
      <description>Traditionally, web applications have been written as HTML pages with embedded JavaScript code that implements dynamic and interactive features by manipulating the Document Object Model (DOM) through a low-level browser API. However, this unprincipled approach leads to code that is brittle, difficult to understand, non-modular, and does not facilitate incremental update of user-interfaces in response to state changes.
React is a popular framework for constructing web applications that aims to overcome these problems. React applications are written in a declarative and object-oriented style, and consist of components that are organized in a tree structure. Each component has a set of properties representing input parameters, a state consisting of values that may vary over time, and a render method that declaratively specifies the subcomponents of the component. React’s concept of reconciliation determines the impact of state changes and updates the user-interface incrementally by selective mounting and unmounting of subcomponents. At designated points, the React framework invokes lifecycle hooks that enable programmers to perform actions outside the framework such as acquiring and releasing resources needed by a component.
These mechanisms exhibit considerable complexity, but, to our knowledge, no formal specification of React’s semantics exists. This paper presents a small-step operational semantics that captures the essence of React, as a first step towards a long-term goal of developing automatic tools for program understanding, automatic testing, and bug finding for React web applications. To demonstrate that key operations such as mounting, unmounting, and reconciliation terminate, we define the notion of a well-behaved component and prove that well-behavedness is preserved by these operations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Frank</first_name>
          <last_name>Tip</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Frank Tip is a Professor and Associate Dean for Graduate Programs at Northeastern University. Previously, he was a Senior Principal Engineer at Samsung Research America in Mountain View, California (2014-2016), a Professor and Cheriton Research Chair in the David R. Cheriton School of Computer Science at the University of Waterloo (2012-2014), and a Research Staff Member and Manager at the Software Technology Department at the IBM T.J. Watson Research Center (1995-2012). He received his PhD in 1995 from the University of Amsterdam.</bio>
          <homepage_url>http://www.franktip.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/franktip/b4b4c804-cf32-45fa-afc8-3058f718b160/small.jpg</picture_url>
          <person_id>franktip</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2913ac75-76fd-4eb6-b428-5f7d01ce72de</slot_id>
      <event_id>1afda63b-ac13-4748-afb4-ec818eef4cfe</event_id>
      <title>A Framework for Resource Dependent EDSLs in a Dependently Typed Language</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>07:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>08:00</end_time>
      <description>Idris’ Effects library demonstrates how to embed resource dependent algebraic effect handlers into a dependently typed host language, providing run-time and compile-time based reasoning on type-level resources. Building upon this work, Resources is a framework for realising Embedded Domain Specific Languages (EDSLs) with type-systems that contain domain specific substructural properties. Differing from Effects, Resources allows a language’s substructural properties to be encoded in a resource that is associated with language variables. Thus, allowing for multiple effect instances to be reasoned about autonomically and without explicit type-level declaration. Type-level predicates are used as proof that the language’s substructural properties hold. Several exemplar EDSLs are presented that illustrates our framework’s operation and how dependent types provide correctness-by-construction guarantees that substructural properties of written programs hold.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jan</first_name>
          <last_name>de Muijnck-Hughes</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>Jan is a Research Associate at the School of Computing at the University of Glasgow, where he investigates the construction of Structural and Behavioural Type-Systems for hardware design. Generally speaking, his research interests are revolved around the Type-Driven Development of Communicating Systems using Dependent Types, Session Types, and Algebraic Effects as presented in the dependently typed programming language Idris.</bio>
          <homepage_url>https://jfdm.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jandemuijnckhughes/6828da0f-67ea-4d2a-9c31-38d84d2e4624/small.jpg</picture_url>
          <person_id>jandemuijnckhughes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Wim</first_name>
          <last_name>Vanderbauwhede</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <person_id>wimvanderbauwhede</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Edwin</first_name>
          <last_name>Brady</last_name>
          <affiliation>University of St. Andrews</affiliation>
          <bio>I am a Lecturer in Computer Science at the University of St Andrews, interested in type theory, dependently typed functional programming, compilers and metaprogramming. I am currently working on a new implementation of Idris, a dependently typed functional programming language. When I’m not doing that, you might find me playing Go (I’m about 2 kyu), walking up a hill, watching a game of cricket, or waiting for a delayed train. I’m afraid I also perpetrated the Whitespace programming language.</bio>
          <homepage_url>https://eb.host.cs.st-andrews.ac.uk</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/edwinbrady/cbff36d2-7476-402e-bc2c-e84d1ceb0ab5/small.jpg</picture_url>
          <person_id>edwinbrady</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>37f0477f-c85b-4d3e-bdb5-c8255e2dd864</slot_id>
      <event_id>d20598bd-55e0-4d3d-9727-0b7b671dbce0</event_id>
      <title>Reconciling Event Structures with Modern Multiprocessors</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>07:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>07:40</end_time>
      <description>Weakestmo is a recently proposed memory consistency model that uses event structures to resolve the infamous “out-of-thin-air” problem, and to enable efficient compilation to hardware. Nevertheless, this latter property—compilation correctness—has not yet been formally established. This paper closes this gap by establishing correctness in Coq of the intended compilation schemes from Weakestmo to a wide range of formal hardware memory models (x86, POWER, ARMv7, ARMv8). Our proof is the first that establishes correctness of compilation of an event-structure-based model that forbids “thin-air” behaviors, as well as the first mechanized compilation proof of a weak memory model supporting sequentially consistent accesses to such a range of hardware platforms. Our compilation proof goes via the recent Intermediate Memory Model (IMM), which we suitably extend with sequentially consistent accesses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Evgenii</first_name>
          <last_name>Moiseenko</last_name>
          <affiliation>St. Petersburg University / JetBrains Research</affiliation>
          <bio>undefined</bio>
          <person_id>evgeniimoiseenko</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anton</first_name>
          <last_name>Podkopaev</last_name>
          <affiliation>MPI-SWS, NRU HSE, JetBrains Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://podkopaev.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/antonpodkopaev/b00dceb2-5b55-4c0b-afe0-17581b19dfee/small.jpg</picture_url>
          <person_id>antonpodkopaev</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~orilahav/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/orilahav/89b656f6-7634-49d1-9917-4b74da70a976/small.jpg</picture_url>
          <person_id>orilahav</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Orestis</first_name>
          <last_name>Melkonian</last_name>
          <affiliation>Utrecht University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://omelkonian.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/orestismelkonian/823e0ead-bc55-4ee3-b97a-114b787ad406/small.jpg</picture_url>
          <person_id>orestismelkonian</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Vafeiadis</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>Viktor Vafeiadis is a tenured faculty at the Max Planck Institute for Software Systems (MPI-SWS) in Germany. He got his BA and PhD from the University of Cambridge, and held post-doctoral researcher positions at the University of Cambridge and at Microsoft Research Cambridge before joining MPI-SWS in October 2010.</bio>
          <homepage_url>http://www.mpi-sws.org/~viktor/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/viktorvafeiadis/6a063832-47ca-4c32-8047-4bf4f74ae764/small.jpg</picture_url>
          <person_id>viktorvafeiadis</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>796a3f14-d818-422a-91ab-8b8da42502cf</slot_id>
      <event_id>c8f92227-97e4-4cd4-97f8-0dbfb0f80f62</event_id>
      <title>Reshape your layouts, not your programs: A safe language extension for better cache locality</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>08:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>08:20</end_time>
      <description>The vast divide between the speed of CPU and RAM means that effective use of CPU caches is often a prerequisite for high performance on modern architectures. Hence, developers need to consider how to place data in memory so as to exploit spatial locality and achieve high memory bandwidth. Such manual memory optimisations are common in unmanaged languages (e.g. C, C++), but they sacrifice readability, maintainability, memory safety, and object abstraction. In managed languages, such as Java and C#, where the runtime abstracts away the memory from the developer, such optimisations are almost impossible.
We present a language extension called SHAPES, which aims to offer developers more fine-grained control over the placement of data, without sacrificing memory safety or object abstraction. In SHAPES, programmers group related objects into pools, and specify how objects are laid out in these pools. Classes and types are annotated by pool parameters, which allow placement aspects to be changed orthogonally to the code that operates on the objects in the pool. These design decisions disentangle business logic and memory concerns.
We give a formal model of SHAPES, present its type and memory safety model, and present its translation to a low-level language. We argue why we expect this translation to be efficient in terms of runtime representation of objects and access to their fields. We argue that SHAPES can be incorporated into existing managed and unmanaged language runtimes and fit well with garbage collection.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexandros</first_name>
          <last_name>Tasos</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexandrostasos/131f6a5e-4994-4195-b143-5eb7d52f3317/small.jpg</picture_url>
          <person_id>alexandrostasos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Juliana</first_name>
          <last_name>Franco</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>julianafranco1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sophia</first_name>
          <last_name>Drossopoulou</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Professor of Programming Languages in the Department of Computing, Imperial College, London, UK.</bio>
          <homepage_url>https://wp.doc.ic.ac.uk/sd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sophiadrossopoulou/f9f2890b-55bd-4796-94ab-fe3291277c90/small.jpg</picture_url>
          <person_id>sophiadrossopoulou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Wrigstad</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wrigstad.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tobiaswrigstad/51b1bbdb-d077-4128-ad29-ec14657617a7/small.jpg</picture_url>
          <person_id>tobiaswrigstad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Susan</first_name>
          <last_name>Eisenbach</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wp.doc.ic.ac.uk/susan/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/susaneisenbach/100322fa-6296-48e2-8238-10431036ea30/small.jpg</picture_url>
          <person_id>susaneisenbach</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bf56d2ad-610c-4f6d-b72b-74e75e8db2a3</subevent_id>
    <title>ECOOP Research Papers: S-4</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>0b6e95e5-07a5-4b8b-a06a-d3b8c1112124</slot_id>
      <title>Session: ECOOP Research Papers - S-4</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>29446384-7b2a-45e7-9929-98a58ee22a67</slot_id>
      <event_id>4706f63e-dc56-4e40-bee4-0b030f2b0fcb</event_id>
      <title>A big step from finite to infinite computations</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>02:00</end_time>
      <description>We provide a construction that, given a big-step semantics describing finite computations and their observations, extends it to include infinite computations as well. The basic idea is that the finite behavior uniquely determines the infinite behavior once observations and their composition operators are fixed. Technically, the construction relies on the framework of inference systems with corules. The effectiveness and scope of the approach are illustrated by several examples. The correctness is formally justified by proving that, starting from a big-step semantics equivalent to a reference small-step semantics, this equivalence is preserved by the construction.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Davide</first_name>
          <last_name>Ancona</last_name>
          <affiliation>DIBRIS, University of Genova, Italy</affiliation>
          <bio>Davide Ancona (PhD in Computer Science, University of Pisa, 1998) is Associate Professor at the University of Genova. His main research interests include type systems, object-oriented programming, coinduction methods for programming languages, modules and components, software reuse and maintenance, multi-agent systems, and behavioral types. He is author of more than 70 publications. He is the secretary of the executive board of AITO, Association Internationale pour les Technologies Objets (since Jan 2013, previously Vice-President since Jan 2012), and member of the editorial board of the ACM/SIGAPP Applied Computing Review (ACR), Scientific Programming (Hindawi), and Open Computer Science. He has been guest editor of special issues of Science of Computer Programming and Journal of Object Technology. In 2009 he received, together with G. Lagorio, the best paper prize at ECOOP. He has participated to several national and European projects and has been PC member of several workshops and conferences: WOOD’04, Bytecode 2008, ESOP 2008, DLS 2009, 2010 and 2013, FOOL 2010, RP 2011 and 2012, ECOOP 2013 and 2014, POPL 2015 (ERC), OOPSLA 2016 (ERC), TASE 2016, FTfJP 2016. He has been involved in the organization of several scientific events: organizing chair of ECOOP 2009, program co-chair of FTfJP06 and of OOPS special track at SAC from 2004 through 2017, co-chair of CILC 2015 and VORTEX 2016.</bio>
          <homepage_url>http://www.disi.unige.it/person/AnconaD/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davideancona/50b3fc2f-1782-4ca1-91a5-6718f42ba51b/small.jpg</picture_url>
          <person_id>davideancona</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Dagnino</last_name>
          <affiliation>DIBRIS, University of Genova, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.dibris.unige.it/en/dagnino-francesco</homepage_url>
          <person_id>francescodagnino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jurriaan</first_name>
          <last_name>Rot</last_name>
          <affiliation>Radboud University Nijmegen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jurriaan.me/</homepage_url>
          <person_id>juriaanrot</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Elena</first_name>
          <last_name>Zucca</last_name>
          <affiliation>University of Genova</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.disi.unige.it/person/ZuccaE/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elenazucca/31be5390-fc85-4134-90af-718c3b50c4a3/small.jpg</picture_url>
          <person_id>elenazucca</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>53bb09a0-53c9-423e-b266-4d7a8dd97f56</slot_id>
      <event_id>5fd7f5f9-a5c0-4369-8869-a0e5cfc60db7</event_id>
      <title>K-LLVM: A Relatively Complete Semantics of LLVM IR</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>01:20</end_time>
      <description>LLVM is designed for the compile-time, link-time and run-time optimization of programs written in various programming languages. The language supported by LLVM targeted by modern compilers is LLVM IR. In this paper we define K-LLVM, a reference semantics for LLVM IR. To the best of our knowledge, K-LLVM is the most complete formal LLVM IR semantics to date, including all LLVM IR instructions, intrinsic functions in the LLVM documentation and Standard-C library functions that are necessary to execute many LLVM IR programs. Additionally, K-LLVM formulates an abstract machine that executes all LLVM IR instructions. The machine allows to describe our formal semantics in terms of simulating a conceptual virtual machine that runs LLVM IR programs, including non-deterministic programs. Even though the K-LLVM memory model in this paper is assumed to be a sequentially consistent memory model and does not include all LLVM concurrency memory behaviors, the design of K-LLVM’s data layout allows the K-LLVM abstract machine to execute some LLVM IR programs that previous semantics did not cover, such as the full range of LLVM IR behaviors for the interaction among LLVM IR casting, pointer arithmetic, memory operations and some memory flags (e.g. readonly) of function headers. Additionally, the memory model is modularized in a manner that supports investigating other memory models. To validate K-LLVM, we have implemented it in K [41], which generated an interpreter for LLVM IR. Using this, we ran tests including 1,385 unit test programs and 2,156 concrete LLVM IR programs, and K-LLVM passed all of them.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Liyi</first_name>
          <last_name>Li</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>I am Liyi Li, a PhD student at the University of Illinois at Urbana-Champaign. I will work at the University of Maryland as a PostDoc this fall. My research area is Programming Language, Formal Methods, Compilers and Software Engineering. I am especially interested in verifying compilers. I like to fully verify a compiler in real-world, such as the compiler from Haskell to LLVM. My plan is to define the semantics of the source and target languages, as well as each step in a compiler, and then verify that the compiler step preserves the language meaning after the translation.</bio>
          <homepage_url>https://github.com/liyili2</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/liyili/e99a1880-eb87-4ca2-ab7a-62657f9c7b1f/small.jpg</picture_url>
          <person_id>liyili</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Elsa</first_name>
          <last_name>Gunter</last_name>
          <affiliation>University of Illinois</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://egunter.cs.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elsagunter/fec4e9dd-f691-4462-a2e0-198dd02b8498/small.jpg</picture_url>
          <person_id>elsagunter</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>703bd3c0-f3cb-424d-8f0f-0afd23c5b2e6</slot_id>
      <event_id>c2888fc6-1e65-49f3-89af-b42b99ffa7d1</event_id>
      <title>Static Type Analysis by Abstract Interpretation of Python Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>02:20</end_time>
      <description>Python is an increasingly popular dynamic programming language, particularly used in the scientific community and well-known for its powerful and permissive high-level syntax. Our work aims at detecting statically and automatically type errors. As these type errors are exceptions that can be caught later on, we precisely track all exceptions (raised or caught). We designed a static analysis by abstract interpretation able to infer the possible types of variables, taking into account the full control-flow. It handles both typing paradigms used in Python, nominal and structural, supports Python’s object model, introspection operators allowing dynamic type testing, dynamic attribute addition, as well as exception handling. We present a flow- and context-sensitive analysis with special domains to support containers (such as lists) and infer type equalities (allowing it to express parametric polymorphism). The analysis is soundly derived by abstract interpretation from a concrete semantics of Python developed by Fromherz et al. Our analysis is designed in a modular way as a set of domains abstracting a concrete collecting semantics. It has been implemented into the MOPSA analysis framework, and leverages external type annotations from the Typeshed project to support the vast standard library. We show that it scales to benchmarks a few thousand lines long, and preliminary results show it is able to analyze a small real-life command-line utility called PathPicker. Compared to previous work, it is sound, while it keeps similar efficiency and precision.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Raphaël</first_name>
          <last_name>Monat</last_name>
          <affiliation>Sorbonne Université  — LIP6</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://rmonat.fr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/raphaelmonat/2405755c-6e69-4ac2-a6af-8231b7b11c81/small.jpg</picture_url>
          <person_id>raphaelmonat</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Abdelraouf</first_name>
          <last_name>Ouadjaout</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~ouadjaout/</homepage_url>
          <person_id>abdelraoufouadjaout</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Miné</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~mine/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/antoinemine/77e18473-3b05-4bec-8b27-3e073a24fb34/small.jpg</picture_url>
          <person_id>antoinemine</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c09b13bb-4623-46ea-a3e4-ba136c3d2114</slot_id>
      <event_id>f09653ca-5d68-454b-9a7a-970d4ca62a1a</event_id>
      <title>A Type-Directed Operational Semantics for a Calculus with a Merge Operator</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>01:40</end_time>
      <description>Calculi with disjoint intersection types and a merge operator provide general mechanisms that can subsume various other features. Such calculi can also encode highly dynamic forms of object composition, which capture common programming patterns in dynamically typed languages (such as JavaScript) in a fully statically typed manner. Unfortunately, unlike many other foundational calculi (such as System $F$, System $F_{&amp;lt;:}$ or Featherweight Java), recent calculi with the merge operator lack a (direct) operational semantics with standard and expected properties such as determinism and subject-reduction. Furthermore the metatheory for such calculi can only account for terminating programs, which is a significant restriction in practice.
This paper proposes a type-directed operational semantics (TDOS) for $\lambda_{i}^{:}$: a calculus with intersection types and a merge operator. The calculus is inspired by two closely related calculi by Dunfield (2014) and Oliveira et al. (2016). Although Dunfield proposes a direct small-step semantics for his calculus, his semantics lacks both determinism and subject-reduction. Using our TDOS we obtain a direct semantics for $\lambda_{i}^{:}$ that has both properties. To fully obtain determinism, the $\lambda_{i}^{:}$ calculus employs a disjointness restriction proposed in Oliveira et al.’s $\lambda_{i}$ calculus. As an added benefit the TDOS approach deals with recursion in a straightforward way, unlike $\lambda_{i}$ and subsequent calculi where recursion is problematic. To further relate $\lambda_{i}^{:}$ to the calculi by Dunfield and Oliveira et al. we show two results. Firstly, the semantics of $\lambda_{i}^{:}$ is sound with respect to Dunfield’s small-step semantics. Secondly, we show that the type system of $\lambda_{i}^{:}$ is complete with respect to the $\lambda_{i}$ type system. All results have been fully formalized in the Coq theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xuejing</first_name>
          <last_name>Huang</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/huangxuejing/b875ad52-4b3e-4a4e-9b2e-b6b48436a581/small.jpg</picture_url>
          <person_id>huangxuejing</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>The University of Hong Kong, Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>52017797-bca9-4c9a-9e99-4baef86dcca9</subevent_id>
    <title>ECOOP Research Papers: M-6B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/17</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>46d9f559-2686-42ec-82c6-ccc8f3c267ba</slot_id>
      <title>Session: ECOOP Research Papers - M-6B</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>05:00</start_time>
      <end_time>05:20</end_time>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5e097435-a31c-47ff-9f51-bdc2527a61e1</slot_id>
      <event_id>b5cd4295-3dae-4811-a9a2-cd69e93f5866</event_id>
      <title>Space-Efficient Gradual Typing in Coercion-Passing Style</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>05:20</end_time>
      <description>Herman et al. (2007, 2010) pointed out that the insertion of run-time checks into a gradually typed program could hamper tail-call optimization and, as a result, worsen the space complexity of the program. To address the problem, they proposed a space-efficient coercion calculus, which was subsequently improved by Garcia, et al. (2009) and Siek et al. (2015). The semantics of these calculi involves eager composition of run-time checks expressed by coercions to prevent the size of a term from growing. However, it relies also on a nonstandard reduction rule, which does not seem easy to implement. In fact, no compiler implementation of gradually typed languages fully supports the space-efficient semantics faithfully.
In this paper, we study coercion-passing style, which Herman et al. have already mentioned, as a technique for straightforward space-efficient implementation of gradually typed languages. A program in coercion-passing style passes “the rest of run-time checks” around—just like continuation-passing style (CPS), in which “the rest of computation” has been passed around—and (unlike CPS) composes coercions eagerly. We give a formal coercion-passing translation from $\lambda$S by Siek et al. to $\lambda$S$_1$, which is a new calculus of first-class coercions tailored for coercion-passing style, and prove correctness of the translation. We also implement our coercion-passing style transformation for the Grift compiler developed by Kuhlenschmidt et al. and give an experimental result.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuya</first_name>
          <last_name>Tsuda</last_name>
          <affiliation>Kyoto University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~tsuda/</homepage_url>
          <person_id>yuyatsuda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Igarashi</last_name>
          <affiliation>Kyoto University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/atsushiigarashi/bbac1695-343a-4091-b33c-b7f01dea73da/small.jpg</picture_url>
          <person_id>atsushiigarashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tomoya</first_name>
          <last_name>Tabuchi</last_name>
          <affiliation>Kyoto University</affiliation>
          <bio>undefined</bio>
          <person_id>tomoyatabuchi</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a68c180a-de03-42eb-84ff-bc28211f37d3</subevent_id>
    <title>ECOOP Research Papers: S-2</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/15</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>762581d5-05f5-4ceb-b4ae-9bfb6b1aff3c</slot_id>
      <title>Session: ECOOP Research Papers - S-2</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>21:00</start_time>
      <end_time>22:20</end_time>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2a204cf6-9bc0-4183-853f-573364f39c81</slot_id>
      <event_id>7a123832-31e7-4cda-8509-cfeef5dacfe3</event_id>
      <title>Don't Panic! Better, Fewer, Syntax Errors for LR Parsers</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>21:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:40</end_time>
      <description>Syntax errors are generally easy to fix for humans, but not for parsers, in general, and LR parsers, in particular. Traditional `panic mode’ error recovery, though easy to implement and applicable to any grammar, often leads to a cascading chain of errors that drown out the original. More advanced error recovery techniques suffer less from this problem but have seen little practical use because their typical performance was seen as poor, their worst case unbounded, and the repairs they reported arbitrary. In this paper we introduce an algorithm and implementation that addresses these issues. First, we report the complete set of minimum cost repair sequences for a given location, allowing programmers to select the one that best fits their intention. Second, on a corpus of 200,000 real-world syntactically invalid Java programs, we are able to repair 98.38% ± 0.018% of files within a cut-off of 0.5s. Finally, we use the existence of the complete set of minimum cost repair sequences to reduce one of the most frustrating consequences of error reporting: the cascading error problem. Across our corpus, we report 435,823.0 ± 478.0 error locations to the user, while the panic mode algorithm reports 981,628.0 ± 0.0 error locations: in other words, we reduce the cascading error problem by well over half.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lukas</first_name>
          <last_name>Diekmann</last_name>
          <affiliation>King's College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://lukasdiekmann.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lukasdiekmann/a00dd8d1-84fa-4f67-9b77-d5994819208f/small.jpg</picture_url>
          <person_id>lukasdiekmann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Laurence</first_name>
          <last_name>Tratt</last_name>
          <affiliation>King's College London</affiliation>
          <bio>Programmer / researcher.</bio>
          <homepage_url>http://tratt.net/laurie/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/laurencetratt/f715fc31-2c46-4e48-9a13-d715343fdd4d/small.jpg</picture_url>
          <person_id>laurencetratt</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>425f8c75-aee6-49d9-9696-14254316b509</slot_id>
      <event_id>938f9252-3dc5-4325-a133-eb25a1ebd488</event_id>
      <title>Perfect is the Enemy of Good: Best-Effort Program Synthesis</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>22:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>22:20</end_time>
      <description>Program synthesis promises to help software developers with everyday tasks by generating code snippets automatically from input-output examples and other high-level specifications. The conventional wisdom is that a synthesizer must always satisfy the specification exactly. We conjecture that this all-or-nothing paradigm stands in the way of adopting program synthesis as a developer tool: in practice, the user-written specification often contains errors or is simply too hard for the synthesizer to solve within a reasonable time; in these cases, the user is left with a single over-fitted result or, more often then not, no result at all. In this paper we propose a new program synthesis paradigm we call \emph{best-effort program synthesis}, where the synthesizer returns a ranked list of partially-valid results, i.e., programs that satisfy some part of the specification.
To support this paradigm, we develop \emph{best-effort enumeration}, a new synthesis algorithm that extends a popular program enumeration technique with the ability to accumulate and return multiple partially-valid results with minimal overhead. We implement this algorithm in a tool called Bester, and evaluate it on $79$ synthesis benchmarks from the literature. Contrary to the conventional wisdom, our evaluation shows that Bester returns useful results even when the specification is flawed or too hard: i) for all benchmarks with an error in the specification, the top three Bester results contain the correct solution, and ii) for most hard benchmarks, the top three results contain non-trivial \emph{fragments} of the correct solution. We also performed a small user study, which confirms our intuition that partially-valid results are useful: the study shows that programmers use the output of the synthesizer for comprehension and often incorporate it into their solutions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>92427527-2df8-4356-9033-44d3a8a53933</slot_id>
      <event_id>b1086991-0f35-4b4b-b7a4-78b902ec9ab5</event_id>
      <title>Blame for Null</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>21:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>22:00</end_time>
      <description>Multiple modern programming languages, including Kotlin, Scala, Swift, and C#, have type systems where nullability is explicitly specified in the types. All of the above also need to interoperate with languages where types remain implicitly nullable, like Java. This leads to runtime errors that can manifest in subtle ways. In this paper, we show how to reason about the presence and provenance of such nullability errors using the concept of blame from gradual typing. Specifically, we introduce a calculus LambdaNull, where some terms are typed as implicitly nullable and others as explicitly nullable. Just like in the original blame calculus of Wadler and Findler, interactions between both kinds of terms are mediated by casts with attached blame labels, which indicate the origin of errors. On top of LambdaNull, we then define a second calculus, StratifiedLambdaNull, which closely models the interoperability between languages with implicit nullability and languages with explicit nullability, such as Java and Scala. Our main result is a theorem that states that nullability errors in StratifiedLambdaNull can always be blamed on terms with less-precise typing; that is, terms typed as implicitly nullable. By analogy, this would mean that NullPointerExceptions in combined Java/Scala programs are always the result of unsoundness in the Java type system. We summarize our result with the slogan explicitly nullable programs can’t be blamed. All our results are formalized in the Coq proof assistant.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abel</first_name>
          <last_name>Nieto</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://abeln.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/abelnieto/88adb2b6-4aa2-4cc1-af2b-5a23289e9794/small.jpg</picture_url>
          <person_id>abelnieto</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marianna</first_name>
          <last_name>Rapoport</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mrapoport.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mariannarapoport/7f9f1bbc-f804-49b4-b350-26210268c55b/small.jpg</picture_url>
          <person_id>mariannarapoport</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gregor</first_name>
          <last_name>Richards</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://the.gregor.institute/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gregorrichards/bd8bf252-24c9-4721-a495-c06a6949a332/small.jpg</picture_url>
          <person_id>gregorrichards</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bbc85d8a-1a5c-4dc5-99a1-fb83a8f83a47</slot_id>
      <event_id>e5b5bb01-82ec-490b-a4e5-e62389f99279</event_id>
      <title>Abstracting gradual references</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>21:20</end_time>
      <description>Gradual typing is an effective approach to integrate static and dynamic typing, which supports the smooth transition between both extremes via the imprecision of type annotations. Gradual typing has been applied in many scenarios such as objects, subtyping, effects, ownership, typestates, information-flow typing, parametric polymorphism, etc. In particular, the combination of gradual typing and mutable references has been explored by different authors, giving rise to four different semantics—invariant, guarded, monotonic and permissive references. These semantics were specially crafted to reflect different design decisions with respect to precision and efficiency tradeoffs. Since then, progress has been made in the formulation of methodologies to systematically derive gradual counterparts of statically-typed languages, but these have not been applied to study mutable references.
In this article, we explore how the Abstracting Gradual Typing (AGT) methodology, which has been shown to be effective in a variety of settings, applies to mutable references. Starting from a standard statically-typed language with references, we systematically derive with AGT a novel gradual language, called λREF˜. We establish the properties of λREF˜; in particular, it is the first gradual language with mutable references that is proven to satisfy the gradual guarantee. We then compare λREF˜ with the main four existing approaches to gradual references, and show that the application of AGT does justify one of the proposed semantics: we formally prove that the treatment of references in λREF˜ corresponds to the guarded semantics, by presenting a bisimilation with the coercion semantics of Herman et al. In the process, we uncover that any direct application of AGT yields a gradual language that is not space-efficient. We consequently adjust the dynamic semantics of λREF˜ to recover space efficiency. We then show how to extend λREF˜ to support both monotonic and permissive references as well. Finally, we provide the first proof of the dynamic gradual guarantee for monotonic references. As a result, this paper sheds further light on the design space of gradual languages with mutable references and contributes to deepening the understanding of the AGT methodology.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matías</first_name>
          <last_name>Toro</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/matiastoro/65656fe4-15fe-4af6-9a50-7f28cdc25fdb/small.jpg</picture_url>
          <person_id>matiastoro</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
          <person_id>etanter</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6f4458f5-e5ee-433b-9978-3748103d3e9d</subevent_id>
    <title>ECOOP Research Papers: S-4</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/15</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>1b95599a-4b52-4b51-b715-3521519d2606</slot_id>
      <title>Session: ECOOP Research Papers - S-4</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>576a651f-1c8d-42c2-be36-fb287f2b9f6e</slot_id>
      <event_id>5fd7f5f9-a5c0-4369-8869-a0e5cfc60db7</event_id>
      <title>K-LLVM: A Relatively Complete Semantics of LLVM IR</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>13:20</end_time>
      <description>LLVM is designed for the compile-time, link-time and run-time optimization of programs written in various programming languages. The language supported by LLVM targeted by modern compilers is LLVM IR. In this paper we define K-LLVM, a reference semantics for LLVM IR. To the best of our knowledge, K-LLVM is the most complete formal LLVM IR semantics to date, including all LLVM IR instructions, intrinsic functions in the LLVM documentation and Standard-C library functions that are necessary to execute many LLVM IR programs. Additionally, K-LLVM formulates an abstract machine that executes all LLVM IR instructions. The machine allows to describe our formal semantics in terms of simulating a conceptual virtual machine that runs LLVM IR programs, including non-deterministic programs. Even though the K-LLVM memory model in this paper is assumed to be a sequentially consistent memory model and does not include all LLVM concurrency memory behaviors, the design of K-LLVM’s data layout allows the K-LLVM abstract machine to execute some LLVM IR programs that previous semantics did not cover, such as the full range of LLVM IR behaviors for the interaction among LLVM IR casting, pointer arithmetic, memory operations and some memory flags (e.g. readonly) of function headers. Additionally, the memory model is modularized in a manner that supports investigating other memory models. To validate K-LLVM, we have implemented it in K [41], which generated an interpreter for LLVM IR. Using this, we ran tests including 1,385 unit test programs and 2,156 concrete LLVM IR programs, and K-LLVM passed all of them.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Liyi</first_name>
          <last_name>Li</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>I am Liyi Li, a PhD student at the University of Illinois at Urbana-Champaign. I will work at the University of Maryland as a PostDoc this fall. My research area is Programming Language, Formal Methods, Compilers and Software Engineering. I am especially interested in verifying compilers. I like to fully verify a compiler in real-world, such as the compiler from Haskell to LLVM. My plan is to define the semantics of the source and target languages, as well as each step in a compiler, and then verify that the compiler step preserves the language meaning after the translation.</bio>
          <homepage_url>https://github.com/liyili2</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/liyili/e99a1880-eb87-4ca2-ab7a-62657f9c7b1f/small.jpg</picture_url>
          <person_id>liyili</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Elsa</first_name>
          <last_name>Gunter</last_name>
          <affiliation>University of Illinois</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://egunter.cs.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elsagunter/fec4e9dd-f691-4462-a2e0-198dd02b8498/small.jpg</picture_url>
          <person_id>elsagunter</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b1188690-f1b8-4f25-83b7-ed38415b9dfc</slot_id>
      <event_id>f09653ca-5d68-454b-9a7a-970d4ca62a1a</event_id>
      <title>A Type-Directed Operational Semantics for a Calculus with a Merge Operator</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>13:40</end_time>
      <description>Calculi with disjoint intersection types and a merge operator provide general mechanisms that can subsume various other features. Such calculi can also encode highly dynamic forms of object composition, which capture common programming patterns in dynamically typed languages (such as JavaScript) in a fully statically typed manner. Unfortunately, unlike many other foundational calculi (such as System $F$, System $F_{&amp;lt;:}$ or Featherweight Java), recent calculi with the merge operator lack a (direct) operational semantics with standard and expected properties such as determinism and subject-reduction. Furthermore the metatheory for such calculi can only account for terminating programs, which is a significant restriction in practice.
This paper proposes a type-directed operational semantics (TDOS) for $\lambda_{i}^{:}$: a calculus with intersection types and a merge operator. The calculus is inspired by two closely related calculi by Dunfield (2014) and Oliveira et al. (2016). Although Dunfield proposes a direct small-step semantics for his calculus, his semantics lacks both determinism and subject-reduction. Using our TDOS we obtain a direct semantics for $\lambda_{i}^{:}$ that has both properties. To fully obtain determinism, the $\lambda_{i}^{:}$ calculus employs a disjointness restriction proposed in Oliveira et al.’s $\lambda_{i}$ calculus. As an added benefit the TDOS approach deals with recursion in a straightforward way, unlike $\lambda_{i}$ and subsequent calculi where recursion is problematic. To further relate $\lambda_{i}^{:}$ to the calculi by Dunfield and Oliveira et al. we show two results. Firstly, the semantics of $\lambda_{i}^{:}$ is sound with respect to Dunfield’s small-step semantics. Secondly, we show that the type system of $\lambda_{i}^{:}$ is complete with respect to the $\lambda_{i}$ type system. All results have been fully formalized in the Coq theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xuejing</first_name>
          <last_name>Huang</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/huangxuejing/b875ad52-4b3e-4a4e-9b2e-b6b48436a581/small.jpg</picture_url>
          <person_id>huangxuejing</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>The University of Hong Kong, Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e4257000-b5ec-43be-9a63-6f27ecf1ff08</slot_id>
      <event_id>c2888fc6-1e65-49f3-89af-b42b99ffa7d1</event_id>
      <title>Static Type Analysis by Abstract Interpretation of Python Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>14:20</end_time>
      <description>Python is an increasingly popular dynamic programming language, particularly used in the scientific community and well-known for its powerful and permissive high-level syntax. Our work aims at detecting statically and automatically type errors. As these type errors are exceptions that can be caught later on, we precisely track all exceptions (raised or caught). We designed a static analysis by abstract interpretation able to infer the possible types of variables, taking into account the full control-flow. It handles both typing paradigms used in Python, nominal and structural, supports Python’s object model, introspection operators allowing dynamic type testing, dynamic attribute addition, as well as exception handling. We present a flow- and context-sensitive analysis with special domains to support containers (such as lists) and infer type equalities (allowing it to express parametric polymorphism). The analysis is soundly derived by abstract interpretation from a concrete semantics of Python developed by Fromherz et al. Our analysis is designed in a modular way as a set of domains abstracting a concrete collecting semantics. It has been implemented into the MOPSA analysis framework, and leverages external type annotations from the Typeshed project to support the vast standard library. We show that it scales to benchmarks a few thousand lines long, and preliminary results show it is able to analyze a small real-life command-line utility called PathPicker. Compared to previous work, it is sound, while it keeps similar efficiency and precision.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Raphaël</first_name>
          <last_name>Monat</last_name>
          <affiliation>Sorbonne Université  — LIP6</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://rmonat.fr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/raphaelmonat/2405755c-6e69-4ac2-a6af-8231b7b11c81/small.jpg</picture_url>
          <person_id>raphaelmonat</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Abdelraouf</first_name>
          <last_name>Ouadjaout</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~ouadjaout/</homepage_url>
          <person_id>abdelraoufouadjaout</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Miné</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~mine/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/antoinemine/77e18473-3b05-4bec-8b27-3e073a24fb34/small.jpg</picture_url>
          <person_id>antoinemine</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>feaeeca3-f65c-4714-9a5a-3bd245fd2e95</slot_id>
      <event_id>4706f63e-dc56-4e40-bee4-0b030f2b0fcb</event_id>
      <title>A big step from finite to infinite computations</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>14:00</end_time>
      <description>We provide a construction that, given a big-step semantics describing finite computations and their observations, extends it to include infinite computations as well. The basic idea is that the finite behavior uniquely determines the infinite behavior once observations and their composition operators are fixed. Technically, the construction relies on the framework of inference systems with corules. The effectiveness and scope of the approach are illustrated by several examples. The correctness is formally justified by proving that, starting from a big-step semantics equivalent to a reference small-step semantics, this equivalence is preserved by the construction.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Davide</first_name>
          <last_name>Ancona</last_name>
          <affiliation>DIBRIS, University of Genova, Italy</affiliation>
          <bio>Davide Ancona (PhD in Computer Science, University of Pisa, 1998) is Associate Professor at the University of Genova. His main research interests include type systems, object-oriented programming, coinduction methods for programming languages, modules and components, software reuse and maintenance, multi-agent systems, and behavioral types. He is author of more than 70 publications. He is the secretary of the executive board of AITO, Association Internationale pour les Technologies Objets (since Jan 2013, previously Vice-President since Jan 2012), and member of the editorial board of the ACM/SIGAPP Applied Computing Review (ACR), Scientific Programming (Hindawi), and Open Computer Science. He has been guest editor of special issues of Science of Computer Programming and Journal of Object Technology. In 2009 he received, together with G. Lagorio, the best paper prize at ECOOP. He has participated to several national and European projects and has been PC member of several workshops and conferences: WOOD’04, Bytecode 2008, ESOP 2008, DLS 2009, 2010 and 2013, FOOL 2010, RP 2011 and 2012, ECOOP 2013 and 2014, POPL 2015 (ERC), OOPSLA 2016 (ERC), TASE 2016, FTfJP 2016. He has been involved in the organization of several scientific events: organizing chair of ECOOP 2009, program co-chair of FTfJP06 and of OOPS special track at SAC from 2004 through 2017, co-chair of CILC 2015 and VORTEX 2016.</bio>
          <homepage_url>http://www.disi.unige.it/person/AnconaD/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davideancona/50b3fc2f-1782-4ca1-91a5-6718f42ba51b/small.jpg</picture_url>
          <person_id>davideancona</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Dagnino</last_name>
          <affiliation>DIBRIS, University of Genova, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.dibris.unige.it/en/dagnino-francesco</homepage_url>
          <person_id>francescodagnino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jurriaan</first_name>
          <last_name>Rot</last_name>
          <affiliation>Radboud University Nijmegen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jurriaan.me/</homepage_url>
          <person_id>juriaanrot</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Elena</first_name>
          <last_name>Zucca</last_name>
          <affiliation>University of Genova</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.disi.unige.it/person/ZuccaE/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elenazucca/31be5390-fc85-4134-90af-718c3b50c4a3/small.jpg</picture_url>
          <person_id>elenazucca</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>368fccf5-9b8a-44e2-bfb8-0f2e6c2492a9</subevent_id>
    <title>ECOOP Research Papers: M-3</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>b4f5f63a-db1a-4a6f-84b3-ced81d79550b</slot_id>
      <title>Session: ECOOP Research Papers - M-3</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3db4a87b-745d-4406-aa9f-98db36a66344</slot_id>
      <event_id>2d767f19-3b2e-4257-94c7-e2f1d09b2a18</event_id>
      <title>The Duality of Subtyping</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>12:00</end_time>
      <description>Subtyping is a concept frequently encountered in many programming languages and calculi. Various forms of subtyping exist for different type system features, including intersection types, union types or bounded quantification. Normally these features are designed independently of each other, without exploiting obvious similarities (or dualities) between features. This paper proposes a novel methodology for designing subtyping relations that exploits duality between features. At the core of our methodology is a generalization of subtyping relations, which we call Duotyping. Duotyping is parameterized by the mode of the relation. One of these modes is theusual subtyping, while another mode is supertyping (the dual of subtyping). Using the mode it is possible to generalize the usual rules of subtyping to account not only for the intended behaviour of one particular language construct, but also of its dual. Duotyping brings multiple benefits, including: shorter specifications and implementations, dual features that come essentially for free, as well as new proof techniques for various properties of subtyping. To evaluate a design based on Duotyping against traditional designs, we formalized various calculi with common OOP features (including union types, intersection types and bounded quantification) in Coq in both styles. Our results show that the metatheory when using Duotyping does not come at a significant cost: the metatheory with Duotyping has similar complexity and size compared to the metatheory for traditional designs. However, we discover new features as duals to well-known features. Furthermore, we also show that Duotyping can significantly simplify transitivity proofs for many of the calculi studied by us.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>The University of Hong Kong, Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shaobo</first_name>
          <last_name>Cui</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>shaobocui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Baber</first_name>
          <last_name>Rehman</last_name>
          <affiliation>University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://baberrehman.github.io/</homepage_url>
          <person_id>baberrehman</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5c268e0c-d05a-4d03-b1c8-d144bb1fec83</slot_id>
      <event_id>c6bed3b0-d795-4378-9f4f-f3f70ea00ede</event_id>
      <title>Data Consistency in Transactional Storage Systems: A Centralised Semantics</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>12:20</end_time>
      <description>We introduce an interleaving operational semantics for describing the client-observable behaviour of atomic transactions on distributed key-value stores. Our semantics builds on abstract states comprising centralised, global key-value stores and partial client views. We provide operational definitions of consistency models for our abstract states which we show to be equivalent to the well known declarative definitions of consistency model on abstract executions. We explore two applications, verifying that the COPS replicated database and the Clock-SI partitioned database satisfy their consistency models using trace refinement, and proving invariant properties of client programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shale</first_name>
          <last_name>Xiong</last_name>
          <affiliation>ARM Research</affiliation>
          <bio>undefined</bio>
          <person_id>shalexiong1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrea</first_name>
          <last_name>Cerone</last_name>
          <affiliation>Football Radar</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/andreacerone1/ed6fc0c4-5ba2-4bdf-bcc7-e202d5b7328e/small.jpg</picture_url>
          <person_id>andreacerone1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Azalea</first_name>
          <last_name>Raad</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.SoundAndComplete.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/azalearaad/180ee602-475f-483f-a01b-ea187c9e8ac1/small.jpg</picture_url>
          <person_id>azalearaad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Philippa</first_name>
          <last_name>Gardner</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Philippa Gardner is a professor in the Department of Computing at Imperial College London and and has a UKRI Established Fellowship from 2018–2023. Her current research focusses on program verification: in particular, reasoning about Web programs (JavaScript and DOM); and reasoning about concurrent programs. She completed her PhD thesis, supervised by Professor Gordon Plotkin FRS at Edinburgh in 1992 and held five years of fellowships at Edinburgh. She moved to Cambridge in 1998 on an EPSRC Advanced Fellowship, hosted by Professor Robin Milner FRS. She obtained a lectureship at Imperial in 2001, and became professor in 2009. She held a Microsoft Research Cambridge/Royal Academy of Engineering Senior Fellowship from 2005 to 2010 at Imperial. Philippa directs the Research Institute on Verified Trustworthy Software Systems (VeTSS), funded by EPSRC, from 2017 to 2022. She chaired the BCS awards committee, 2013-2018, which decides the Lovelace medal (senior) and Roger Needham award (mid-career) for computer science and engineering.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~pg</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippagardner/8031e77a-ebbb-4963-a5de-94895edd7f71/small.jpg</picture_url>
          <person_id>philippagardner</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7a717952-485a-495a-8224-17f5f129097e</slot_id>
      <event_id>4bf0a52b-ba6b-417a-97bb-1a2326f941ab</event_id>
      <title>Tackling the Awkward Squad for Reactive Programming: The Actor-Reactor Model</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:20</end_time>
      <description>Reactive programming is a programming paradigm whereby programs are internally represented by a dependency graph, which is used to automatically (re)compute parts of a program whenever its input changes. In practice reactive programming can only be used for some parts of an application: a reactive program is usually embedded in an application that is still written in ordinary imperative languages such as JavaScript or Scala. In this paper we investigate this embedding and we distill “the awkward squad for reactive programming” as 3 concerns that are essential for real-world software development, but that do not fit within reactive programming. They are related to long lasting computations, side-effects, and the coordination between imperative and reactive code. To solve these issues we design a new programming model called the Actor-Reactor Model in which programs are split up in a number of actors and reactors. Actors and reactors enforce a strict separation of imperative and reactive code, and they can be composed via a number of composition operators that make use of data streams. We demonstrate the model via our own implementation in a language called Stella.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sam</first_name>
          <last_name>Van den Vonder</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>PhD candidate at the Software Languages Lab of the Vrije Universiteit Brussel.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/samvandenvonder/2ccd1dd4-a774-4f8b-b2a1-c601a5adc3d5/small.jpg</picture_url>
          <person_id>samvandenvonder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thierry</first_name>
          <last_name>Renaux</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <person_id>thierryrenaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bjarno</first_name>
          <last_name>Oeyen</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/bjarnooeyen/c798be09-5fc6-45f6-9840-071793035cef/small.jpg</picture_url>
          <person_id>bjarnooeyen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Joeri</first_name>
          <last_name>De Koster</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/joeridekoster/2f5765d5-6ed1-4a75-acf1-99a86a994912/small.jpg</picture_url>
          <person_id>joeridekoster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Wolfgang</first_name>
          <last_name>De Meuter</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/soft/users/wdmeuter</homepage_url>
          <person_id>wolfgangdemeuter</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e096ce52-f8ba-4ea3-81ab-207dcc70741c</slot_id>
      <event_id>19f2611f-fa87-46d5-b52e-767476c387fb</event_id>
      <title>Lifting Sequential Effects to Control Operators</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:40</end_time>
      <description>Sequential effect systems are a class of effect system that exploits information about program order, rather than discarding it as traditional commutative effect systems do. This extra expressive power allows effect systems to reason about behavior over time, capturing properties such as atomicity, unstructured lock ownership, or even general safety properties. While we now understand the essential denotational (categorical) models fairly well, application of these ideas to real software is hampered by the variety of source level control flow constructs and control operators in real languages.
We address this new problem by appeal to a classic idea: macro-expression of commonly-used programming constructs in terms of control operators. We give an effect system for a subset of Racket’s tagged delimited control operators, as a lifting of an effect system for a language without direct control operators. This gives the first account of sequential effects in the presence of general control operators. Using this system, we also re-derive the sequential effect system rules for control flow constructs previously shown sound directly, and derive sequential effect rules for new constructs not previously studied in the context of source-level sequential effect systems. This offers a way to directly extend source-level support for sequential effect systems to real programming languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Colin</first_name>
          <last_name>Gordon</last_name>
          <affiliation>Drexel University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.drexel.edu/~csgordon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/colingordon/d990db47-1ece-4016-bce5-b764428bd0ee/small.jpg</picture_url>
          <person_id>colingordon</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ee5d5ba4-bab0-4d93-9ea9-14e2d9d5874a</subevent_id>
    <title>ECOOP Research Papers: M-1</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>7ce72c03-3ca2-453f-8e32-4753c10206ab</slot_id>
      <title>Session: ECOOP Research Papers - M-1</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>19:00</start_time>
      <end_time>20:20</end_time>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2ce00e35-6dd2-414e-9d7b-c11e0e15e83a</slot_id>
      <event_id>fa9502c6-8ae7-4b07-8206-b46b73a9a756</event_id>
      <title>A Semantics for the Essence of React</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>19:20</end_time>
      <description>Traditionally, web applications have been written as HTML pages with embedded JavaScript code that implements dynamic and interactive features by manipulating the Document Object Model (DOM) through a low-level browser API. However, this unprincipled approach leads to code that is brittle, difficult to understand, non-modular, and does not facilitate incremental update of user-interfaces in response to state changes.
React is a popular framework for constructing web applications that aims to overcome these problems. React applications are written in a declarative and object-oriented style, and consist of components that are organized in a tree structure. Each component has a set of properties representing input parameters, a state consisting of values that may vary over time, and a render method that declaratively specifies the subcomponents of the component. React’s concept of reconciliation determines the impact of state changes and updates the user-interface incrementally by selective mounting and unmounting of subcomponents. At designated points, the React framework invokes lifecycle hooks that enable programmers to perform actions outside the framework such as acquiring and releasing resources needed by a component.
These mechanisms exhibit considerable complexity, but, to our knowledge, no formal specification of React’s semantics exists. This paper presents a small-step operational semantics that captures the essence of React, as a first step towards a long-term goal of developing automatic tools for program understanding, automatic testing, and bug finding for React web applications. To demonstrate that key operations such as mounting, unmounting, and reconciliation terminate, we define the notion of a well-behaved component and prove that well-behavedness is preserved by these operations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Frank</first_name>
          <last_name>Tip</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Frank Tip is a Professor and Associate Dean for Graduate Programs at Northeastern University. Previously, he was a Senior Principal Engineer at Samsung Research America in Mountain View, California (2014-2016), a Professor and Cheriton Research Chair in the David R. Cheriton School of Computer Science at the University of Waterloo (2012-2014), and a Research Staff Member and Manager at the Software Technology Department at the IBM T.J. Watson Research Center (1995-2012). He received his PhD in 1995 from the University of Amsterdam.</bio>
          <homepage_url>http://www.franktip.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/franktip/b4b4c804-cf32-45fa-afc8-3058f718b160/small.jpg</picture_url>
          <person_id>franktip</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7bd54833-4892-4397-be7f-72214870f047</slot_id>
      <event_id>d20598bd-55e0-4d3d-9727-0b7b671dbce0</event_id>
      <title>Reconciling Event Structures with Modern Multiprocessors</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>19:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>19:40</end_time>
      <description>Weakestmo is a recently proposed memory consistency model that uses event structures to resolve the infamous “out-of-thin-air” problem, and to enable efficient compilation to hardware. Nevertheless, this latter property—compilation correctness—has not yet been formally established. This paper closes this gap by establishing correctness in Coq of the intended compilation schemes from Weakestmo to a wide range of formal hardware memory models (x86, POWER, ARMv7, ARMv8). Our proof is the first that establishes correctness of compilation of an event-structure-based model that forbids “thin-air” behaviors, as well as the first mechanized compilation proof of a weak memory model supporting sequentially consistent accesses to such a range of hardware platforms. Our compilation proof goes via the recent Intermediate Memory Model (IMM), which we suitably extend with sequentially consistent accesses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Evgenii</first_name>
          <last_name>Moiseenko</last_name>
          <affiliation>St. Petersburg University / JetBrains Research</affiliation>
          <bio>undefined</bio>
          <person_id>evgeniimoiseenko</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anton</first_name>
          <last_name>Podkopaev</last_name>
          <affiliation>MPI-SWS, NRU HSE, JetBrains Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://podkopaev.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/antonpodkopaev/b00dceb2-5b55-4c0b-afe0-17581b19dfee/small.jpg</picture_url>
          <person_id>antonpodkopaev</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~orilahav/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/orilahav/89b656f6-7634-49d1-9917-4b74da70a976/small.jpg</picture_url>
          <person_id>orilahav</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Orestis</first_name>
          <last_name>Melkonian</last_name>
          <affiliation>Utrecht University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://omelkonian.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/orestismelkonian/823e0ead-bc55-4ee3-b97a-114b787ad406/small.jpg</picture_url>
          <person_id>orestismelkonian</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Vafeiadis</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>Viktor Vafeiadis is a tenured faculty at the Max Planck Institute for Software Systems (MPI-SWS) in Germany. He got his BA and PhD from the University of Cambridge, and held post-doctoral researcher positions at the University of Cambridge and at Microsoft Research Cambridge before joining MPI-SWS in October 2010.</bio>
          <homepage_url>http://www.mpi-sws.org/~viktor/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/viktorvafeiadis/6a063832-47ca-4c32-8047-4bf4f74ae764/small.jpg</picture_url>
          <person_id>viktorvafeiadis</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>82f3388b-4997-4341-9da4-7ea46a1cd475</slot_id>
      <event_id>1afda63b-ac13-4748-afb4-ec818eef4cfe</event_id>
      <title>A Framework for Resource Dependent EDSLs in a Dependently Typed Language</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>19:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>20:00</end_time>
      <description>Idris’ Effects library demonstrates how to embed resource dependent algebraic effect handlers into a dependently typed host language, providing run-time and compile-time based reasoning on type-level resources. Building upon this work, Resources is a framework for realising Embedded Domain Specific Languages (EDSLs) with type-systems that contain domain specific substructural properties. Differing from Effects, Resources allows a language’s substructural properties to be encoded in a resource that is associated with language variables. Thus, allowing for multiple effect instances to be reasoned about autonomically and without explicit type-level declaration. Type-level predicates are used as proof that the language’s substructural properties hold. Several exemplar EDSLs are presented that illustrates our framework’s operation and how dependent types provide correctness-by-construction guarantees that substructural properties of written programs hold.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jan</first_name>
          <last_name>de Muijnck-Hughes</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>Jan is a Research Associate at the School of Computing at the University of Glasgow, where he investigates the construction of Structural and Behavioural Type-Systems for hardware design. Generally speaking, his research interests are revolved around the Type-Driven Development of Communicating Systems using Dependent Types, Session Types, and Algebraic Effects as presented in the dependently typed programming language Idris.</bio>
          <homepage_url>https://jfdm.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jandemuijnckhughes/6828da0f-67ea-4d2a-9c31-38d84d2e4624/small.jpg</picture_url>
          <person_id>jandemuijnckhughes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Wim</first_name>
          <last_name>Vanderbauwhede</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <person_id>wimvanderbauwhede</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Edwin</first_name>
          <last_name>Brady</last_name>
          <affiliation>University of St. Andrews</affiliation>
          <bio>I am a Lecturer in Computer Science at the University of St Andrews, interested in type theory, dependently typed functional programming, compilers and metaprogramming. I am currently working on a new implementation of Idris, a dependently typed functional programming language. When I’m not doing that, you might find me playing Go (I’m about 2 kyu), walking up a hill, watching a game of cricket, or waiting for a delayed train. I’m afraid I also perpetrated the Whitespace programming language.</bio>
          <homepage_url>https://eb.host.cs.st-andrews.ac.uk</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/edwinbrady/cbff36d2-7476-402e-bc2c-e84d1ceb0ab5/small.jpg</picture_url>
          <person_id>edwinbrady</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a11f9569-36d1-45ac-8af7-897171004f89</slot_id>
      <event_id>c8f92227-97e4-4cd4-97f8-0dbfb0f80f62</event_id>
      <title>Reshape your layouts, not your programs: A safe language extension for better cache locality</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>20:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>20:20</end_time>
      <description>The vast divide between the speed of CPU and RAM means that effective use of CPU caches is often a prerequisite for high performance on modern architectures. Hence, developers need to consider how to place data in memory so as to exploit spatial locality and achieve high memory bandwidth. Such manual memory optimisations are common in unmanaged languages (e.g. C, C++), but they sacrifice readability, maintainability, memory safety, and object abstraction. In managed languages, such as Java and C#, where the runtime abstracts away the memory from the developer, such optimisations are almost impossible.
We present a language extension called SHAPES, which aims to offer developers more fine-grained control over the placement of data, without sacrificing memory safety or object abstraction. In SHAPES, programmers group related objects into pools, and specify how objects are laid out in these pools. Classes and types are annotated by pool parameters, which allow placement aspects to be changed orthogonally to the code that operates on the objects in the pool. These design decisions disentangle business logic and memory concerns.
We give a formal model of SHAPES, present its type and memory safety model, and present its translation to a low-level language. We argue why we expect this translation to be efficient in terms of runtime representation of objects and access to their fields. We argue that SHAPES can be incorporated into existing managed and unmanaged language runtimes and fit well with garbage collection.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexandros</first_name>
          <last_name>Tasos</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexandrostasos/131f6a5e-4994-4195-b143-5eb7d52f3317/small.jpg</picture_url>
          <person_id>alexandrostasos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Juliana</first_name>
          <last_name>Franco</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>julianafranco1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sophia</first_name>
          <last_name>Drossopoulou</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Professor of Programming Languages in the Department of Computing, Imperial College, London, UK.</bio>
          <homepage_url>https://wp.doc.ic.ac.uk/sd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sophiadrossopoulou/f9f2890b-55bd-4796-94ab-fe3291277c90/small.jpg</picture_url>
          <person_id>sophiadrossopoulou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Wrigstad</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wrigstad.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tobiaswrigstad/51b1bbdb-d077-4128-ad29-ec14657617a7/small.jpg</picture_url>
          <person_id>tobiaswrigstad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Susan</first_name>
          <last_name>Eisenbach</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wp.doc.ic.ac.uk/susan/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/susaneisenbach/100322fa-6296-48e2-8238-10431036ea30/small.jpg</picture_url>
          <person_id>susaneisenbach</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4b8d9f85-ec15-433b-b6b4-e895e845b115</subevent_id>
    <title>ECOOP Research Papers: S-3</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/15</date>
    <url>https://2020.ecoop.org/track/ecoop-2020-papers</url>
    <url_link_display>ECOOP 2020</url_link_display>
    <tracks>
      <track>ECOOP 2020</track>
    </tracks>
    <timeslot>
      <slot_id>b13f8bbd-b83a-485c-a954-fbfff331ecc3</slot_id>
      <title>Session: ECOOP Research Papers - S-3</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1a36f697-fa4d-4d98-93b9-4d8a1c906e4f</slot_id>
      <event_id>b3bfaad5-f792-4abe-beec-b2c3543839eb</event_id>
      <title>Row and Bounded Polymorphism via Disjoint Polymorphism</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>12:20</end_time>
      <description>Polymorphism and subtyping are important features in mainstream OO languages. The most common way to integrate the two is via F&amp;lt;: style bounded quantification. A closely related mechanism is row polymorphism, which provides an alternative to subtyping, while still enabling many of the same applications. Yet another approach is to have type systems with intersection types and polymorphism. A recent addition to this design space are calculi with disjoint intersection types and disjoint polymorphism. With all these alternatives it is natural to wonder how they are related.
This paper provides an answer to this question. We show that disjoint polymorphism can recover forms of both row polymorphism and bounded polymorphism, while retaining key desirable properties, such as type-safety and decidability. Furthermore, we identify the extra power of disjoint polymorphism which enables additional features that cannot be easily encoded in calculi with row polymorphism or bounded quantification alone. Ultimately we expect that our work is useful to inform language designers about the expressive power of those common features, and to simplify implementations and metatheory of feature-rich languages with polymorphism and subtyping.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ningning</first_name>
          <last_name>Xie</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://xnning.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ningningxie/99787204-daa9-484a-bea5-4b2b88551687/small.jpg</picture_url>
          <person_id>ningningxie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>The University of Hong Kong, Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xuan</first_name>
          <last_name>Bi</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <person_id>xuanbi1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>30550858-93a6-4f1f-8b67-199ad7187016</slot_id>
      <event_id>fca401c6-2be9-4344-9688-7495c67214c0</event_id>
      <title>Value Partitioning: A Lightweight Approach to Relational Static Analysis for JavaScript</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>12:00</end_time>
      <description>In static analysis of modern JavaScript libraries, relational analysis at key locations is critical to provide sound and useful results. Prior work addresses this challenge by the use of various forms of trace partitioning and syntactic patterns, which is fragile and does not scale well, or by incorporating complex backwards analysis.
In this paper, we propose a new lightweight variant of trace partitioning named value partitioning that refines individual abstract values instead of entire abstract states. We describe how this approach can effectively capture important relational properties involving dynamic property accesses, functions with free variables, and predicate functions.
We extend an existing JavaScript analyzer with value partitioning and demonstrate experimentally that it is a simple, precise, and efficient alternative to the existing approaches for analyzing widely used JavaScript libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Benjamin Barslev</first_name>
          <last_name>Nielsen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/benjaminbarslevnielsen/7c6acacc-eb83-4ad2-8f27-d9a7ce64e58e/small.jpg</picture_url>
          <person_id>benjaminbarslevnielsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anders</first_name>
          <last_name>Møller</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
          <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
          <person_id>andersmoller</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3ca76479-5347-4043-be29-5b14131bc209</slot_id>
      <event_id>a6b2d038-de0e-4dba-afec-21ca56a42e47</event_id>
      <title>Sound regular corecursion in coFJ</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>11:40</end_time>
      <description>The aim of the paper is to provide solid foundations for a programming paradigm natively supporting the creation and manipulation of cyclic data structures. To this end, we describe coFJ, a Java-like calculus where objects can be \emph{infinite} and methods are equipped with a \emph{codefinition} (an alternative body). We provide an abstract semantics of the calculus based on the framework of \emph{inference systems with corules}. In coFJ with this semantics, FJ recursive methods on finite objects can be extended to infinite objects as well, and behave as desired by the programmer, by specifying a codefinition. In the meantime, we describe an operational semantics which can be directly implemented in a programming language, and prove the soundness of such semantics with respect to the abstract one.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Davide</first_name>
          <last_name>Ancona</last_name>
          <affiliation>DIBRIS, University of Genova, Italy</affiliation>
          <bio>Davide Ancona (PhD in Computer Science, University of Pisa, 1998) is Associate Professor at the University of Genova. His main research interests include type systems, object-oriented programming, coinduction methods for programming languages, modules and components, software reuse and maintenance, multi-agent systems, and behavioral types. He is author of more than 70 publications. He is the secretary of the executive board of AITO, Association Internationale pour les Technologies Objets (since Jan 2013, previously Vice-President since Jan 2012), and member of the editorial board of the ACM/SIGAPP Applied Computing Review (ACR), Scientific Programming (Hindawi), and Open Computer Science. He has been guest editor of special issues of Science of Computer Programming and Journal of Object Technology. In 2009 he received, together with G. Lagorio, the best paper prize at ECOOP. He has participated to several national and European projects and has been PC member of several workshops and conferences: WOOD’04, Bytecode 2008, ESOP 2008, DLS 2009, 2010 and 2013, FOOL 2010, RP 2011 and 2012, ECOOP 2013 and 2014, POPL 2015 (ERC), OOPSLA 2016 (ERC), TASE 2016, FTfJP 2016. He has been involved in the organization of several scientific events: organizing chair of ECOOP 2009, program co-chair of FTfJP06 and of OOPS special track at SAC from 2004 through 2017, co-chair of CILC 2015 and VORTEX 2016.</bio>
          <homepage_url>http://www.disi.unige.it/person/AnconaD/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davideancona/50b3fc2f-1782-4ca1-91a5-6718f42ba51b/small.jpg</picture_url>
          <person_id>davideancona</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pietro</first_name>
          <last_name>Barbieri</last_name>
          <affiliation>Università di Genova</affiliation>
          <bio>undefined</bio>
          <person_id>pietrobarbieri</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Dagnino</last_name>
          <affiliation>DIBRIS, University of Genova, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.dibris.unige.it/en/dagnino-francesco</homepage_url>
          <person_id>francescodagnino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Elena</first_name>
          <last_name>Zucca</last_name>
          <affiliation>University of Genova</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.disi.unige.it/person/ZuccaE/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elenazucca/31be5390-fc85-4134-90af-718c3b50c4a3/small.jpg</picture_url>
          <person_id>elenazucca</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a80a8a53-b755-469d-b4cb-a1b4fe2eab6a</slot_id>
      <event_id>51bcdb71-4f23-4307-a4b8-8565ca1fb7ab</event_id>
      <title>Flow-Sensitive Type-Based Heap Cloning</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>11:20</end_time>
      <description>Flow-sensitive pointer analysis promises more precise results than its flow-insensitive counterpart by respecting program control-flow. However, existing heap abstractions for C/C++ flow-sensitive pointer analysis model the heap by creating one heap object per memory allocation. Two runtime heap objects which originate from the same allocation site are imprecisely modeled using one abstract object, which makes them share the same imprecise points-to sets and thus reduces the benefit of analysing heap objects flow-sensitively. On the other hand, equipping flow-sensitive analysis with context-sensitivity where an abstract heap object is created (cloned) per calling context can yield a more precise heap modeling for flow-sensitive analysis, but at the cost of uncontrollable analysis overhead when analysing larger programs.
This paper presents TypeClone, a new type-based heap model for flow-sensitive analysis. Our key insight is to differentiate concrete heap objects lazily using the type information at their use sites (e.g., accessed via pointer dereferencing) within the program control-flow. The novelty of TypeClone lies in its lazy heap cloning: an untyped abstract heap object created at an allocation site is killed and replaced with a new (cloned) object uniquely identified by the type information at its use site for flow-sensitive points-to propagation. This yields more precise points-to relations for each program point through well-typed objects where necessary. Thus, heap cloning can be performed within a flow-sensitive analysis without the need for context-sensitivity. Moreover, we extend TypeClone to support new kinds of strong updates for heap objects to filter out imprecise points-to relations at object use sites for programs conforming to the strict aliasing rules based on the standard C/C++ specification. Our method is neither strictly superior nor inferior to context-sensitive heap cloning, but rather, represents a new dimension that achieves a sweet spot between precision and efficiency. Our experimental results also confirm that TypeClone is more precise than flow-sensitive pointer analysis by increasing the percentage of no-alias queries by 12% on average.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohamad</first_name>
          <last_name>Barbar</last_name>
          <affiliation>University of Technology, Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>mohamadbarbar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yulei</first_name>
          <last_name>Sui</last_name>
          <affiliation>University of Technology Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuleisui.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yuleisui/e6ce6e88-3cd8-4595-9c61-a8da6f7319f6/small.jpg</picture_url>
          <person_id>yuleisui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Shiping</first_name>
          <last_name>Chen</last_name>
          <affiliation>Data61 at CSIRO, Australia / UNSW, Australia</affiliation>
          <bio>Dr. Shiping Chen is a principal research scientist in CSIRO Data61. He also holds an conjoint A/Professor title with the University of New Suouth Wales (UNSW) and the University of Sydney through teaching and supervising PhD students. He has been working on distributed systems for over 20 years with focus on performance and security. He has published 150+ research papers in these research areas. He is actively involved in computing research community through publications, journal editorship and conference TPC services, including WWW, EDOC, ICSOC and IEEE ICWS/SCC/CLOUD. His current research interests include application security, blockchain and service-oriented trusted collaboration. He is a senior member of the IEEE.</bio>
          <homepage_url>https://www.cse.unsw.edu.au/~z9195738/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shipingchen/820fa36a-2dfb-43c7-996f-98306efc746b/small.jpg</picture_url>
          <person_id>shipingchen</person_id>
        </person>
      </persons>
      <tracks>
        <track>ECOOP 2020</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>06d37bf3-a470-4e21-ba9c-af4808dd90e0</subevent_id>
    <title>SAS: 6</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>0705e3f8-5266-487a-bcc8-31d43b56c1a9</slot_id>
      <title>Session: SAS - 6</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>21:00</start_time>
      <end_time>22:00</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c430fb59-1e22-415a-a722-80f85be2ef23</slot_id>
      <event_id>fa77e119-6a7c-478d-a301-745160397e38</event_id>
      <title>Invited Talk: Polynomial Invariants for Affine Programs</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>21:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>James</first_name>
          <last_name>Worrell</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ox.ac.uk/people/james.worrell/home.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jamesworrell/6504b62e-546c-401b-ba8d-2749ee9c9308/small.jpg</picture_url>
          <person_id>jamesworrell</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ea24a961-4a75-45d9-86c4-ef7b41349bf4</slot_id>
      <event_id>187c6e5a-f0c2-4d97-b61b-97cf948fa0e3</event_id>
      <title>Termination of Polynomial Loops</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>21:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>22:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Florian</first_name>
          <last_name>Frohn</last_name>
          <affiliation>Max Planck Institute for Informatics</affiliation>
          <bio>undefined</bio>
          <person_id>florianfrohn</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marcel</first_name>
          <last_name>Hark</last_name>
          <affiliation>RWTH Aachen University, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/marcelhark/5357ec40-8b32-4698-8252-6c0d8b96f75e/small.jpg</picture_url>
          <person_id>marcelhark</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jürgen</first_name>
          <last_name>Giesl</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://verify.rwth-aachen.de/giesl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jurgengiesl/b1a15529-1129-4608-9104-be1d58d0e129/small.jpg</picture_url>
          <person_id>jurgengiesl</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>43f8b378-d451-4237-9fe9-5740fb84771b</subevent_id>
    <title>SAS: 9</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>c5fa98ba-95b9-4437-83ef-f1352225a175</slot_id>
      <title>Session: SAS - 9</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4f51e173-f461-401b-a06c-01ec8b6001c5</slot_id>
      <event_id>826b72b5-8d2a-4c83-b0c8-2893d66b8ea5</event_id>
      <title>Predicate Abstraction and CEGAR for nuHFL(Z) Validity Checking</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>16:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Iwayama</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <person_id>naokiiwayama</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.kb.is.s.u-tokyo.ac.jp/~koba/</homepage_url>
          <person_id>naokikobayashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ryota</first_name>
          <last_name>Suzuki</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>ryotasuzuki</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Takeshi</first_name>
          <last_name>Tsukada</last_name>
          <affiliation>Chiba University, Japan</affiliation>
          <bio>undefined</bio>
          <person_id>takeshitsukada</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c646040b-ec16-4689-ae43-e3983579f60e</slot_id>
      <event_id>b673ae70-f50a-4531-b748-2fe1a22e890b</event_id>
      <title>Counterexample- and Simulation-Guided Floating-Point Loop Invariant Synthesis</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>15:20</end_time>
      <description>We present an automated procedure for synthesizing sound inductive invariants for floating-point numerical loops. Our procedure generates invariants of the form of a convex polynomial inequality that tightly bounds the values of loop variables. Such invariants are a prerequisite for reasoning about the safety and roundoff errors of floating-point programs.
Unlike previous approaches that rely on policy iteration, linear algebra or semi-definite programming, we propose a heuristic procedure based on simulation and counterexample-guided refinement. We observe that this combination is remarkably effective and general and can handle both linear and nonlinear loop bodies, nondeterministic values as well as conditional statements. Our evaluation shows that our approach can efficiently synthesize loop invariants for existing benchmarks from literature, but that it is also able to find invariants for nonlinear loops that today’s tools cannot handle.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anastasiia</first_name>
          <last_name>Izycheva</last_name>
          <affiliation>Technical University of Munich</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/anastasiiaizycheva/049b4a5f-65b4-44c8-bc62-ba47c866094f/small.jpg</picture_url>
          <person_id>anastasiiaizycheva</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eva</first_name>
          <last_name>Darulova</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mpi-sws.org/~eva/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/evadarulova/0d98744b-ec94-4a27-b1c0-0d728d54bdb7/small.jpg</picture_url>
          <person_id>evadarulova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Helmut</first_name>
          <last_name>Seidl</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www2.in.tum.de/~seidl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/helmutseidl/2dcd593b-82c2-48ee-b042-87ebd49b4379/small.jpg</picture_url>
          <person_id>helmutseidl</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6c62b8ba-9d6d-41ef-bf60-1c8af7a133c3</subevent_id>
    <title>SAS: 10</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>fe43ff36-ac9b-48a0-87b5-f464a0724deb</slot_id>
      <title>Session: SAS - 10</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>876958c4-fa98-474c-9723-27b17d8c0931</slot_id>
      <event_id>887f15df-4810-48ff-86b1-91907513cccf</event_id>
      <title>Invited Talk</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>17:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Gogul</first_name>
          <last_name>Balakrishnan</last_name>
          <affiliation>Google</affiliation>
          <bio>I am a staff engineer at Google, where I work on using formal methods for privacy preserving AI. Until recently, I was working as part of the exciting Swift for TensorFlow project. Previously, I led a team that develops static analysis tools to improve the security of Android Apps. Before that I was an engineer at Facebook, and a research staff member in the Systems Analysis and Verification (SAV) group at NEC Laboratories America, Inc. I got my Ph.D in from the University of Wisconsin-Madison.</bio>
          <homepage_url>http://pages.cs.wisc.edu/~bgogul/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gogulbalakrishnan/7e9d2712-94c4-4da1-8fdb-a6203f61414d/small.jpg</picture_url>
          <person_id>gogulbalakrishnan</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5b0a3b73-4050-45fe-afd4-829fdfd9f123</subevent_id>
    <title>SAS: 7</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>489b1b55-2802-4675-ad3e-196e0cc611a7</slot_id>
      <title>Session: SAS - 7</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>344d4621-55c6-4de3-a424-16f77e015089</slot_id>
      <event_id>e3e14325-c529-4426-a059-6ef122bc4c43</event_id>
      <title>Stratified Guarded First-order Transition Systems</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>12:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christian</first_name>
          <last_name>Müller</last_name>
          <affiliation>Technical University of Munich</affiliation>
          <bio>undefined</bio>
          <person_id>christianmuller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Helmut</first_name>
          <last_name>Seidl</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www2.in.tum.de/~seidl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/helmutseidl/2dcd593b-82c2-48ee-b042-87ebd49b4379/small.jpg</picture_url>
          <person_id>helmutseidl</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6a987258-4ef2-489c-bdf3-ac4ae32d38c3</slot_id>
      <event_id>d282d18e-5f62-43fb-b68c-eb3bf99afa68</event_id>
      <title>Sampling Optimized Code for Type Feedback</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>12:20</end_time>
      <description>To efficiently execute dynamically typed languages, many language implementations have adopted a two-tier architecture. The first tier aims for low-latency startup times and collects dynamic profiles, such as the types of every program variable. The second tier provides high-throughput using an optimizing compiler that specializes code to the recorded type information. If the program behavior changes to the point that not previously seen types occur in specialized code, that specialized code becomes invalid, it is deoptimized, and control is transferred back to the first tier execution engine which will start specializing anew. However, if the program behavior becomes more specific, for instance, if a variable that was recorded as holding values of many types becomes monomorphic, no deoptimization will be triggered. Once the program is running optimized code, there are no means to notice that an opportunity for optimization has been missed or to restart specialization.
We propose to employ a sampling-based profiler to monitor native code without any instrumentation. The absence of instrumentation means that when the profiler is not active, no overhead is incurred. When the profiler is active, the overhead can be controlled by limiting the sampling rate. Our implementation is in the context of the Ř just-in-time, optimizing, compiler for the R language. Based on the sampled profiles, we are able to detect when the native code produced by Ř is specialized for stale type feedback and recompile it to more type-specific code. We show that recording in our profiler adds an overhead of less than 3% in most cases and up to 9% in few cases when engaged and that it reliably detects stale type feedback within milliseconds.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Flückiger</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.o1o.ch</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/olivierfluckiger/6051271d-0eac-48f3-b931-bff878bbce61/small.jpg</picture_url>
          <person_id>olivierfluckiger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Wälchli</last_name>
          <affiliation>University of Bern</affiliation>
          <bio>undefined</bio>
          <person_id>andreaswalchli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sebastián</first_name>
          <last_name>Krynski</last_name>
          <affiliation>Czech Technical University, National University of Quilmes</affiliation>
          <bio>undefined</bio>
          <person_id>sebastiankrynski</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ccb940ec-6584-4e84-9690-fc6ebce19a17</slot_id>
      <event_id>76914a82-f0e1-4d78-8093-7ea5ce50bb37</event_id>
      <title>DelayRepay: Delayed Execution for Kernel Fusion in Python</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>11:40</end_time>
      <description>Python is a popular, dynamic language for data science and scientific computing. To ensure efficiency, significant numerical libraries are implemented in static native languages. However, performance suffers when switching between native and non-native code, especially if data has to be converted between native arrays and Python data structures. As GPU accelerators are increasingly used, this problem becomes particularly acute. Data and control has to be repeatedly transferred between the accelerator and the host.
In this paper, we present DelayRepay, a delayed execution framework for numeric Python programs. It avoids excessive switching and data transfer by using lazy evaluation and kernel fusion. Using DelayRepay, operations on NumPy arrays are executed lazily, allowing multiple calls to accelerator kernels to be fused together dynamically. DelayRepay is available as a drop-in replacement for existing Python libraries. This approach enables significant performance improvement over the state-of-the-art and is invisible to the application programmer. We show that our approach provides an average $24\times$ speedup over NumPy - a 60% increase over the state of the art.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John Magnus</first_name>
          <last_name>Morton</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>johnmagnusmorton</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kuba</first_name>
          <last_name>Kaszyk</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>kubakaszyk</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Lu</first_name>
          <last_name>Li</last_name>
          <affiliation>Linköping University</affiliation>
          <bio>undefined</bio>
          <person_id>luli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jiawen</first_name>
          <last_name>Sun</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>jiawensun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Christophe</first_name>
          <last_name>Dubach</last_name>
          <affiliation>McGill University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/cdubach/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/christophedubach/dc7b0040-a3ef-46dd-b4f3-0f0ea3b2b026/small.jpg</picture_url>
          <person_id>christophedubach</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Michel</first_name>
          <last_name>Steuwer</last_name>
          <affiliation>The University of Edinburgh</affiliation>
          <bio>I am a lecturer (assistant professor) in compilers and runtime systems in the School of Informatics at the University of Edinburgh in Scotland. I am a member of the Compiler and Architecture Design Group (CArD), the Institute for Computing Systems Architecture (ICSA), and a visiting member of staff at the School of Computing Science at the University of Glasgow.
Before joining the faculty in Edinburgh I was a lecturer in the School of Computing Science at the University of Glasgow. Prior to that, I was a postdoctoral researcher at the School of Informatics at the University of Edinburgh. I received my PhD from the University of Münster in Germany.
I am interested in all aspects of parallel programming. Particular research interests of mine include performance portability, structured parallel programming, heterogeneous and GPU computing, and novel compilation techniques for high-level languages.</bio>
          <homepage_url>http://michel.steuwer.info/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michelsteuwer/5a465be6-d235-472c-8ace-4894a70bb742/small.jpg</picture_url>
          <person_id>michelsteuwer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Murray</first_name>
          <last_name>Cole</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <person_id>murraycole</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Michael</first_name>
          <last_name>O'Boyle</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>michaeloboyle</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ed5fd028-b2c5-432f-8023-330cd4bda01b</slot_id>
      <event_id>932e180e-dfa8-48ee-bea1-99cedf469770</event_id>
      <title>Interprocedural Shape Analysis Using Separation Logic-based Transformer Summaries</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>11:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hugo</first_name>
          <last_name>Illous</last_name>
          <affiliation>CEA &amp; INRIA / ENS Paris</affiliation>
          <bio>undefined</bio>
          <person_id>hugoillous</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthieu</first_name>
          <last_name>Lemerre</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>matthieulemerre</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xavier</first_name>
          <last_name>Rival</last_name>
          <affiliation>INRIA/CNRS/ENS Paris</affiliation>
          <bio>Xavier Rival is a Senior Research Scientist (Directeur de Recherche) at INRIA Paris. His research interest focus on abstract interpretation and software verification by static analysis. He is mainly working on symbolic abstractions (trace partitionning abstraction, shape analysis, separation logic and memory abstract domains). He has been involved in the design, implementation and transfer of the Astrée analyser, a static analyser able to verify safety properties on industrial size safety critical softwares. He is currently the PI of the MemCAD ERC Starting Grant, aiming at the design of a library of abstract domains to describe memory states containing a wide range of complex data structures. He is also the Head of the ANTIQUE INRIA group, located at ENS Paris, and Professeur Chargé de Cours at Ecole Polytechnique.</bio>
          <homepage_url>http://www.di.ens.fr/~rival/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xavierrival/036511d0-47a1-4db2-97df-0bf5da1a2c8d/small.jpg</picture_url>
          <person_id>xavierrival</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0843b270-3f27-4a54-ba5e-7c1449cc209e</subevent_id>
    <title>SAS: 9</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/20</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>01c81f7c-64ed-49e2-9ba3-aa2916017efa</slot_id>
      <title>Session: SAS - 9</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>69d30a54-a0c6-4cd5-a489-888238b136c8</slot_id>
      <event_id>b673ae70-f50a-4531-b748-2fe1a22e890b</event_id>
      <title>Counterexample- and Simulation-Guided Floating-Point Loop Invariant Synthesis</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>03:20</end_time>
      <description>We present an automated procedure for synthesizing sound inductive invariants for floating-point numerical loops. Our procedure generates invariants of the form of a convex polynomial inequality that tightly bounds the values of loop variables. Such invariants are a prerequisite for reasoning about the safety and roundoff errors of floating-point programs.
Unlike previous approaches that rely on policy iteration, linear algebra or semi-definite programming, we propose a heuristic procedure based on simulation and counterexample-guided refinement. We observe that this combination is remarkably effective and general and can handle both linear and nonlinear loop bodies, nondeterministic values as well as conditional statements. Our evaluation shows that our approach can efficiently synthesize loop invariants for existing benchmarks from literature, but that it is also able to find invariants for nonlinear loops that today’s tools cannot handle.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anastasiia</first_name>
          <last_name>Izycheva</last_name>
          <affiliation>Technical University of Munich</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/anastasiiaizycheva/049b4a5f-65b4-44c8-bc62-ba47c866094f/small.jpg</picture_url>
          <person_id>anastasiiaizycheva</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eva</first_name>
          <last_name>Darulova</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mpi-sws.org/~eva/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/evadarulova/0d98744b-ec94-4a27-b1c0-0d728d54bdb7/small.jpg</picture_url>
          <person_id>evadarulova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Helmut</first_name>
          <last_name>Seidl</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www2.in.tum.de/~seidl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/helmutseidl/2dcd593b-82c2-48ee-b042-87ebd49b4379/small.jpg</picture_url>
          <person_id>helmutseidl</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fa844ea3-09f0-4771-b77b-efdd50b3d260</slot_id>
      <event_id>826b72b5-8d2a-4c83-b0c8-2893d66b8ea5</event_id>
      <title>Predicate Abstraction and CEGAR for nuHFL(Z) Validity Checking</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>04:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Iwayama</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <person_id>naokiiwayama</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.kb.is.s.u-tokyo.ac.jp/~koba/</homepage_url>
          <person_id>naokikobayashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ryota</first_name>
          <last_name>Suzuki</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>ryotasuzuki</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Takeshi</first_name>
          <last_name>Tsukada</last_name>
          <affiliation>Chiba University, Japan</affiliation>
          <bio>undefined</bio>
          <person_id>takeshitsukada</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>eaaab73d-9570-4cf1-a622-32cdf2fa157b</subevent_id>
    <title>SAS: 6</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>b048de65-2444-4346-958b-ec6e2ea8706e</slot_id>
      <title>Session: SAS - 6</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>09:00</start_time>
      <end_time>10:00</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>811a300d-9918-4516-848b-83dad9f38e6d</slot_id>
      <event_id>187c6e5a-f0c2-4d97-b61b-97cf948fa0e3</event_id>
      <title>Termination of Polynomial Loops</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>10:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Florian</first_name>
          <last_name>Frohn</last_name>
          <affiliation>Max Planck Institute for Informatics</affiliation>
          <bio>undefined</bio>
          <person_id>florianfrohn</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marcel</first_name>
          <last_name>Hark</last_name>
          <affiliation>RWTH Aachen University, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/marcelhark/5357ec40-8b32-4698-8252-6c0d8b96f75e/small.jpg</picture_url>
          <person_id>marcelhark</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jürgen</first_name>
          <last_name>Giesl</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://verify.rwth-aachen.de/giesl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jurgengiesl/b1a15529-1129-4608-9104-be1d58d0e129/small.jpg</picture_url>
          <person_id>jurgengiesl</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d9aa46d6-ff33-40fc-89c4-3c292af007e0</slot_id>
      <event_id>fa77e119-6a7c-478d-a301-745160397e38</event_id>
      <title>Invited Talk: Polynomial Invariants for Affine Programs</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>09:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>James</first_name>
          <last_name>Worrell</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ox.ac.uk/people/james.worrell/home.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jamesworrell/6504b62e-546c-401b-ba8d-2749ee9c9308/small.jpg</picture_url>
          <person_id>jamesworrell</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>edf310d8-458d-473b-b249-35fb424f8188</subevent_id>
    <title>SAS: 2</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/18</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>dbd3b557-c3f4-42fd-8da1-e7e905444d10</slot_id>
      <title>Session: SAS - 2</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6b367a68-fe3c-4faa-b0ee-87ed44c40832</slot_id>
      <event_id>9dacd93d-13cf-4a2c-9a12-ef5b3d814e72</event_id>
      <title>Croquet: A Unique Collaboration Architecture (Keynote)</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>00:20</end_time>
      <description>The next generation of our connected world calls for a low-latency, low-bandwidth, low-development-effort platform for synchronized interactions. The platform must also enforce privacy from the ground up, in particular in anticipation of an always-on Augmented Reality future.
In traditional synchronization approaches, computations are performed on a server and results are continuously distributed to clients. Croquet moves all computation to the clients. A lightweight “reflector” server directs the clients to advance time in sync, and ensures that any external event is incorporated by all clients at exactly the same point in the computation, leading to synchronized, bit-identical state. All data is end-to-end encrypted by the clients; the server stores and distributes data, but can never peek inside.
Croquet’s programming model separates the synchronized computation of “models” from individually computed “views”. This means the world is the same for everyone, but the display of the world can be tailored to each device and user. Models and views communicate using a publish/subscribe mechanism that routes certain events via the reflector. This model/view separation and pub/sub communication is a major departure from the previous, proxy-based Smalltalk implementation of Croquet. It retains the ability for live programming by atomically incorporating new code.
Vanessa is the chief architect of the current JavaScript-based implementation. She will give an overview of the system, highlight challenges in designing the API, and explore the far-reaching implications of the shift from server to client.</description>
      <persons>
        <person>
          <role>Presenter</role>
          <sort_key>1</sort_key>
          <first_name>Vanessa</first_name>
          <last_name>Freudenberg</last_name>
          <affiliation>Croquet Corp</affiliation>
          <bio>Vanessa is a co-founder of Croquet Corp and the principal engineer of the current Teatime client/server architecture underlying Croquet. She has been developing interactive systems for more than 20 years with a focus on live, self-supporting systems (including Squeak Etoys, Scratch, Lively, Smalltalk VMs).</bio>
          <homepage_url>https://www.croquet.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vanessafreudenberg/846610a3-d712-4599-95cb-b259a0d51d2b/small.jpg</picture_url>
          <person_id>vanessafreudenberg</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fed3a4c3-3a03-4162-8820-29f699121c48</slot_id>
      <event_id>a314d207-12a7-4384-9f2a-43bf0cacd948</event_id>
      <title>Invited Talk: Static Resource Analysis at Scale</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>23:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Ezgi</first_name>
          <last_name>Çiçek</last_name>
          <affiliation>Facebook London</affiliation>
          <bio>I have obtained my PhD in Programming Languages at MPI-SWS (Max Planck Institute for Software Systems, Saarbrücken, Germany) and Saarland University in January 2018. I was advised by Deepak Garg. I am currently a Software Engineer at Facebook’s Static Analysis team, Infer. Nowadays, I am working on a static analysis tool for detecting performance regressions at diff time.</bio>
          <homepage_url>https://ezgicicek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ezgicicek/fd8cd7b8-388d-46de-960d-2e5912ceae85/small.jpg</picture_url>
          <person_id>ezgicicek</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>376c14b7-ab5a-41a2-bd9a-a678372cef80</subevent_id>
    <title>SAS: 5</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>edd33d48-1172-40c3-8148-7c61294c737d</slot_id>
      <title>Session: SAS - 5</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5f46fb26-3a63-4ae7-a578-99dfdd0dbf3f</slot_id>
      <event_id>890ea906-b119-4828-8f45-d132f9c38082</event_id>
      <title>Abstract Neural Networks</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>05:20</end_time>
      <description>Deep Neural Networks (DNNs) are rapidly being applied to safety-critical domains such as drone and airplane control, motivating techniques for verifying the safety of their behavior. Unfortunately, DNN verification is NP-hard, with current algorithms slowing exponentially with the number of nodes in the DNN. This paper introduces the notion of Abstract Neural Networks (ANNs), which can be used to soundly overapproximate DNNs while using fewer nodes. An ANN is like a DNN except weight matrices are replaced by values in a given abstract domain. We present a framework parameterized by the abstract domain and activation functions used in the DNN that can be used to construct a corresponding ANN. We present necessary and sufficient conditions on the DNN activation functions for the constructed ANN to soundly over-approximate the given DNN. Prior work on DNN abstraction was restricted to the interval domain and ReLU activation function. Our framework can be instantiated with other abstract domains such as octagons and polyhedra, as well as other activation functions such as Leaky ReLU, Sigmoid, and Hyperbolic Tangent.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Sotoudeh</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://masot.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthewsotoudeh/32b819f5-05ef-4b0a-8a19-d59eed661278/small.jpg</picture_url>
          <person_id>matthewsotoudeh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aditya V.</first_name>
          <last_name>Thakur</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://thakur.cs.ucdavis.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adityavthakur/89eb0287-7273-4261-b8a5-47ccfc8799b0/small.jpg</picture_url>
          <person_id>adityavthakur</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>96624ab6-7b23-44d2-9f90-6c913772f35a</slot_id>
      <event_id>5360324a-7234-4b20-95d8-80639f65ad7a</event_id>
      <title>Probabilistic Lipschitz Analysis of Neural Networks</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>05:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>06:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ravi</first_name>
          <last_name>Mangal</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cc.gatech.edu/~rmangal3/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ravimangal/a3129793-a42b-47f4-8195-79800685503e/small.jpg</picture_url>
          <person_id>ravimangal</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kartik</first_name>
          <last_name>Sarangmath</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>kartiksarangmath</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aditya</first_name>
          <last_name>Nori</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>adityanori</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Alessandro</first_name>
          <last_name>Orso</last_name>
          <affiliation>Georgia Tech</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cc.gatech.edu/~orso/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alessandroorso/5f7dffa8-54ca-4f1e-84f0-1f1a9affbf55/small.jpg</picture_url>
          <person_id>alessandroorso</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>aee87c67-5a0c-4016-8f75-9be6ef04b1ae</slot_id>
      <event_id>179704f8-cb35-4d44-8ef9-ea437c436204</event_id>
      <title>Amalgamating Different JIT Compilations in a Meta-tracing JIT Compiler Framework</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>05:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>05:40</end_time>
      <description>Most virtual machines employ just-in-time (JIT) compilers to achieve their high-performance. Trace-based compilation and method-based compilation are two major compilation strategies in JIT compilers. In general, the former excels in compiling programs with more in-depth method calls and more dynamic branches, while the latter is suitable for a wide range of programs. Some previous studies have suggested that each strategy has its advantages and disadvantages, and there is no clear winner.
In this paper, we present a new approach, namely, the meta-hybrid JIT compilation strategy. It combines trace-based and method-based compilations to utilize the advantages of both strategies. Moreover, it is realized as a meta JIT compiler framework; thus, we can generate a VM with a hybrid JIT compiler that can apply different program parts by merely writing an interpreter with our framework.
We chose to extend a meta-tracing JIT compiler and supported the two compilations on it. As a prototype, we implemented a simple meta-tracing JIT compiler framework called BacCaml based on the MinCaml compiler by following RPython’s architecture.
We evaluated its performance by creating a small functional programming language with BacCaml and running microbenchmark programs. Furthermore, we performed a synthetic experiment to confirm that there are programs that run faster by hybrid compilation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yusuke</first_name>
          <last_name>Izawa</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://3tty0n.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yusukeizawa/2d1131a1-4abb-4ade-9761-e3d2648bd9f5/small.jpg</picture_url>
          <person_id>yusukeizawa</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hidehiko</first_name>
          <last_name>Masuhara</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>Hidehiko Masuhara is a Professor of Mathematical and Computing Science, Tokyo Institute of Technology since April 2013. He received his B.S., M.S., and Ph.D. in Computer Science from Department of Information Science, University of Tokyo in 1992, 1994, and 1999, respectively, and served as an assistant professor, lecturer, and associate professor at Graphics and Computer Science, Graduate School of Arts and Sciences, University of Tokyo from 1995 until 2013.</bio>
          <homepage_url>http://prg.is.titech.ac.jp/people/masuhara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hidehikomasuhara/3ea94269-6fb5-4c6d-8d6f-0435717377d6/small.jpg</picture_url>
          <person_id>hidehikomasuhara</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>edab5d5e-1266-4297-80cb-335754c7bef6</slot_id>
      <event_id>5013f5f6-0c92-406c-b516-126cc1c9f16c</event_id>
      <title>Pricing Python Parallelism: a Dynamic Language Cost Model for Heterogeneous Platforms</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>06:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>06:20</end_time>
      <description>Execution times may be reduced by offloading parallel loop nests to a GPU. Auto-parallelizing compilers are common for static languages, often using a cost model to determine when the GPU execution speed will outweigh the offload overheads. Nowadays scientific software is increasingly written in dynamic languages and would benefit from compute accelerators. The ALPyNA framework analyses moderately complex Python loop nests and automatically JIT compiles code for heterogeneous CPU and GPU architectures.
We present the first analytical cost model for auto-parallelizing loop nests in a dynamic language on heterogeneous architectures. Predicting execution time in a language like Python is extremely challenging, since aspects like the element types, size of the iteration space, and amenability to parallelization can only be determined at runtime. Hence the cost model must be both staged, to combine compile and run-time information, and lightweight to minimize runtime overhead. GPU execution time prediction must account for factors like data transfer, block-structured execution, and starvation.
We show that a comparatively simple, staged analytical model can accurately determine during execution when it is profitable to offload a loop nest. We evaluate our model on three heterogeneous platforms across 360 experiments with 12 loop-intensive Python benchmark programs. The results show small misprediction intervals and a mean slowdown of just 13.6%, relative to the optimal (oracular) offload strategy.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dejice</first_name>
          <last_name>Jacob</last_name>
          <affiliation>University of Glasgow, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~jacobd</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/dejicejacob/3f7c1cd4-c004-439f-a953-1389a8b68578/small.jpg</picture_url>
          <person_id>dejicejacob</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Phil</first_name>
          <last_name>Trinder</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~trinder/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philtrinder/fa2ffb07-cddf-4a8d-a52a-ca1aaad1273b/small.jpg</picture_url>
          <person_id>philtrinder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Singer</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~jsinger</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeremysinger/14db1542-37ba-4e0e-b338-e3a952991f1a/small.jpg</picture_url>
          <person_id>jeremysinger</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>aebfc60d-dc95-4034-a752-a7a52f07ecf9</subevent_id>
    <title>SAS: 8</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>798ae7a2-c991-4cc4-916e-57e8d7df8a17</slot_id>
      <title>Session: SAS - 8</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>46008787-c9af-4d90-bef1-d4283eb6a52f</slot_id>
      <event_id>43e38930-e679-4381-b5e9-f606f58d5550</event_id>
      <title>Harming Dynamic Analysis</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>13:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mila</first_name>
          <last_name>Dalla Preda</last_name>
          <affiliation>University of Verona, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://profs.sci.univr.it/~dallapre</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/miladallapreda/bfe198ed-1dee-40dd-a639-ad6951f36888/small.jpg</picture_url>
          <person_id>miladallapreda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roberto</first_name>
          <last_name>Giacobazzi</last_name>
          <affiliation>University of Verona and IMDEA Software Institute</affiliation>
          <bio>Roberto Giacobazzi received the Laurea degree in Computer Science in 1988 from the University of Pisa, and in 1993 he received the Ph.D. in Computer Science from the same university, with a Ph.D. thesis on Semantic aspects of logic program analysis, under the supervision of Prof. Giorgio Levi. From 1993 to 1995 he had a Post Doctoral Research position at Laboratoire d’Informatique (LIX), Ecole Polytechnique (Paris) in the equipe Cousot. From 1995 to 1998 he was (tenured) Assistant Professor in Computer Science at the University of Pisa. From May 2000 until now he is Full Professor in Computer Science at the University of Verona. The research interests of Roberto Giacobazzi include abstract interpretation, static program analysis, semantics of programming languages, program verification, abstract model-checking, program transformation and optimization, digital asset protection, code obfuscation, malware detection, software watermarking, computability and lattice theory. He has been Program Chair of SAS, VMCAI, of workshops in programming languages and language based security, and General Chair of ACM POPL2013. From 2006 to 2012 he has been Dean of the College of Science of the University of Verona. He works at the University of Verona and at IMDEA Software Institute.</bio>
          <homepage_url>http://profs.sci.univr.it/~giaco/index.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/robertogiacobazzi/3a292abe-6f69-4d5d-bfa3-305417b39cba/small.jpg</picture_url>
          <person_id>robertogiacobazzi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Niccolò</first_name>
          <last_name>Marastoni</last_name>
          <affiliation>University of Verona</affiliation>
          <bio>undefined</bio>
          <person_id>niccolomarastoni</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>65ca0aac-d1e0-4410-8b79-8634eafb21c4</slot_id>
      <event_id>3faff150-5135-4eb3-affb-a5bfe3c3fe17</event_id>
      <title>Framework-Aware Debugging with Stack Tailoring</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>14:20</end_time>
      <description>Debugging applications that execute within a framework is not always easy: the call-stack offered to developers is often a mix-up of stack frames that belong to different frameworks, introducing an unnecessary noise that prevents developers from focusing on the debugging task. Moreover, relevant application code is not always available in the call-stack because it may have already returned, or is available in another thread. In such cases, manually gathering all relevant information from these different sources is not only cumbersome but also costly.
In this paper we introduce Sarto, a call-stack instrumentation layer that allows developers to tailor the stack to make debugging framework-aware. The goal is to improve the quality and amount information present in the call-stack to reduce debugging time without impacting the execution time. Sarto proposes a set of six stack operations that combined hide irrelevant information, introduce missing information, and relate dispersed debugging sources before this is fed to the debugger.
We validate Sarto by applying it to four application cases using inherently different frameworks: unit testing, web server, remote promises and big data processing. We showcase our experiences in using Sarto in the different frameworks, and perform some performance benchmarks to demonstrate that Sarto does not generate noticeable overhead when instrumenting a call-stack. We also show that our solution reduces by half the amount of data stored to debug similar exceptions happening in a parallel setup.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matteo</first_name>
          <last_name>Marra</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>I am a pre-doctoral researcher at the Vrije Universiteit Brussel (Belgium). After completing my bachelor studies in Italy (Università degli studi di Bologna), I moved to Brussels for a master at the Vrije Universiteit Brussel, in the Software Languages Lab, and decided to start a PhD under the guide of prof. Elisa Gonzalez Boix. I also cooperate with the RMoD research group at INRIA Lille Nord-Europe.
My research focuses on debugging concurrent and parallel applications, particularly Big Data (or data intensive) applications.</bio>
          <homepage_url>https://soft.vub.ac.be/~mmarra</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matteomarra/71e5312b-940b-4349-afaf-fa0a934b2c49/small.jpg</picture_url>
          <person_id>matteomarra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guillermo</first_name>
          <last_name>Polito</last_name>
          <affiliation>Univ. Lille, CNRS, Centrale Lille, Inria, UMR 9189 - CRIStAL - Centre de Recherche en Informatique Signal et Automatique de Lille</affiliation>
          <bio>Guille Polito is research engineer at the CRIStAL laboratory in the university of Lille, working in tight relation with the RMoD team. Guille’s main research interests are programming language development, programming tools, modular systems, and maintenance of large software systems.
He currently works on techniques to develop modular systems and languages, and new development tools. Guille works in the development of the open source Pharo programming language and environment since 2010, and he is a member of its technical board since 2018.</bio>
          <homepage_url>https://guillep.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guillermopolito/fb027991-a37d-4375-8c71-1858ce478695/small.jpg</picture_url>
          <person_id>guillermopolito</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Elisa</first_name>
          <last_name>Gonzalez Boix</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~egonzale</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elisagonzalezboix/8e8a61c4-366e-49b5-a861-7dfbc98ee129/small.jpg</picture_url>
          <person_id>elisagonzalezboix</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>eb80fe7a-f17d-45c0-8660-63205463d67a</slot_id>
      <event_id>4fd50d6f-63a1-4bda-a578-b90810c55019</event_id>
      <title>Farkas-Based Tree Interpolation</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>13:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sepideh</first_name>
          <last_name>Asadi</last_name>
          <affiliation>PhD Student</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.inf.usi.ch/phd/asadi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sepidehasadi/68b2e971-e6c1-495a-be27-6eeedea8173c/small.jpg</picture_url>
          <person_id>sepidehasadi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin</first_name>
          <last_name>Blicha</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>martinblicha</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Antti</first_name>
          <last_name>Hyvärinen</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>anttihyvarinen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Grigory</first_name>
          <last_name>Fedyukovich</last_name>
          <affiliation>Florida State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.fsu.edu/~grigory</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/grigoryfedyukovich/902a9cea-9078-42f4-9fb4-19a433865738/small.jpg</picture_url>
          <person_id>grigoryfedyukovich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Natasha</first_name>
          <last_name>Sharygina</last_name>
          <affiliation>USI Lugano, Switzerland</affiliation>
          <bio>Natasha Sharygina is a Full Professor of Computer Science at the University of Lugano, Switzerland. Prof. Sharygina received a Ph.D. degree from the University of Texas at Austin, USA in 2002. Her professional experience includes a visiting professor position at Imperial college, London, UK in 2018, a research faculty position at Carnegie Mellon University, SEI in 2002-2005 and consulting at Bell Labs, Lucent Technologies at the Computing Sciences Research in 2000-2001. Prof. Sharygina directs the USI Formal Verification and Security group whose research deals with improving the program development process through formal methods of specification and verification. Prof. Sharygina´s interests lie in software and hardware verification, temporal logics, model checking, SAT/SMT methods, and concurrent and distributed computing. Prof. Sharygina´s current focus is on applying automated formal methods to problems in computer security, electronic design automation, and program analysis. Prof. Sharygina is the recipient of various awards among which are the ACM recognition of service award and CMU Technical Excellence awards. Prof. Sharygina´s research has been funded by multiple grants from the Swiss National Foundation, EU Research and Innovation programs, EU cooperation in science and technology projects, Hasler Foundation and TASSO career awards. Prof. Sharygina has authored more than 150 research papers in areas of formal verification, and system design. She served on program committees of various major conferences in the field of computer-aided verification (e.g., CAV, TACAS, FMCAD, SPIN), given keynote and invited presentations, and co-chaired highly competitive international conferences and symposia such as FMCAD 2010 and CAV 2013.</bio>
          <homepage_url>https://www.inf.usi.ch/faculty/sharygina/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/natashasharygina/9f9a75af-6af0-4d73-ab0c-c440c28bdb5f/small.jpg</picture_url>
          <person_id>natashasharygina</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0ef7cbf0-f06f-45b9-9a9b-b9f38270ce9a</subevent_id>
    <title>SAS: 8</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/20</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>87ddc621-e199-4058-9b18-4f86ab08813f</slot_id>
      <title>Session: SAS - 8</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>005f57fd-94b4-4d26-a09e-e928a5c2ecbc</slot_id>
      <event_id>43e38930-e679-4381-b5e9-f606f58d5550</event_id>
      <title>Harming Dynamic Analysis</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>01:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mila</first_name>
          <last_name>Dalla Preda</last_name>
          <affiliation>University of Verona, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://profs.sci.univr.it/~dallapre</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/miladallapreda/bfe198ed-1dee-40dd-a639-ad6951f36888/small.jpg</picture_url>
          <person_id>miladallapreda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roberto</first_name>
          <last_name>Giacobazzi</last_name>
          <affiliation>University of Verona and IMDEA Software Institute</affiliation>
          <bio>Roberto Giacobazzi received the Laurea degree in Computer Science in 1988 from the University of Pisa, and in 1993 he received the Ph.D. in Computer Science from the same university, with a Ph.D. thesis on Semantic aspects of logic program analysis, under the supervision of Prof. Giorgio Levi. From 1993 to 1995 he had a Post Doctoral Research position at Laboratoire d’Informatique (LIX), Ecole Polytechnique (Paris) in the equipe Cousot. From 1995 to 1998 he was (tenured) Assistant Professor in Computer Science at the University of Pisa. From May 2000 until now he is Full Professor in Computer Science at the University of Verona. The research interests of Roberto Giacobazzi include abstract interpretation, static program analysis, semantics of programming languages, program verification, abstract model-checking, program transformation and optimization, digital asset protection, code obfuscation, malware detection, software watermarking, computability and lattice theory. He has been Program Chair of SAS, VMCAI, of workshops in programming languages and language based security, and General Chair of ACM POPL2013. From 2006 to 2012 he has been Dean of the College of Science of the University of Verona. He works at the University of Verona and at IMDEA Software Institute.</bio>
          <homepage_url>http://profs.sci.univr.it/~giaco/index.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/robertogiacobazzi/3a292abe-6f69-4d5d-bfa3-305417b39cba/small.jpg</picture_url>
          <person_id>robertogiacobazzi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Niccolò</first_name>
          <last_name>Marastoni</last_name>
          <affiliation>University of Verona</affiliation>
          <bio>undefined</bio>
          <person_id>niccolomarastoni</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4d7b415f-b0f8-4d98-95d2-57a5ab51e9bb</slot_id>
      <event_id>3faff150-5135-4eb3-affb-a5bfe3c3fe17</event_id>
      <title>Framework-Aware Debugging with Stack Tailoring</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>02:20</end_time>
      <description>Debugging applications that execute within a framework is not always easy: the call-stack offered to developers is often a mix-up of stack frames that belong to different frameworks, introducing an unnecessary noise that prevents developers from focusing on the debugging task. Moreover, relevant application code is not always available in the call-stack because it may have already returned, or is available in another thread. In such cases, manually gathering all relevant information from these different sources is not only cumbersome but also costly.
In this paper we introduce Sarto, a call-stack instrumentation layer that allows developers to tailor the stack to make debugging framework-aware. The goal is to improve the quality and amount information present in the call-stack to reduce debugging time without impacting the execution time. Sarto proposes a set of six stack operations that combined hide irrelevant information, introduce missing information, and relate dispersed debugging sources before this is fed to the debugger.
We validate Sarto by applying it to four application cases using inherently different frameworks: unit testing, web server, remote promises and big data processing. We showcase our experiences in using Sarto in the different frameworks, and perform some performance benchmarks to demonstrate that Sarto does not generate noticeable overhead when instrumenting a call-stack. We also show that our solution reduces by half the amount of data stored to debug similar exceptions happening in a parallel setup.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matteo</first_name>
          <last_name>Marra</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>I am a pre-doctoral researcher at the Vrije Universiteit Brussel (Belgium). After completing my bachelor studies in Italy (Università degli studi di Bologna), I moved to Brussels for a master at the Vrije Universiteit Brussel, in the Software Languages Lab, and decided to start a PhD under the guide of prof. Elisa Gonzalez Boix. I also cooperate with the RMoD research group at INRIA Lille Nord-Europe.
My research focuses on debugging concurrent and parallel applications, particularly Big Data (or data intensive) applications.</bio>
          <homepage_url>https://soft.vub.ac.be/~mmarra</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matteomarra/71e5312b-940b-4349-afaf-fa0a934b2c49/small.jpg</picture_url>
          <person_id>matteomarra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guillermo</first_name>
          <last_name>Polito</last_name>
          <affiliation>Univ. Lille, CNRS, Centrale Lille, Inria, UMR 9189 - CRIStAL - Centre de Recherche en Informatique Signal et Automatique de Lille</affiliation>
          <bio>Guille Polito is research engineer at the CRIStAL laboratory in the university of Lille, working in tight relation with the RMoD team. Guille’s main research interests are programming language development, programming tools, modular systems, and maintenance of large software systems.
He currently works on techniques to develop modular systems and languages, and new development tools. Guille works in the development of the open source Pharo programming language and environment since 2010, and he is a member of its technical board since 2018.</bio>
          <homepage_url>https://guillep.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guillermopolito/fb027991-a37d-4375-8c71-1858ce478695/small.jpg</picture_url>
          <person_id>guillermopolito</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Elisa</first_name>
          <last_name>Gonzalez Boix</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~egonzale</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elisagonzalezboix/8e8a61c4-366e-49b5-a861-7dfbc98ee129/small.jpg</picture_url>
          <person_id>elisagonzalezboix</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>98c89d91-3a9c-4b65-ae75-d270c6128833</slot_id>
      <event_id>4fd50d6f-63a1-4bda-a578-b90810c55019</event_id>
      <title>Farkas-Based Tree Interpolation</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>01:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sepideh</first_name>
          <last_name>Asadi</last_name>
          <affiliation>PhD Student</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.inf.usi.ch/phd/asadi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sepidehasadi/68b2e971-e6c1-495a-be27-6eeedea8173c/small.jpg</picture_url>
          <person_id>sepidehasadi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin</first_name>
          <last_name>Blicha</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>martinblicha</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Antti</first_name>
          <last_name>Hyvärinen</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>anttihyvarinen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Grigory</first_name>
          <last_name>Fedyukovich</last_name>
          <affiliation>Florida State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.fsu.edu/~grigory</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/grigoryfedyukovich/902a9cea-9078-42f4-9fb4-19a433865738/small.jpg</picture_url>
          <person_id>grigoryfedyukovich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Natasha</first_name>
          <last_name>Sharygina</last_name>
          <affiliation>USI Lugano, Switzerland</affiliation>
          <bio>Natasha Sharygina is a Full Professor of Computer Science at the University of Lugano, Switzerland. Prof. Sharygina received a Ph.D. degree from the University of Texas at Austin, USA in 2002. Her professional experience includes a visiting professor position at Imperial college, London, UK in 2018, a research faculty position at Carnegie Mellon University, SEI in 2002-2005 and consulting at Bell Labs, Lucent Technologies at the Computing Sciences Research in 2000-2001. Prof. Sharygina directs the USI Formal Verification and Security group whose research deals with improving the program development process through formal methods of specification and verification. Prof. Sharygina´s interests lie in software and hardware verification, temporal logics, model checking, SAT/SMT methods, and concurrent and distributed computing. Prof. Sharygina´s current focus is on applying automated formal methods to problems in computer security, electronic design automation, and program analysis. Prof. Sharygina is the recipient of various awards among which are the ACM recognition of service award and CMU Technical Excellence awards. Prof. Sharygina´s research has been funded by multiple grants from the Swiss National Foundation, EU Research and Innovation programs, EU cooperation in science and technology projects, Hasler Foundation and TASSO career awards. Prof. Sharygina has authored more than 150 research papers in areas of formal verification, and system design. She served on program committees of various major conferences in the field of computer-aided verification (e.g., CAV, TACAS, FMCAD, SPIN), given keynote and invited presentations, and co-chaired highly competitive international conferences and symposia such as FMCAD 2010 and CAV 2013.</bio>
          <homepage_url>https://www.inf.usi.ch/faculty/sharygina/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/natashasharygina/9f9a75af-6af0-4d73-ab0c-c440c28bdb5f/small.jpg</picture_url>
          <person_id>natashasharygina</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8070343f-e9f1-42f0-b94a-20fbd02c6d0e</subevent_id>
    <title>SAS: Tool environments</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/18</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>d4212569-60b3-4c6a-912c-db565d53e08c</slot_id>
      <title>Session: SAS - Tool environments</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>07:00</start_time>
      <end_time>08:00</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2bad46cf-da0e-4a38-affd-cdc6d07704ba</slot_id>
      <event_id>ae38a637-3b97-4277-a496-2c1f2d2c6a6b</event_id>
      <title>Invited Talk: Cost Analysis of Smart Contracts via Parametric Resource Analysis</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>07:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Hermenegildo</last_name>
          <affiliation>IMDEA Software Institute and T.U. of Madrid</affiliation>
          <bio>Manuel Hermenegildo is Distinguished Professor at (and was the Founding Director of) the IMDEA Software Institute. He is also full Prof. of Computer Science at the Tech. U. of Madrid, UPM. Previously he held an Endowed Chair in Information Science and Technology at the U. of New Mexico. He was also project leader at the MCC research center and Adjunct Associate Prof. at the CS Department of the U. of Texas, both in Austin, Texas. See his home page for more information.
Research interests: Energy-Aware Computing, Resource / non-functional property analysis, verification, and control; Global Program Analysis, Optimization, Verification, Debugging; Abstract Interpretation; Partial Evaluation; Parallelism and Parallelizing Compilers; Constraint/Logic/Functional Programming Theory and Implementation, Abstract Machines; Automatic Documentation Tools, Execution Visualization; Sequential and Parallel Computer Architecture.</bio>
          <homepage_url>http://cliplab.org/herme</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelhermengildo/9ad5b1a1-5b09-4700-a372-66f4683bb674/small.jpg</picture_url>
          <person_id>manuelhermengildo</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ca939b92-d7ad-4a8d-af82-0766061ad965</slot_id>
      <event_id>96776028-772c-4c12-bdda-eb5721127c2c</event_id>
      <title>A Library Modeling Language for the Static Analysis of C Programs</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>07:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>08:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abdelraouf</first_name>
          <last_name>Ouadjaout</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~ouadjaout/</homepage_url>
          <person_id>abdelraoufouadjaout</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Miné</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~mine/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/antoinemine/77e18473-3b05-4bec-8b27-3e073a24fb34/small.jpg</picture_url>
          <person_id>antoinemine</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>92d46c4f-ce8c-4c02-a7dd-a0be0d570172</subevent_id>
    <title>SAS: 4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/18</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>6182b3f7-1cf7-4834-a423-f63788fc56ab</slot_id>
      <title>Session: SAS - 4</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>214d03e9-fa36-4b7c-ac05-44089ceeceb4</slot_id>
      <event_id>ce3e05fe-bed4-4c6e-8f2f-3ec96e59bf13</event_id>
      <title>Dynamic Pattern Matching with Python</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>15:40</end_time>
      <description>Pattern matching allows programs both to extract specific information from complex data types, as well as to branch on the structure of data and thus apply specialized actions to different forms of data. Originally designed for strongly typed functional languages with algebraic data types, pattern matching has since been adapted for object-oriented and even dynamic languages. This paper discusses how pattern matching can be included in the dynamically typed language Python in line with existing features that support extracting values from sequential data structures.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Kohn</last_name>
          <affiliation>University of Cambridge, UK</affiliation>
          <bio>undefined</bio>
          <person_id>tobiaskohn</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guido</first_name>
          <last_name>van Rossum</last_name>
          <affiliation>Python Software Foundation</affiliation>
          <bio>undefined</bio>
          <person_id>guidovanrossum</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gary Brandt</first_name>
          <last_name>Bucher, II</last_name>
          <affiliation>Research Affiliates, LLC</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://brandtbucher.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/garybrandtbucherii/4d2da008-7dca-4c6f-805b-65214288ada8/small.jpg</picture_url>
          <person_id>garybrandtbucherii</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>undefined</first_name>
          <last_name>Talin</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>talin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Levkivskyi</last_name>
          <affiliation>Dropbox Ireland</affiliation>
          <bio>undefined</bio>
          <person_id>ivanlevkivskyi</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>88394186-cbb7-43fb-b7e9-773c79c6ce07</slot_id>
      <event_id>b5f8101e-f7bf-45b0-98cf-165cd7531f05</event_id>
      <title>Sound, Heuristic Type Annotation Inference For Ruby</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>16:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>16:20</end_time>
      <description>Many researchers have explored retrofitting static type systems to dynamic languages. This raises the question of how to add type annotations to code that was previously untyped. One obvious solution is type inference. However, in complex type systems, in particular those with structural types, type inference typically produces most general types that are large, hard to understand, and unnatural for programmers. To solve this problem, we introduce InferDL, a novel Ruby type inference system that infers sound and useful type annotations by incorporating heuristics that guess types. For example, we might heuristically guess that a parameter whose name ends in “count” is an integer. InferDL works by first running standard type inference, and then applying heuristics to any positions for which standard type inference produces overly-general types. Heuristic guesses are added as constraints to the type inference problem to ensure they are consistent with the rest of the program and other heuristic guesses; inconsistent guesses are discarded. We formalized InferDL in a core type and constraint language. We implemented InferDL on top of RDL, an existing Ruby type checker. To evaluate InferDL, we applied it to four Ruby on Rails apps that had been previously type checked with RDL, and hence had type annotations. We found that, when using heuristics, InferDL inferred 22% more types that were as or more precise than the previous annotations, compared to standard type inference without heuristics. We also found one new type error. We further evaluated InferDL by applying it to six additional apps, finding five additional type errors. Thus, we believe InferDL represents a promising approach for inferring type annotations in dynamic languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Milod</first_name>
          <last_name>Kazerounian</last_name>
          <affiliation>University of Maryland, College Park</affiliation>
          <bio>undefined</bio>
          <person_id>milodkazerounian1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Brianna M.</first_name>
          <last_name>Ren</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
          <person_id>briannamren</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jeffrey S.</first_name>
          <last_name>Foster</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.tufts.edu/~jfoster/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeffreysfoster/b22ce952-32b0-48bd-be56-12fd87bf3469/small.jpg</picture_url>
          <person_id>jeffreysfoster</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>db8d3a86-8581-4930-87d3-b8b949fd82ad</slot_id>
      <event_id>5e5d5e27-4f5e-4ec9-be96-5f1f0a5bfe96</event_id>
      <title>Simple and Efficient Computation of Minimal Weak Control Closure</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>16:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abu Naser</first_name>
          <last_name>Masud</last_name>
          <affiliation>Malardalen University</affiliation>
          <bio>undefined</bio>
          <person_id>abunasermasud</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ea0555f9-6f56-4516-86fc-ab280024219c</slot_id>
      <event_id>60869a0f-9da8-4a93-9b8e-4d4adbc8ef13</event_id>
      <title>Memory-Efficient Fixpoint Computation</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>15:20</end_time>
      <description>Practical adoption of static analysis often requires trading precision for performance. This paper focuses on improving the memory efficiency of abstract interpretation without sacrificing precision or time efficiency. Computationally, abstract interpretation reduces the problem of inferring program invariants to computing a fixpoint of a set of equations. This paper presents a method to minimize the memory footprint in Bourdoncle’s iteration strategy, a widely-used technique for fixpoint computation. Our technique is agnostic to the abstract domain used. We prove that our technique is optimal (i.e., it results in minimum memory footprint) for Bourdoncle’s iteration strategy while computing the same result. We evaluate the efficacy of our technique by implementing it in a tool called MIKOS, which extends the state-of-the-art abstract interpreter IKOS. When verifying user-provided assertions, MIKOS shows a decrease in peak-memory usage to 4.07% (24.57x) on average compared to IKOS. When performing interprocedural buffer-overflow analysis, MIKOS shows a decrease in peak-memory usage to 43.7% (2.29x) on average compared to IKOS.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sung</first_name>
          <last_name>Kook Kim</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>sungkookkim</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Arnaud J.</first_name>
          <last_name>Venet</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>arnaudjvenet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aditya V.</first_name>
          <last_name>Thakur</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://thakur.cs.ucdavis.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adityavthakur/89eb0287-7273-4261-b8a5-47ccfc8799b0/small.jpg</picture_url>
          <person_id>adityavthakur</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e7e78624-0128-48c6-9995-52dbadf83238</subevent_id>
    <title>SAS: 2</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/18</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>d04d25bd-9163-4e4a-aed0-fd381eea73ed</slot_id>
      <title>Session: SAS - 2</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2b30c6b3-ab33-4d2a-a456-1b42d2d22811</slot_id>
      <event_id>a314d207-12a7-4384-9f2a-43bf0cacd948</event_id>
      <title>Invited Talk: Static Resource Analysis at Scale</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>11:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Ezgi</first_name>
          <last_name>Çiçek</last_name>
          <affiliation>Facebook London</affiliation>
          <bio>I have obtained my PhD in Programming Languages at MPI-SWS (Max Planck Institute for Software Systems, Saarbrücken, Germany) and Saarland University in January 2018. I was advised by Deepak Garg. I am currently a Software Engineer at Facebook’s Static Analysis team, Infer. Nowadays, I am working on a static analysis tool for detecting performance regressions at diff time.</bio>
          <homepage_url>https://ezgicicek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ezgicicek/fd8cd7b8-388d-46de-960d-2e5912ceae85/small.jpg</picture_url>
          <person_id>ezgicicek</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9a9c5487-bf59-4b3d-8001-7775ee2700d7</slot_id>
      <event_id>9dacd93d-13cf-4a2c-9a12-ef5b3d814e72</event_id>
      <title>Croquet: A Unique Collaboration Architecture (Keynote)</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>12:20</end_time>
      <description>The next generation of our connected world calls for a low-latency, low-bandwidth, low-development-effort platform for synchronized interactions. The platform must also enforce privacy from the ground up, in particular in anticipation of an always-on Augmented Reality future.
In traditional synchronization approaches, computations are performed on a server and results are continuously distributed to clients. Croquet moves all computation to the clients. A lightweight “reflector” server directs the clients to advance time in sync, and ensures that any external event is incorporated by all clients at exactly the same point in the computation, leading to synchronized, bit-identical state. All data is end-to-end encrypted by the clients; the server stores and distributes data, but can never peek inside.
Croquet’s programming model separates the synchronized computation of “models” from individually computed “views”. This means the world is the same for everyone, but the display of the world can be tailored to each device and user. Models and views communicate using a publish/subscribe mechanism that routes certain events via the reflector. This model/view separation and pub/sub communication is a major departure from the previous, proxy-based Smalltalk implementation of Croquet. It retains the ability for live programming by atomically incorporating new code.
Vanessa is the chief architect of the current JavaScript-based implementation. She will give an overview of the system, highlight challenges in designing the API, and explore the far-reaching implications of the shift from server to client.</description>
      <persons>
        <person>
          <role>Presenter</role>
          <sort_key>1</sort_key>
          <first_name>Vanessa</first_name>
          <last_name>Freudenberg</last_name>
          <affiliation>Croquet Corp</affiliation>
          <bio>Vanessa is a co-founder of Croquet Corp and the principal engineer of the current Teatime client/server architecture underlying Croquet. She has been developing interactive systems for more than 20 years with a focus on live, self-supporting systems (including Squeak Etoys, Scratch, Lively, Smalltalk VMs).</bio>
          <homepage_url>https://www.croquet.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vanessafreudenberg/846610a3-d712-4599-95cb-b259a0d51d2b/small.jpg</picture_url>
          <person_id>vanessafreudenberg</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6b29ee13-1e63-41cd-87b7-c76b3a95625d</subevent_id>
    <title>SAS: 10</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/20</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>a9f44810-f840-4aaf-b908-958b95d27bed</slot_id>
      <title>Session: SAS - 10</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ade687ad-8ef5-4fdd-b7eb-67e1b2215b28</slot_id>
      <event_id>887f15df-4810-48ff-86b1-91907513cccf</event_id>
      <title>Invited Talk</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>05:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Gogul</first_name>
          <last_name>Balakrishnan</last_name>
          <affiliation>Google</affiliation>
          <bio>I am a staff engineer at Google, where I work on using formal methods for privacy preserving AI. Until recently, I was working as part of the exciting Swift for TensorFlow project. Previously, I led a team that develops static analysis tools to improve the security of Android Apps. Before that I was an engineer at Facebook, and a research staff member in the Systems Analysis and Verification (SAV) group at NEC Laboratories America, Inc. I got my Ph.D in from the University of Wisconsin-Madison.</bio>
          <homepage_url>http://pages.cs.wisc.edu/~bgogul/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gogulbalakrishnan/7e9d2712-94c4-4da1-8fdb-a6203f61414d/small.jpg</picture_url>
          <person_id>gogulbalakrishnan</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0ab8aedf-90c3-4695-b4c5-34e5523bb10b</subevent_id>
    <title>SAS: 3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/18</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>adf975c2-8c9f-4c33-9ae1-9b9554e0a8b4</slot_id>
      <title>Session: SAS - 3</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>458a30b3-7c5e-4b97-87ec-78c2083c8739</slot_id>
      <event_id>d008d8aa-e072-4ded-bb28-92df9b4a75ab</event_id>
      <title>On Multi-Language Abstraction: Towards a Static Analysis of Multi-Language Programs</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>14:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Samuele</first_name>
          <last_name>Buro</last_name>
          <affiliation>Università degli Studi di Verona</affiliation>
          <bio>undefined</bio>
          <person_id>samueleburo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roy</first_name>
          <last_name>Crole</last_name>
          <affiliation>University of Leicester</affiliation>
          <bio>undefined</bio>
          <person_id>roycrole</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Isabella</first_name>
          <last_name>Mastroeni</last_name>
          <affiliation>University of Verona, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://profs.scienze.univr.it/mastroeni/Welcome.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/isabellamastroeni/35102ab8-17d3-49b9-8ae0-f3990cb799b5/small.jpg</picture_url>
          <person_id>isabellamastroeni</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6fa596e8-6e99-46f1-8874-1d865d1fa222</slot_id>
      <event_id>74b4eec7-f45e-46a4-915c-a2812474e966</event_id>
      <title>Exact and Linear-Time Gas-Cost Analysis</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>13:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ankush</first_name>
          <last_name>Das</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~ankushd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ankushdas/25c652a4-c4da-4eac-8520-4fa23d996157/small.jpg</picture_url>
          <person_id>ankushdas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shaz</first_name>
          <last_name>Qadeer</last_name>
          <affiliation>Facebook</affiliation>
          <bio>Shaz Qadeer has worked at Facebook, Microsoft, HP, and Compaq. He has studied at the University of California at Berkeley and the Indian Institute of Technology at Kanpur.</bio>
          <homepage_url>https://scholar.google.com/citations?user=EqIVfYcAAAAJ&amp;hl=en</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shazqadeer1/f224e8bb-da8c-4512-b63b-d56831c9f712/small.jpg</picture_url>
          <person_id>shazqadeer1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bd126cb0-6dda-4c11-ad4e-e1dd2976c290</slot_id>
      <event_id>3935655d-f3ff-4f44-8de9-a461cc25e8d1</event_id>
      <title>Python 3 Types in the Wild: A Tale of Two Type Systems</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>13:40</end_time>
      <description>Python 3 is a highly dynamic language, but it has introduced a syntax for expressing types with PEP484. This paper explores how developers use these type annotations, the type system semantics provided by type checking and inference tools, and the performance of these tools. We evaluate the types and tools on a corpus of public Github repositories. We review MyPy and PyType, two canonical static type checking and inference tools, and their distinct approaches to type analysis. We then address three research questions: (i) How often and in what ways do developers use Python 3 types? (ii) Which type errors do developers make? (iii) How do type errors from different tools compare?
Surprisingly, when developers use static types, the code rarely type-checks with either of the tools. MyPy and PyType exhibit false positives, due to their static nature, but also flag many useful errors in our corpus. Lastly, MyPy and PyType embody two distinct type systems, flagging different errors in many cases. Understanding the usage of Python types can help guide tool-builders and researchers. Understanding the performance of popular tools can help increase the adoption of static types and tools by practitioners, ultimately leading to more correct and more robust Python code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ingkarat</first_name>
          <last_name>Rak-amnouykit</last_name>
          <affiliation>Rensselaer Polytechnic Institute</affiliation>
          <bio>undefined</bio>
          <person_id>ingkaratrakamnouykit</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>McCrevan</last_name>
          <affiliation>Rensselaer Polytechnic Institute</affiliation>
          <bio>undefined</bio>
          <person_id>danielmccrevan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ana</first_name>
          <last_name>Milanova</last_name>
          <affiliation>Rensselaer Polytechnic Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.rpi.edu/~milanova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anamilanova/4fa9038c-d0e6-44ca-b1b7-2420329714f4/small.jpg</picture_url>
          <person_id>anamilanova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Martin</first_name>
          <last_name>Hirzel</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hirzels.com/martin/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/martinhirzel/8ffffeeb-b25c-4f90-b2e3-4949c2871a2a/small.jpg</picture_url>
          <person_id>martinhirzel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Julian</first_name>
          <last_name>Dolby</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-dolby</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juliandolby/092667c4-6e51-4476-8ef0-58b41ce9014d/small.jpg</picture_url>
          <person_id>juliandolby</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fc834762-aa54-42f7-b01d-b6f7a7b304fc</slot_id>
      <event_id>e665af34-4eeb-4601-96fd-e5aa138a4c64</event_id>
      <title>Wasm/k: Delimited Continuations for WebAssembly</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>14:20</end_time>
      <description>WebAssembly is designed to be an alternative to JavaScript that is a safe, portable, and efficient compilation target for a variety of languages. The performance of high-level languages depends not only on the underlying performance of WebAssembly, but also on the quality of the generated WebAssembly code. In this paper, we identify several features of high-level languages that current approaches can only compile to WebAssembly by generating complex and inefficient code. We argue that these problems could be addressed if WebAssembly natively supported first-class continuations. We then present Wasm/k, which extends WebAssembly with delimited continuations. Wasm/k introduces no new value types, and thus does not require significant changes to the WebAssembly type system (validation). Wasm/k is safe, even in the presence of foreign function calls (e.g., to and from JavaScript). Finally, Wasm/k is amenable to efficient implementation: we implement Wasm/k as a local change to Wasmtime, an existing WebAssembly JIT. We evaluate Wasm/k by implementing C/k, which adds delimited continuations to C/C++. C/k uses Emscripten and its implementation serves as a case study on how to use Wasm/k in a compiler that targets WebAssembly. We present several case studies using C/k, and show that on implementing green threads, it can outperform the state-of-the-art approach Asyncify with an 18% improvement in performance and a 30% improvement in code size.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Donald</first_name>
          <last_name>Pinckney</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Currently, I’m a computer science PhD student at Northeastern Univeristy, where I study programming languages and software engineering. However, I’m relatively new to Massachusetts, as I grew up for most of my life in California. For my undergraduate degree, I completed a double major in math and computer science at UC Davis. Meanwhile, I interned in industry for 3 summers, primarily at Apple, where I worked on the AppKit user interface library for macOS. After interning in industry I decided to pursue a PhD in computer science, and specifically programming languages, so I can work to drive the field forward in creating correct, safe, and secure software more easily.</bio>
          <homepage_url>https://donaldpinckney.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/donaldpinckney/90179ee6-31e2-4b13-8a6b-dddb6a1ec706/small.jpg</picture_url>
          <person_id>donaldpinckney</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Guha</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cics.umass.edu/~arjun</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjunguha/284e0782-ec24-4ad9-b6a4-b6a1d0e2fe9a/small.jpg</picture_url>
          <person_id>arjunguha</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yuriy</first_name>
          <last_name>Brun</last_name>
          <affiliation>University of Massachusetts at Amherst, USA</affiliation>
          <bio>My research is in software engineering. I am interested in improving our ability to build systems that are smart, and self-adapt to their environment. I am particularly interested in ensuring fairness in software systems. Watch a video describing my latest work on software fairness testing here: http://tinyurl.com/FairnessVideo</bio>
          <homepage_url>http://people.cs.umass.edu/~brun/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yuriybrun/15eff225-fb71-4b2c-9925-a0d731136238/small.jpg</picture_url>
          <person_id>yuriybrun</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>406657d0-5f8b-4a94-8172-d17fc3bf2b2d</subevent_id>
    <title>SAS: 5</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/18</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>f08b7def-94a1-416c-b258-358471b66c99</slot_id>
      <title>Session: SAS - 5</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1b0c8169-e5f5-4301-af7b-4d1acc1464b0</slot_id>
      <event_id>5013f5f6-0c92-406c-b516-126cc1c9f16c</event_id>
      <title>Pricing Python Parallelism: a Dynamic Language Cost Model for Heterogeneous Platforms</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>18:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>18:20</end_time>
      <description>Execution times may be reduced by offloading parallel loop nests to a GPU. Auto-parallelizing compilers are common for static languages, often using a cost model to determine when the GPU execution speed will outweigh the offload overheads. Nowadays scientific software is increasingly written in dynamic languages and would benefit from compute accelerators. The ALPyNA framework analyses moderately complex Python loop nests and automatically JIT compiles code for heterogeneous CPU and GPU architectures.
We present the first analytical cost model for auto-parallelizing loop nests in a dynamic language on heterogeneous architectures. Predicting execution time in a language like Python is extremely challenging, since aspects like the element types, size of the iteration space, and amenability to parallelization can only be determined at runtime. Hence the cost model must be both staged, to combine compile and run-time information, and lightweight to minimize runtime overhead. GPU execution time prediction must account for factors like data transfer, block-structured execution, and starvation.
We show that a comparatively simple, staged analytical model can accurately determine during execution when it is profitable to offload a loop nest. We evaluate our model on three heterogeneous platforms across 360 experiments with 12 loop-intensive Python benchmark programs. The results show small misprediction intervals and a mean slowdown of just 13.6%, relative to the optimal (oracular) offload strategy.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dejice</first_name>
          <last_name>Jacob</last_name>
          <affiliation>University of Glasgow, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~jacobd</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/dejicejacob/3f7c1cd4-c004-439f-a953-1389a8b68578/small.jpg</picture_url>
          <person_id>dejicejacob</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Phil</first_name>
          <last_name>Trinder</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~trinder/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philtrinder/fa2ffb07-cddf-4a8d-a52a-ca1aaad1273b/small.jpg</picture_url>
          <person_id>philtrinder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Singer</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~jsinger</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeremysinger/14db1542-37ba-4e0e-b338-e3a952991f1a/small.jpg</picture_url>
          <person_id>jeremysinger</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3bf82d53-7ac3-4551-a63a-7fa1666ee629</slot_id>
      <event_id>890ea906-b119-4828-8f45-d132f9c38082</event_id>
      <title>Abstract Neural Networks</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>17:20</end_time>
      <description>Deep Neural Networks (DNNs) are rapidly being applied to safety-critical domains such as drone and airplane control, motivating techniques for verifying the safety of their behavior. Unfortunately, DNN verification is NP-hard, with current algorithms slowing exponentially with the number of nodes in the DNN. This paper introduces the notion of Abstract Neural Networks (ANNs), which can be used to soundly overapproximate DNNs while using fewer nodes. An ANN is like a DNN except weight matrices are replaced by values in a given abstract domain. We present a framework parameterized by the abstract domain and activation functions used in the DNN that can be used to construct a corresponding ANN. We present necessary and sufficient conditions on the DNN activation functions for the constructed ANN to soundly over-approximate the given DNN. Prior work on DNN abstraction was restricted to the interval domain and ReLU activation function. Our framework can be instantiated with other abstract domains such as octagons and polyhedra, as well as other activation functions such as Leaky ReLU, Sigmoid, and Hyperbolic Tangent.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Sotoudeh</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://masot.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthewsotoudeh/32b819f5-05ef-4b0a-8a19-d59eed661278/small.jpg</picture_url>
          <person_id>matthewsotoudeh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aditya V.</first_name>
          <last_name>Thakur</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://thakur.cs.ucdavis.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adityavthakur/89eb0287-7273-4261-b8a5-47ccfc8799b0/small.jpg</picture_url>
          <person_id>adityavthakur</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>dbdc6a65-7df8-4ce3-9a5f-d947e28a4a75</slot_id>
      <event_id>179704f8-cb35-4d44-8ef9-ea437c436204</event_id>
      <title>Amalgamating Different JIT Compilations in a Meta-tracing JIT Compiler Framework</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>17:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>17:40</end_time>
      <description>Most virtual machines employ just-in-time (JIT) compilers to achieve their high-performance. Trace-based compilation and method-based compilation are two major compilation strategies in JIT compilers. In general, the former excels in compiling programs with more in-depth method calls and more dynamic branches, while the latter is suitable for a wide range of programs. Some previous studies have suggested that each strategy has its advantages and disadvantages, and there is no clear winner.
In this paper, we present a new approach, namely, the meta-hybrid JIT compilation strategy. It combines trace-based and method-based compilations to utilize the advantages of both strategies. Moreover, it is realized as a meta JIT compiler framework; thus, we can generate a VM with a hybrid JIT compiler that can apply different program parts by merely writing an interpreter with our framework.
We chose to extend a meta-tracing JIT compiler and supported the two compilations on it. As a prototype, we implemented a simple meta-tracing JIT compiler framework called BacCaml based on the MinCaml compiler by following RPython’s architecture.
We evaluated its performance by creating a small functional programming language with BacCaml and running microbenchmark programs. Furthermore, we performed a synthetic experiment to confirm that there are programs that run faster by hybrid compilation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yusuke</first_name>
          <last_name>Izawa</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://3tty0n.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yusukeizawa/2d1131a1-4abb-4ade-9761-e3d2648bd9f5/small.jpg</picture_url>
          <person_id>yusukeizawa</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hidehiko</first_name>
          <last_name>Masuhara</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>Hidehiko Masuhara is a Professor of Mathematical and Computing Science, Tokyo Institute of Technology since April 2013. He received his B.S., M.S., and Ph.D. in Computer Science from Department of Information Science, University of Tokyo in 1992, 1994, and 1999, respectively, and served as an assistant professor, lecturer, and associate professor at Graphics and Computer Science, Graduate School of Arts and Sciences, University of Tokyo from 1995 until 2013.</bio>
          <homepage_url>http://prg.is.titech.ac.jp/people/masuhara/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hidehikomasuhara/3ea94269-6fb5-4c6d-8d6f-0435717377d6/small.jpg</picture_url>
          <person_id>hidehikomasuhara</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fcfa6794-c3c5-4a25-92f8-6a7eb65ca070</slot_id>
      <event_id>5360324a-7234-4b20-95d8-80639f65ad7a</event_id>
      <title>Probabilistic Lipschitz Analysis of Neural Networks</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>17:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>18:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ravi</first_name>
          <last_name>Mangal</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cc.gatech.edu/~rmangal3/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ravimangal/a3129793-a42b-47f4-8195-79800685503e/small.jpg</picture_url>
          <person_id>ravimangal</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kartik</first_name>
          <last_name>Sarangmath</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>kartiksarangmath</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aditya</first_name>
          <last_name>Nori</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>adityanori</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Alessandro</first_name>
          <last_name>Orso</last_name>
          <affiliation>Georgia Tech</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cc.gatech.edu/~orso/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alessandroorso/5f7dffa8-54ca-4f1e-84f0-1f1a9affbf55/small.jpg</picture_url>
          <person_id>alessandroorso</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ceb1318a-f724-444a-b7cd-32491a8a5ce8</subevent_id>
    <title>SAS: 3</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>2404923b-a6a6-4b98-9f20-85e94d0fba3c</slot_id>
      <title>Session: SAS - 3</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>170cd952-feec-43f0-afe6-2ce7adf3fbb3</slot_id>
      <event_id>3935655d-f3ff-4f44-8de9-a461cc25e8d1</event_id>
      <title>Python 3 Types in the Wild: A Tale of Two Type Systems</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>01:40</end_time>
      <description>Python 3 is a highly dynamic language, but it has introduced a syntax for expressing types with PEP484. This paper explores how developers use these type annotations, the type system semantics provided by type checking and inference tools, and the performance of these tools. We evaluate the types and tools on a corpus of public Github repositories. We review MyPy and PyType, two canonical static type checking and inference tools, and their distinct approaches to type analysis. We then address three research questions: (i) How often and in what ways do developers use Python 3 types? (ii) Which type errors do developers make? (iii) How do type errors from different tools compare?
Surprisingly, when developers use static types, the code rarely type-checks with either of the tools. MyPy and PyType exhibit false positives, due to their static nature, but also flag many useful errors in our corpus. Lastly, MyPy and PyType embody two distinct type systems, flagging different errors in many cases. Understanding the usage of Python types can help guide tool-builders and researchers. Understanding the performance of popular tools can help increase the adoption of static types and tools by practitioners, ultimately leading to more correct and more robust Python code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ingkarat</first_name>
          <last_name>Rak-amnouykit</last_name>
          <affiliation>Rensselaer Polytechnic Institute</affiliation>
          <bio>undefined</bio>
          <person_id>ingkaratrakamnouykit</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>McCrevan</last_name>
          <affiliation>Rensselaer Polytechnic Institute</affiliation>
          <bio>undefined</bio>
          <person_id>danielmccrevan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ana</first_name>
          <last_name>Milanova</last_name>
          <affiliation>Rensselaer Polytechnic Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.rpi.edu/~milanova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anamilanova/4fa9038c-d0e6-44ca-b1b7-2420329714f4/small.jpg</picture_url>
          <person_id>anamilanova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Martin</first_name>
          <last_name>Hirzel</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hirzels.com/martin/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/martinhirzel/8ffffeeb-b25c-4f90-b2e3-4949c2871a2a/small.jpg</picture_url>
          <person_id>martinhirzel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Julian</first_name>
          <last_name>Dolby</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-dolby</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juliandolby/092667c4-6e51-4476-8ef0-58b41ce9014d/small.jpg</picture_url>
          <person_id>juliandolby</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>327f8696-c675-40b0-b105-65b5c4663a54</slot_id>
      <event_id>d008d8aa-e072-4ded-bb28-92df9b4a75ab</event_id>
      <title>On Multi-Language Abstraction: Towards a Static Analysis of Multi-Language Programs</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>02:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Samuele</first_name>
          <last_name>Buro</last_name>
          <affiliation>Università degli Studi di Verona</affiliation>
          <bio>undefined</bio>
          <person_id>samueleburo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roy</first_name>
          <last_name>Crole</last_name>
          <affiliation>University of Leicester</affiliation>
          <bio>undefined</bio>
          <person_id>roycrole</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Isabella</first_name>
          <last_name>Mastroeni</last_name>
          <affiliation>University of Verona, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://profs.scienze.univr.it/mastroeni/Welcome.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/isabellamastroeni/35102ab8-17d3-49b9-8ae0-f3990cb799b5/small.jpg</picture_url>
          <person_id>isabellamastroeni</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>522632c8-9aef-4df9-a493-dc19ed15e0dd</slot_id>
      <event_id>e665af34-4eeb-4601-96fd-e5aa138a4c64</event_id>
      <title>Wasm/k: Delimited Continuations for WebAssembly</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>02:20</end_time>
      <description>WebAssembly is designed to be an alternative to JavaScript that is a safe, portable, and efficient compilation target for a variety of languages. The performance of high-level languages depends not only on the underlying performance of WebAssembly, but also on the quality of the generated WebAssembly code. In this paper, we identify several features of high-level languages that current approaches can only compile to WebAssembly by generating complex and inefficient code. We argue that these problems could be addressed if WebAssembly natively supported first-class continuations. We then present Wasm/k, which extends WebAssembly with delimited continuations. Wasm/k introduces no new value types, and thus does not require significant changes to the WebAssembly type system (validation). Wasm/k is safe, even in the presence of foreign function calls (e.g., to and from JavaScript). Finally, Wasm/k is amenable to efficient implementation: we implement Wasm/k as a local change to Wasmtime, an existing WebAssembly JIT. We evaluate Wasm/k by implementing C/k, which adds delimited continuations to C/C++. C/k uses Emscripten and its implementation serves as a case study on how to use Wasm/k in a compiler that targets WebAssembly. We present several case studies using C/k, and show that on implementing green threads, it can outperform the state-of-the-art approach Asyncify with an 18% improvement in performance and a 30% improvement in code size.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Donald</first_name>
          <last_name>Pinckney</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Currently, I’m a computer science PhD student at Northeastern Univeristy, where I study programming languages and software engineering. However, I’m relatively new to Massachusetts, as I grew up for most of my life in California. For my undergraduate degree, I completed a double major in math and computer science at UC Davis. Meanwhile, I interned in industry for 3 summers, primarily at Apple, where I worked on the AppKit user interface library for macOS. After interning in industry I decided to pursue a PhD in computer science, and specifically programming languages, so I can work to drive the field forward in creating correct, safe, and secure software more easily.</bio>
          <homepage_url>https://donaldpinckney.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/donaldpinckney/90179ee6-31e2-4b13-8a6b-dddb6a1ec706/small.jpg</picture_url>
          <person_id>donaldpinckney</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Guha</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cics.umass.edu/~arjun</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjunguha/284e0782-ec24-4ad9-b6a4-b6a1d0e2fe9a/small.jpg</picture_url>
          <person_id>arjunguha</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yuriy</first_name>
          <last_name>Brun</last_name>
          <affiliation>University of Massachusetts at Amherst, USA</affiliation>
          <bio>My research is in software engineering. I am interested in improving our ability to build systems that are smart, and self-adapt to their environment. I am particularly interested in ensuring fairness in software systems. Watch a video describing my latest work on software fairness testing here: http://tinyurl.com/FairnessVideo</bio>
          <homepage_url>http://people.cs.umass.edu/~brun/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yuriybrun/15eff225-fb71-4b2c-9925-a0d731136238/small.jpg</picture_url>
          <person_id>yuriybrun</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>904d8b77-4ab4-4047-80cf-5a5963930872</slot_id>
      <event_id>74b4eec7-f45e-46a4-915c-a2812474e966</event_id>
      <title>Exact and Linear-Time Gas-Cost Analysis</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>01:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ankush</first_name>
          <last_name>Das</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~ankushd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ankushdas/25c652a4-c4da-4eac-8520-4fa23d996157/small.jpg</picture_url>
          <person_id>ankushdas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shaz</first_name>
          <last_name>Qadeer</last_name>
          <affiliation>Facebook</affiliation>
          <bio>Shaz Qadeer has worked at Facebook, Microsoft, HP, and Compaq. He has studied at the University of California at Berkeley and the Indian Institute of Technology at Kanpur.</bio>
          <homepage_url>https://scholar.google.com/citations?user=EqIVfYcAAAAJ&amp;hl=en</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shazqadeer1/f224e8bb-da8c-4512-b63b-d56831c9f712/small.jpg</picture_url>
          <person_id>shazqadeer1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b52c17f9-95a7-44df-a670-3c3109c47088</subevent_id>
    <title>SAS: 7</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>1cbf45c2-1f1b-4229-9213-fd2e7e187277</slot_id>
      <title>Session: SAS - 7</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>653d4359-4ce0-4d5c-8eee-f3d400bd008a</slot_id>
      <event_id>76914a82-f0e1-4d78-8093-7ea5ce50bb37</event_id>
      <title>DelayRepay: Delayed Execution for Kernel Fusion in Python</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>23:40</end_time>
      <description>Python is a popular, dynamic language for data science and scientific computing. To ensure efficiency, significant numerical libraries are implemented in static native languages. However, performance suffers when switching between native and non-native code, especially if data has to be converted between native arrays and Python data structures. As GPU accelerators are increasingly used, this problem becomes particularly acute. Data and control has to be repeatedly transferred between the accelerator and the host.
In this paper, we present DelayRepay, a delayed execution framework for numeric Python programs. It avoids excessive switching and data transfer by using lazy evaluation and kernel fusion. Using DelayRepay, operations on NumPy arrays are executed lazily, allowing multiple calls to accelerator kernels to be fused together dynamically. DelayRepay is available as a drop-in replacement for existing Python libraries. This approach enables significant performance improvement over the state-of-the-art and is invisible to the application programmer. We show that our approach provides an average $24\times$ speedup over NumPy - a 60% increase over the state of the art.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John Magnus</first_name>
          <last_name>Morton</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>johnmagnusmorton</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kuba</first_name>
          <last_name>Kaszyk</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>kubakaszyk</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Lu</first_name>
          <last_name>Li</last_name>
          <affiliation>Linköping University</affiliation>
          <bio>undefined</bio>
          <person_id>luli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jiawen</first_name>
          <last_name>Sun</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>jiawensun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Christophe</first_name>
          <last_name>Dubach</last_name>
          <affiliation>McGill University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/cdubach/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/christophedubach/dc7b0040-a3ef-46dd-b4f3-0f0ea3b2b026/small.jpg</picture_url>
          <person_id>christophedubach</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Michel</first_name>
          <last_name>Steuwer</last_name>
          <affiliation>The University of Edinburgh</affiliation>
          <bio>I am a lecturer (assistant professor) in compilers and runtime systems in the School of Informatics at the University of Edinburgh in Scotland. I am a member of the Compiler and Architecture Design Group (CArD), the Institute for Computing Systems Architecture (ICSA), and a visiting member of staff at the School of Computing Science at the University of Glasgow.
Before joining the faculty in Edinburgh I was a lecturer in the School of Computing Science at the University of Glasgow. Prior to that, I was a postdoctoral researcher at the School of Informatics at the University of Edinburgh. I received my PhD from the University of Münster in Germany.
I am interested in all aspects of parallel programming. Particular research interests of mine include performance portability, structured parallel programming, heterogeneous and GPU computing, and novel compilation techniques for high-level languages.</bio>
          <homepage_url>http://michel.steuwer.info/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michelsteuwer/5a465be6-d235-472c-8ace-4894a70bb742/small.jpg</picture_url>
          <person_id>michelsteuwer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Murray</first_name>
          <last_name>Cole</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <person_id>murraycole</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Michael</first_name>
          <last_name>O'Boyle</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>michaeloboyle</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b801108b-784f-46cd-9f41-63e427054a50</slot_id>
      <event_id>d282d18e-5f62-43fb-b68c-eb3bf99afa68</event_id>
      <title>Sampling Optimized Code for Type Feedback</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>00:20</end_time>
      <description>To efficiently execute dynamically typed languages, many language implementations have adopted a two-tier architecture. The first tier aims for low-latency startup times and collects dynamic profiles, such as the types of every program variable. The second tier provides high-throughput using an optimizing compiler that specializes code to the recorded type information. If the program behavior changes to the point that not previously seen types occur in specialized code, that specialized code becomes invalid, it is deoptimized, and control is transferred back to the first tier execution engine which will start specializing anew. However, if the program behavior becomes more specific, for instance, if a variable that was recorded as holding values of many types becomes monomorphic, no deoptimization will be triggered. Once the program is running optimized code, there are no means to notice that an opportunity for optimization has been missed or to restart specialization.
We propose to employ a sampling-based profiler to monitor native code without any instrumentation. The absence of instrumentation means that when the profiler is not active, no overhead is incurred. When the profiler is active, the overhead can be controlled by limiting the sampling rate. Our implementation is in the context of the Ř just-in-time, optimizing, compiler for the R language. Based on the sampled profiles, we are able to detect when the native code produced by Ř is specialized for stale type feedback and recompile it to more type-specific code. We show that recording in our profiler adds an overhead of less than 3% in most cases and up to 9% in few cases when engaged and that it reliably detects stale type feedback within milliseconds.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Flückiger</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.o1o.ch</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/olivierfluckiger/6051271d-0eac-48f3-b931-bff878bbce61/small.jpg</picture_url>
          <person_id>olivierfluckiger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Wälchli</last_name>
          <affiliation>University of Bern</affiliation>
          <bio>undefined</bio>
          <person_id>andreaswalchli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sebastián</first_name>
          <last_name>Krynski</last_name>
          <affiliation>Czech Technical University, National University of Quilmes</affiliation>
          <bio>undefined</bio>
          <person_id>sebastiankrynski</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bc979c2a-78e6-443b-91ac-835e82a1389a</slot_id>
      <event_id>932e180e-dfa8-48ee-bea1-99cedf469770</event_id>
      <title>Interprocedural Shape Analysis Using Separation Logic-based Transformer Summaries</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>23:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hugo</first_name>
          <last_name>Illous</last_name>
          <affiliation>CEA &amp; INRIA / ENS Paris</affiliation>
          <bio>undefined</bio>
          <person_id>hugoillous</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthieu</first_name>
          <last_name>Lemerre</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>matthieulemerre</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xavier</first_name>
          <last_name>Rival</last_name>
          <affiliation>INRIA/CNRS/ENS Paris</affiliation>
          <bio>Xavier Rival is a Senior Research Scientist (Directeur de Recherche) at INRIA Paris. His research interest focus on abstract interpretation and software verification by static analysis. He is mainly working on symbolic abstractions (trace partitionning abstraction, shape analysis, separation logic and memory abstract domains). He has been involved in the design, implementation and transfer of the Astrée analyser, a static analyser able to verify safety properties on industrial size safety critical softwares. He is currently the PI of the MemCAD ERC Starting Grant, aiming at the design of a library of abstract domains to describe memory states containing a wide range of complex data structures. He is also the Head of the ANTIQUE INRIA group, located at ENS Paris, and Professeur Chargé de Cours at Ecole Polytechnique.</bio>
          <homepage_url>http://www.di.ens.fr/~rival/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xavierrival/036511d0-47a1-4db2-97df-0bf5da1a2c8d/small.jpg</picture_url>
          <person_id>xavierrival</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f365cc3d-f750-4d4b-994e-d360451b267d</slot_id>
      <event_id>e3e14325-c529-4426-a059-6ef122bc4c43</event_id>
      <title>Stratified Guarded First-order Transition Systems</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>00:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christian</first_name>
          <last_name>Müller</last_name>
          <affiliation>Technical University of Munich</affiliation>
          <bio>undefined</bio>
          <person_id>christianmuller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Helmut</first_name>
          <last_name>Seidl</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www2.in.tum.de/~seidl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/helmutseidl/2dcd593b-82c2-48ee-b042-87ebd49b4379/small.jpg</picture_url>
          <person_id>helmutseidl</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5d15614c-7cb1-4fce-81a2-7d7dccbba6f2</subevent_id>
    <title>SAS: 4</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/19</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>afc5939d-da85-433a-8453-ebbead43e756</slot_id>
      <title>Session: SAS - 4</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2c9a5e27-bc34-4cf2-b4e5-27e566f654ae</slot_id>
      <event_id>60869a0f-9da8-4a93-9b8e-4d4adbc8ef13</event_id>
      <title>Memory-Efficient Fixpoint Computation</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>03:20</end_time>
      <description>Practical adoption of static analysis often requires trading precision for performance. This paper focuses on improving the memory efficiency of abstract interpretation without sacrificing precision or time efficiency. Computationally, abstract interpretation reduces the problem of inferring program invariants to computing a fixpoint of a set of equations. This paper presents a method to minimize the memory footprint in Bourdoncle’s iteration strategy, a widely-used technique for fixpoint computation. Our technique is agnostic to the abstract domain used. We prove that our technique is optimal (i.e., it results in minimum memory footprint) for Bourdoncle’s iteration strategy while computing the same result. We evaluate the efficacy of our technique by implementing it in a tool called MIKOS, which extends the state-of-the-art abstract interpreter IKOS. When verifying user-provided assertions, MIKOS shows a decrease in peak-memory usage to 4.07% (24.57x) on average compared to IKOS. When performing interprocedural buffer-overflow analysis, MIKOS shows a decrease in peak-memory usage to 43.7% (2.29x) on average compared to IKOS.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sung</first_name>
          <last_name>Kook Kim</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>sungkookkim</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Arnaud J.</first_name>
          <last_name>Venet</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>arnaudjvenet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aditya V.</first_name>
          <last_name>Thakur</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://thakur.cs.ucdavis.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adityavthakur/89eb0287-7273-4261-b8a5-47ccfc8799b0/small.jpg</picture_url>
          <person_id>adityavthakur</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6c2e5501-13d0-42c4-8796-57a411c6fa21</slot_id>
      <event_id>ce3e05fe-bed4-4c6e-8f2f-3ec96e59bf13</event_id>
      <title>Dynamic Pattern Matching with Python</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>03:40</end_time>
      <description>Pattern matching allows programs both to extract specific information from complex data types, as well as to branch on the structure of data and thus apply specialized actions to different forms of data. Originally designed for strongly typed functional languages with algebraic data types, pattern matching has since been adapted for object-oriented and even dynamic languages. This paper discusses how pattern matching can be included in the dynamically typed language Python in line with existing features that support extracting values from sequential data structures.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Kohn</last_name>
          <affiliation>University of Cambridge, UK</affiliation>
          <bio>undefined</bio>
          <person_id>tobiaskohn</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guido</first_name>
          <last_name>van Rossum</last_name>
          <affiliation>Python Software Foundation</affiliation>
          <bio>undefined</bio>
          <person_id>guidovanrossum</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gary Brandt</first_name>
          <last_name>Bucher, II</last_name>
          <affiliation>Research Affiliates, LLC</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://brandtbucher.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/garybrandtbucherii/4d2da008-7dca-4c6f-805b-65214288ada8/small.jpg</picture_url>
          <person_id>garybrandtbucherii</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>undefined</first_name>
          <last_name>Talin</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>talin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Levkivskyi</last_name>
          <affiliation>Dropbox Ireland</affiliation>
          <bio>undefined</bio>
          <person_id>ivanlevkivskyi</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d6cf4501-816d-4640-b1cb-d57ee4d6d475</slot_id>
      <event_id>b5f8101e-f7bf-45b0-98cf-165cd7531f05</event_id>
      <title>Sound, Heuristic Type Annotation Inference For Ruby</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>04:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>04:20</end_time>
      <description>Many researchers have explored retrofitting static type systems to dynamic languages. This raises the question of how to add type annotations to code that was previously untyped. One obvious solution is type inference. However, in complex type systems, in particular those with structural types, type inference typically produces most general types that are large, hard to understand, and unnatural for programmers. To solve this problem, we introduce InferDL, a novel Ruby type inference system that infers sound and useful type annotations by incorporating heuristics that guess types. For example, we might heuristically guess that a parameter whose name ends in “count” is an integer. InferDL works by first running standard type inference, and then applying heuristics to any positions for which standard type inference produces overly-general types. Heuristic guesses are added as constraints to the type inference problem to ensure they are consistent with the rest of the program and other heuristic guesses; inconsistent guesses are discarded. We formalized InferDL in a core type and constraint language. We implemented InferDL on top of RDL, an existing Ruby type checker. To evaluate InferDL, we applied it to four Ruby on Rails apps that had been previously type checked with RDL, and hence had type annotations. We found that, when using heuristics, InferDL inferred 22% more types that were as or more precise than the previous annotations, compared to standard type inference without heuristics. We also found one new type error. We further evaluated InferDL by applying it to six additional apps, finding five additional type errors. Thus, we believe InferDL represents a promising approach for inferring type annotations in dynamic languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Milod</first_name>
          <last_name>Kazerounian</last_name>
          <affiliation>University of Maryland, College Park</affiliation>
          <bio>undefined</bio>
          <person_id>milodkazerounian1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Brianna M.</first_name>
          <last_name>Ren</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
          <person_id>briannamren</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jeffrey S.</first_name>
          <last_name>Foster</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.tufts.edu/~jfoster/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeffreysfoster/b22ce952-32b0-48bd-be56-12fd87bf3469/small.jpg</picture_url>
          <person_id>jeffreysfoster</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f1c964b9-9190-4a42-9d05-b112a3996fc2</slot_id>
      <event_id>5e5d5e27-4f5e-4ec9-be96-5f1f0a5bfe96</event_id>
      <title>Simple and Efficient Computation of Minimal Weak Control Closure</title>
      <room>Online | SPLASH</room>
      <date>2020/11/19</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>04:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abu Naser</first_name>
          <last_name>Masud</last_name>
          <affiliation>Malardalen University</affiliation>
          <bio>undefined</bio>
          <person_id>abunasermasud</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ced79737-c6d5-4061-a938-8ca960644a52</subevent_id>
    <title>SAS: Tool environments</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/18</date>
    <url>https://conf.researchr.org/home/sas-2020</url>
    <url_link_display>SAS 2020 - 27th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2020 - 27th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>3f8e8aff-c9cd-49b5-b5a8-168af79d0f09</slot_id>
      <title>Session: SAS - Tool environments</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>19:00</start_time>
      <end_time>20:00</end_time>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c022ecf0-309b-49a6-860a-fa41b7479b8e</slot_id>
      <event_id>96776028-772c-4c12-bdda-eb5721127c2c</event_id>
      <title>A Library Modeling Language for the Static Analysis of C Programs</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>19:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>20:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abdelraouf</first_name>
          <last_name>Ouadjaout</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~ouadjaout/</homepage_url>
          <person_id>abdelraoufouadjaout</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Miné</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~mine/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/antoinemine/77e18473-3b05-4bec-8b27-3e073a24fb34/small.jpg</picture_url>
          <person_id>antoinemine</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ecba2904-73db-4b85-966d-5c9a3adf8ec5</slot_id>
      <event_id>ae38a637-3b97-4277-a496-2c1f2d2c6a6b</event_id>
      <title>Invited Talk: Cost Analysis of Smart Contracts via Parametric Resource Analysis</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>19:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Hermenegildo</last_name>
          <affiliation>IMDEA Software Institute and T.U. of Madrid</affiliation>
          <bio>Manuel Hermenegildo is Distinguished Professor at (and was the Founding Director of) the IMDEA Software Institute. He is also full Prof. of Computer Science at the Tech. U. of Madrid, UPM. Previously he held an Endowed Chair in Information Science and Technology at the U. of New Mexico. He was also project leader at the MCC research center and Adjunct Associate Prof. at the CS Department of the U. of Texas, both in Austin, Texas. See his home page for more information.
Research interests: Energy-Aware Computing, Resource / non-functional property analysis, verification, and control; Global Program Analysis, Optimization, Verification, Debugging; Abstract Interpretation; Partial Evaluation; Parallelism and Parallelizing Compilers; Constraint/Logic/Functional Programming Theory and Implementation, Abstract Machines; Automatic Documentation Tools, Execution Visualization; Sequential and Parallel Computer Architecture.</bio>
          <homepage_url>http://cliplab.org/herme</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelhermengildo/9ad5b1a1-5b09-4700-a372-66f4683bb674/small.jpg</picture_url>
          <person_id>manuelhermengildo</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2020 - 27th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a69d48a6-0cf3-4308-a04e-93f73af48d7d</subevent_id>
    <title>SPLASH REBASE: 9</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>8f57c2d3-ab83-48fa-8b92-2816ffb64ccc</slot_id>
      <title>Session: SPLASH REBASE - 9</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>15:00</start_time>
      <end_time>15:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0c7c6168-61e9-40ba-b602-36af3dca504e</slot_id>
      <event_id>d0422a7b-b071-4c38-901b-e817df74486e</event_id>
      <title>Non-local compiler transformations in the presence of dynamic dispatch</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>15:40</end_time>
      <description>Non-local, semantic compiler transformations such as Automatic Differentiation and certain Bayesian Inference algorithms pose particular challenges for dynamic dispatch systems, where non-local information may not necessarily be computable at compile time. In this talk, I will describe how we approach these problems in Julia while retaining performance scalability all the way from completely dynamic information situations to the semi-static case. Along the way, I will introduce optical constructions, a recent result from Category Theory that provides a useful guide when choosing abstractions for this class of transformations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Keno</first_name>
          <last_name>Fischer</last_name>
          <affiliation>Julia Computing</affiliation>
          <bio>Keno Fischer is a core developer of the Julia programming language and co-founder and CTO at Julia Computing. Keno has been working on Julia for most of the past 8 years, contributing major parts of the compiler, REPL and binary package management infrastructure, as well as the Julia Machine Learning stack. In his research, Keno likes to push the boundaries of possibilities for programming systems, from exascale computation to practical systems for homomorphic encryption. Keno holds an AM degree in Physics from Harvard University and was recognized by Forbes as one of their “30 under 30”.</bio>
          <homepage_url>https://github.com/Keno</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/kenofischer/b110c2b1-0ad1-4469-8459-5f667861d8ea/small.jpg</picture_url>
          <person_id>kenofischer</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8421eb0c-28c9-4d01-82f5-876f9fc7b5a5</subevent_id>
    <title>SPLASH REBASE: 26</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>60400f54-1c96-46ca-831f-9097e37ab7b0</slot_id>
      <title>Session: SPLASH REBASE - 26</title>
      <room>Online | Rebase</room>
      <date>2020/11/20</date>
      <start_time>07:00</start_time>
      <end_time>07:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9cbd97a6-a957-43c2-887f-b13d1b9d17f3</slot_id>
      <event_id>59a73831-882e-4229-b00a-9f8b357d17b3</event_id>
      <title>PL and HCI: Better Together</title>
      <room>Online | Rebase</room>
      <date>2020/11/20</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>07:40</end_time>
      <description>Programming Languages (PL), Human-Computer Interaction (HCI), and Software Engineering (SE) have a key overlapping interest: getting computers to do what we want. Each field has a different balance of methods and beneficiaries, from novice programmers to professional programmers. This talk will highlight the overlaps between HCI and PL, a powerful but under-explored pairing with much mutual benefit. HCI is concerned with creating new ways of interacting with computers and using computers to enhance human-to-human interaction, as well as studying how existing systems impact individuals and society. PL is concerned with the theory, design, and implementation of programming languages, program analyses, and program transformations. I will highlight several existing systems that demonstrate how PL and HCI are better together, as well as dispel common misconceptions and lay out some promising future research directions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Elena</first_name>
          <last_name>Glassman</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>Elena Glassman is a the Stanley A. Marks and William H. Marks Assistant Professor at the Radcliffe Institute and a professor of computer science at the Harvard Paulson School of Engineering and Applied Sciences specializing in human-computer interaction. She designs, builds and evaluates systems for comprehending and interacting with intelligent systems and population-level structure in large code and data corpora. Prior to joining Harvard as an assistant professor, Glassman earned BS, MEng and PhD degrees from MIT EECS and served as a postdoctoral scholar at the University of California, Berkeley EECS department and Berkeley Institute for Design.</bio>
          <homepage_url>http://glassmanlab.seas.harvard.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elenaglassman/4951972c-4212-4bfb-9e7a-bdaefbf84466/small.jpg</picture_url>
          <person_id>elenaglassman</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3599907a-19ab-403d-8bfd-f893298ed9ed</subevent_id>
    <title>SPLASH REBASE: 20</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>9259d6c8-7044-4f36-909a-b0456839430e</slot_id>
      <title>Session: SPLASH REBASE - 20</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>05:00</start_time>
      <end_time>05:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9bfe5752-2b1f-4abf-8e92-4258c1edfceb</slot_id>
      <event_id>4b457c84-3b99-44ca-afaa-f1811e462b6e</event_id>
      <title>Tales from the Frontlines: Startup War Stories</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>05:40</end_time>
      <description>Can one build the Hotspot VM, the Azul GC and the H20 big data engine without getting into the occasional battle and making a mistake or two? This talk distill the lessons of success and wrings wisdom out of failures over three decades in the industy.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cliff</first_name>
          <last_name>Click</last_name>
          <affiliation>Self</affiliation>
          <bio>Cliff Click was the CTO and Co-Founder of H2O, makers of H2O, the open source math and machine learning engine for Big Data. Cliff wrote his first compiler when he was 15 (Pascal to TRS Z-80!), although Cliff’s most famous compiler is the HotSpot Server Compiler (the Sea of Nodes IR). Cliff helped Azul Systems build an 864 core pure-Java mainframe that keeps GC pauses on 500Gb heaps to under 10ms, and worked on all aspects of that JVM. Before that he worked on HotSpot at Sun Microsystems, and was at least partially responsible for bringing Java into the mainstream. Cliff is invited to speak regularly at industry and academic conferences and has published many papers about HotSpot technology. He holds a PhD in Computer Science from Rice University and about 20 patents.</bio>
          <homepage_url>http://cliffc.org/blog/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cliffclick/73d11404-ae6e-4004-80e3-b75f7f40656b/small.jpg</picture_url>
          <person_id>cliffclick</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4056e5e5-b63a-4214-855e-0ecb3e3f036e</subevent_id>
    <title>SPLASH REBASE: 23</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>36c4cfb1-2744-4b82-8315-ecbcec27ea32</slot_id>
      <title>Session: SPLASH REBASE - 23</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>13:00</start_time>
      <end_time>13:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3f72c1b4-7266-42ce-86df-c4eb3a1d87cf</slot_id>
      <event_id>be69fb05-2d8f-41eb-9a0b-aa5c1cb43a59</event_id>
      <title>JAX: accelerated machine learning research via composable function transformations in Python</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>13:40</end_time>
      <description>JAX is a system for high-performance machine learning research and numerical computing. It offers the familiarity of Python+NumPy together with hardware acceleration, and it enables the definition and composition of user-wielded function transformations useful for machine learning programs. These transformations include automatic differentiation, automatic batching, end-to-end compilation (via XLA), parallelizing over multiple accelerators, and more. Composing these transformations is the key to JAX’s power and simplicity.
JAX had its initial open-source release in December 2018 (https://github.com/google/jax). It’s used by researchers for a wide range of advanced applications, from studying training dynamics of neural networks, to probabilistic programming, to scientific applications in physics and biology.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Johnson</last_name>
          <affiliation>Google Brain</affiliation>
          <bio>Matt Johnson is a research scientist at Google Brain interested in software systems powering machine learning research. When moonlighting as a machine learning researcher, he works on composing graphical models with neural networks, automatically recognizing and exploiting conjugacy structure, and model-based reinforcement learning from pixels. Matt was a postdoc with Ryan Adams at the Harvard Intelligent Probabilistic Systems Group and Bob Datta in the Datta Lab at the Harvard Medical School. His Ph.D. is from MIT in EECS, where he worked with Alan Willsky on Bayesian time series models and scalable inference. He was an undergrad at UC Berkeley (Go Bears!).</bio>
          <homepage_url>https://people.csail.mit.edu/mattjj/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthewjohnson/c8772aa1-ea44-4d16-a4a1-bf5aafd05f76/small.jpg</picture_url>
          <person_id>matthewjohnson</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>454040ec-b762-40dd-952a-37dcd52ed332</subevent_id>
    <title>SPLASH REBASE: 19</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>2a2a28ad-4287-4066-92af-b5c9facd9bd3</slot_id>
      <title>Session: SPLASH REBASE - 19</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>15:00</start_time>
      <end_time>15:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>74cb04d6-7167-4a52-83e8-f2e4a62ceafe</slot_id>
      <event_id>f3ec9a74-d5ee-4008-9430-ff52af55c713</event_id>
      <title>Speculation in Smart Contracts</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>15:40</end_time>
      <description>A smart contract is a script that controls the transfer of electronic assets within a distributed ledger. Existing smart contract architectures suffer from a bottleneck problem: contract calls place arbitrary user code right in the ledger’s critical path, so relatively complex contract executions delay processing for all transactions, especially simple payments and transfers that could otherwise be cleared quickly. This talk describes an alternative smart contract architecture that executes user code speculatively off the blockchain’s critical path. A secure committee validates and votes on each such computation, certifying the computation’s preconditions and its effects, and forwarding the certified results to a different committee controlling the blockchain. The paper focuses on the authors’ experience integrating this smart contract architecture with an existing commercial blockchain and an existing language virtual machine.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Maurice</first_name>
          <last_name>Herlihy</last_name>
          <affiliation>Brown University</affiliation>
          <bio>Maurice Herlihy has an A.B. in Mathematics from Harvard University, and a Ph.D. in Computer Science from M.I.T. He has served on the faculty of Carnegie Mellon University and the staff of DEC Cambridge Research Lab. He is the recipient of the 2003 Dijkstra Prize in Distributed Computing, the 2004 Gödel Prize in theoretical computer science, the 2008 ISCA influential paper award, the 2012 Edsger W. Dijkstra Prize, and the 2013 Wallace McDowell award. He received a 2012 Fulbright Distinguished Chair in the Natural Sciences and Engineering Lecturing Fellowship, and he is fellow of the ACM, a fellow of the National Academy of Inventors, the National Academy of Engineering, and the National Academy of Arts and Sciences.</bio>
          <homepage_url>http://cs.brown.edu/~mph/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mauriceherlihy/475dd54e-d8ee-47c6-9eb8-d0ebae4914e2/small.jpg</picture_url>
          <person_id>mauriceherlihy</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>903afa25-efd4-4497-b599-a89a25303820</subevent_id>
    <title>SPLASH REBASE: 21</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>ba5ab9e6-64b0-4a9e-bcf2-8e6d30b3b99e</slot_id>
      <title>Session: SPLASH REBASE - 21</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>21:00</start_time>
      <end_time>21:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5862dee6-d917-4e7a-84d2-d77a6778c0cc</slot_id>
      <event_id>03ce757b-14f2-4cff-96de-d52eb26aa2bf</event_id>
      <title>Relational Reasoning in Object-based Programs</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>21:40</end_time>
      <description>Relational properties arise in many settings: relating two versions of a program that use different data representations, noninterference properties for security, conditional equivalence in program transformations, etc. How might one reason about such relational properties? The talk reports on current investigations of a logic based on novel syntax that weaves together product programs to express alignment of control flow points at which relational formulas are asserted. Correctness judgments feature hypotheses with relational specifications, discharged by a rule for the linking of procedure implementations. The logic supports reasoning about program-pairs containing both similar and dissimilar control and data structures. Reasoning about dynamically allocated objects is supported by a frame rule based on frame conditions amenable to SMT provers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anindya</first_name>
          <last_name>Banerjee</last_name>
          <affiliation>National Science Foundation</affiliation>
          <bio>Anindya is a Program Director at the National Science Foundation in the CISE Directorate in the Division of Computing and Communication Foundations (CCF) where he focuses on the issues of Software and Hardware Foundations; Exploiting Parallelism for Scalability; Cyber-physical Systems; Research Experience for Undergraduates; CISE Research Initiation Initiatives. Banerjee’s research interests span software security, software verification, probabilistic programming, semantics and logics of programs, abstract interpretation, program analysis and program transformation. He received his Ph.D. from Kansas State University, USA, in 1995. After his Ph.D., Anindya was a postdoctoral researcher, first in the Labaratoire d’Informatique (LIX) of Ecole Polytechnique, Paris and subsequently at the University of Aarhus. He joined the IMDEA Software Institute in February 2009 as Full Professor. Immediately prior to this position, Anindya was Full Professor of Computing and Information Sciences at Kansas State University, USA. He was an Academic Visitor in the Advanced Programming Tools group, IBM T. J. Watson Research Center in 2007 and a Visiting Researcher in the Programming Languages and Methodology group at Microsoft Research in 2007–2008. He was a recipient of the Career Award of the US National Science Foundation in 2001.</bio>
          <homepage_url>https://www.nsf.gov/staff/staff_bio.jsp?lan=abanerje&amp;org=NSF&amp;from_org=NSF</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anindyabanerjee1/fe921757-de11-449b-9c37-f3c7d07db1bb/small.jpg</picture_url>
          <person_id>anindyabanerjee1</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3f750f4b-e824-4bec-a997-4dd047dab920</subevent_id>
    <title>SPLASH REBASE: 15</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>f793901a-c978-4a44-880d-09df7d5d7603</slot_id>
      <title>Session: SPLASH REBASE - 15</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>05:00</start_time>
      <end_time>05:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>03d26fcb-26c5-4ec2-8e77-017d3fd1744f</slot_id>
      <event_id>a89b8a71-8095-4032-a94a-5405a58da74b</event_id>
      <title>Technology Today: A Paucity of Integrity and Imagination</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>05:40</end_time>
      <description>Judging by the experiences of Robert Grimm and a close confidante, both academe and industry have long given up even trying to conduct their business in an ethical fashion. In this talk, the author will detail some of the most egregious instances of deeply unethical if not outright criminal behavior across their career, will argue that they are representative of elites acting in a deeply irresponsible and self-serving manner, causally tie that misbehavior to the rise of nativist nationalism across the western world, and contrast it all against the civilization-ending threat of climate change. This talk sounds the alarm as much as it identifies our last best hope for survival. It’s up to us!</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Grimm</last_name>
          <affiliation>Self</affiliation>
          <bio>Robert worked at Facebook. He was also Vice President in the Technology Division of Goldman Sachs, where he worked on the company’s risk and trading platform. Robert was an Associate Professor of Computer Science at New York University, researching how to leverage programming language technologies to make complex systems easier to build, maintain and extend. He received a Ph.D. in Computer Science from the University of Washington at Seattle in 2002. His honors include the Best Paper award at the 6th ACM International Conference on Distributed Event-Based Systems, a Junior Fellowship at NYU’s Center for Teaching Excellence, and an NSF CAREER award.</bio>
          <homepage_url>http://cs.nyu.edu/rgrimm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/robertgrimm/00645048-2d05-48ed-ae6f-50c441f41179/small.jpg</picture_url>
          <person_id>robertgrimm</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>dd25ec73-3a78-442d-b5e8-fb590b6001a3</subevent_id>
    <title>SPLASH REBASE: 8</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>4d50c27e-b42e-4626-b3c9-58a68c5dfc43</slot_id>
      <title>Session: SPLASH REBASE - 8</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>13:00</start_time>
      <end_time>13:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3278d263-db91-4af5-8b79-47cae9bb0c1d</slot_id>
      <event_id>9909752f-2f85-4ed3-abab-a13ebbc9e912</event_id>
      <title>Herding Nulls in Dart</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>13:40</end_time>
      <description>The programming language Dart is about to introduce sound null safety, which involves a bundle of language mechanisms associated with null as a typing property. This talk presents these mechanisms, including nullable types, late variables, type promotion, null shorting, and the handling of programs with both legacy and null safe libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Erik</first_name>
          <last_name>Ernst</last_name>
          <affiliation>Google Inc.</affiliation>
          <bio>Erik Ernst is a member of the Dart language team at Google, maintaining the language specification. He has been an associate professor at Aarhus University. He has published research on virtual classes, establishing that they can be statically safe. He introduced family polymorphism, which is foundational for path dependent types, and he contributed to the introduction of generics is Java.</bio>
          <homepage_url>https://scholar.google.com/citations?user=L-i5BHcAAAAJ&amp;hl=en</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/erikernst/dbb8033d-763a-4571-90ef-c750ed5f597b/small.jpg</picture_url>
          <person_id>erikernst</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>002a72fd-18fc-455b-a274-493ff380afd1</subevent_id>
    <title>SPLASH REBASE: 10</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>8346649c-a00c-4f27-8366-d393c579411b</slot_id>
      <title>Session: SPLASH REBASE - 10</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>17:00</start_time>
      <end_time>17:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7ee3f126-2b71-485b-9a7c-5819aa046a40</slot_id>
      <event_id>dbb6bee0-b4d0-48fe-aa57-9d19010b0d78</event_id>
      <title>Lies we tell ourselves about developer infrastructure</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>17:40</end_time>
      <description>Over the past decade “developer infrastructure” teams have become an increasingly common presence in industry. Focused on serving the unique needs of an organization’s engineers, their responsibilities can be as modest as build script support or as ambitious as developing new general-purpose programming languages. As a practitioner they can be a wonderful place to work; a perfect environment to apply state of the art techniques to real world problems and invest in new ideas, all while keeping a tight feedback loop with a potentially massive user base. But with great power comes great responsibility, and the potential for waste is real.
How many build systems, UI frameworks, code review tools, and bespoke IDEs have been developed in industry because of “unique needs”? Of those, how many actually improved the state of the art or eventually provided a return on their investment? Why does conventional wisdom — or common sense — so seldom apply when we choose to pursue these sorts of projects? (Why is it so often easier to get funding to develop a new programming language than it is to make critical improvements to an aging but essential piece of infrastructure?) The truth is that we often build new developer tools not because they’re necessary, but because personally meaningful, easy to rationalize, and fun.
While fun is great – I’m a big fan of it – we have a professional obligation to be honest about our intentions, use resources responsibly, and go into our work with open eyes. In this talk I aim to call out the most common sources of irrational exuberance when it comes to developer infrastructure, and the lies I’ve been told (or told others) to justify certain classes of projects. Where appropriate I’ll provide cautionary tales from my last two decades working in the field (names will be changed to protect the innocent), sensible alternatives for those wiser than I was, and advice for those foolhardy enough to try and build that better wheel. (Because I guarantee you – whatever mistake you’re thinking of making, I’ve either made it myself or know someone who did.)</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joe</first_name>
          <last_name>Pamer</last_name>
          <affiliation>Facebook</affiliation>
          <bio>Joe Pamer is an Engineering Director at Instagram, where he serves as their Head of Infrastructure, Feed, and ML. Before joining Facebook to help lead their programming language efforts, he was instrumental in the design and development of the F#, TypeScript, and Swift programming languages, and has contributed to many other major developer technologies ranging from .NET to VS Code to Clang. He currently resides in Brooklyn, New York.</bio>
          <homepage_url>http://noteven.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joepamer/8638da18-a5b0-4543-9d00-fd4b97be5d14/small.jpg</picture_url>
          <person_id>joepamer</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>161ff398-399e-40a5-9c63-a94c4c893d45</subevent_id>
    <title>SPLASH REBASE: 3</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>b9a5158f-2c8a-4133-a05c-04f394f77fa6</slot_id>
      <title>Session: SPLASH REBASE - 3</title>
      <room>Online | Rebase</room>
      <date>2020/11/15</date>
      <start_time>13:00</start_time>
      <end_time>13:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>41259158-4892-4ad0-aa15-4ed22d968069</slot_id>
      <event_id>bc103573-47f7-44f0-b8e7-b629c50d6e17</event_id>
      <title>Probabilistic Programming: The What, Why and How</title>
      <room>Online | Rebase</room>
      <date>2020/11/15</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>13:40</end_time>
      <description>f(x) = y, but y = 5. What’s the probability that x =1? Probabilistic programming is the idea of describing probabilistic models as programs, to then automatically infer how our beliefs about model parameters change given observed data. In recent years, probabilistic programming languages (such as Stan) have demonstrated the power of this approach by becoming the underlying tool behind numerous projects in social science, biology, genetics, astrophysics, and engineering. But why haven’t such languages been more widely adopted yet? In this talk, Maria will talk about the nuts and bolts of probabilistic programming languages, addressing the challenges behind making these languages general-purpose, automatic, and efficient.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Maria I.</first_name>
          <last_name>Gorinova</last_name>
          <affiliation>The University of Edinburgh</affiliation>
          <bio>Maria is a Data Science PhD student at the University of Edinburgh, where she works on improving the expressivity and efficiency of probabilistic programming languages. In particular, she is interested in applying program-analysis techniques to existing probabilistic languages, such as Stan, and she is also part of Stan’s development team. Previously, Maria worked as a Research Assistant in the Graphics and Interaction Group at the University of Cambridge, where she also received her BA, developing an interactive development environment for probabilistic programming for her final year project.</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/s1207807/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mariaigorinova/d9555ab1-6d7e-4631-bcc7-2f6ed701a677/small.jpg</picture_url>
          <person_id>mariaigorinova</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>dc63f7ab-7a83-4698-bdd1-6eb84997c21b</subevent_id>
    <title>SPLASH REBASE: 32</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>9f79ede8-f660-47db-8e52-6d261c5fd47b</slot_id>
      <title>Session: SPLASH REBASE - 32</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>03:00</start_time>
      <end_time>03:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9b6c3eb8-295c-4590-9efb-7929aa1fdac0</slot_id>
      <event_id>05a740f8-7a2d-42bb-a92d-7cfa31345b5f</event_id>
      <title>Gillian: a Multi-language Platform for Compositional Symbolic Analysis</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>03:40</end_time>
      <description>This talk will give a general introduction to Gillian, a multi-language platform for symbolic program analysis being developed by my team at Imperial College London. Gillian currently supports three types of analysis: whole-program symbolic testing; full verification based on separation logic; and automatic compositional testing based on bi-abduction. It uses a core symbolic execution engine, with strong mathematical foundations, that unifies bug catching and verification. To instantiate Gillian to a new target language (TL), the tool developer must provide: a compiler from the TL to GIL, an intermediate representation which is parametric on the TL memory model: that is, on the set of basic actions capturing the ways in which TL programs fundamentally interact with their memories; an OCaml implementation of the TL memory model using the basic actions; proofs of simple lemmas for the TL basic actions, if interested in correctness guarantees. So far, we have instantiated Gillian to JavaScript and C. These instantiations have been used to: find bugs in the real-world data-structure libraries Buckets.js and Collections-C; find bugs and prove bounded correctness results for a real-world jQuery-like library, cash; and verify the deserialisation function of the AWS Encryption SDK messaging system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Philippa</first_name>
          <last_name>Gardner</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Philippa Gardner is a professor in the Department of Computing at Imperial College London and and has a UKRI Established Fellowship from 2018–2023. Her current research focusses on program verification: in particular, reasoning about Web programs (JavaScript and DOM); and reasoning about concurrent programs. She completed her PhD thesis, supervised by Professor Gordon Plotkin FRS at Edinburgh in 1992 and held five years of fellowships at Edinburgh. She moved to Cambridge in 1998 on an EPSRC Advanced Fellowship, hosted by Professor Robin Milner FRS. She obtained a lectureship at Imperial in 2001, and became professor in 2009. She held a Microsoft Research Cambridge/Royal Academy of Engineering Senior Fellowship from 2005 to 2010 at Imperial. Philippa directs the Research Institute on Verified Trustworthy Software Systems (VeTSS), funded by EPSRC, from 2017 to 2022. She chaired the BCS awards committee, 2013-2018, which decides the Lovelace medal (senior) and Roger Needham award (mid-career) for computer science and engineering.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~pg</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippagardner/8031e77a-ebbb-4963-a5de-94895edd7f71/small.jpg</picture_url>
          <person_id>philippagardner</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c68c3682-381a-4ee4-87bd-2206e1496d56</subevent_id>
    <title>SPLASH REBASE: 2</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>fbe47638-7c05-47d3-8c24-b577e51b24d3</slot_id>
      <title>Session: SPLASH REBASE - 2</title>
      <room>Online | Rebase</room>
      <date>2020/11/15</date>
      <start_time>11:00</start_time>
      <end_time>11:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>33f0896c-ff56-4cde-91f7-36f88a3d9c8a</slot_id>
      <event_id>4e833098-9571-41d8-9ce8-db793ded3069</event_id>
      <title>Back to the Future! A History of UIs through Trends and Mass Culture</title>
      <room>Online | Rebase</room>
      <date>2020/11/15</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>11:40</end_time>
      <description>Digital interfaces have changed a lot since the good old days of CERN’s first webpage. UI design has evolved in a very unpredictable way, generating new trends year after year always based on the needs and expectations of users. Also, in popular culture, we can find more and more user interfaces: TV shows, movies, comics and video clips are full of digital systems and it is very interesting to see how the media industry perceives the “shape” of technology and how it is used. From the colorful (and pixelated) iframe-based websites in the 90s to the minimalist and pretentious interfaces of 2020, we will take a journey through the trends, patterns and perception of mass culture of user interfaces, trying to understand how and why. they evolved in this way. Furthermore, we will try to understand why hackers in TV shows are able to break into the FBI’s servers by simply clicking a button.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paola</first_name>
          <last_name>Bisogno</last_name>
          <affiliation>Casavo</affiliation>
          <bio>Paola is an italian digital product designer with more than 15 years of experience. She started as a web master in the early 00s, building web 1.0 sites. After years in digital agencies, she switched to focus on user experience and interface design. She now works as UX/UI Designer at Casavo, one of the most innovative italian proptech startups. She worries about usability, design patterns, engineering design process, heuristic evaluation, information architecture and cognitive design. She is on the jury of the international design and development awards CSS Design Awards.</bio>
          <homepage_url>https://www.paobi.it/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/paolabisogno/494b3b99-2e72-47b6-b372-df5227bd8469/small.jpg</picture_url>
          <person_id>paolabisogno</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f0c8344c-714d-480a-8e2c-737e5f38e36a</subevent_id>
    <title>SPLASH REBASE: 6</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>00790be9-15d8-4b9d-a10e-bb9c47e4023a</slot_id>
      <title>Session: SPLASH REBASE - 6</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>19:00</start_time>
      <end_time>19:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>03f7b8c9-8b79-4f72-a281-5c08478f1144</slot_id>
      <event_id>f62da32e-6fe2-4aae-a89f-747447ef4bac</event_id>
      <title>Reliable Stack Traces, the Reality of Myth</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>19:40</end_time>
      <description>Debug information is a hidden and obscure component of our computing infrastructure obviously used by debuggers, but also playing a key role in program analysis tools, and, most surprisingly, in the runtime of programming languages. For instance C++ leverages DWARF stack unwind tables to implement exceptions! Alas, generating debug information adds significant burden to compilers, and the debug info itself can be pervaded by subtle bugs, making the whole infrastructure unreliable. Additionally, interpreting the debug tables is a bottleneck. My talk focuses on the DWARF unwind table, that enables stack unwinding in absence of frame-pointer information. I show two techniques to perform validation and synthesis of unwinding tables, and their implementation for x86_64. Our validator has proven effective for compiler and inline assembly testing, while the synthesis tool can generate unwind tables for arbitrary binaries lacking debug information. Additionally, I will report on a technique to precompile unwind tables into native x86_64 code, which we have implemented and integrated into libunwind, resulting in a 25x DWARF-based unwind speedup.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Zappa Nardelli</last_name>
          <affiliation>Facebook</affiliation>
          <bio>My work is at boundaries between programming languages, system programming, and computer architectures, with the overall goal of producing systems which are better-understood, more robust, and more secure.</bio>
          <homepage_url>https://fzn.fr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/francescozappanardelli/e7d164ff-66ed-4309-b99f-60e2f77f7b02/small.jpg</picture_url>
          <person_id>francescozappanardelli</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5017f4a5-0a5a-44bf-8c6c-d89617ab12fb</subevent_id>
    <title>SPLASH REBASE: 4</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>aef61d76-ca26-44a4-9a87-17632ac3fa8a</slot_id>
      <title>Session: SPLASH REBASE - 4</title>
      <room>Online | Rebase</room>
      <date>2020/11/15</date>
      <start_time>15:00</start_time>
      <end_time>15:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>429f2790-02ed-402d-8178-9bb423efdef7</slot_id>
      <event_id>9ca583dd-05ba-44fc-b913-6a78719ea4e0</event_id>
      <title>A Ray of Hope: Array Programming for the 21st Century</title>
      <room>Online | Rebase</room>
      <date>2020/11/15</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>15:40</end_time>
      <description>The ideas of APL and its successors, the array programming languages, were two generations ahead of their time.&amp;nbsp; These languages are based on the notion that everything is a tensor, and all operations are rank-polymorphic: they extend automatically to tensors of any rank. These ideas are perfectly suited to an era of machine learning, large scale data, GPUs and other accelerators. Building on recent academic research, we are building ShapeRank, a new statically typed, purely functional language for industrial use, that extends rank-polymorphism to streams. We’ll introduce the key ideas and show how they are realized in ShapeRank.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gilad</first_name>
          <last_name>Bracha</last_name>
          <affiliation>F5 Networks</affiliation>
          <bio>Gilad Bracha is the creator of the Newspeak programming language and a well known researcher in the area of object-oriented programming languages. He was awarded the senior Dahl-Nygaard prize in 2017. Previously, he has worked at Google, as a VP at SAP Labs in Palo Alto, a Distinguished Engineer at Cadence, and a Computational Theologist and Distinguished Engineer at Sun. He has authored or co-authored several books including the Java Language and Virtual Machine Specifications, and the Dart Programming Language. Prior to joining Sun, he worked on Strongtalk, the Animorphic Smalltalk System. He received his B.Sc in Mathematics and Computer Science from Ben Gurion University in Israel and a Ph.D. in Computer Science from the University of Utah.</bio>
          <homepage_url>https://bracha.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/giladbracha/66fe962c-9388-4df3-aaaa-677a8e2e64df/small.jpg</picture_url>
          <person_id>giladbracha</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c41d960f-8617-4f16-be0f-1e11b2718e49</subevent_id>
    <title>SPLASH REBASE: 18</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>0b305cf8-c0d2-46ba-83dd-34bbd3b0efc6</slot_id>
      <title>Session: SPLASH REBASE - 18</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>13:00</start_time>
      <end_time>13:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bb3f37ff-0a0f-4b29-b0b7-1878de6d707a</slot_id>
      <event_id>a1270bf8-34d0-477b-b540-3c525ff165fa</event_id>
      <title>Inside Every Calculus Is A Little Algebra Waiting To Get Out</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>13:40</end_time>
      <description>Because of deep learning, there has been a surge in interest in automatic differentiation, especially from the functional programming community. As a result there are many recent papers that look at AD from a Category Theory perspective. However, Category Theorists have already been looking at differentiation and calculus in general since the late 60’s in the context of Synthetic Differential Geometry, but it seems that this work is largely ignored by those interested in AD. In this talk, we will provide a gentle introduction to the ideas of SDG, by relating them to dual numbers, and show how it provides a simple and purely algebraic approach to (automatic) differentiation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Erik</first_name>
          <last_name>Meijer</last_name>
          <affiliation>Facebook</affiliation>
          <bio>Erik Meijer has been trying to bridge the ridge between theory and practice for most of his career. He is perhaps best known for his work on, amongst others, Haskell, C#, Visual Basic, and Dart programming languages, as well as for his contributions to LINQ and the Reactive Framework (Rx). Most recently he is on a quest to make uncertainty a first-class citizen in mainstream programming languages.</bio>
          <homepage_url>https://twitter.com/headinthebox</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/erikmeijer/caccbe57-ed32-4b35-966a-886c97f93d47/small.jpg</picture_url>
          <person_id>erikmeijer</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>93c368ec-1d51-4c6c-9aef-b5193f764c4f</subevent_id>
    <title>SPLASH REBASE: 26</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>51f85b91-645a-42de-bc21-a7104037535e</slot_id>
      <title>Session: SPLASH REBASE - 26</title>
      <room>Online | Rebase</room>
      <date>2020/11/20</date>
      <start_time>19:00</start_time>
      <end_time>19:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>61bf489a-8364-4ddd-90b0-69d3f1d6bd5b</slot_id>
      <event_id>59a73831-882e-4229-b00a-9f8b357d17b3</event_id>
      <title>PL and HCI: Better Together</title>
      <room>Online | Rebase</room>
      <date>2020/11/20</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>19:40</end_time>
      <description>Programming Languages (PL), Human-Computer Interaction (HCI), and Software Engineering (SE) have a key overlapping interest: getting computers to do what we want. Each field has a different balance of methods and beneficiaries, from novice programmers to professional programmers. This talk will highlight the overlaps between HCI and PL, a powerful but under-explored pairing with much mutual benefit. HCI is concerned with creating new ways of interacting with computers and using computers to enhance human-to-human interaction, as well as studying how existing systems impact individuals and society. PL is concerned with the theory, design, and implementation of programming languages, program analyses, and program transformations. I will highlight several existing systems that demonstrate how PL and HCI are better together, as well as dispel common misconceptions and lay out some promising future research directions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Elena</first_name>
          <last_name>Glassman</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>Elena Glassman is a the Stanley A. Marks and William H. Marks Assistant Professor at the Radcliffe Institute and a professor of computer science at the Harvard Paulson School of Engineering and Applied Sciences specializing in human-computer interaction. She designs, builds and evaluates systems for comprehending and interacting with intelligent systems and population-level structure in large code and data corpora. Prior to joining Harvard as an assistant professor, Glassman earned BS, MEng and PhD degrees from MIT EECS and served as a postdoctoral scholar at the University of California, Berkeley EECS department and Berkeley Institute for Design.</bio>
          <homepage_url>http://glassmanlab.seas.harvard.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/elenaglassman/4951972c-4212-4bfb-9e7a-bdaefbf84466/small.jpg</picture_url>
          <person_id>elenaglassman</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>56be88cd-f1c8-4d33-914a-2c5d0ebe5d74</subevent_id>
    <title>SPLASH REBASE: 3</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>d596dcec-4825-4ac5-bb7c-7caa20d5fa50</slot_id>
      <title>Session: SPLASH REBASE - 3</title>
      <room>Online | Rebase</room>
      <date>2020/11/15</date>
      <start_time>23:00</start_time>
      <end_time>23:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>979f5f3c-351e-482f-aff4-31199d685adf</slot_id>
      <event_id>bc103573-47f7-44f0-b8e7-b629c50d6e17</event_id>
      <title>Probabilistic Programming: The What, Why and How</title>
      <room>Online | Rebase</room>
      <date>2020/11/15</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>23:40</end_time>
      <description>f(x) = y, but y = 5. What’s the probability that x =1? Probabilistic programming is the idea of describing probabilistic models as programs, to then automatically infer how our beliefs about model parameters change given observed data. In recent years, probabilistic programming languages (such as Stan) have demonstrated the power of this approach by becoming the underlying tool behind numerous projects in social science, biology, genetics, astrophysics, and engineering. But why haven’t such languages been more widely adopted yet? In this talk, Maria will talk about the nuts and bolts of probabilistic programming languages, addressing the challenges behind making these languages general-purpose, automatic, and efficient.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Maria I.</first_name>
          <last_name>Gorinova</last_name>
          <affiliation>The University of Edinburgh</affiliation>
          <bio>Maria is a Data Science PhD student at the University of Edinburgh, where she works on improving the expressivity and efficiency of probabilistic programming languages. In particular, she is interested in applying program-analysis techniques to existing probabilistic languages, such as Stan, and she is also part of Stan’s development team. Previously, Maria worked as a Research Assistant in the Graphics and Interaction Group at the University of Cambridge, where she also received her BA, developing an interactive development environment for probabilistic programming for her final year project.</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/s1207807/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mariaigorinova/d9555ab1-6d7e-4631-bcc7-2f6ed701a677/small.jpg</picture_url>
          <person_id>mariaigorinova</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7aaf739f-ff37-4155-b059-e151a06c2a00</subevent_id>
    <title>SPLASH REBASE: 19</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>aec850b8-8994-4871-aa4a-7939bc0a1a23</slot_id>
      <title>Session: SPLASH REBASE - 19</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>03:00</start_time>
      <end_time>03:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a540c1d4-1a16-4ff6-aab2-6e6bd8cbb59c</slot_id>
      <event_id>f3ec9a74-d5ee-4008-9430-ff52af55c713</event_id>
      <title>Speculation in Smart Contracts</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>03:40</end_time>
      <description>A smart contract is a script that controls the transfer of electronic assets within a distributed ledger. Existing smart contract architectures suffer from a bottleneck problem: contract calls place arbitrary user code right in the ledger’s critical path, so relatively complex contract executions delay processing for all transactions, especially simple payments and transfers that could otherwise be cleared quickly. This talk describes an alternative smart contract architecture that executes user code speculatively off the blockchain’s critical path. A secure committee validates and votes on each such computation, certifying the computation’s preconditions and its effects, and forwarding the certified results to a different committee controlling the blockchain. The paper focuses on the authors’ experience integrating this smart contract architecture with an existing commercial blockchain and an existing language virtual machine.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Maurice</first_name>
          <last_name>Herlihy</last_name>
          <affiliation>Brown University</affiliation>
          <bio>Maurice Herlihy has an A.B. in Mathematics from Harvard University, and a Ph.D. in Computer Science from M.I.T. He has served on the faculty of Carnegie Mellon University and the staff of DEC Cambridge Research Lab. He is the recipient of the 2003 Dijkstra Prize in Distributed Computing, the 2004 Gödel Prize in theoretical computer science, the 2008 ISCA influential paper award, the 2012 Edsger W. Dijkstra Prize, and the 2013 Wallace McDowell award. He received a 2012 Fulbright Distinguished Chair in the Natural Sciences and Engineering Lecturing Fellowship, and he is fellow of the ACM, a fellow of the National Academy of Inventors, the National Academy of Engineering, and the National Academy of Arts and Sciences.</bio>
          <homepage_url>http://cs.brown.edu/~mph/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mauriceherlihy/475dd54e-d8ee-47c6-9eb8-d0ebae4914e2/small.jpg</picture_url>
          <person_id>mauriceherlihy</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fe58d1e2-729e-4beb-839b-ccca5b5054bc</subevent_id>
    <title>SPLASH REBASE: 28</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>b6757c7a-01ed-42dd-9be2-4d9eacac2130</slot_id>
      <title>Session: SPLASH REBASE - 28</title>
      <room>Online | Rebase</room>
      <date>2020/11/20</date>
      <start_time>09:00</start_time>
      <end_time>09:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>efcd09df-7247-4f2e-8db9-4d588f54da75</slot_id>
      <event_id>fbb11428-c9f3-4c7b-8395-2c4f79d8f397</event_id>
      <title>Performance Really Matters</title>
      <room>Online | Rebase</room>
      <date>2020/11/20</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>09:40</end_time>
      <description>Performance clearly matters to users. For example, the most common software update on the AppStore is “Bug fixes and performance enhancements.” Now that Moore’s Law has ended, programmers have to work hard to get high performance for their applications. But why is performance hard to deliver? I will first explain why current approaches to evaluating and optimizing performance don’t work. I’ll show how complicated performance has become on modern systems, and how compiler optimizations have essentially run out of steam. Next, I’ll introduce two radically new performance profilers that guide programmers directly to the code they need to change to improve application performance. The first is Coz, a new “causal profiler” for C/C++/Rust that lets programmers optimize for throughput or latency, and which pinpoints and accurately predicts the impact of optimizations via what we call “virtual speedup” experiments. Coz’s approach unlocks previously unknown optimization opportunities. Guided by Coz, we improved the performance of applications by as much as 68%; in most cases, this involved modifying less than 10 lines of code and took under half an hour (without any prior understanding of the programs!). Coz now ships as part of standard Linux distros. The second is Scalene, a “scripting-language aware” profiler for Python. Scalene runs orders of magnitude faster than other profilers while delivering far more detailed information – information that’s especially valuable to Python programmers. Via a combination of sampling, inference, and disassembly of byte-codes, Scalene efficiently and precisely attributes execution time and memory usage to Python, which developers can optimize, or library code, which they cannot. Its novel sampling memory allocator efficiently reports line-level memory consumption and trends with low overhead, helping developers reduce footprints and identify leaks. Finally, Scalene reports a new metric, copy volume, that helps developers root out insidious copying costs across the Python/library boundary, which can drastically degrade performance. Scalene is available on PyPi.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Emery</first_name>
          <last_name>Berger</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>Emery is a Professor at the University of Massachusetts Amherst. He researches languages, runtime systems, and operating systems, with a particular focus on systems that transparently improve reliability, security, and performance. Emery and friends have created Hoard, the first scalable memory manager (malloc), on which the Mac OS X memory manager is based; DieHard, an error-avoiding memory manager that directly influenced the design of the Windows 7 Fault-Tolerant Heap; DieHarder, a secure memory manager that was an inspiration for hardening changes made to the Windows 8 heap; the Coz profiler, which ships with modern Linux distros; and more. He was named an ACM Fellow in 2019.</bio>
          <homepage_url>http://www.emeryberger.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/emeryberger/6187feeb-700c-48d5-aceb-6d7b87490a7a/small.jpg</picture_url>
          <person_id>emeryberger</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>373f228d-2693-4fa0-83bd-95c0f93aa51d</subevent_id>
    <title>SPLASH REBASE: 14</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>eaad0ba2-b12b-4703-80e8-1ee2d60931c4</slot_id>
      <title>Session: SPLASH REBASE - 14</title>
      <room>Online | Rebase</room>
      <date>2020/11/17</date>
      <start_time>15:00</start_time>
      <end_time>15:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8e805bc5-89e8-4da6-ace7-cdf24ae2ea5d</slot_id>
      <event_id>3915f558-1e15-450f-b38f-222ffd9da8ca</event_id>
      <title>Quantitative Types in Idris 2</title>
      <room>Online | Rebase</room>
      <date>2020/11/17</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>15:40</end_time>
      <description>Dependent types allow us to express precisely what a function is intended to do. Recent work on Quantitative Type Theory (QTT) extends dependent type systems with linearity, also allowing precision in expressing when a function can run. This is promising, because it suggests the ability to design and reason about resource usage protocols, such as we might find in distributed and concurrent programming, where the state of a communication channel changes throughout program execution. Up to now, however, there has not been a full-scale programming language with which to experiment with these ideas. Idris 2 is a new version of the dependently typed language Idris, with a new core language based on QTT, supporting linear and dependent types. In this talk I will show the benfits of QTT in Idris 2, in particular how it improves interactive program development by reducing the search space for type-driven program synthesis; and, how resource tracking in the type system leads to type-safe concurrent programming with session types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Edwin</first_name>
          <last_name>Brady</last_name>
          <affiliation>University of St. Andrews</affiliation>
          <bio>I am a Lecturer in Computer Science at the University of St Andrews, interested in type theory, dependently typed functional programming, compilers and metaprogramming. I am currently working on a new implementation of Idris, a dependently typed functional programming language. When I’m not doing that, you might find me playing Go (I’m about 2 kyu), walking up a hill, watching a game of cricket, or waiting for a delayed train. I’m afraid I also perpetrated the Whitespace programming language.</bio>
          <homepage_url>https://eb.host.cs.st-andrews.ac.uk</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/edwinbrady/cbff36d2-7476-402e-bc2c-e84d1ceb0ab5/small.jpg</picture_url>
          <person_id>edwinbrady</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>59951e75-9819-4b3c-be3b-d4db99ccbdd5</subevent_id>
    <title>SPLASH REBASE: 12</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>bee2c3f9-aad9-40dc-ba1d-4532742b84ff</slot_id>
      <title>Session: SPLASH REBASE - 12</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>07:00</start_time>
      <end_time>07:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>56094898-54bf-4e11-ad85-f6dd88cbde18</slot_id>
      <event_id>903e6b1f-a35a-40b8-a306-8d3a5bde3b5e</event_id>
      <title>Towards the tower of Babel: a Polyglot Language VM in Java</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>07:40</end_time>
      <description>Meet the GraalVM, a technology you can use to build composable high-performance language implementations and tools. Most production-level virtual machines duplicate their target language’s semantics in the interpreter, in the compiler, and in the runtime system. This violates DRY and is hell on the maintainers as the target evolves. In contrast, Truffle lets you define languages by simply writing their interpreter. That interpreter can be seamlessly combined with interpreters of different languages in a single just-in-time compilation unit. By treating the host language as just another language, you can reuse embeddings across languages. A language agnostic instrumentation mechanism enables us to build tools that attach cross-cutting concerns to applications with zero overhead.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christian</first_name>
          <last_name>Humer</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>Christian Humer is a researcher at Oracle Labs in Zurich, working on the GraalVM project. He develops the Truffle framework which aims to make all programming languages fast, composable and embeddable. His research interests include virtual machines, partial evaluation, and domain-specific languages. He is the main author of Truffle DSL, a domain-specific language to simplify the development of Truffle interpreters.</bio>
          <homepage_url>https://labs.oracle.com/pls/apex/f?p=LABS:bio:0:2137</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/christianhumer/7a395af3-35b6-4728-81d5-bf478224f957/small.jpg</picture_url>
          <person_id>christianhumer</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>52a13995-d6c0-47f8-93fd-3145c3655568</subevent_id>
    <title>SPLASH REBASE: 16</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>109b4cfe-94cb-457b-8237-6650026b2d30</slot_id>
      <title>Session: SPLASH REBASE - 16</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>19:00</start_time>
      <end_time>19:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e3960dcd-d0ed-400e-a526-01408aa8fee8</slot_id>
      <event_id>f8bcf094-fae6-48e2-b07b-243759ea945b</event_id>
      <title>Miniaturize All States!</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>19:40</end_time>
      <description>Like science, software is in reproducibility crisis. All too often, “steps to reproduce” in bug reports don’t work or are too long and complicated. They shouldn’t be necessary to begin with. Fleets of servers suffer from constant “configuration drift”, making any incremental change to their state hazardous. Will an upgrade that worked yesterday work today? Will it work for you if it worked for me? We’re never quite sure. Lack of reproducibility hinders sharing, from lab reports to bug reports to build instructions to software packages to cloud infrastructure. The solution: miniaturizing the inputs to your lab experiment and to your build bots, the state of your laptop and of your resources in the cloud, using precise, shareable, composable declarative specifications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mathieu</first_name>
          <last_name>Boespflug</last_name>
          <affiliation>Tweag I/O</affiliation>
          <bio>Mathieu is the CEO of Tweag I/O, an independent industrial lab helping startups and research groups within the enterprise boldly ship high-risk, high-reward digital products. He was involved in European initiatives for exascale storage, worked on build systems, programming language interop and compilers. In a previous life, Mathieu was a researcher in formal methods and programming language design. He has a PhD from École Polytechnique.</bio>
          <homepage_url>https://www.linkedin.com/in/mboes</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mathieuboespflug/d01c0846-8cf1-41ab-bbbd-2aa6beba122b/small.jpg</picture_url>
          <person_id>mathieuboespflug</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c8596b01-f09c-4d8a-a808-33e4aec7a9ce</subevent_id>
    <title>SPLASH REBASE: 1</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>8f336250-1be9-4a38-8ade-e09b33509d4d</slot_id>
      <title>Session: SPLASH REBASE - 1</title>
      <room>Online | Rebase</room>
      <date>2020/11/15</date>
      <start_time>09:00</start_time>
      <end_time>09:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ecb7cd03-7f6e-4d8f-aa14-b1c2e9482686</slot_id>
      <event_id>910bd8ae-8e1b-40c6-af3c-b39c2bf4431b</event_id>
      <title>Move Semantics for Nim</title>
      <room>Online | Rebase</room>
      <date>2020/11/15</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>09:40</end_time>
      <description>This talk explains Nim’s move semantics and their connection to reference counting, how Nim’s model differs from C++/Rust and why move semantics can offer superior performance. It is explained how to leverage this technology to make multi-threading safer. Nim with deterministic memory management never has been easier.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Rumpf</last_name>
          <affiliation>Freelancer</affiliation>
          <bio>Andreas is the designer of the Nim programming language, which he develops full-time with a team of developers and the help of an enthusiastic open source community. He has programmed in various languages over the years (including quite obscure ones) without being satisfied with any of them. Andreas holds a degree in Computer Science which he obtained from University of Kaiserslautern.</bio>
          <homepage_url>https://nim-lang.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andreasrumpf/4b595ba1-d534-4051-8273-b37195473412/small.jpg</picture_url>
          <person_id>andreasrumpf</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ad76bb85-804d-41e3-b37c-06e468f0dd88</subevent_id>
    <title>SPLASH REBASE: 17</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>412dd819-e73a-4bac-8adf-052a27a1e119</slot_id>
      <title>Session: SPLASH REBASE - 17</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>11:00</start_time>
      <end_time>11:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b4f41074-bcd2-4b11-b0ac-dd29a3757ff0</slot_id>
      <event_id>737532d5-e146-4b76-8463-400864a7a121</event_id>
      <title>Paradigms Without Progress: Kuhnian Reflections on Programming Practice</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>11:40</end_time>
      <description>Borrowing from Thomas Kuhn’s definition of a paradigm, Robert Floyd introduced the notion of a programming paradigm in his 1978 Turing Award acceptance speech. Ever since, this idea has infected the software world, becoming an organizing principle for jobs, conferences, and research. But further than that, it has become a ground for interminable debate and disagreement. In order to help us understand this unfortunate situation, we will explore Thomas Kuhn’s notion of a paradigm. Kuhn’s paradigm is much richer than our ordinary everyday understanding; it is not merely a way of approaching problems, but is itself the system in which problems are made intelligible. We will discover the ways in which paradigm is apt for discussing the activities of the software world, and the ways in which our usage of the word deviates from its history. We will then explore these insights showing how they might apply in specific circumstances not typically considered. Finally, we will talk about philosophy’s place in computer science’s practice and possible avenues for further exploration.
What you will learn
We will not focus on the substance of debate between the various partisans of programming paradigms (object oriented, functional, and imperative being the most popular). Nor will we try to bridge the gap, finding some synthesis to make all parties agree. Instead we will explore the philosophy of science background that gave rise to these ideas. Focusing primarily on Thomas Kuhn, we will explore the notion of a paradigm and the ways in which paradigms are created, maintained, and discarded. Next we will evalute the ways in which our usage of paradigm aligns with Kuhn’s. We will consider the ways in which this alignment impacts these programming paradigms debates and further consider Kuhn’s notion of incommensurability. Can we borrow insights from the history of science to better understand our own practices? Can find a compelling reason for why these interminable debates seem to plague the software world at large? Next, we will consider ways in which our usage of paradigm diverge from that of Kuhn and consider other areas of software practice where Kuhn’s ideas may apply more directly. Finally we will consider philosophy’s impact on programming. Setting aside the ever popular discussions around Artificial Intelligence, we will begin by exploring how philosophy shaped foundational elements of computer science. We will explore under appreciated applications, especially those insights from Turing Award winner Peter Naur. Finally, we will look at areas where further insights may be gained in the future.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jimmy</first_name>
          <last_name>Miller</last_name>
          <affiliation>Adzerk</affiliation>
          <bio>Jimmy is a Senior Software Engineer at Adzerk where he uses Clojure to build data transformation and analysis systems. In his spare time he enjoys exploring programming language theory, reading analytic philosophy, and writing code that no one will ever use.</bio>
          <homepage_url>https://jimmyhmiller.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jimmymiller/820df0a6-b4ae-4b50-90b7-9a7ac0965e99/small.jpg</picture_url>
          <person_id>jimmymiller</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2d6d8215-54be-45b3-8067-13a15a3ead79</subevent_id>
    <title>SPLASH REBASE: 29</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>7c7df92e-d291-4409-b483-b59ac71e4b3d</slot_id>
      <title>Session: SPLASH REBASE - 29</title>
      <room>Online | Rebase</room>
      <date>2020/11/20</date>
      <start_time>11:00</start_time>
      <end_time>11:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>502c7df7-70a4-4fc6-8c07-d55826005cc9</slot_id>
      <event_id>0b5c7264-a9ac-43c5-b25b-baff765650af</event_id>
      <title>Co-Design for High-Performance Computing Software Systems</title>
      <room>Online | Rebase</room>
      <date>2020/11/20</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>11:40</end_time>
      <description>High-performance computing (HPC) systems are designed for pursuing extreme-scale parallelism and computational power to accelerate various computational-expensive applications in scientific computing. HPC software stack is deep and wide, mainly due to the complex computational requirements from various domain-specific algorithms and the diverse capacities provided by the underlying hardware architecture. For instance, domain-specific language or multi-layer runtime library is a common approach for developers to decouple the complex scientific algorithms from parallel programming (i.e., deep). To fully utilize different hardware components, different parallel programming models and runtime subsystems often coexist in an application software stack such as the popular MPI + “X” programming model (i.e., wide). Although abstraction allows developers and researchers to isolate innovations for different software components, experiences have indicated that co-design is the key strategy to achieve exascale computing and beyond. Co-design across the deep and wide HPC software stack is a very challenging task. However, the potential performance gain can be significant. In this talk, I will share the experiences and insights from several projects that explored the co-design approach across applications and parallel runtime subsystems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Min</first_name>
          <last_name>Si</last_name>
          <affiliation>Argonne National Laboratory</affiliation>
          <bio>Dr. Min Si is an Assistant Computer Scientist at Argonne National Laboratory working with the Programming Models and Runtime Systems group. Min’s research interests include communication runtime in high-performance computing and parallel programming models. Min was previously an Enrico Fermi Postdoctoral Scholar of Argonne National Laboratory. She received the Ph.D. degree in computer science from the University of Tokyo. Her doctoral dissertation focused on the optimization of high performance message passing communication on massively parallel multi-/many-core architectures. Min is the recipient of the 2018 IEEE-CS Technical Consortium on High Performance Computing (TCHPC) Early Career Researchers Award for Excellence in High Performance Computing, and won the Karsten Schwan Best Paper Award at HPDC 2018.</bio>
          <homepage_url>https://www.mcs.anl.gov/~minsi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/minsi/b566ccd5-1498-4770-923d-94635bfad191/small.jpg</picture_url>
          <person_id>minsi</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>281f401d-a0c3-4a33-950b-e4a70729429d</subevent_id>
    <title>SPLASH REBASE: 25</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>4cca2560-a0d7-465e-bd72-1d42fa0175e8</slot_id>
      <title>Session: SPLASH REBASE - 25</title>
      <room>Online | Rebase</room>
      <date>2020/11/20</date>
      <start_time>05:00</start_time>
      <end_time>05:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>92c6aa5e-2cde-4f4c-94ba-c2ca72048f65</slot_id>
      <event_id>eb49d071-bd76-4216-8ac6-0fc3cf3a7f99</event_id>
      <title>Enterprise-scale static analysis: A Pinpoint experience</title>
      <room>Online | Rebase</room>
      <date>2020/11/20</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>05:40</end_time>
      <description>Despite years of research and practice, modern static analysis techniques still cannot detect oldest and extremely well understood software bugs such as the Heartbleed, one of the most “spectacular” security flaws of the recent decade. A remedy, as what we have attempted through the successful commercialization of the Pinpoint platform (PLDI 18), is to make static program analysis aware of the basic characteristics of the modern enterprise-scale software system. The talk focuses on discussing these characteristics and how Pinpoint addresses them pragmatically as well as its future directions. Pinpoint is a LLVM-based cross-language static analysis platform and deployed in major Chinese tech companies such as Tencent, Baidu, Huawei, and Alibaba.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Charles</first_name>
          <last_name>Zhang</last_name>
          <affiliation>The Hong Kong University of Science and Technology</affiliation>
          <bio>My general research interest centers around the use of both static and dynamic programming analysis techniques for making complex software systems more secure and reliable. I’m an Associate Professor and director of the Cybersecurity Lab at HKUST. My research received an ICSE and a PLDI distinguished paper award, as well as the ACM SIGSOFT Doctoral Dissertation Award, and IBM PhD fellowships. I co-founded and served as the chairman of Sourcebrella Inc, a static analysis tool vendor.</bio>
          <homepage_url>http://www.cse.ust.hk/~charlesz</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/charleszhang/059321fa-d896-44bf-b4a8-02ec597c0b3b/small.jpg</picture_url>
          <person_id>charleszhang</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2c1ad239-8a92-4038-bc1b-5adae9f50edf</subevent_id>
    <title>SPLASH REBASE: 30</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>ba185812-5f2b-46ae-a4bb-2960aaf2d9a1</slot_id>
      <title>Session: SPLASH REBASE - 30</title>
      <room>Online | Rebase</room>
      <date>2020/11/20</date>
      <start_time>13:00</start_time>
      <end_time>13:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a5428976-4028-4b07-b6c6-0adf43015ae2</slot_id>
      <event_id>31254170-da2a-4537-8030-95b74ed3df9d</event_id>
      <title>Variant analysis</title>
      <room>Online | Rebase</room>
      <date>2020/11/20</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>13:40</end_time>
      <description>In security, ‘variant analysis’ is the process of searching for variants of known vulnerabilities. This used to be done with grep and painstaking manual code audits, but it can be automated with a powerful semantic query language like CodeQL. The idea of such a query language had been around in academic research for a long time, but we had to create a startup named Semmle to make CodeQL reality. Semmle was acquired by GitHub in September 2019. I’ll show with a few in-depth examples how security researchers have used the CodeQL product to find and fix many vulnerabilities in popular open source projects. I’ll also discuss why the focus on variant analysis was a critical step in making Semmle a successful startup company. Finally, I’ll explain why the experience of creating Semmle and CodeQL convinced me that blue skies research goes fastest with user needs driving the research agenda.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Oege</first_name>
          <last_name>de Moor</last_name>
          <affiliation>Semmle</affiliation>
          <bio>Oege de Moor is the CEO and Founder of Semmle. Semmle’s mission is to secure the software that runs the world. From 1994 to 2014, Oege was a professor of computer science at the University of Oxford, where he did research in programming languages and tools. Semmle’s products are used by Microsoft, Google, NASA, NASDAQ, Credit Suisse, Dell, and many other leading software organisations. It has offices in Oxford, Copenhagen, Valencia, New York, San Francisco and Seattle. The technology at Semmle is a fun combination of deep theory (if you like lattice theory, you’ll like our engine), good engineering (making it work on some of the largest code bases on the planet) and cool applications (like the 0-days we report in open source). Semmle is always on the look-out for new team members.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/oegedemoor/8ea496f6-779b-47b3-9df9-6e7d2ad698eb/small.jpg</picture_url>
          <person_id>oegedemoor</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a89dc9b7-acdc-4e1d-87b7-9450bf78cd2c</subevent_id>
    <title>SPLASH REBASE: 5</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>3dbfb017-faee-42b7-b263-d9b21c2ccd00</slot_id>
      <title>Session: SPLASH REBASE - 5</title>
      <room>Online | Rebase</room>
      <date>2020/11/15</date>
      <start_time>17:00</start_time>
      <end_time>17:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>be1ae549-530d-4547-b581-525cf4ffa505</slot_id>
      <event_id>04f10f98-8485-40ec-8ac4-3c6c4925b7b5</event_id>
      <title>APIs are Illness and Cure: The Software Heterogeneity Problem in Web Programming</title>
      <room>Online | Rebase</room>
      <date>2020/11/15</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>17:40</end_time>
      <description>It is easier than ever before to build complex web applications. But developer tooling for understanding, testing, and maintaining these systems has not caught up. Something I heard over and over again when starting Akita was that developers could log, measure, monitor, but they have a hard time understanding what was really going on with their software systems. A major challenge comes from the fact that modern web applications run across many heterogenous components, often communicating via remote procedure calls. Current software analysis methods do not work here, as network calls across heterogeneous components subvert language-level modelings. And using network tools alone do not yield the full picture. The result is that developers end up piecing the whole story together through reading code, logs, and documentation. At Akita, we observe that network-based application programming interfaces (APIs) are both a root cause of what we call the Software Heterogeneity Problem—and also the key to the solution. The proliferation of APIs for both internal and external use, with the rise of service-oriented architectures and the growth of the API economy, have made it easy to quickly build applications that are amalgams of cross-service network calls. At the same time, there is consolidation around a handful of interface definition languages for web APIs. This makes it possible for us to address the Software Heterogeneity problem by applying programming languages techniques at the API layer. In this talk, I will introduce the Software Heterogeneity Problem, show how we at Akita are solving this problem at the API layer, and outline API-level PL problems we can solve as a community.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jean</first_name>
          <last_name>Yang</last_name>
          <affiliation>Akita Software</affiliation>
          <bio>Hi there. I’m Jean. I started Akita because I wanted to build practical, principled tooling for modern software systems. I’ve spent my career in pursuit of better software tools. I grew up programming—and it felt like magic that a kid like me could just conjure software. In college, I fell in love with programming tools: helping people make magic faster felt like pretty much the coolest thing a person could do. This was why I got my PhD in programming languages, at MIT. After that, I was a tenure-track professor at Carnegie Mellon University. The whole time I was in research, I wanted to build tools that could majorly help practicing software developers. Early in my PhD, I got obsessed with two problems around this that I couldn’t solve using application-level techniques. First, the legacy software problem: you can’t just easily port most code to a fancy new language or type system. And even if you could, you run into the second problem: the heterogeneity of software systems. Modern software is an ecosystem, with your data stores, data streams, services, and third-party APIs. This is how I became obsessed with APIs: APIs let you encapsulate any code written in any language—and you can apply language design principles, just one zoom level up. This is why, while at CMU, I started doing research about APIs. This takes us to Spring 2018. Cambridge Analytica happened. GDPR was just about to come out. I realized that we were entering into a new era of software, where people were realizing that not having visibility or control over your software can hold you back in a major way. I called everyone on my LinkedIn who would talk to me and asked them about their tooling needs. When I realized there were big and interesting problems I was uniquely positioned to solve with my API tooling ideas, I just couldn’t miss out on the action. I took leave from CMU, sold my furniture, and drove across the country to the Bay Area to start Akita.</bio>
          <homepage_url>http://jeanyang.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeanyang/be7879c9-e0d3-4a7c-af5c-7aec4693cc67/small.jpg</picture_url>
          <person_id>jeanyang</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>90c2ac04-3fb6-4d05-8cae-b62804efb6b6</subevent_id>
    <title>SPLASH REBASE: 25</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>c0524c08-96bf-4fe6-a5c4-502795e0ac12</slot_id>
      <title>Session: SPLASH REBASE - 25</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>17:00</start_time>
      <end_time>17:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ba880232-4415-45c8-8e0b-52b094937484</slot_id>
      <event_id>eb49d071-bd76-4216-8ac6-0fc3cf3a7f99</event_id>
      <title>Enterprise-scale static analysis: A Pinpoint experience</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>17:40</end_time>
      <description>Despite years of research and practice, modern static analysis techniques still cannot detect oldest and extremely well understood software bugs such as the Heartbleed, one of the most “spectacular” security flaws of the recent decade. A remedy, as what we have attempted through the successful commercialization of the Pinpoint platform (PLDI 18), is to make static program analysis aware of the basic characteristics of the modern enterprise-scale software system. The talk focuses on discussing these characteristics and how Pinpoint addresses them pragmatically as well as its future directions. Pinpoint is a LLVM-based cross-language static analysis platform and deployed in major Chinese tech companies such as Tencent, Baidu, Huawei, and Alibaba.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Charles</first_name>
          <last_name>Zhang</last_name>
          <affiliation>The Hong Kong University of Science and Technology</affiliation>
          <bio>My general research interest centers around the use of both static and dynamic programming analysis techniques for making complex software systems more secure and reliable. I’m an Associate Professor and director of the Cybersecurity Lab at HKUST. My research received an ICSE and a PLDI distinguished paper award, as well as the ACM SIGSOFT Doctoral Dissertation Award, and IBM PhD fellowships. I co-founded and served as the chairman of Sourcebrella Inc, a static analysis tool vendor.</bio>
          <homepage_url>http://www.cse.ust.hk/~charlesz</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/charleszhang/059321fa-d896-44bf-b4a8-02ec597c0b3b/small.jpg</picture_url>
          <person_id>charleszhang</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d1ceef15-ea86-41b7-97f9-09c711066091</subevent_id>
    <title>SPLASH REBASE: 22</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>9af27c73-2e24-48d6-9854-0b20099029bf</slot_id>
      <title>Session: SPLASH REBASE - 22</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>11:00</start_time>
      <end_time>11:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0e7001b7-a203-4748-b093-803bd69d06ec</slot_id>
      <event_id>dc0729ca-9f38-4990-9628-8170b60af78e</event_id>
      <title>Intermittent Computer Systems on Earth and in Space</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>11:40</end_time>
      <description>Intermittent computing is an emerging computational model that allows software to operate reliably on devices that harvest energy from their environment. Energy-harvesting frees devices from the need for batteries, battery replacements, tethered power, and regular maintenance, enabling deployment to far remote installations, such as in civil infrastructure and outer space. This does not come for free: power failures impede progress and can leave a system’s memory and execution state inconsistent. Unpredictable future energy availability, and the difficulty of precisely characterizing device power consumption makes building a reliable intermittent system a challenge. I describe our experience with intermittent computing. I describe our recent efforts to mathematically formalize the behavior of intermittent software execution, and lessons learned from these formal modeling efforts. I discuss concrete incarnations of our intermittent and energy-harvesting computing results: a terrestrial, long-range batteryless camera system with the ability to do on-device machine learning and transmit over 10km distances with no batteries and two tiny, intermittent computing nanosatellites that sense, compute on sensor data, and communicate with Earth.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Brandon</first_name>
          <last_name>Lucia</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Brandon is a Professor at Carnegie Mellon University working on hardware and software computer systems to answer the question: “How capable can a computing system be, given physical restrictions on its form factor, input power, energy storage, or other resource constraints?” His research has been recognized with 8 best paper awards, the 2019 IEEE TCCA Young Computer Architect Award and the 2015 Bell Labs Prize.</bio>
          <homepage_url>http://brandonlucia.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brandonlucia/e10fc900-d74f-44e7-a793-5e2f21a7dd0b/small.jpg</picture_url>
          <person_id>brandonlucia</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1dc261ca-c682-49ea-84cc-b9826da542b6</subevent_id>
    <title>SPLASH REBASE: 6</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>122b6c78-dd81-4895-ba8b-21e372c50dc0</slot_id>
      <title>Session: SPLASH REBASE - 6</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>07:00</start_time>
      <end_time>07:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e3d053d8-a95e-4ecb-ba59-385525e014d7</slot_id>
      <event_id>f62da32e-6fe2-4aae-a89f-747447ef4bac</event_id>
      <title>Reliable Stack Traces, the Reality of Myth</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>07:40</end_time>
      <description>Debug information is a hidden and obscure component of our computing infrastructure obviously used by debuggers, but also playing a key role in program analysis tools, and, most surprisingly, in the runtime of programming languages. For instance C++ leverages DWARF stack unwind tables to implement exceptions! Alas, generating debug information adds significant burden to compilers, and the debug info itself can be pervaded by subtle bugs, making the whole infrastructure unreliable. Additionally, interpreting the debug tables is a bottleneck. My talk focuses on the DWARF unwind table, that enables stack unwinding in absence of frame-pointer information. I show two techniques to perform validation and synthesis of unwinding tables, and their implementation for x86_64. Our validator has proven effective for compiler and inline assembly testing, while the synthesis tool can generate unwind tables for arbitrary binaries lacking debug information. Additionally, I will report on a technique to precompile unwind tables into native x86_64 code, which we have implemented and integrated into libunwind, resulting in a 25x DWARF-based unwind speedup.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Zappa Nardelli</last_name>
          <affiliation>Facebook</affiliation>
          <bio>My work is at boundaries between programming languages, system programming, and computer architectures, with the overall goal of producing systems which are better-understood, more robust, and more secure.</bio>
          <homepage_url>https://fzn.fr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/francescozappanardelli/e7d164ff-66ed-4309-b99f-60e2f77f7b02/small.jpg</picture_url>
          <person_id>francescozappanardelli</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>93ab618f-38c3-41ec-84da-e489b559bd0e</subevent_id>
    <title>SPLASH REBASE: 4</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>d2c44eaf-3742-4249-b404-2a1094d2869b</slot_id>
      <title>Session: SPLASH REBASE - 4</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>01:00</start_time>
      <end_time>01:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>28f00528-e62f-45d5-9f30-893405c4b3bd</slot_id>
      <event_id>9ca583dd-05ba-44fc-b913-6a78719ea4e0</event_id>
      <title>A Ray of Hope: Array Programming for the 21st Century</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>01:40</end_time>
      <description>The ideas of APL and its successors, the array programming languages, were two generations ahead of their time.&amp;nbsp; These languages are based on the notion that everything is a tensor, and all operations are rank-polymorphic: they extend automatically to tensors of any rank. These ideas are perfectly suited to an era of machine learning, large scale data, GPUs and other accelerators. Building on recent academic research, we are building ShapeRank, a new statically typed, purely functional language for industrial use, that extends rank-polymorphism to streams. We’ll introduce the key ideas and show how they are realized in ShapeRank.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gilad</first_name>
          <last_name>Bracha</last_name>
          <affiliation>F5 Networks</affiliation>
          <bio>Gilad Bracha is the creator of the Newspeak programming language and a well known researcher in the area of object-oriented programming languages. He was awarded the senior Dahl-Nygaard prize in 2017. Previously, he has worked at Google, as a VP at SAP Labs in Palo Alto, a Distinguished Engineer at Cadence, and a Computational Theologist and Distinguished Engineer at Sun. He has authored or co-authored several books including the Java Language and Virtual Machine Specifications, and the Dart Programming Language. Prior to joining Sun, he worked on Strongtalk, the Animorphic Smalltalk System. He received his B.Sc in Mathematics and Computer Science from Ben Gurion University in Israel and a Ph.D. in Computer Science from the University of Utah.</bio>
          <homepage_url>https://bracha.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/giladbracha/66fe962c-9388-4df3-aaaa-677a8e2e64df/small.jpg</picture_url>
          <person_id>giladbracha</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>03a8bcb6-ef58-4382-b484-d92d9776fb4e</subevent_id>
    <title>SPLASH REBASE: 13</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>49709cee-89ce-42e9-8a7c-0f6a83a15158</slot_id>
      <title>Session: SPLASH REBASE - 13</title>
      <room>Online | Rebase</room>
      <date>2020/11/17</date>
      <start_time>13:00</start_time>
      <end_time>13:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>93ca958a-5ffd-4242-8785-dd91bf50965d</slot_id>
      <event_id>e076a4e6-6258-4908-8dc8-3802e89a0f59</event_id>
      <title>Developing the Wolfram Language Compiler</title>
      <room>Online | Rebase</room>
      <date>2020/11/17</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:40</end_time>
      <description>The Wolfram Language is a high level computation language used in many technical, scientific, engineering, mathematical, and computing fields. It is widely used in practice and, in particular, it is the foundation of Wolfram Mathematica and Wolfram Alpha. This talk describes the Wolfram Language Compiler; a long term project for compilation of Wolfram programs. The talk will show how clever use of parametric types, code specialization, and optimization techniques allow compilation of Wolfram Language programs to achieve performance that rivals hand-tuned C code. It will show how the compiler enables features for scientific computation (such as automatic differentiation) and how it provides a key new implementation layer for future development of the language. It will also show how the type system allows disambiguating and optimizing function calls despite seemingly ambiguous input. Finally, it will demonstrate how the Wolfram compiler is used to target specialized output such as WebAssembly) or accelerators (e.g. CUDA or FPGAs).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tom</first_name>
          <last_name>Wickham-Jones</last_name>
          <affiliation>Wolfram Research, Inc.</affiliation>
          <bio>Tom Wickham-Jones has worked for Wolfram Research on the implementation of Mathematica since 1990. He is currently the Director of Kernel Technology. He has worked on many details of the Mathematica programming language, as well as other areas such as graphics. In addition he is the architect of webMathematica and Wolfram Workbench. In 1992 he published the book Mathematica Graphics: Techniques and Applications. His most recent work has focused on the Mathematica compiler and parallel computation.</bio>
          <homepage_url>https://www.linkedin.com/in/tom-wickham-jones-a452777</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomwickhamjones/21c29c5a-05a7-4519-9853-7f0b38511ed9/small.jpg</picture_url>
          <person_id>tomwickhamjones</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bf227431-8525-4654-aaf7-60679c07b2aa</subevent_id>
    <title>SPLASH REBASE: 20</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>8fb8a3a7-1528-4ea6-bb6d-24bc4fd988cf</slot_id>
      <title>Session: SPLASH REBASE - 20</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>17:00</start_time>
      <end_time>17:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7d8eee74-943d-4ee4-a6b9-beccd5ddbe6f</slot_id>
      <event_id>4b457c84-3b99-44ca-afaa-f1811e462b6e</event_id>
      <title>Tales from the Frontlines: Startup War Stories</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>17:40</end_time>
      <description>Can one build the Hotspot VM, the Azul GC and the H20 big data engine without getting into the occasional battle and making a mistake or two? This talk distill the lessons of success and wrings wisdom out of failures over three decades in the industy.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cliff</first_name>
          <last_name>Click</last_name>
          <affiliation>Self</affiliation>
          <bio>Cliff Click was the CTO and Co-Founder of H2O, makers of H2O, the open source math and machine learning engine for Big Data. Cliff wrote his first compiler when he was 15 (Pascal to TRS Z-80!), although Cliff’s most famous compiler is the HotSpot Server Compiler (the Sea of Nodes IR). Cliff helped Azul Systems build an 864 core pure-Java mainframe that keeps GC pauses on 500Gb heaps to under 10ms, and worked on all aspects of that JVM. Before that he worked on HotSpot at Sun Microsystems, and was at least partially responsible for bringing Java into the mainstream. Cliff is invited to speak regularly at industry and academic conferences and has published many papers about HotSpot technology. He holds a PhD in Computer Science from Rice University and about 20 patents.</bio>
          <homepage_url>http://cliffc.org/blog/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cliffclick/73d11404-ae6e-4004-80e3-b75f7f40656b/small.jpg</picture_url>
          <person_id>cliffclick</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>70e64597-f8bb-4aed-81f0-f1873647ca1f</subevent_id>
    <title>SPLASH REBASE: 13</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>2cddbd0f-cf81-4749-8a48-7745a8c8bb85</slot_id>
      <title>Session: SPLASH REBASE - 13</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>01:00</start_time>
      <end_time>01:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>77fc7582-3b07-4b4d-a619-bc4e24bcb44e</slot_id>
      <event_id>e076a4e6-6258-4908-8dc8-3802e89a0f59</event_id>
      <title>Developing the Wolfram Language Compiler</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:40</end_time>
      <description>The Wolfram Language is a high level computation language used in many technical, scientific, engineering, mathematical, and computing fields. It is widely used in practice and, in particular, it is the foundation of Wolfram Mathematica and Wolfram Alpha. This talk describes the Wolfram Language Compiler; a long term project for compilation of Wolfram programs. The talk will show how clever use of parametric types, code specialization, and optimization techniques allow compilation of Wolfram Language programs to achieve performance that rivals hand-tuned C code. It will show how the compiler enables features for scientific computation (such as automatic differentiation) and how it provides a key new implementation layer for future development of the language. It will also show how the type system allows disambiguating and optimizing function calls despite seemingly ambiguous input. Finally, it will demonstrate how the Wolfram compiler is used to target specialized output such as WebAssembly) or accelerators (e.g. CUDA or FPGAs).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tom</first_name>
          <last_name>Wickham-Jones</last_name>
          <affiliation>Wolfram Research, Inc.</affiliation>
          <bio>Tom Wickham-Jones has worked for Wolfram Research on the implementation of Mathematica since 1990. He is currently the Director of Kernel Technology. He has worked on many details of the Mathematica programming language, as well as other areas such as graphics. In addition he is the architect of webMathematica and Wolfram Workbench. In 1992 he published the book Mathematica Graphics: Techniques and Applications. His most recent work has focused on the Mathematica compiler and parallel computation.</bio>
          <homepage_url>https://www.linkedin.com/in/tom-wickham-jones-a452777</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomwickhamjones/21c29c5a-05a7-4519-9853-7f0b38511ed9/small.jpg</picture_url>
          <person_id>tomwickhamjones</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>947127c4-e78b-4f98-8e17-ddbbbf3f519c</subevent_id>
    <title>SPLASH REBASE: 8</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>5d5f1c1a-c3c6-4880-9020-d803accbd389</slot_id>
      <title>Session: SPLASH REBASE - 8</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>23:00</start_time>
      <end_time>23:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e2d50cc1-354c-4541-b1d6-9d002b364a9c</slot_id>
      <event_id>9909752f-2f85-4ed3-abab-a13ebbc9e912</event_id>
      <title>Herding Nulls in Dart</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>23:40</end_time>
      <description>The programming language Dart is about to introduce sound null safety, which involves a bundle of language mechanisms associated with null as a typing property. This talk presents these mechanisms, including nullable types, late variables, type promotion, null shorting, and the handling of programs with both legacy and null safe libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Erik</first_name>
          <last_name>Ernst</last_name>
          <affiliation>Google Inc.</affiliation>
          <bio>Erik Ernst is a member of the Dart language team at Google, maintaining the language specification. He has been an associate professor at Aarhus University. He has published research on virtual classes, establishing that they can be statically safe. He introduced family polymorphism, which is foundational for path dependent types, and he contributed to the introduction of generics is Java.</bio>
          <homepage_url>https://scholar.google.com/citations?user=L-i5BHcAAAAJ&amp;hl=en</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/erikernst/dbb8033d-763a-4571-90ef-c750ed5f597b/small.jpg</picture_url>
          <person_id>erikernst</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3c18ec84-815a-4d1c-ad30-8c482dda958b</subevent_id>
    <title>SPLASH REBASE: 16</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>2434986c-0885-4bed-9226-566ed4d284d9</slot_id>
      <title>Session: SPLASH REBASE - 16</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>07:00</start_time>
      <end_time>07:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5a6177c9-0085-44f8-ae73-ef07867b86db</slot_id>
      <event_id>f8bcf094-fae6-48e2-b07b-243759ea945b</event_id>
      <title>Miniaturize All States!</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>07:40</end_time>
      <description>Like science, software is in reproducibility crisis. All too often, “steps to reproduce” in bug reports don’t work or are too long and complicated. They shouldn’t be necessary to begin with. Fleets of servers suffer from constant “configuration drift”, making any incremental change to their state hazardous. Will an upgrade that worked yesterday work today? Will it work for you if it worked for me? We’re never quite sure. Lack of reproducibility hinders sharing, from lab reports to bug reports to build instructions to software packages to cloud infrastructure. The solution: miniaturizing the inputs to your lab experiment and to your build bots, the state of your laptop and of your resources in the cloud, using precise, shareable, composable declarative specifications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mathieu</first_name>
          <last_name>Boespflug</last_name>
          <affiliation>Tweag I/O</affiliation>
          <bio>Mathieu is the CEO of Tweag I/O, an independent industrial lab helping startups and research groups within the enterprise boldly ship high-risk, high-reward digital products. He was involved in European initiatives for exascale storage, worked on build systems, programming language interop and compilers. In a previous life, Mathieu was a researcher in formal methods and programming language design. He has a PhD from École Polytechnique.</bio>
          <homepage_url>https://www.linkedin.com/in/mboes</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mathieuboespflug/d01c0846-8cf1-41ab-bbbd-2aa6beba122b/small.jpg</picture_url>
          <person_id>mathieuboespflug</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>38269062-ab8c-4df0-b4e6-8f810e5e72e0</subevent_id>
    <title>SPLASH REBASE: 24</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>7dc201fd-9d71-40d2-8297-65f44bc68e41</slot_id>
      <title>Session: SPLASH REBASE - 24</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>15:00</start_time>
      <end_time>15:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>63e997e3-d18e-44eb-bff7-9b9d20dcd2c4</slot_id>
      <event_id>e57184bb-0544-49be-bf26-5c1369670c39</event_id>
      <title>On the Future of Flight Software</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>15:40</end_time>
      <description>In recent years, mishaps in commercial aviation have been predominantly due to software; meanwhile software continues to grow more complex. Combining this with the on-going trend toward converting aviation hardware and mechanical systems to software, and the popular claim that aircraft are already more than half software, it is clear that the future of flight software faces a formidable challenge. The FAA provides regulations through documents such as DO-333, but little guidance as to how to achieve them. In short: for software to be certified to fly, the chance of a safety-critical failure must be less than one in a billion. So how do we do that? Particularly how do we achieve a sustainable, scalable schema for future avionics? We will overview the difficulties that face fabricating formidable flight software, break out the challenges facing future flight software, and pose possibilities for boldly going where no software has gone before.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kristin</first_name>
          <last_name>Yvonne Rozier</last_name>
          <affiliation>Iowa State University</affiliation>
          <bio>NSF CAREER Award winner and recipient of the Inaugural Initiative-Inspiration-Impact Award from Women in Aerospace, Kristin Yvonne Rozier joined the faculty of the Aerospace Engineering and CS in Fall, 2016. Previous to that she spent 14 years as a Research Scientist at NASA. She contributed research to the Aeroacoustics, and Safety-Critial Avionics groups and to the Robust Software Engineering, and Discovery and Systems Health groups in the Intelligent Systems Division. Most recently, Rozier was a primary contributing researcher to the Next Generation Air Transportation System (NextGen) Air Traffic Management project of the Airspace Systems Program at NASA. She also served as Principal Investigator of an ARMD Seedling project advancing System and Safety Health Management for Unmanned Aerial Systems (UAS).</bio>
          <homepage_url>https://www.aere.iastate.edu/kyrozier/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/kristinyvonnerozier/6da96576-6d4d-492d-8631-0d8ef350b15a/small.jpg</picture_url>
          <person_id>kristinyvonnerozier</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9ae02012-545e-42d5-a4b2-7021174609a9</subevent_id>
    <title>SPLASH REBASE: 5</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>d0a525a0-27df-429c-a06b-58925cb6f79e</slot_id>
      <title>Session: SPLASH REBASE - 5</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>05:00</start_time>
      <end_time>05:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>97cb1ee1-7e4e-4fba-9bd6-306c8705ac98</slot_id>
      <event_id>04f10f98-8485-40ec-8ac4-3c6c4925b7b5</event_id>
      <title>APIs are Illness and Cure: The Software Heterogeneity Problem in Web Programming</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>05:40</end_time>
      <description>It is easier than ever before to build complex web applications. But developer tooling for understanding, testing, and maintaining these systems has not caught up. Something I heard over and over again when starting Akita was that developers could log, measure, monitor, but they have a hard time understanding what was really going on with their software systems. A major challenge comes from the fact that modern web applications run across many heterogenous components, often communicating via remote procedure calls. Current software analysis methods do not work here, as network calls across heterogeneous components subvert language-level modelings. And using network tools alone do not yield the full picture. The result is that developers end up piecing the whole story together through reading code, logs, and documentation. At Akita, we observe that network-based application programming interfaces (APIs) are both a root cause of what we call the Software Heterogeneity Problem—and also the key to the solution. The proliferation of APIs for both internal and external use, with the rise of service-oriented architectures and the growth of the API economy, have made it easy to quickly build applications that are amalgams of cross-service network calls. At the same time, there is consolidation around a handful of interface definition languages for web APIs. This makes it possible for us to address the Software Heterogeneity problem by applying programming languages techniques at the API layer. In this talk, I will introduce the Software Heterogeneity Problem, show how we at Akita are solving this problem at the API layer, and outline API-level PL problems we can solve as a community.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jean</first_name>
          <last_name>Yang</last_name>
          <affiliation>Akita Software</affiliation>
          <bio>Hi there. I’m Jean. I started Akita because I wanted to build practical, principled tooling for modern software systems. I’ve spent my career in pursuit of better software tools. I grew up programming—and it felt like magic that a kid like me could just conjure software. In college, I fell in love with programming tools: helping people make magic faster felt like pretty much the coolest thing a person could do. This was why I got my PhD in programming languages, at MIT. After that, I was a tenure-track professor at Carnegie Mellon University. The whole time I was in research, I wanted to build tools that could majorly help practicing software developers. Early in my PhD, I got obsessed with two problems around this that I couldn’t solve using application-level techniques. First, the legacy software problem: you can’t just easily port most code to a fancy new language or type system. And even if you could, you run into the second problem: the heterogeneity of software systems. Modern software is an ecosystem, with your data stores, data streams, services, and third-party APIs. This is how I became obsessed with APIs: APIs let you encapsulate any code written in any language—and you can apply language design principles, just one zoom level up. This is why, while at CMU, I started doing research about APIs. This takes us to Spring 2018. Cambridge Analytica happened. GDPR was just about to come out. I realized that we were entering into a new era of software, where people were realizing that not having visibility or control over your software can hold you back in a major way. I called everyone on my LinkedIn who would talk to me and asked them about their tooling needs. When I realized there were big and interesting problems I was uniquely positioned to solve with my API tooling ideas, I just couldn’t miss out on the action. I took leave from CMU, sold my furniture, and drove across the country to the Bay Area to start Akita.</bio>
          <homepage_url>http://jeanyang.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jeanyang/be7879c9-e0d3-4a7c-af5c-7aec4693cc67/small.jpg</picture_url>
          <person_id>jeanyang</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>116bc97c-46c4-4f50-b1dc-1a0831a2cf9f</subevent_id>
    <title>SPLASH REBASE: 30</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>84089aec-329e-44fd-a394-106178a52849</slot_id>
      <title>Session: SPLASH REBASE - 30</title>
      <room>Online | Rebase</room>
      <date>2020/11/21</date>
      <start_time>01:00</start_time>
      <end_time>01:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>250d32d2-3d46-4748-978b-2881bf0456d0</slot_id>
      <event_id>31254170-da2a-4537-8030-95b74ed3df9d</event_id>
      <title>Variant analysis</title>
      <room>Online | Rebase</room>
      <date>2020/11/21</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>01:40</end_time>
      <description>In security, ‘variant analysis’ is the process of searching for variants of known vulnerabilities. This used to be done with grep and painstaking manual code audits, but it can be automated with a powerful semantic query language like CodeQL. The idea of such a query language had been around in academic research for a long time, but we had to create a startup named Semmle to make CodeQL reality. Semmle was acquired by GitHub in September 2019. I’ll show with a few in-depth examples how security researchers have used the CodeQL product to find and fix many vulnerabilities in popular open source projects. I’ll also discuss why the focus on variant analysis was a critical step in making Semmle a successful startup company. Finally, I’ll explain why the experience of creating Semmle and CodeQL convinced me that blue skies research goes fastest with user needs driving the research agenda.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Oege</first_name>
          <last_name>de Moor</last_name>
          <affiliation>Semmle</affiliation>
          <bio>Oege de Moor is the CEO and Founder of Semmle. Semmle’s mission is to secure the software that runs the world. From 1994 to 2014, Oege was a professor of computer science at the University of Oxford, where he did research in programming languages and tools. Semmle’s products are used by Microsoft, Google, NASA, NASDAQ, Credit Suisse, Dell, and many other leading software organisations. It has offices in Oxford, Copenhagen, Valencia, New York, San Francisco and Seattle. The technology at Semmle is a fun combination of deep theory (if you like lattice theory, you’ll like our engine), good engineering (making it work on some of the largest code bases on the planet) and cool applications (like the 0-days we report in open source). Semmle is always on the look-out for new team members.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/oegedemoor/8ea496f6-779b-47b3-9df9-6e7d2ad698eb/small.jpg</picture_url>
          <person_id>oegedemoor</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>43842c92-31f5-4b22-a784-0585fa02ba6c</subevent_id>
    <title>SPLASH REBASE: 7</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>9f0394cd-6e98-4725-ac58-a965963268dc</slot_id>
      <title>Session: SPLASH REBASE - 7</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>11:00</start_time>
      <end_time>11:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b0991f43-b304-41b2-9c49-c4133ce6a055</slot_id>
      <event_id>0afb2ceb-8556-4b8b-a17f-1c5eb0d00ffc</event_id>
      <title>Paparazzi, an open source UAV for research</title>
      <room>Online | Rebase</room>
      <date>2020/11/16</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>11:40</end_time>
      <description>Unmanned Aerial Systems have rapidly reached the maturity allowing them to be used in many civil applications. Open-source communities and research laboratories have played an important role to this breakthrough in aviation history. I will present the Paparazzi UAV system, a research oriented fully open-source hardware and software project dedicated to mini and micro drones. Through its rich history of collaborations, I will show how our laboratory and our community have been able to contribute to various HMI innovations, rich flight plan concepts, novel aerodynamic designs, efficient and robust control algorithms and many multi-disciplinary applications spreading the usage of drones in various scientific fields. This has been made possible by seeking the right balance between innovations, experimental needs, real world operations and more fundamental contributions. Finally, I will point to some of the future challenges for light UAV systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gautier</first_name>
          <last_name>Hattenberger</last_name>
          <affiliation>ENAC</affiliation>
          <bio>Gautier Hattenberger is an assistant-professor at the French Civil Aviation University (ENAC) in Toulouse, France. As a member of the UAV Research Program, he is working on flight dynamics and control of micro-UAVs, modeling and simulation, architecture of embedded systems, trajectory planing and formation flight. Most of his work is based on the Open-Source UAV system “Paparazzi”, for which he is now one of the head developer. He graduate from the French national engineering school of aeronautical construction in 2004 and received his Ph.D Degree at the Robotic department of the Laboratory for Analysis and Architecture of Systems (LAAS-CNRS, Toulouse), for his work on formation flight control and planing of UAVs in 2008.</bio>
          <homepage_url>http://optim.recherche.enac.fr/?staff-member=gautier-hattenberger</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gautierhattenberger/a799856f-c948-40c1-8ee2-aab746ddb41b/small.jpg</picture_url>
          <person_id>gautierhattenberger</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>53307b8a-e386-451c-aff4-3189ce645d7f</subevent_id>
    <title>SPLASH REBASE: 29</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>0ef8812d-80ad-4365-8610-24721a7e5fa3</slot_id>
      <title>Session: SPLASH REBASE - 29</title>
      <room>Online | Rebase</room>
      <date>2020/11/20</date>
      <start_time>23:00</start_time>
      <end_time>23:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>71b041b3-84fa-47fe-aecc-32716b5df0a1</slot_id>
      <event_id>0b5c7264-a9ac-43c5-b25b-baff765650af</event_id>
      <title>Co-Design for High-Performance Computing Software Systems</title>
      <room>Online | Rebase</room>
      <date>2020/11/20</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>23:40</end_time>
      <description>High-performance computing (HPC) systems are designed for pursuing extreme-scale parallelism and computational power to accelerate various computational-expensive applications in scientific computing. HPC software stack is deep and wide, mainly due to the complex computational requirements from various domain-specific algorithms and the diverse capacities provided by the underlying hardware architecture. For instance, domain-specific language or multi-layer runtime library is a common approach for developers to decouple the complex scientific algorithms from parallel programming (i.e., deep). To fully utilize different hardware components, different parallel programming models and runtime subsystems often coexist in an application software stack such as the popular MPI + “X” programming model (i.e., wide). Although abstraction allows developers and researchers to isolate innovations for different software components, experiences have indicated that co-design is the key strategy to achieve exascale computing and beyond. Co-design across the deep and wide HPC software stack is a very challenging task. However, the potential performance gain can be significant. In this talk, I will share the experiences and insights from several projects that explored the co-design approach across applications and parallel runtime subsystems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Min</first_name>
          <last_name>Si</last_name>
          <affiliation>Argonne National Laboratory</affiliation>
          <bio>Dr. Min Si is an Assistant Computer Scientist at Argonne National Laboratory working with the Programming Models and Runtime Systems group. Min’s research interests include communication runtime in high-performance computing and parallel programming models. Min was previously an Enrico Fermi Postdoctoral Scholar of Argonne National Laboratory. She received the Ph.D. degree in computer science from the University of Tokyo. Her doctoral dissertation focused on the optimization of high performance message passing communication on massively parallel multi-/many-core architectures. Min is the recipient of the 2018 IEEE-CS Technical Consortium on High Performance Computing (TCHPC) Early Career Researchers Award for Excellence in High Performance Computing, and won the Karsten Schwan Best Paper Award at HPDC 2018.</bio>
          <homepage_url>https://www.mcs.anl.gov/~minsi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/minsi/b566ccd5-1498-4770-923d-94635bfad191/small.jpg</picture_url>
          <person_id>minsi</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ba3a9726-6d5d-4832-8f7d-bee00b86b655</subevent_id>
    <title>SPLASH REBASE: 28</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>82bd82b7-a303-4e7d-a681-dfa99ac2c134</slot_id>
      <title>Session: SPLASH REBASE - 28</title>
      <room>Online | Rebase</room>
      <date>2020/11/20</date>
      <start_time>21:00</start_time>
      <end_time>21:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>89f41788-cb17-48ed-a6cf-3c08a0a92cc9</slot_id>
      <event_id>fbb11428-c9f3-4c7b-8395-2c4f79d8f397</event_id>
      <title>Performance Really Matters</title>
      <room>Online | Rebase</room>
      <date>2020/11/20</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>21:40</end_time>
      <description>Performance clearly matters to users. For example, the most common software update on the AppStore is “Bug fixes and performance enhancements.” Now that Moore’s Law has ended, programmers have to work hard to get high performance for their applications. But why is performance hard to deliver? I will first explain why current approaches to evaluating and optimizing performance don’t work. I’ll show how complicated performance has become on modern systems, and how compiler optimizations have essentially run out of steam. Next, I’ll introduce two radically new performance profilers that guide programmers directly to the code they need to change to improve application performance. The first is Coz, a new “causal profiler” for C/C++/Rust that lets programmers optimize for throughput or latency, and which pinpoints and accurately predicts the impact of optimizations via what we call “virtual speedup” experiments. Coz’s approach unlocks previously unknown optimization opportunities. Guided by Coz, we improved the performance of applications by as much as 68%; in most cases, this involved modifying less than 10 lines of code and took under half an hour (without any prior understanding of the programs!). Coz now ships as part of standard Linux distros. The second is Scalene, a “scripting-language aware” profiler for Python. Scalene runs orders of magnitude faster than other profilers while delivering far more detailed information – information that’s especially valuable to Python programmers. Via a combination of sampling, inference, and disassembly of byte-codes, Scalene efficiently and precisely attributes execution time and memory usage to Python, which developers can optimize, or library code, which they cannot. Its novel sampling memory allocator efficiently reports line-level memory consumption and trends with low overhead, helping developers reduce footprints and identify leaks. Finally, Scalene reports a new metric, copy volume, that helps developers root out insidious copying costs across the Python/library boundary, which can drastically degrade performance. Scalene is available on PyPi.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Emery</first_name>
          <last_name>Berger</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>Emery is a Professor at the University of Massachusetts Amherst. He researches languages, runtime systems, and operating systems, with a particular focus on systems that transparently improve reliability, security, and performance. Emery and friends have created Hoard, the first scalable memory manager (malloc), on which the Mac OS X memory manager is based; DieHard, an error-avoiding memory manager that directly influenced the design of the Windows 7 Fault-Tolerant Heap; DieHarder, a secure memory manager that was an inspiration for hardening changes made to the Windows 8 heap; the Coz profiler, which ships with modern Linux distros; and more. He was named an ACM Fellow in 2019.</bio>
          <homepage_url>http://www.emeryberger.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/emeryberger/6187feeb-700c-48d5-aceb-6d7b87490a7a/small.jpg</picture_url>
          <person_id>emeryberger</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4af05212-0b1b-4429-bbc2-cde006ae8737</subevent_id>
    <title>SPLASH REBASE: 14</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>52d12bf1-0f87-4777-8b38-1a6231c44ae4</slot_id>
      <title>Session: SPLASH REBASE - 14</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>03:00</start_time>
      <end_time>03:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>861395e1-afd3-4128-b852-f0b7accdb497</slot_id>
      <event_id>3915f558-1e15-450f-b38f-222ffd9da8ca</event_id>
      <title>Quantitative Types in Idris 2</title>
      <room>Online | Rebase</room>
      <date>2020/11/18</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>03:40</end_time>
      <description>Dependent types allow us to express precisely what a function is intended to do. Recent work on Quantitative Type Theory (QTT) extends dependent type systems with linearity, also allowing precision in expressing when a function can run. This is promising, because it suggests the ability to design and reason about resource usage protocols, such as we might find in distributed and concurrent programming, where the state of a communication channel changes throughout program execution. Up to now, however, there has not been a full-scale programming language with which to experiment with these ideas. Idris 2 is a new version of the dependently typed language Idris, with a new core language based on QTT, supporting linear and dependent types. In this talk I will show the benfits of QTT in Idris 2, in particular how it improves interactive program development by reducing the search space for type-driven program synthesis; and, how resource tracking in the type system leads to type-safe concurrent programming with session types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Edwin</first_name>
          <last_name>Brady</last_name>
          <affiliation>University of St. Andrews</affiliation>
          <bio>I am a Lecturer in Computer Science at the University of St Andrews, interested in type theory, dependently typed functional programming, compilers and metaprogramming. I am currently working on a new implementation of Idris, a dependently typed functional programming language. When I’m not doing that, you might find me playing Go (I’m about 2 kyu), walking up a hill, watching a game of cricket, or waiting for a delayed train. I’m afraid I also perpetrated the Whitespace programming language.</bio>
          <homepage_url>https://eb.host.cs.st-andrews.ac.uk</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/edwinbrady/cbff36d2-7476-402e-bc2c-e84d1ceb0ab5/small.jpg</picture_url>
          <person_id>edwinbrady</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e3067d06-12d4-4ae6-b906-efed9f3c4195</subevent_id>
    <title>SPLASH REBASE: 21</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>83385d5f-17e1-4a99-984a-be58fff06b57</slot_id>
      <title>Session: SPLASH REBASE - 21</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>09:00</start_time>
      <end_time>09:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>53904de7-0dae-46cb-9a64-205c7d3008d1</slot_id>
      <event_id>03ce757b-14f2-4cff-96de-d52eb26aa2bf</event_id>
      <title>Relational Reasoning in Object-based Programs</title>
      <room>Online | Rebase</room>
      <date>2020/11/19</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>09:40</end_time>
      <description>Relational properties arise in many settings: relating two versions of a program that use different data representations, noninterference properties for security, conditional equivalence in program transformations, etc. How might one reason about such relational properties? The talk reports on current investigations of a logic based on novel syntax that weaves together product programs to express alignment of control flow points at which relational formulas are asserted. Correctness judgments feature hypotheses with relational specifications, discharged by a rule for the linking of procedure implementations. The logic supports reasoning about program-pairs containing both similar and dissimilar control and data structures. Reasoning about dynamically allocated objects is supported by a frame rule based on frame conditions amenable to SMT provers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anindya</first_name>
          <last_name>Banerjee</last_name>
          <affiliation>National Science Foundation</affiliation>
          <bio>Anindya is a Program Director at the National Science Foundation in the CISE Directorate in the Division of Computing and Communication Foundations (CCF) where he focuses on the issues of Software and Hardware Foundations; Exploiting Parallelism for Scalability; Cyber-physical Systems; Research Experience for Undergraduates; CISE Research Initiation Initiatives. Banerjee’s research interests span software security, software verification, probabilistic programming, semantics and logics of programs, abstract interpretation, program analysis and program transformation. He received his Ph.D. from Kansas State University, USA, in 1995. After his Ph.D., Anindya was a postdoctoral researcher, first in the Labaratoire d’Informatique (LIX) of Ecole Polytechnique, Paris and subsequently at the University of Aarhus. He joined the IMDEA Software Institute in February 2009 as Full Professor. Immediately prior to this position, Anindya was Full Professor of Computing and Information Sciences at Kansas State University, USA. He was an Academic Visitor in the Advanced Programming Tools group, IBM T. J. Watson Research Center in 2007 and a Visiting Researcher in the Programming Languages and Methodology group at Microsoft Research in 2007–2008. He was a recipient of the Career Award of the US National Science Foundation in 2001.</bio>
          <homepage_url>https://www.nsf.gov/staff/staff_bio.jsp?lan=abanerje&amp;org=NSF&amp;from_org=NSF</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anindyabanerjee1/fe921757-de11-449b-9c37-f3c7d07db1bb/small.jpg</picture_url>
          <person_id>anindyabanerjee1</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b9dc3a0b-551b-4ad4-bc33-c5e5d4625713</subevent_id>
    <title>SPLASH REBASE: 32</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>9d303976-60f2-4f3d-a8b1-44facb9b81ef</slot_id>
      <title>Session: SPLASH REBASE - 32</title>
      <room>Online | Rebase</room>
      <date>2020/11/17</date>
      <start_time>09:00</start_time>
      <end_time>09:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fb68692e-7ad7-48ba-b8e2-65d191e99ddc</slot_id>
      <event_id>05a740f8-7a2d-42bb-a92d-7cfa31345b5f</event_id>
      <title>Gillian: a Multi-language Platform for Compositional Symbolic Analysis</title>
      <room>Online | Rebase</room>
      <date>2020/11/17</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>09:40</end_time>
      <description>This talk will give a general introduction to Gillian, a multi-language platform for symbolic program analysis being developed by my team at Imperial College London. Gillian currently supports three types of analysis: whole-program symbolic testing; full verification based on separation logic; and automatic compositional testing based on bi-abduction. It uses a core symbolic execution engine, with strong mathematical foundations, that unifies bug catching and verification. To instantiate Gillian to a new target language (TL), the tool developer must provide: a compiler from the TL to GIL, an intermediate representation which is parametric on the TL memory model: that is, on the set of basic actions capturing the ways in which TL programs fundamentally interact with their memories; an OCaml implementation of the TL memory model using the basic actions; proofs of simple lemmas for the TL basic actions, if interested in correctness guarantees. So far, we have instantiated Gillian to JavaScript and C. These instantiations have been used to: find bugs in the real-world data-structure libraries Buckets.js and Collections-C; find bugs and prove bounded correctness results for a real-world jQuery-like library, cash; and verify the deserialisation function of the AWS Encryption SDK messaging system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Philippa</first_name>
          <last_name>Gardner</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Philippa Gardner is a professor in the Department of Computing at Imperial College London and and has a UKRI Established Fellowship from 2018–2023. Her current research focusses on program verification: in particular, reasoning about Web programs (JavaScript and DOM); and reasoning about concurrent programs. She completed her PhD thesis, supervised by Professor Gordon Plotkin FRS at Edinburgh in 1992 and held five years of fellowships at Edinburgh. She moved to Cambridge in 1998 on an EPSRC Advanced Fellowship, hosted by Professor Robin Milner FRS. She obtained a lectureship at Imperial in 2001, and became professor in 2009. She held a Microsoft Research Cambridge/Royal Academy of Engineering Senior Fellowship from 2005 to 2010 at Imperial. Philippa directs the Research Institute on Verified Trustworthy Software Systems (VeTSS), funded by EPSRC, from 2017 to 2022. She chaired the BCS awards committee, 2013-2018, which decides the Lovelace medal (senior) and Roger Needham award (mid-career) for computer science and engineering.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~pg</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippagardner/8031e77a-ebbb-4963-a5de-94895edd7f71/small.jpg</picture_url>
          <person_id>philippagardner</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1a6a85dc-cbe9-4cfc-bf10-d97922d1a7fa</subevent_id>
    <title>SPLASH REBASE: 15</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>09c7411a-4b9d-442f-8eef-8df59f5df8c6</slot_id>
      <title>Session: SPLASH REBASE - 15</title>
      <room>Online | Rebase</room>
      <date>2020/11/17</date>
      <start_time>17:00</start_time>
      <end_time>17:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8ff28324-f1b8-4efa-a9f0-50e60f9aacd8</slot_id>
      <event_id>a89b8a71-8095-4032-a94a-5405a58da74b</event_id>
      <title>Technology Today: A Paucity of Integrity and Imagination</title>
      <room>Online | Rebase</room>
      <date>2020/11/17</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>17:40</end_time>
      <description>Judging by the experiences of Robert Grimm and a close confidante, both academe and industry have long given up even trying to conduct their business in an ethical fashion. In this talk, the author will detail some of the most egregious instances of deeply unethical if not outright criminal behavior across their career, will argue that they are representative of elites acting in a deeply irresponsible and self-serving manner, causally tie that misbehavior to the rise of nativist nationalism across the western world, and contrast it all against the civilization-ending threat of climate change. This talk sounds the alarm as much as it identifies our last best hope for survival. It’s up to us!</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Grimm</last_name>
          <affiliation>Self</affiliation>
          <bio>Robert worked at Facebook. He was also Vice President in the Technology Division of Goldman Sachs, where he worked on the company’s risk and trading platform. Robert was an Associate Professor of Computer Science at New York University, researching how to leverage programming language technologies to make complex systems easier to build, maintain and extend. He received a Ph.D. in Computer Science from the University of Washington at Seattle in 2002. His honors include the Best Paper award at the 6th ACM International Conference on Distributed Event-Based Systems, a Junior Fellowship at NYU’s Center for Teaching Excellence, and an NSF CAREER award.</bio>
          <homepage_url>http://cs.nyu.edu/rgrimm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/robertgrimm/00645048-2d05-48ed-ae6f-50c441f41179/small.jpg</picture_url>
          <person_id>robertgrimm</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c4bf39eb-5f9e-4a2b-b1fd-c8f227be2c77</subevent_id>
    <title>SPLASH REBASE: 27</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>b7d63c88-e065-4d2a-aab9-724cb1ffccf5</slot_id>
      <title>Session: SPLASH REBASE - 27</title>
      <room>Online | Rebase</room>
      <date>2020/11/20</date>
      <start_time>15:00</start_time>
      <end_time>15:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>60c509ae-28a8-4828-81f1-6a58bcb3ee82</slot_id>
      <event_id>039345f2-202a-48a0-a868-2c9d3ff80808</event_id>
      <title>The impact of differentiable programming: how ∂P is enabling new science in Julia</title>
      <room>Online | Rebase</room>
      <date>2020/11/20</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>15:40</end_time>
      <description>Fully incorporating differentiable programming (∂P) into the Julia language has enabled composability between modern machine learning techniques and existing high performance computing (HPC) modeling and simulation without sacrificing expressivity. Most notably, this has meant that small neural networks can be embedded within larger models whose other behaviors are fully understood and can be concretely represented. Smaller neural networks, in turn, are easier to train and interpret. It has also enabled complex computations to be embedded within cost functions for fast and robust reinforcement learning. In this talk, we’ll walk through several concrete examples and demonstrate how the combination of ∂P with Julia’s generic programming has enabled powerful and expressive new models.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matt</first_name>
          <last_name>Bauman</last_name>
          <affiliation>Julia Computing</affiliation>
          <bio>Matt Bauman is a Senior Research Scientist at JuliaComputing’s Chicago outpost, where he spends lots of time working on arrays and broadcasting. He’s been contributing to both the core language and multiple packages since 2014. At his previous position as a Data Science Fellow at the University of Chicago’s Center for Data Science and Public Policy, he longed for dot-broadcasting in Python while working with local governments to use data science for social good. He recently defended his PhD dissertation in Bioengineering from the University of Pittsburgh, focusing on neural prosthetics.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/mattbauman/d7111f63-4de2-423b-904f-d652ac16868b/small.jpg</picture_url>
          <person_id>mattbauman</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>153834eb-a2fc-4b23-a4f3-57ae520d4a13</subevent_id>
    <title>SPLASH REBASE: 12</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>ce72e07e-df22-45bc-8fcf-ec9f7023be11</slot_id>
      <title>Session: SPLASH REBASE - 12</title>
      <room>Online | Rebase</room>
      <date>2020/11/17</date>
      <start_time>11:00</start_time>
      <end_time>11:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2d307b18-0cd6-42fe-ae3c-f2a6de427eb2</slot_id>
      <event_id>903e6b1f-a35a-40b8-a306-8d3a5bde3b5e</event_id>
      <title>Towards the tower of Babel: a Polyglot Language VM in Java</title>
      <room>Online | Rebase</room>
      <date>2020/11/17</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>11:40</end_time>
      <description>Meet the GraalVM, a technology you can use to build composable high-performance language implementations and tools. Most production-level virtual machines duplicate their target language’s semantics in the interpreter, in the compiler, and in the runtime system. This violates DRY and is hell on the maintainers as the target evolves. In contrast, Truffle lets you define languages by simply writing their interpreter. That interpreter can be seamlessly combined with interpreters of different languages in a single just-in-time compilation unit. By treating the host language as just another language, you can reuse embeddings across languages. A language agnostic instrumentation mechanism enables us to build tools that attach cross-cutting concerns to applications with zero overhead.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christian</first_name>
          <last_name>Humer</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>Christian Humer is a researcher at Oracle Labs in Zurich, working on the GraalVM project. He develops the Truffle framework which aims to make all programming languages fast, composable and embeddable. His research interests include virtual machines, partial evaluation, and domain-specific languages. He is the main author of Truffle DSL, a domain-specific language to simplify the development of Truffle interpreters.</bio>
          <homepage_url>https://labs.oracle.com/pls/apex/f?p=LABS:bio:0:2137</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/christianhumer/7a395af3-35b6-4728-81d5-bf478224f957/small.jpg</picture_url>
          <person_id>christianhumer</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a041f42b-d6a8-40f1-88df-97d3d02e7dc4</subevent_id>
    <title>SPLASH REBASE: 10</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>d8cd57ba-feb7-4d82-aa4a-26664e3a89ad</slot_id>
      <title>Session: SPLASH REBASE - 10</title>
      <room>Online | Rebase</room>
      <date>2020/11/17</date>
      <start_time>01:00</start_time>
      <end_time>01:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0a38cc43-23e5-4f4e-bdbf-659d90b9474f</slot_id>
      <event_id>dbb6bee0-b4d0-48fe-aa57-9d19010b0d78</event_id>
      <title>Lies we tell ourselves about developer infrastructure</title>
      <room>Online | Rebase</room>
      <date>2020/11/17</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>01:40</end_time>
      <description>Over the past decade “developer infrastructure” teams have become an increasingly common presence in industry. Focused on serving the unique needs of an organization’s engineers, their responsibilities can be as modest as build script support or as ambitious as developing new general-purpose programming languages. As a practitioner they can be a wonderful place to work; a perfect environment to apply state of the art techniques to real world problems and invest in new ideas, all while keeping a tight feedback loop with a potentially massive user base. But with great power comes great responsibility, and the potential for waste is real.
How many build systems, UI frameworks, code review tools, and bespoke IDEs have been developed in industry because of “unique needs”? Of those, how many actually improved the state of the art or eventually provided a return on their investment? Why does conventional wisdom — or common sense — so seldom apply when we choose to pursue these sorts of projects? (Why is it so often easier to get funding to develop a new programming language than it is to make critical improvements to an aging but essential piece of infrastructure?) The truth is that we often build new developer tools not because they’re necessary, but because personally meaningful, easy to rationalize, and fun.
While fun is great – I’m a big fan of it – we have a professional obligation to be honest about our intentions, use resources responsibly, and go into our work with open eyes. In this talk I aim to call out the most common sources of irrational exuberance when it comes to developer infrastructure, and the lies I’ve been told (or told others) to justify certain classes of projects. Where appropriate I’ll provide cautionary tales from my last two decades working in the field (names will be changed to protect the innocent), sensible alternatives for those wiser than I was, and advice for those foolhardy enough to try and build that better wheel. (Because I guarantee you – whatever mistake you’re thinking of making, I’ve either made it myself or know someone who did.)</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joe</first_name>
          <last_name>Pamer</last_name>
          <affiliation>Facebook</affiliation>
          <bio>Joe Pamer is an Engineering Director at Instagram, where he serves as their Head of Infrastructure, Feed, and ML. Before joining Facebook to help lead their programming language efforts, he was instrumental in the design and development of the F#, TypeScript, and Swift programming languages, and has contributed to many other major developer technologies ranging from .NET to VS Code to Clang. He currently resides in Brooklyn, New York.</bio>
          <homepage_url>http://noteven.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joepamer/8638da18-a5b0-4543-9d00-fd4b97be5d14/small.jpg</picture_url>
          <person_id>joepamer</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e3c29b86-3865-4ef3-a1f5-af5fc31c02c7</subevent_id>
    <title>SPLASH REBASE: 31</title>
    <subevent_type type="regular"/>
    <room>Online | Rebase</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>0e493c88-6dbb-48b6-9a92-a11f08139fa9</slot_id>
      <title>Session: SPLASH REBASE - 31</title>
      <room>Online | Rebase</room>
      <date>2020/11/17</date>
      <start_time>03:00</start_time>
      <end_time>03:40</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cc52047b-5367-46fe-bd2b-95a81618a34f</slot_id>
      <event_id>8875d96d-01cb-41f7-bb72-48ddc6799c32</event_id>
      <title>SQLancer: Automatically Finding Bugs in Databases</title>
      <room>Online | Rebase</room>
      <date>2020/11/17</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>03:40</end_time>
      <description>Abstract: This talk presents our work on automatic testing of Database Management Systems (DBMS), part of which we found over 400 bugs in widely-used DBMS such as SQLite, MySQL, and PostgreSQL. While crash bugs in DBMS can be detected via fuzzers such as AFL, we aim to detect correctness bugs, which cause a DBMS to produce an incorrect result set for a given query. These bugs are more difficult to detect, since it is unclear how an effective test oracle could be created that could judge whether a given result set is correct. We designed three practical approaches for finding correctness bugs that we implemented as a tool called SQLancer. Besides providing a general overview of the bug-finding techniques, we will also present a number of interesting and surprising bugs that we found in the DBMS that we tested.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Rigger</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>Manuel Rigger is a postdoctoral researcher in the Advanced Software Technologies (AST) Lab at ETH Zurich, mentored by Zhendong Su. He is working on programming language implementation, software reliability, and systems. He completed his PhD at Johannes Kepler University Linz, mentored by Hanspeter Mössenböck, and is known for his work on Sulong to support the safe execution of LLVM-based languages.</bio>
          <homepage_url>http://www.manuelrigger.at/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelrigger/47e268e9-158c-471f-a7e9-442216c54550/small.jpg</picture_url>
          <person_id>manuelrigger</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>91a18757-b55d-46f5-b239-0d0057a37cf1</subevent_id>
    <title>SPLASH OOPSLA: F-1A</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>571f5e92-e578-4333-862b-f279686713f1</slot_id>
      <title>Session: SPLASH OOPSLA - F-1A</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>19:00</start_time>
      <end_time>20:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5c9fc485-bcd7-42ce-8fb4-e9b92f3a73b1</slot_id>
      <event_id>a96ad696-c68c-417e-8be4-411ad8b965f2</event_id>
      <title>Pomsets with Preconditions: A Simple Model of Relaxed Memory</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>19:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>19:40</end_time>
      <description>Relaxed memory models must simultaneously achieve efficient implementability and thread-compositional reasoning. Is that why they have become so complicated? We argue that the answer is no: It is possible to achieve these goals by combining an idea from the 60s (preconditions) with an idea from the 80s (pomsets), at least for X64 and ARMv8. We show that the resulting model (1) supports compositional reasoning for temporal safety properties, (2) supports all reasonable sequential compiler optimizations, (3) satisfies the DRF-SC criterion, and (4) compiles to X64 and ARMv8 microprocessors without requiring extra fences on relaxed accesses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Radha</first_name>
          <last_name>Jagadeesan</last_name>
          <affiliation>DePaul University</affiliation>
          <bio>undefined</bio>
          <person_id>radhajagadeesan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alan</first_name>
          <last_name>Jeffrey</last_name>
          <affiliation>Mozilla Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://asaj.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alanjeffrey1/85292841-a6a7-416c-8808-fc36002bf1bd/small.jpg</picture_url>
          <person_id>alanjeffrey1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>James</first_name>
          <last_name>Riely</last_name>
          <affiliation>DePaul University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/jamesriely/3e1c46e0-9695-4c0f-aa5e-63f6577a3720/small.jpg</picture_url>
          <person_id>jamesriely</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8b2a08cd-ca41-431a-803b-69518cbf9d28</slot_id>
      <event_id>3f5436ba-b7cb-4e49-a7d9-a11c2a16b38a</event_id>
      <title>StreamQL: A Query Language for Processing Streaming Time Series</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>19:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>20:00</end_time>
      <description>Real-time data analysis applications increasingly rely on complex streaming computations over time-series data. We propose StreamQL, a language that facilitates the high-level specification of complex analyses over streaming time series. StreamQL is built upon stream transformations, which allows it to integrate three language-based approaches for data stream processing: relational queries, dataflow composition, and temporal formalisms. The relational constructs are useful for specifying simple transformations, aggregations, and the partitioning of data into key-based groups or windows. The dataflow abstractions enable the modular description of a computation as a pipeline of stages or, more generally, as a directed graph of independent tasks. Finally, temporal constructs can be used to specify complex temporal patterns and time-varying computations. These three constructs can be composed freely to describe complex streaming computations.
StreamQL has a formal denotational semantics, which we use to prove the expressive completeness of the language. We provide an implementation of StreamQL as a lightweight Java library, which we use to experimentally evaluate our approach. The experiments show that the throughput of our implementation is consistently higher than that of state-of-the-art streaming engines.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lingkun</first_name>
          <last_name>Kong</last_name>
          <affiliation>Rice University</affiliation>
          <bio>undefined</bio>
          <person_id>lingkunkong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Mamouras</last_name>
          <affiliation>Rice University</affiliation>
          <bio>undefined</bio>
          <person_id>konstantinosmamouras1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c67941a0-e58c-4e2f-88d1-66f9d735420b</slot_id>
      <event_id>3b3961c4-c2ea-4595-931e-44ad2b54fd4e</event_id>
      <title>Foundations of Empirical Memory Consistency Testing</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>20:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>20:20</end_time>
      <description>Modern memory consistency models are complex and it is difficult to reason about the weak behaviors that current systems allow. Programming languages, such as C and OpenCL, offer a memory model interface that developers can use to safely write concurrent applications. This abstraction provides functional portability across any platform that implements the interface, regardless of differences in the underlying systems. This powerful abstraction hinges on the ability of the system to correctly implement the interface. Many techniques for memory consistency model validation use empirical testing, which has been effective at uncovering undocumented behaviors and even finding bugs in trusted compilation schemes. Memory model testing consists of small concurrent unit tests called “litmus tests”. In these tests, certain observations, \emph{including potential bugs}, are exceedingly rare, as they may only be triggered by precise interleaving of system steps in a complex processor, which is probabilistic in nature. Thus, each test must be run many times in order to provide high level of confidence of correctness.
In this work, we rigorously investigate empirical memory model testing. In particular, we propose methodologies for navigating complex stressing routines and analyzing large numbers of testing observations. Using these insights, we can more efficiently tune stressing parameters, which can lead to higher confidence results at a faster rate. We emphasize the need for such approaches by performing a meta-study of prior work, which reveals results with low reproducibility and inefficient use of testing time.
Our investigation is presented alongside with empirical data. We believe that OpenCL targeting GPUs is a pragmatic choice in this domain as there exists a variety of different platforms to test: from large HPC servers to power-efficient edge devices. The tests presented in the work span 3 GPUs from 3 different vendors. We show that our methodologies are applicable across the GPUs, despite significant variances in the results. Concretely, our results show: lossless speedups of more than $5\times$ in tuning using data-peeking; a definition of portable stressing parameters which loses only 12% efficiency when generalized across our domain; a priority order of litmus tests for tuning. We stress test a conformance test suite for OpenCL 2.0 memory model and discover a bug in Intel’s compiler. Our methods are evaluated on the other two GPUs using mutation testing. We end with recommendations for official memory model conformance tests.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Sorensen</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>I am a Post Doc researcher at Princeton University working in Margaret Martonosi’s group. My research interests are in concurrency: programming, modeling, testing, and architecture. In particular, I am interested in exploring new heterogeneous architectures and how programming models can enable development of secure and efficient applications.
I received my PhD from the Multicore Programming Group at Imperial College London supervised by Alastair Donaldson. Previously, I worked with Ganesh Gopalakrishnan and Zvonimir Rakamaric at University of Utah.</bio>
          <homepage_url>https://www.cs.princeton.edu/~ts20/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tylersorensen1/e6c9c5cc-65e1-4a42-87c2-5e4a7d347b0d/small.jpg</picture_url>
          <person_id>tylersorensen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Esin</first_name>
          <last_name>Tureci</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <person_id>esintureci</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jake</first_name>
          <last_name>Kirkham</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <person_id>jakekirkham</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Margaret R.</first_name>
          <last_name>Martonosi</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <person_id>margaretrmartonosi</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e860f5a5-928e-433d-ab7a-638506192b70</slot_id>
      <event_id>3cd8b177-a095-4aa3-b2fb-63a917807035</event_id>
      <title>DiffStream: Differential Output Testing for Stream Processing Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>19:20</end_time>
      <description>High performance architectures for processing distributed data streams, such as Flink, Spark, and Storm, are increasingly deployed in emerging data-driven computing systems. Exploiting the parallelism afforded by such platforms, while preserving the semantics of the desired computation, is prone to errors, and motivates the development of tools for specification, testing, and verification. We focus on the problem of differential output testing for distributed stream processing systems, that is, checking whether two implementations produce equivalent output streams in response to a given input stream. The notion of equivalence allows reordering of logically independent data items, and the main technical contribution of the paper is an optimal online algorithm for checking this equivalence. Our testing framework is implemented as a library called \library in Flink. We present four case studies to illustrate how our framework can be used to (1) correctly identify bugs in a set of benchmark MapReduce programs, (2) facilitate the development of difficult-to-parallelize high performance applications, and (3) monitor an application for a long period of time using minimal computational resources.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Kallas</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://angelhof.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/konstantinoskallas/58e65111-bc8d-4f20-9522-b677a026f0c4/small.jpg</picture_url>
          <person_id>konstantinoskallas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Filip</first_name>
          <last_name>Niksic</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://fniksic.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/filipniksic/404f7660-8944-48cb-b97d-7b25a191367c/small.jpg</picture_url>
          <person_id>filipniksic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Caleb</first_name>
          <last_name>Stanford</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cis.upenn.edu/~castan/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/calebstanford/ecc7c13b-42ab-49e9-a867-dd26542ae449/small.jpg</picture_url>
          <person_id>calebstanford</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rajeev</first_name>
          <last_name>Alur</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cis.upenn.edu/~alur/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rajeevalur/3b3a4dca-8d4b-4db9-9986-376b2352a264/small.jpg</picture_url>
          <person_id>rajeevalur</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a410c6d7-161d-4300-b942-b133c01d790e</subevent_id>
    <title>SPLASH OOPSLA: T-2</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>3c03fc1d-7062-4f36-88b9-b0b8fff66ab7</slot_id>
      <title>Session: SPLASH OOPSLA - T-2</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>45cdfcd9-8587-4709-91bb-b078aabbe0f8</slot_id>
      <event_id>b5281650-dcac-4963-b682-1fed545a5e0a</event_id>
      <title>WATCHER: In-Situ Failure Diagnosis</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>10:20</end_time>
      <description>Diagnosing in-production software failures is important but notoriously challenging. Existing work either requires extensive manual effort, imposes a serious privacy concern, or cannot report sufficient information for bug fixes.
This paper presents a novel diagnosis system, named WATCHER, that can pinpoint root causes of program failures within the failing process (“in-situ”), eliminating the privacy concern. It combines identical record-and-replay, binary analysis, dynamic analysis, and hardware support together to perform the diagnosis without human involvement. It further proposes two optimizations to reduce the diagnosis time and diagnose failures with control flow hijacks. WATCHER can be easily deployed, without requiring custom hardware, operating system, program modification, or recompilation. We evaluate WATCHER with 24 program failures in real-world deployed software, including large-scale applications, such as Memcached, SQLite, and OpenJPEG. Experimental results show that WATCHER can accurately identify the real root causes in only a few seconds.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hongyu</first_name>
          <last_name>Liu</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://liuhycs.github.io/</homepage_url>
          <person_id>hongyuliu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Silvestro</last_name>
          <affiliation>University of Texas at San Antonio, USA</affiliation>
          <bio>undefined</bio>
          <person_id>samsilvestro</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xiangyu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/xyzhang/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xiangyuzhang/57d4d88e-c02e-41fc-836c-0e22cdf6b3b8/small.jpg</picture_url>
          <person_id>xiangyuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jian</first_name>
          <last_name>Huang</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jianh.web.engr.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jianhuang/f6e25055-585a-40e2-89ae-b28280a62eab/small.jpg</picture_url>
          <person_id>jianhuang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Tongping</first_name>
          <last_name>Liu</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>undefined</bio>
          <person_id>tongpingliu1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9e2419ac-e94e-4e63-aa71-945dab2eae16</slot_id>
      <event_id>93f41bfd-9988-4002-8de8-22ce8bf00c55</event_id>
      <title>A Large-Scale Longitudinal Study of Flaky Tests</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>09:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>09:40</end_time>
      <description>Flaky tests are tests that can non-deterministically pass or fail for the same code version. These tests undermine regression testing efficiency, because developers cannot easily identify whether a test fails due to their recent changes or due to flakiness. Ideally, one would detect flaky tests right when flakiness is introduced, so that developers can then immediately remove the flakiness. Some software organizations, e.g., Mozilla and Netflix, run some tools—detectors—to detect flaky tests as soon as possible. However, detecting flaky tests is costly due to their inherent non-determinism, so even state-of-the-art detectors are often impractical to be used on all tests for each project change. To combat the high cost of applying detectors, these organizations typically run a detector solely on newly added or directly modified tests, i.e., not on unmodified tests or when other changes occur (including changes to the test suite, the code under test, and library dependencies). However, it is unclear how many flaky tests can be detected or missed by applying detectors in only these limited circumstances.
To better understand this problem, we conduct a large-scale longitudinal study of flaky tests to determine when flaky tests become flaky and what changes cause them to become flaky. We apply two state-of-theart detectors to 55 Java projects, identifying a total of 245 flaky tests that can be compiled and run in the code version where each test was added. We find that 75% of flaky tests (184 out of 245) are flaky when added, indicating substantial potential value for developers to run detectors specifically on newly added tests. However, running detectors solely on newly added tests would still miss detecting 25% of flaky tests. The percentage of flaky tests that can be detected does increase to 85% when detectors are run on newly added or directly modified tests. The remaining 15% of flaky tests become flaky due to other changes and can be detected only when detectors are always applied to all tests. Our study is the first to empirically evaluate when tests become flaky and to recommend guidelines for applying detectors in the future.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wing</first_name>
          <last_name>Lam</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://winglam2.web.engr.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/winglam/4052f462-6ac0-4252-8c59-92a77a7c33dc/small.jpg</picture_url>
          <person_id>winglam</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stefan</first_name>
          <last_name>Winter</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>I am a postdoctoral researcher at TU Darmstadt in Germany, from where I previously obtained a Ph.D. in computer science. My research interests span a variety of topics related to the design and analysis of dependable software systems from operating system design to system-level test efficiency.</bio>
          <homepage_url>http://www.stefan-winter.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stefanwinter/b2ba53f2-c875-4cd6-b938-2152649c47bb/small.jpg</picture_url>
          <person_id>stefanwinter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anjiang</first_name>
          <last_name>Wei</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/anjiangwei/680e5627-484e-433a-be11-7fcc497f7075/small.jpg</picture_url>
          <person_id>anjiangwei</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tao</first_name>
          <last_name>Xie</last_name>
          <affiliation>Peking University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://taoxiease.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/taoxie/14ae8022-1dd6-4455-a54f-157c86bc406d/small.jpg</picture_url>
          <person_id>taoxie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Darko</first_name>
          <last_name>Marinov</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>Please see my website</bio>
          <homepage_url>http://mir.cs.illinois.edu/marinov</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/darkomarinov/715fd20e-8e93-48b7-8f26-4e80ed2aeab5/small.jpg</picture_url>
          <person_id>darkomarinov</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Bell</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Jon is an Assistant Professor directing research in Software Engineering and Software Systems at Northeastern University. His research makes it easier for developers to create reliable and secure software by improving software testing and program analysis. Jon’s work on accelerating software testing has been recognized with an ACM SIGSOFT Distinguished Paper Award (ICSE ’14 – Unit Test Virtualization with VMVM), and was the basis for an industrial collaboration with Electric Cloud. His program analysis research has resulted in several widely adopted runtime systems for the JVM, including the Phosphor taint tracking system (OOPSLA ’14) and CROCHET checkpoint/rollback tool (ECOOP ’18). His research has been funded by the NSA and the NSF, and he is the recipient of the NSF CAREER award. At George Mason, Jon taught courses in distributed systems, web development, and program analysis. His teaching at GMU has been recognized with a departmental award. Jon serves on a variety of program committees and was recently co-chair of the PLDI 2020 Artifact Evaluation Committee. As part of his efforts to broaden the participation of underrepresented groups in computing, Jon co-organizes the PL/SE mentoring workshop at SPLASH (in 2017, 2018, 2019 and 2020).</bio>
          <homepage_url>http://jonbell.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanbell/1ef3641d-0ed6-4021-aab6-b13b53962e3d/small.jpg</picture_url>
          <person_id>jonathanbell</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b9480495-eb6b-42e6-a413-b3fc3416ef06</slot_id>
      <event_id>bf240e74-90f0-407b-8552-d2d71c9c86e4</event_id>
      <title>Handling Bidirectional Control Flow</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>10:00</end_time>
      <description>Pressed by the difficulty of writing asynchronous, event-driven code, it has become popular for mainstream languages to build in support for a variety of advanced control-flow features. Meanwhile recent, experimental language designs have suggested effect handlers as a unifying solution to programmer-defined control effects, subsuming exceptions, generators, and async–await. However, despite these trends, complex control flow—in particular, control flow that exhibits a bidirectional pattern—remains challenging to manage.
We introduce bidirectional algebraic effects, a new programming abstraction that supports bidirectional control transfer in a more natural way. Handlers of bidirectional effects can raise further effects to transfer control back to the site where the initiating effect was raised, and can use themselves to handle their own effects. We present applications of this expressive power, which falls out naturally as we push toward the unification of effectful programming with object-oriented programming. We pin down the mechanism and the unification formally using a core language that makes generalizations to effect operations and effect handlers.
The usual propagation semantics of control effects such as exceptions conflicts with modular reasoning in the presence of effect polymorphism—it breaks parametricity. Bidirectionality exacerbates the problem. Hence, we set out to show the core language, which builds on the existing tunneling semantics for algebraic effects, is not only type-safe (no effects go unhandled), but also abstraction-safe (no effects are accidentally handled). We devise a step-indexed logical-relations model, and construct its parametricity and soundness proofs. These core results are fully mechanized in Coq. While a full-featured compiler is left to future work, experiments show that as a first-class language feature, bidirectional handlers can be implemented efficiently.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yizhou</first_name>
          <last_name>Zhang</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.uwaterloo.ca/~yizhou</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yizhouzhang/0629b9fd-c9c0-44e9-ac08-6760a0b35950/small.jpg</picture_url>
          <person_id>yizhouzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guido</first_name>
          <last_name>Salvaneschi</last_name>
          <affiliation>University of St. Gallen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.guidosalvaneschi.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guidosalvaneschi/6f1373d5-57c6-4d68-b6c3-c0a679ee24ed/small.jpg</picture_url>
          <person_id>guidosalvaneschi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Myers</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>Andrew Myers is a Professor in the Department of Computer Science at Cornell University in Ithaca, NY. His research interests include programming languages, computer security, and distributed and persistent programming systems. Myers is an ACM Fellow. He has received awards for papers appearing in POPL’99, SOSP’01, SOSP’07, CIDR’13, PLDI’13, and PLDI’15. Myers is currently the Editor-in-Chief for ACM Transactions on Programming Languages and Systems (TOPLAS). He has also served as program chair or co-chair for a few conferences: ACM POPL 2018, ACM CCS 2016, POST 2014, IEEE CSF 2010, and IEEE S&amp;amp;P 2009.</bio>
          <homepage_url>http://www.cs.cornell.edu/andru</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andrewmyers/88baadd2-5ed8-4687-b205-3cbbe8b1a848/small.jpg</picture_url>
          <person_id>andrewmyers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c9735190-c1fa-4e0c-b296-47c7cc98905a</slot_id>
      <event_id>5d1aeb28-75c6-4924-8e7a-5cbbe33cfacd</event_id>
      <title>Formulog: Datalog for SMT-based Static Analysis</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>09:20</end_time>
      <description>Satisfiability modulo theories (SMT) solving has become a critical part of many static analyses, including symbolic execution, refinement type checking, and model checking. We propose Formulog, a domain-specific language that makes it possible to write a range of SMT-based static analyses in a way that is both close to their formal specifications and amenable to high-level optimizations and efficient evaluation.
Formulog extends the logic programming language Datalog with a first-order functional language and mechanisms for representing and reasoning about SMT formulas; a novel type system supports the construction of expressive formulas, while ensuring that neither normal evaluation nor SMT solving goes wrong. Our case studies demonstrate that a range of SMT-based analyses can naturally and concisely be encoded in Formulog, and that — thanks to this encoding — high-level Datalog-style optimizations can be automatically and advantageously applied to these analyses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Bembenek</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>Aaron Bembenek is currently a computer science PhD candidate at Harvard University working under Stephen Chong. He previously earned an undergraduate degree in classics from Princeton University.</bio>
          <homepage_url>http://people.seas.harvard.edu/~bembenek/index.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aaronbembenek/def526d3-8049-43ee-a891-2437ec903da6/small.jpg</picture_url>
          <person_id>aaronbembenek</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Greenberg</last_name>
          <affiliation>Pomona College</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.pomona.edu/~michael/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
          <person_id>michaelgreenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chong</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>Stephen Chong is a Gordon McKay Professor of Computer Science in the Harvard John A. Paulson School of Engineering and Applied Sciences. Steve’s research focuses on programming languages, information security, and the intersection of these two areas. He is the recipient of an NSF CAREER award, an AFOSR Young Investigator award, and a Sloan Research Fellowship. He received a PhD from Cornell University, and a bachelor’s degree from Victoria University of Wellington, New Zealand.</bio>
          <homepage_url>https://people.seas.harvard.edu/~chong/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stephenchong/91e43651-bcd6-40dc-b231-4c92711b0e95/small.jpg</picture_url>
          <person_id>stephenchong</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f3674f64-bf0e-4d31-a6d3-e09729aa3fd1</subevent_id>
    <title>SPLASH OOPSLA: F-3A</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>9eb9161d-a683-4e79-b88d-7fc9afd686e1</slot_id>
      <title>Session: SPLASH OOPSLA - F-3A</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a2255de5-3c79-480a-994b-d06c21da7d27</slot_id>
      <event_id>8d09d351-1484-4e6f-a97b-31fc3a8589f5</event_id>
      <title>Fixpoints for the Masses: Programming with First-class Datalog Constraints</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>11:40</end_time>
      <description>Datalog is a declarative logic programming language that has been used in a variety of applications, including big-data analytics, language processing, networking and distributed systems, and program analysis.
In this paper, we propose first-class Datalog constraints as a mechanism to construct, compose, and solve Datalog programs at run time. The benefits are twofold: We gain the full power of a functional programming language to operate on Datalog constraints-as-values, while simultaneously we can use Datalog where it really shines: to declaratively express and solve fixpoint problems.
We present an extension of the lambda calculus with first-class Datalog constraints, including its semantics and a type system with row polymorphism based on Hindley-Milner. We prove soundness of the type system and implement it as an extension of the Flix programming language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b93b8a6c-c3cf-46a5-ac5b-8eb9bb0cef93</slot_id>
      <event_id>50c0fcb1-ef71-4df6-9d10-ebeddb89add2</event_id>
      <title>Polymorphic Types and Effects with Boolean Unification</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>12:20</end_time>
      <description>We present a simple, practical, and expressive type and effect system based on Boolean constraints. The effect system extends the Hindley-Milner type system, supports parametric polymorphism, and preserves principal types modulo Boolean equivalence. We show how to support type inference by extending Algorithm W with Boolean unification based on the successive variable elimination algorithm.
We implement the type and effect system in the Flix programming language. We perform an in-depth evaluation on the impact of Boolean unification on type inference time and end-to-end compilation time. While the computational complexity of boolean unification is NP-hard, the experimental results demonstrate that it works well in practice. We find that the impact on type inference time is on average a 1.4x slowdown and the overall impact on end-to-end compilation time is a 1.1x slowdown.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jaco</first_name>
          <last_name>van de Pol</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>Jaco van de Pol started his research in Utrecht on rewrite systems, in particular termination of higher-order rewrite systems. At CWI Amsterdam, he published several papers on theorem proving and model checking for concurrent systems in process algebra and contributed to the µCRL toolset. In Twente, he started a new research line on parallel model checking algorithms. This resulted in the LTSmin toolset for high-performance model checking. He worked on applications in embedded systems, safety &amp;amp; security and systems biology. He published ~25 journal papers, ~100 conference papers, and edited ~10 volumes. Publications at Google Scholar and DBLP.
Affiliations:

 MSc Utrecht University (supervisor Hans Zantema)
 PhD Utrecht University (supervisor Jan Bergstra)
 Research Assistant LMU Mathematisches Institute Munich (with Helmut Schwichtenberg)
 Postdoc Technical University of Eindhoven (with Jozef Hooman)
 Senior Researcher CWI (1999-2007)
 Associate Professor Technical University of Eindhoven (2004-2007, 20%)
 Professor Formal Methods and Tools at University of Twente (2007-2018; from Nov 2018 10%)
 Professor Computer Science at Aarhus University (from Nov 2018)
          </bio>
          <homepage_url>http://fmt.cs.utwente.nl/~vdpol/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jacovandepol/b053e08d-fe52-46a9-b4cd-b863ea6c9c07/small.jpg</picture_url>
          <person_id>jacovandepol</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d28157cf-5ad0-4a67-bb9e-28f6c987ee42</slot_id>
      <event_id>c3da127b-d137-44d6-888b-a9da4ddc54a5</event_id>
      <title>Verifying and Improving Halide’s Term Rewriting System with Program Synthesis</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>12:00</end_time>
      <description>Halide is a domain-specific language for high-performance image processing and tensor computations, widely adopted in industry. Internally, the Halide compiler relies on a term rewriting system to prove properties of code required for efficient and correct compilation. This rewrite system is a collection of handwritten transformation rules that incrementally rewrite expressions into simpler forms; the system requires high performance in both time and memory usage to keep compile times low. In this work, we apply formal techniques to prove the correctness of existing rewrite rules and provide a guarantee of termination. Then, we build an automatic program synthesis system that operates over the undecidable theory of integers in order to craft new, provably correct rules from failure cases where the compiler was unable to prove properties. We identify and fix 5 incorrect rules as well as 8 rules which could give rise to infinite rewriting loops. We demonstrate that the synthesizer can produce better rules than hand-authored ones in five bug fixes, and describe four cases in which it has served as an assistant to a human compiler engineer. We further show that it can proactively improve weaknesses in the compiler by synthesizing a large number of rules without human supervision and showing that the enhanced ruleset lowers peak memory usage of compiled code without appreciably increasing compilation times.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julie L.</first_name>
          <last_name>Newcomb</last_name>
          <affiliation>University of California at Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jn80842.github.io/</homepage_url>
          <person_id>julielnewcomb</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Adams</last_name>
          <affiliation>Adobe</affiliation>
          <bio>undefined</bio>
          <person_id>andrewadams</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Steven</first_name>
          <last_name>Johnson</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <person_id>stevenjohnson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rastislav</first_name>
          <last_name>Bodik</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://homes.cs.washington.edu/~bodik</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rastislavbodik/ae16ae8e-9d00-41c4-9067-0c37da65dde7/small.jpg</picture_url>
          <person_id>rastislavbodik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Shoaib</first_name>
          <last_name>Kamil</last_name>
          <affiliation>Adobe</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shoaibkamil/2bc60aee-bda5-437e-9e74-e00f5a55c9ef/small.jpg</picture_url>
          <person_id>shoaibkamil</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d98c66e7-6e79-4f7a-8aec-6664eed59998</slot_id>
      <event_id>8cf8faa8-1f32-4ec8-b6ba-b5a6fc13efef</event_id>
      <title>Contextual Dispatch for Function Specialization</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>11:20</end_time>
      <description>In order to generate efficient code for dynamic languages, compilers often need information not readily available in the source code. Leveraging a mixture of static and dynamic information, just-in-time compilers can speculate on the missing information. Within one compilation unit, code is specialized to the observed behaviors. We propose an approach to further the specialization, by disentangling classes of behaviors into separate optimization units. With contextual dispatch, functions are versioned and each version is compiled under different assumptions. When a function is invoked, the implementation dispatches to a version that was optimized under assumptions matching the dynamic context of the call. As a proof-of-concept, we describe a compiler for the R language which uses this approach. We evaluate contextual dispatch on a set of benchmarks and compare to traditional speculation with deoptimization techniques. Our implementation is, on average, 1.7× faster than the GNU R reference implementation, and contextual dispatch contributes to the performance significantly in 18 of 46 programs in our benchmark suite.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Flückiger</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.o1o.ch</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/olivierfluckiger/6051271d-0eac-48f3-b931-bff878bbce61/small.jpg</picture_url>
          <person_id>olivierfluckiger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guido</first_name>
          <last_name>Chari</last_name>
          <affiliation>ASAPP Inc</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://charig.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guidochari/a0147ecd-ef4f-404e-ba4a-ffa5894e8830/small.jpg</picture_url>
          <person_id>guidochari</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ming-Ho</first_name>
          <last_name>Yee</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>I’m currently a Ph.D. student in computer science at Northeastern University in Boston, Massachusetts. I work on programming language design and implementation with Jan Vitek.</bio>
          <homepage_url>http://mhyee.com</homepage_url>
          <person_id>minghoyee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jan</first_name>
          <last_name>Jecmen</last_name>
          <affiliation>Czech Technical University</affiliation>
          <bio>undefined</bio>
          <person_id>janjecmen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jakob</first_name>
          <last_name>Hain</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.linkedin.com/in/jakobeha/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jakobhain/d10d3ad5-e905-4e33-93d6-7d1545e3ab22/small.jpg</picture_url>
          <person_id>jakobhain</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c05beda1-42bb-407b-9385-4c90690279fe</subevent_id>
    <title>SPLASH OOPSLA: F-1A</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>15a60fd9-d319-4f35-a13d-c68fd92a4ee5</slot_id>
      <title>Session: SPLASH OOPSLA - F-1A</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>07:00</start_time>
      <end_time>08:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1ecef038-5bcc-47bb-92df-f8152b344088</slot_id>
      <event_id>3f5436ba-b7cb-4e49-a7d9-a11c2a16b38a</event_id>
      <title>StreamQL: A Query Language for Processing Streaming Time Series</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>07:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>08:00</end_time>
      <description>Real-time data analysis applications increasingly rely on complex streaming computations over time-series data. We propose StreamQL, a language that facilitates the high-level specification of complex analyses over streaming time series. StreamQL is built upon stream transformations, which allows it to integrate three language-based approaches for data stream processing: relational queries, dataflow composition, and temporal formalisms. The relational constructs are useful for specifying simple transformations, aggregations, and the partitioning of data into key-based groups or windows. The dataflow abstractions enable the modular description of a computation as a pipeline of stages or, more generally, as a directed graph of independent tasks. Finally, temporal constructs can be used to specify complex temporal patterns and time-varying computations. These three constructs can be composed freely to describe complex streaming computations.
StreamQL has a formal denotational semantics, which we use to prove the expressive completeness of the language. We provide an implementation of StreamQL as a lightweight Java library, which we use to experimentally evaluate our approach. The experiments show that the throughput of our implementation is consistently higher than that of state-of-the-art streaming engines.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lingkun</first_name>
          <last_name>Kong</last_name>
          <affiliation>Rice University</affiliation>
          <bio>undefined</bio>
          <person_id>lingkunkong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Mamouras</last_name>
          <affiliation>Rice University</affiliation>
          <bio>undefined</bio>
          <person_id>konstantinosmamouras1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6e600620-4d73-4be4-84e0-45ca66c3d6e8</slot_id>
      <event_id>3cd8b177-a095-4aa3-b2fb-63a917807035</event_id>
      <title>DiffStream: Differential Output Testing for Stream Processing Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>07:20</end_time>
      <description>High performance architectures for processing distributed data streams, such as Flink, Spark, and Storm, are increasingly deployed in emerging data-driven computing systems. Exploiting the parallelism afforded by such platforms, while preserving the semantics of the desired computation, is prone to errors, and motivates the development of tools for specification, testing, and verification. We focus on the problem of differential output testing for distributed stream processing systems, that is, checking whether two implementations produce equivalent output streams in response to a given input stream. The notion of equivalence allows reordering of logically independent data items, and the main technical contribution of the paper is an optimal online algorithm for checking this equivalence. Our testing framework is implemented as a library called \library in Flink. We present four case studies to illustrate how our framework can be used to (1) correctly identify bugs in a set of benchmark MapReduce programs, (2) facilitate the development of difficult-to-parallelize high performance applications, and (3) monitor an application for a long period of time using minimal computational resources.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Kallas</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://angelhof.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/konstantinoskallas/58e65111-bc8d-4f20-9522-b677a026f0c4/small.jpg</picture_url>
          <person_id>konstantinoskallas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Filip</first_name>
          <last_name>Niksic</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://fniksic.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/filipniksic/404f7660-8944-48cb-b97d-7b25a191367c/small.jpg</picture_url>
          <person_id>filipniksic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Caleb</first_name>
          <last_name>Stanford</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cis.upenn.edu/~castan/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/calebstanford/ecc7c13b-42ab-49e9-a867-dd26542ae449/small.jpg</picture_url>
          <person_id>calebstanford</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rajeev</first_name>
          <last_name>Alur</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cis.upenn.edu/~alur/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rajeevalur/3b3a4dca-8d4b-4db9-9986-376b2352a264/small.jpg</picture_url>
          <person_id>rajeevalur</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bc78856b-9b95-49a3-8375-3c133752e25b</slot_id>
      <event_id>a96ad696-c68c-417e-8be4-411ad8b965f2</event_id>
      <title>Pomsets with Preconditions: A Simple Model of Relaxed Memory</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>07:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>07:40</end_time>
      <description>Relaxed memory models must simultaneously achieve efficient implementability and thread-compositional reasoning. Is that why they have become so complicated? We argue that the answer is no: It is possible to achieve these goals by combining an idea from the 60s (preconditions) with an idea from the 80s (pomsets), at least for X64 and ARMv8. We show that the resulting model (1) supports compositional reasoning for temporal safety properties, (2) supports all reasonable sequential compiler optimizations, (3) satisfies the DRF-SC criterion, and (4) compiles to X64 and ARMv8 microprocessors without requiring extra fences on relaxed accesses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Radha</first_name>
          <last_name>Jagadeesan</last_name>
          <affiliation>DePaul University</affiliation>
          <bio>undefined</bio>
          <person_id>radhajagadeesan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alan</first_name>
          <last_name>Jeffrey</last_name>
          <affiliation>Mozilla Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://asaj.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alanjeffrey1/85292841-a6a7-416c-8808-fc36002bf1bd/small.jpg</picture_url>
          <person_id>alanjeffrey1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>James</first_name>
          <last_name>Riely</last_name>
          <affiliation>DePaul University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/jamesriely/3e1c46e0-9695-4c0f-aa5e-63f6577a3720/small.jpg</picture_url>
          <person_id>jamesriely</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fe527ff7-74a1-40c3-bac3-a053d323a48a</slot_id>
      <event_id>3b3961c4-c2ea-4595-931e-44ad2b54fd4e</event_id>
      <title>Foundations of Empirical Memory Consistency Testing</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>08:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>08:20</end_time>
      <description>Modern memory consistency models are complex and it is difficult to reason about the weak behaviors that current systems allow. Programming languages, such as C and OpenCL, offer a memory model interface that developers can use to safely write concurrent applications. This abstraction provides functional portability across any platform that implements the interface, regardless of differences in the underlying systems. This powerful abstraction hinges on the ability of the system to correctly implement the interface. Many techniques for memory consistency model validation use empirical testing, which has been effective at uncovering undocumented behaviors and even finding bugs in trusted compilation schemes. Memory model testing consists of small concurrent unit tests called “litmus tests”. In these tests, certain observations, \emph{including potential bugs}, are exceedingly rare, as they may only be triggered by precise interleaving of system steps in a complex processor, which is probabilistic in nature. Thus, each test must be run many times in order to provide high level of confidence of correctness.
In this work, we rigorously investigate empirical memory model testing. In particular, we propose methodologies for navigating complex stressing routines and analyzing large numbers of testing observations. Using these insights, we can more efficiently tune stressing parameters, which can lead to higher confidence results at a faster rate. We emphasize the need for such approaches by performing a meta-study of prior work, which reveals results with low reproducibility and inefficient use of testing time.
Our investigation is presented alongside with empirical data. We believe that OpenCL targeting GPUs is a pragmatic choice in this domain as there exists a variety of different platforms to test: from large HPC servers to power-efficient edge devices. The tests presented in the work span 3 GPUs from 3 different vendors. We show that our methodologies are applicable across the GPUs, despite significant variances in the results. Concretely, our results show: lossless speedups of more than $5\times$ in tuning using data-peeking; a definition of portable stressing parameters which loses only 12% efficiency when generalized across our domain; a priority order of litmus tests for tuning. We stress test a conformance test suite for OpenCL 2.0 memory model and discover a bug in Intel’s compiler. Our methods are evaluated on the other two GPUs using mutation testing. We end with recommendations for official memory model conformance tests.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Sorensen</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>I am a Post Doc researcher at Princeton University working in Margaret Martonosi’s group. My research interests are in concurrency: programming, modeling, testing, and architecture. In particular, I am interested in exploring new heterogeneous architectures and how programming models can enable development of secure and efficient applications.
I received my PhD from the Multicore Programming Group at Imperial College London supervised by Alastair Donaldson. Previously, I worked with Ganesh Gopalakrishnan and Zvonimir Rakamaric at University of Utah.</bio>
          <homepage_url>https://www.cs.princeton.edu/~ts20/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tylersorensen1/e6c9c5cc-65e1-4a42-87c2-5e4a7d347b0d/small.jpg</picture_url>
          <person_id>tylersorensen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Esin</first_name>
          <last_name>Tureci</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <person_id>esintureci</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jake</first_name>
          <last_name>Kirkham</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <person_id>jakekirkham</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Margaret R.</first_name>
          <last_name>Martonosi</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <person_id>margaretrmartonosi</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f9c51d4a-8558-4abc-9e12-86c7e7a65d1e</subevent_id>
    <title>SPLASH OOPSLA: F-1B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>8eb16d17-df94-44cd-8880-cead41740b89</slot_id>
      <title>Session: SPLASH OOPSLA - F-1B</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>07:00</start_time>
      <end_time>08:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>486d83a8-eb92-46b5-9232-8119282a2a2f</slot_id>
      <event_id>fd3d1690-7023-4d0a-a100-6ba2b8f4497c</event_id>
      <title>Incremental Predicate Analysis for Regression Verification</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>07:20</end_time>
      <description>Software products are evolving during their life cycles. Ideally, every revision need be formally verified to ensure software quality. Yet repeated formal verification requires significant computing resources. Verifying each and every revision can be very challenging. It is desirable to ameliorate regression verification for practical purposes. In this paper, we regard predicate analysis as a process of assertion annotation. We propose to reuse the previously-yielded assertion annotation in regression verification. A light-weight impact-analysis technique is proposed to analyze the reusability of assertions. A novel assertion strengthening technique is furthermore developed to improve reusability of annotation. With these techniques, we present an incremental predicate analysis technique for regression verification. Correctness of our incremental technique is formally proved. We performed comprehensive experiments on revisions of Linux kernel device drivers. Our technique outperforms the state-of-the-art program verification tool CPAchecker by getting x1.4 speedup in analysis time and solving additional 78 tasks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Qianshan</first_name>
          <last_name>Yu</last_name>
          <affiliation>Tsinghua University</affiliation>
          <bio>undefined</bio>
          <person_id>qianshanyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fei</first_name>
          <last_name>He</last_name>
          <affiliation>Tsinghua University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://feihe.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/feihe/8546030e-3821-4cb3-8f33-23a258579461/small.jpg</picture_url>
          <person_id>feihe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bow-Yaw</first_name>
          <last_name>Wang</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <person_id>bowyawwang1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8764b9cf-d445-41c7-8614-52e58863d2f2</slot_id>
      <event_id>256ca32c-494b-45db-903d-d2bbabbfbd1b</event_id>
      <title>Guiding Dynamic Programing via Structural Probability for Accelerating Programming by Example</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>08:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>08:20</end_time>
      <description>Programming by example (PBE) is an important subproblem of program synthesis and the techniques of PBE have been applied to many domains. Though many techniques for accelerating PBE systems have been explored, the scalability remains one of the main challenges: there is still a gap between the performances of state-of-the-art synthesizers and the industrial requirement. To further speed up solving PBE tasks, in this paper we propose a novel PBE framework MaxFlash, which uses the naturalness of programs to guide a search based on dynamic programming, such that the search will focus on subproblems that form more natural programs, and avoid unnatural programs. Our evaluation shows that MaxFlash achieves $\times 5.097- \times 2321$ speed-ups against state-of-the-art solvers on $244$ real-world tasks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ruyi</first_name>
          <last_name>Ji</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <person_id>ruyiji</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yican</first_name>
          <last_name>Sun</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>yicansun1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yingfei</first_name>
          <last_name>Xiong</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>Associate Professor</bio>
          <homepage_url>http://sei.pku.edu.cn/~xiongyf04/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yingfeixiong/18fb7368-4f14-462a-b038-9990eebb7a9c/small.jpg</picture_url>
          <person_id>yingfeixiong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhenjiang</first_name>
          <last_name>Hu</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sei.pku.edu.cn/~hu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhenjianghu/5d426480-5589-46be-b4f6-f98cf2acc80e/small.jpg</picture_url>
          <person_id>zhenjianghu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>95340fd6-11b2-4bc9-9d54-4dcaf8ed02c0</slot_id>
      <event_id>8068ce72-3e63-4d39-8209-298d9b3bc05d</event_id>
      <title>Learning Graph-based Heuristics for Pointer Analysis without Handcrafting Application-Specific Features</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>07:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>07:40</end_time>
      <description>We present Graphick, a new technique for automatically learning graph-based heuristics for pointer analysis. Striking a balance between precision and scalability of pointer analysis requires designing good analysis heuristics. For example, because applying context sensitivity to all methods in a real-world program is impractical, pointer analysis typically uses a heuristic to employ context sensitivity only when it is necessary. Past research has shown that exploiting the program’s graph structure is a promising way of developing cost-effective analysis heuristics, promoting the recent trend of ``graph-based heuristics'' that work on the graph representations of programs obtained from a pre-analysis. Although promising, developing such heuristics manually remains challenging, requiring a great deal of expertise and laborious effort. In this paper, we aim to reduce this burden by learning graph-based heuristics automatically, in particular without hand-crafted application-specific features. To do so, we present a general feature language to describe graph structures and an algorithm for learning analysis heuristics within the language. We implemented Graphick on top of Doop and learned graph-based heuristics for context sensitivity and heap abstraction. The evaluation results show that our approach is general and can effectively generate high-quality heuristics; for both instances, the learned heuristics are as competitive as the existing state-of-the-art heuristics designed manually by analysis experts.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Minseok</first_name>
          <last_name>Jeon</last_name>
          <affiliation>Korea University, South Korea</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://prl.korea.ac.kr/~minseok/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/minseokjeon/69505413-080b-41a8-8714-56f24d788995/small.jpg</picture_url>
          <person_id>minseokjeon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Myungho</first_name>
          <last_name>Lee</last_name>
          <affiliation>Korea University</affiliation>
          <bio>undefined</bio>
          <person_id>myungholee1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hakjoo</first_name>
          <last_name>Oh</last_name>
          <affiliation>Korea University, South Korea</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://prl.korea.ac.kr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hakjoooh/d607b778-78f3-41c4-84d9-4693c8923bc3/small.jpg</picture_url>
          <person_id>hakjoooh</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e0f191b8-395b-4979-9075-4064321d914a</slot_id>
      <event_id>29356edb-fec4-4b97-9278-0bf447a06e5d</event_id>
      <title>TacTok: Semantics-Aware Proof Synthesis</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>07:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>08:00</end_time>
      <description>Formally verifying software correctness is a highly manual process. However, because verification proofs often share structure, it is possible to learn from existing proofs to fully automate some formal verification. The goal of this paper is to improve proof synthesis and enable fully automating more verification. Interactive theorem provers, such as the Coq proof assistant, allow developers to write partial proofs, observe the semantics of the proof state thus far, and then attempt more progress. Knowing the proof state semantics is a significant aid. Recent research has shown that the proof state can help predict the next step. In this paper, we present TacTok, the first technique that attempts to fully automate proof synthesis by modeling proofs using both the partial proof written thus far and the semantics of the proof state. Thus, TacTok more completely models the information the developer has access to when writing proofs manually. TacTok is open-source. We evaluate TacTok on a benchmark of 26 software projects in Coq, consisting of over 10 thousand theorems. We compare our approach to two tools, CoqHammer, the state-of-the-art proof synthesis technique, and ASTactic, a proof synthesis technique that models proof state. We find that TacTok is complementary to CoqHammer and ASTactic: for 24 out of the 26 projects, TacTok can synthesize proofs for some theorems prior tools cannot. Together with TacTok, 11.5% more theorems can be proven automatically than by CoqHammer alone, and 20.0% than by ASTactic alone. Compared to a combination of CoqHammer and ASTactic, TacTok can prove an additional 3.6% more theorems, proving 115 theorems no tool could previously prove. Overall, our experiments provide evidence that partial proof and proof state semantics, together, provide useful information for proof modeling.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Emily</first_name>
          <last_name>First</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>undefined</bio>
          <person_id>emilyfirst</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yuriy</first_name>
          <last_name>Brun</last_name>
          <affiliation>University of Massachusetts at Amherst, USA</affiliation>
          <bio>My research is in software engineering. I am interested in improving our ability to build systems that are smart, and self-adapt to their environment. I am particularly interested in ensuring fairness in software systems. Watch a video describing my latest work on software fairness testing here: http://tinyurl.com/FairnessVideo</bio>
          <homepage_url>http://people.cs.umass.edu/~brun/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yuriybrun/15eff225-fb71-4b2c-9925-a0d731136238/small.jpg</picture_url>
          <person_id>yuriybrun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Guha</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cics.umass.edu/~arjun</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjunguha/284e0782-ec24-4ad9-b6a4-b6a1d0e2fe9a/small.jpg</picture_url>
          <person_id>arjunguha</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f733e01f-19f7-4133-8aa0-744ab5bd0d3d</subevent_id>
    <title>SPLASH OOPSLA: T-6A</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>8bc51aba-3a23-456d-adc5-cd974e579a63</slot_id>
      <title>Session: SPLASH OOPSLA - T-6A</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>89363f6e-b4c3-404a-a330-c5fe5219d97c</slot_id>
      <event_id>bebba2c1-25ac-4031-96fd-49f091a06a15</event_id>
      <title>Flow2Vec: Value-Flow-Based Precise Code Embedding</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>05:20</end_time>
      <description>Code embedding, as an emerging paradigm for source code analysis, has attracted much attention over the past few years. It aims to represent code semantics through distributed vector representations, which can be used to support a variety of program analysis tasks (e.g., code summarization and semantic labeling). However, existing code embedding approaches are intraprocedural, alias-unaware and ignoring the asymmetric transitivity of directed graphs abstracted from source code, thus they are still ineffective in preserving the structural information of code.
This paper presents Flow2Vec, a new code embedding approach that precisely preserves interprocedural program dependence (a.k.a value-flows). By approximating the high-order proximity, i.e., the asymmetric transitivity of value-flows, Flow2Vec embeds control-flows and alias-aware data-flows of a program in a low-dimensional vector space. Our value-flow embedding is formulated as matrix multiplication to preserve context-sensitive transitivity through CFL reachability by filtering out infeasible value-flow paths.
We have evaluated Flow2Vec using 32 popular open-source projects. Results from our experiments show that Flow2Vec successfully boosts the performance of two recent code embedding approaches code2vec and code2seq for two client applications, i.e., code classification and code summarization. For code classification, Flow2Vec improves code2vec with an average increase of 21.2%, 20.1% and 20.7% in precision, recall and F1, respectively. For code summarization, Flow2Vec outperforms code2seq by an average of 13.2%, 18.8% and 16.0% in precision, recall and F1, respectively.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yulei</first_name>
          <last_name>Sui</last_name>
          <affiliation>University of Technology Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuleisui.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yuleisui/e6ce6e88-3cd8-4595-9c61-a8da6f7319f6/small.jpg</picture_url>
          <person_id>yuleisui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xiao</first_name>
          <last_name>Cheng</last_name>
          <affiliation>Beijing University of Posts and Telecommunications</affiliation>
          <bio>undefined</bio>
          <person_id>xiaocheng</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Guanqin</first_name>
          <last_name>Zhang</last_name>
          <affiliation>University of Technology Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>guanqinzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Haoyu</first_name>
          <last_name>Wang</last_name>
          <affiliation>Beijing University of Posts and Telecommunications, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://howiepku.github.io/</homepage_url>
          <person_id>haoyuwang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9f8c659e-a171-4008-bac6-44de49d1c157</slot_id>
      <event_id>a1340467-2468-4939-918c-5b03056c26fd</event_id>
      <title>FlowCFL: Generalized Type-based Reachability Analysis</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>05:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>05:40</end_time>
      <description>Reachability analysis is a fundamental program analysis with a wide variety of applications. We present FlowCFL, a framework for type-based reachability analysis in the presence of mutable data. Interestingly, the underlying semantics of FlowCFL is CFL-reachability.
We make three contributions. First, we define a dynamic semantics that captures the notion of flow commonly used in reachability analysis. Second, we establish correctness of CFL-reachability over graphs with \emph{inverse} edges (inverse edges are necessary for the handling of mutable heap data). Our approach combines CFL-reachability with \emph{reference immutability} to avoid the addition of certain infeasible inverse edges and we demonstrate empirically that avoiding those edges results in precision improvement. Our formal account of correctness extends to this case as well. Third, we present a type-based reachability analysis and establish equivalence between a certain CFL-reachability analysis and the type-based analysis, thus proving correctness of the type-based analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ana</first_name>
          <last_name>Milanova</last_name>
          <affiliation>Rensselaer Polytechnic Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.rpi.edu/~milanova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anamilanova/4fa9038c-d0e6-44ca-b1b7-2420329714f4/small.jpg</picture_url>
          <person_id>anamilanova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b04f8cc5-d164-479b-a241-0b1904991fec</slot_id>
      <event_id>970b6051-9a69-4c86-97a5-c53ea48536a0</event_id>
      <title>Hidden Inheritance: An Inline Caching Design for TypeScript Performance</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>05:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>06:00</end_time>
      <description>TypeScript is a dynamically-typed language widely used to develop large-scale mobile applications nowadays. These applications are usually designed with complex class or interface hierarchy. These object-oriented (OO) features will lead to inefficient inline caches (ICs) or trigger deoptimizations, and impact the performance of TypeScript applications. To address this problem, we introduce an enhanced inline caching design called hidden inheritance (HI). The basic idea of HI is to cache the static class/interface hierarchy information into extended hidden classes (EHCs), and generate enhanced inline caches (EICs) to reduce IC misses or deoptimizations for OO-style TypeScript programs. The HI technique is implemented in a TypeScript engine (including a static compiler and a runtime) called STSC. STSC not only statically generates EHCs and EICs but also applies them to generate specialized machine code via ahead-of-time compilation (AOTC) or just-in-time compilation (JITC). To demonstrate the efficiency of this technique, we implement STSC on a state-of-the-art JavaScript Engine V8 and demonstrate performance improvements on industrial benchmarks and applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zhefeng</first_name>
          <last_name>Wu</last_name>
          <affiliation>Alibaba Group</affiliation>
          <bio>undefined</bio>
          <person_id>zhefengwu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zhe</first_name>
          <last_name>Sun</last_name>
          <affiliation>Alibaba Group</affiliation>
          <bio>undefined</bio>
          <person_id>zhesun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kai</first_name>
          <last_name>Gong</last_name>
          <affiliation>Alibaba Group</affiliation>
          <bio>undefined</bio>
          <person_id>kaigong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>lingyun</first_name>
          <last_name>Chen</last_name>
          <affiliation>Alibaba Group</affiliation>
          <bio>undefined</bio>
          <person_id>lingyunchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Bin</first_name>
          <last_name>Liao</last_name>
          <affiliation>Alibaba Group</affiliation>
          <bio>undefined</bio>
          <person_id>binliao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Yihua</first_name>
          <last_name>Jin</last_name>
          <affiliation>Alibaba Group</affiliation>
          <bio>undefined</bio>
          <person_id>yihuajin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b4fd46b0-dafe-4490-a041-e38b18c2b15d</slot_id>
      <event_id>71956917-c601-44ae-8f7c-0e7327f4fa45</event_id>
      <title>Gradual Verification of Recursive Heap Data Structures</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>06:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>06:20</end_time>
      <description>Current static verification techniques do not provide good support for incrementality, making it difficult for developers to focus their limited effort on specifying and verifying the properties and components that are most important. Dynamic verification approaches support incrementality, but cannot provide static guarantees. To bridge this gap, prior work proposed gradual verification, which supports incrementality by allowing every assertion to be complete, partial, or omitted, and provides sound verification that smoothly scales from dynamic to static checking. The prior approach to gradual verification, however, was limited to toy programs without recursive data structures. This paper extends gradual verification to realistic programs that manipulate recursive, mutable data structures on the heap. We solve key technical challenges, semantically connecting iso- and equi-recursive interpretations of abstract predicates as well as gradual verification of heap ownership. Our work thus lays the foundation for future tools that work on realistic programs and support verification within an engineering process in which cost-benefit trade-offs can be made.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jenna</first_name>
          <last_name>Wise</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jlwise/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jennawise/614a00d0-d8ab-4b2f-8ec7-96abcb5c3d5b/small.jpg</picture_url>
          <person_id>jennawise</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Johannes</first_name>
          <last_name>Bader</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.johannes-bader.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johannesbader/0b7e635c-fba7-4113-a53d-4451edd44ca5/small.jpg</picture_url>
          <person_id>johannesbader</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Cameron</first_name>
          <last_name>Wong</last_name>
          <affiliation>Jane Street</affiliation>
          <bio>Wannabe type theorist.</bio>
          <homepage_url>https://camdar.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cameronwong/1e4412d3-e79b-4f6a-8465-6b756986e1d0/small.jpg</picture_url>
          <person_id>cameronwong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech.
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
          <person_id>etanter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Sunshine</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jssunshi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joshuasunshine/474067e5-86e8-476c-9622-5c89be145f4b/small.jpg</picture_url>
          <person_id>joshuasunshine</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8ae9cd9f-ef33-44c5-b831-b3dc7f615daf</subevent_id>
    <title>SPLASH OOPSLA: F-5A</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>9ec5ac70-d2a5-4a25-8be9-ee949bb3ce88</slot_id>
      <title>Session: SPLASH OOPSLA - F-5A</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7b564f95-c5b6-41ca-a606-03651eb61476</slot_id>
      <event_id>d2aab79b-b621-41d8-b67d-1273235197f3</event_id>
      <title>Effects as Capabilities: Effect Handlers and Lightweight Effect Polymorphism</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>15:20</end_time>
      <description>Effect handlers have recently gained popularity amongst programming language researchers. Existing type- and effect systems for effect handlers are often complicated and potentially hinder a wide-spread adoption. In this paper, we present the language Effekt with the goal to close the gap between research languages with effect handlers and languages for working programmers. The design of Effekt revolves around a different view of effects and effect types. Traditionally, effect types express which side effects a computation might have. In Effekt, effect types express which capabilities a computation requires from its context. While this new point in the design space of effect systems impedes reasoning about the absense of effects, we demonstrate that it significantly simplifies the treatment of effect polymorphism and the related issues of effect parametricity and effect encapsulation. To guarantee effect safety, we separate functions from values and treat all functions as second-class. We define the semantics of Effekt as a translation to System Xi, a calculus in explicit capability-passing style. We prove soundness of System Xi and of our translation. We present a full implementation together with an IDE integration helping programmers to understand the typing of effectful programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan Immanuel</first_name>
          <last_name>Brachthäuser</last_name>
          <affiliation>University of Tübingen, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanbrachthauser/f9c0b5dc-9b85-444f-baed-e807673f202d/small.jpg</picture_url>
          <person_id>jonathanbrachthauser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Philipp</first_name>
          <last_name>Schuster</last_name>
          <affiliation>University of Tübingen, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippschuster/b2af00d9-c827-45e0-9805-0bf508cae083/small.jpg</picture_url>
          <person_id>philippschuster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Klaus</first_name>
          <last_name>Ostermann</last_name>
          <affiliation>University of Tübingen, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ps.informatik.uni-tuebingen.de/team/ostermann/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/klausostermann/3b2188f0-6472-4a18-b97c-765414c990c8/small.jpg</picture_url>
          <person_id>klausostermann</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b351a196-6797-4855-9961-12fe7a0bb2ed</slot_id>
      <event_id>88644c6c-8c4f-495f-859b-174d3c0ad26b</event_id>
      <title>Fast Linear Programming through Transprecision Computing on Small and Sparse Data</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>15:40</end_time>
      <description>A plethora of program analysis and optimization techniques rely on linear programming at their heart. However, such techniques are often considered too slow for production use. While today’s best solvers are optimized for complex problems with thousands of dimensions, linear programming, as used in compilers, is typically applied to seemingly trivial problems – but many instances in a single compilation run. As a result, compilers do not benefit from the decades of research on optimizing large-scale linear programming. We design a simplex solver targeted at compilers. A novel theory of transprecison computation applied from individual elements to full data-structures provides the computational foundation. By carefully combining it with optimized representations for small and sparse matrices and specialized small-coefficient algorithms, we (a) reduce memory traffic, (b) exploit wide vectors, and (c) use low-precision arithmetic units effectively. We evaluate our work by embedding our solver into a state-of-the-art integer set library and implement one essential operation, coalescing, on top of our transprecision solver. Our evaluation shows orders-of-magnitude speedup on the core simplex pivot and a 6.3x runtime reduction for the optimized operation. Our results demonstrate that optimizations for low dimensionality and small (often zero) coefficients exploit the wide SIMD instruction of modern microarchitectures effectively. By providing a highly-optimized key operation we lay new foundations for the development of next-generation integer arithmetic libraries that will power future compiler analysis and optimization frameworks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Grosser</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.grosser.es</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tobiasgrosser/1ee43044-14e9-497e-a230-90f96a8da867/small.jpg</picture_url>
          <person_id>tobiasgrosser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Theodoros</first_name>
          <last_name>Theodoridis</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/theodorostheodoridis/910b8757-b907-47c7-967c-de5414cae4b3/small.jpg</picture_url>
          <person_id>theodorostheodoridis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Maxmilian</first_name>
          <last_name>Falkenstein</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>maxmilianfalkenstein</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Pitchanathan</last_name>
          <affiliation>IIIT Hyderabad</affiliation>
          <bio>undefined</bio>
          <person_id>arjunpitchanathan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Kruse</last_name>
          <affiliation>Argonne National Laboratory</affiliation>
          <bio>undefined</bio>
          <person_id>michaelkruse1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Rigger</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>Manuel Rigger is a postdoctoral researcher in the Advanced Software Technologies (AST) Lab at ETH Zurich, mentored by Zhendong Su. He is working on programming language implementation, software reliability, and systems. He completed his PhD at Johannes Kepler University Linz, mentored by Hanspeter Mössenböck, and is known for his work on Sulong to support the safe execution of LLVM-based languages.</bio>
          <homepage_url>http://www.manuelrigger.at/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelrigger/47e268e9-158c-471f-a7e9-442216c54550/small.jpg</picture_url>
          <person_id>manuelrigger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Torsten</first_name>
          <last_name>Hoefler</last_name>
          <affiliation>Department of Computer Science, ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>torstenhoefler1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c49b3977-bf78-4796-930d-b360d8899600</subevent_id>
    <title>SPLASH OOPSLA: M-5</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>20b051f9-879f-4a54-82ee-a7fc714c84aa</slot_id>
      <title>Session: SPLASH OOPSLA - M-5</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>07e5ef70-f028-4862-a5ed-01aef07f7d89</slot_id>
      <event_id>d3521f08-1659-438b-8e27-401ba4d8046c</event_id>
      <title>Counterexample-Guided Correlation Algorithm for Translation Validation</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>15:40</end_time>
      <description>Automatic translation validation across the unoptimized intermediate representation (IR) of the original source code and the optimized executable assembly code is a desirable capability, and has the potential to compete with existing approaches to verified compilation such as CompCert [Leroy 2006]. A difficult subproblem is the automatic identification of the correlations across the transitions between the two programs’ respective locations. We present a counterexample-guided algorithm to identify these correlations in a robust and scalable manner. Our algorithm has both theoretical and empirical advantages over prior work in this problem space.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shubhani</first_name>
          <last_name>undefined</last_name>
          <affiliation>Indian Institute of Technology Delhi</affiliation>
          <bio>undefined</bio>
          <person_id>shubhani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Abhishek</first_name>
          <last_name>Rose</last_name>
          <affiliation>Indian Institute of Technology Delhi</affiliation>
          <bio>undefined</bio>
          <person_id>abhishekrose</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sorav</first_name>
          <last_name>Bansal</last_name>
          <affiliation>IIT Delhi, India</affiliation>
          <bio>See http://compiler.ai for recent work</bio>
          <homepage_url>http://www.cse.iitd.ac.in/~sbansal</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/soravbansal1/3bacf39b-3a07-41a7-9acd-f6b4c27d2f89/small.jpg</picture_url>
          <person_id>soravbansal1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5c141a66-1d47-472c-85dd-f713a9a20d5b</slot_id>
      <event_id>41308516-fe76-4573-a027-84e9a6af5694</event_id>
      <title>Multiparty Motion Coordination: From Choreographies to Robotics Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>16:00</end_time>
      <description>We present a programming model and typing discipline for complex multi-robot coordination programming. Our model encompasses both synchronisation through message passing and continuous-time dynamic motion primitives in physical space. We specify continuous-time motion primitives in an assume-guarantee logic that ensures compatibility of motion primitives as well as collision freedom. We specify global behaviour of programs in a choreographic type system that extends multiparty session types with jointly executed motion primitives, predicated refinements, as well as a separating conjunction that allows reasoning about subsets of interacting robots. We describe a notion of well-formedness for global types that ensures motion and communication can be correctly synchronised and provide algorithms for checking well-formedness, projecting a type, and local type checking. A well-typed program is communication safe, motion compatible, and collision free. Our type system provides a compositional approach to ensuring these properties.
We have implemented our model on top of the ROS framework. This allows us to program multi-robot coordination scenarios on top of commercial and custom robotics hardware platforms. We show through case studies that we can model and statically verify quite complex manoeuvres involving multiple manipulators and mobile robots—such examples are beyond the scope of previous approaches.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rupak</first_name>
          <last_name>Majumdar</last_name>
          <affiliation>Max Planck Institute for Software Systems (MPI-SWS)</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~rupak</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rupakmajumdar/3289b197-9f9a-4880-94c5-d9cf6d764bb1/small.jpg</picture_url>
          <person_id>rupakmajumdar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Damien</first_name>
          <last_name>Zufferey</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://dzufferey.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/damienzufferey/5dc321db-5cef-4f4b-bd3c-a5bbb2f11dd1/small.jpg</picture_url>
          <person_id>damienzufferey</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>71dad1ce-ad7f-45f4-95d9-6deb5c2480fd</slot_id>
      <event_id>8ec74bdb-391c-4417-a0de-3cfe60039dfb</event_id>
      <title>On the Unusual Effectiveness of Type-aware Operator Mutations for Testing SMT Solvers</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>16:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>16:20</end_time>
      <description>We propose type-aware operator mutation, a simple, but unusually effective approach for testing SMT solvers. The key idea is to mutate operators of conforming types within the seed formulas to generate well-typed mutant formulas. These mutant formulas are then used as the test cases for SMT solvers. We realized type-aware operator mutation within the OpFuzz tool and used it to stress-test Z3 and CVC4, two state-of-the-art SMT solvers. Type-aware operator mutations are unusually effective: During nine months of extensive testing with OpFuzz, we reported 909 bugs in Z3 and CVC4, out of which 632 bugs were confirmed and 531 of the confirmed bugs were fixed by the developers. The detected bugs are highly diverse — we found bugs of many different types (soundness bugs, invalid model bugs, crashes, etc.), logics and solver configurations. We have further conducted an in-depth study on the bugs found by OpFuzz. The study results show that the bugs found by OpFuzz are of high quality. Many of them affect core components of the SMT solvers’ codebases, and some required major changes for the developers to fix. Among the 909 bugs found by OpFuzz, 130 were soundness bugs, the most critical bugs in SMT solvers, and 501 were in the default modes of the solvers. Notably, OpFuzz found 16 critical soundness bugs in CVC4, which has proved to be a very stable SMT solver.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dominik</first_name>
          <last_name>Winterer</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/dominikwinterer/f89f4b13-8156-4541-b618-d5128446e27f/small.jpg</picture_url>
          <person_id>dominikwinterer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chengyu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.chengyuzhang.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/chengyuzhang/eee80413-7fee-43ac-88d2-72212b8b352a/small.jpg</picture_url>
          <person_id>chengyuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b61fb79f-5c61-4f3f-bf25-c57de286980a</slot_id>
      <event_id>f94ed25c-81d9-4aad-b499-42ebb3391f9d</event_id>
      <title>CAMP: Cost-Aware Multiparty Session Protocols</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>15:20</end_time>
      <description>This paper presents CAMP, a new static performance analysis framework for message-passing concurrent and distributed systems, based on the theory of multiparty session types (MPST). Understanding the run-time performance of concurrent and distributed systems is of great importance for the identification of bottlenecks and optimisation opportunities. In the message-passing setting, these bottlenecks are generally communication overheads and synchronisation times. Despite its importance, reasoning about these intensional properties of software, such as performance, has received little attention, compared to verifying extensional properties, such as correctness. Behavioural protocol specifications based on sessions types capture not only extensional, but also intensional properties of concurrent and distributed systems. CAMP augments MPST with annotations of communication latency and local computation cost, defined as estimated execution times, that we use to extract cost equations from protocol descriptions. CAMP is also extendable to analyse asynchronous communication optimisation built on a recent advance of session type theories. We apply our tool to different existing benchmarks and usecases in the literature with a wide range of communication protocols, implemented in C, MPI-C, Java, Go and OCaml. Our benchmarks show that, in most of the cases, we predict an upper-bound on the real execution costs with &amp;lt; 15 % error.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Castro</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <person_id>davidcastro</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4a52e381-9c16-4a27-9878-300edb61b391</subevent_id>
    <title>SPLASH OOPSLA: F-4B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>3c0ae0c3-b2e1-417c-9d69-e2d7b4da1cb0</slot_id>
      <title>Session: SPLASH OOPSLA - F-4B</title>
      <room>Online | SPLASH</room>
      <date>2020/11/21</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>62440e50-778a-40c5-84f4-750ac0be65fa</slot_id>
      <event_id>88401ded-3b58-4749-8aef-7b24b61ab09f</event_id>
      <title>Neural Reverse Engineering of Stripped Binaries using Augmented Control Flow Graphs</title>
      <room>Online | SPLASH</room>
      <date>2020/11/21</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>02:00</end_time>
      <description>We address the problem of reverse engineering of stripped executables, which contain no debug information. This is a challenging problem because of the low amount of syntactic information available in stripped executables, and the diverse assembly code patterns arising from compiler optimizations.
We present a novel approach for predicting procedure names in stripped executables. Our approach combines static analysis with neural models. The main idea is to use static analysis to obtain augmented representations of call sites; encode the structure of these call sites using the control-flow graph (CFG) and finally, generate a target name while attending to these call sites. We use our representation to drive graph-based, LSTM-based and Transformer-based architectures.
Our evaluation shows that our models produce predictions that are difficult and time consuming for humans, while improving on existing methods by 28% and by 100% over state-of-the-art neural textual models that do not use any static analysis. Code and data for this evaluation are available at https://github.com/tech-srl/Nero .</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yaniv</first_name>
          <last_name>David</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://yanivd.cswp.cs.technion.ac.il</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yanivdavid/83ffa94a-79ef-4627-b213-9d48cfeac290/small.jpg</picture_url>
          <person_id>yanivdavid</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Uri</first_name>
          <last_name>Alon</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~urialon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/urialon/a0488e4f-5173-472b-af25-10666c27e3d4/small.jpg</picture_url>
          <person_id>urialon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion</affiliation>
          <bio>Eran Yahav is an associate professor at the Computer Science Department, Technion, Israel. Prior to that, he was a research staff member at the IBM T.J. Watson Research Center (2004-2010). He received his Ph.D. from Tel Aviv University (2005) and his B.Sc. from the Technion in 1996. His research interests include program analysis, program synthesis and program verification. Eran is a recipient of the prestigious Alon Fellowship for Outstanding Young Researchers, the Andre Deloro Career Advancement Chair in Engineering, the ERC Consolidator Grant as well as multiple best paper awards at various conferences.</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
          <person_id>eranyahav</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>66eb9fb0-cc8a-4ec4-9ba7-68efdd3b1362</slot_id>
      <event_id>ec90eddc-d967-43e8-8847-c0b006802b6a</event_id>
      <title>Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification</title>
      <room>Online | SPLASH</room>
      <date>2020/11/21</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>01:40</end_time>
      <description>Lighthouse projects such as CompCert, seL4, IronFleet, and DeepSpec have demonstrated that full verification of entire systems is feasible by establishing a refinement relation between an abstract system specification and an executable implementation. Existing approaches however impose severe restrictions on either the abstract system specifications due to their limited expressiveness or versatility, or on the executable code due to their reliance on suboptimal code extraction or inexpressive program logics.
We propose a novel methodology that combines the compositional refinement of abstract, event-based models of distributed systems with the verification of full-fledged program code using expressive separation logics, which support features of realistic programming languages like mutable heap data structures and concurrency. The main technical contribution of our work is a formal framework that soundly relates event-based system models to program specifications in separation logics, such that successful verification establishes a refinement relation between the model and the code. We formalized our framework, \emph{Igloo}, in Isabelle/HOL.
Our approach leverages existing program verifiers. We report on three case studies, a leader election protocol, a replication protocol, and a security protocol, for which we refine formal requirements into program specifications that we implement in Java and Python and prove correct using the VeriFast and Nagini tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Sprenger</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>christophsprenger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Klenze</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>tobiasklenze</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marco</first_name>
          <last_name>Eilers</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch/people/personal/meilers-pers.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/marcoeilers/fbfa4a0a-c277-440b-af64-20c5dbf19d0c/small.jpg</picture_url>
          <person_id>marcoeilers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Felix</first_name>
          <last_name>Wolf</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>felixwolf2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Peter</first_name>
          <last_name>Müller</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/petermller/aeb8e276-62cb-4ad1-aa7d-96f76c0c405d/small.jpg</picture_url>
          <person_id>petermller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Martin</first_name>
          <last_name>Clochard</last_name>
          <affiliation>ETH Zürich</affiliation>
          <bio>undefined</bio>
          <person_id>martinclochard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>David</first_name>
          <last_name>Basin</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>davidbasin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6bbadf28-dbf9-4724-9579-ab5c94f57a50</slot_id>
      <event_id>cb73d5d3-92d2-4ee8-bb13-8a1b4731e3a3</event_id>
      <title>Termination Analysis for Evolving Programs</title>
      <room>Online | SPLASH</room>
      <date>2020/11/21</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>02:20</end_time>
      <description>Research on program termination has a long tradition. However, most of the existing techniques target a single program only. We propose in this paper an incremental termination analysis approach by reusing certified modules across different program versions. A transformation-based procedure is further developed to increase the reusability of certified modules. The proposed approach has wide applicability, applicable to various program changes. The proposed technique, to the best of our knowledge, represents a novel attempt to the termination analysis of evolving programs. We implemented the approach on top of \textsc{Ultimate Automizer}. Experimental results show dramatic improvement of our approach over the state-of-the-art tool.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fei</first_name>
          <last_name>He</last_name>
          <affiliation>Tsinghua University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://feihe.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/feihe/8546030e-3821-4cb3-8f33-23a258579461/small.jpg</picture_url>
          <person_id>feihe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jitao</first_name>
          <last_name>Han</last_name>
          <affiliation>School of Software, Tsinghua University</affiliation>
          <bio>undefined</bio>
          <person_id>jitaohan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e8599349-96f9-41e3-b1d9-ea4d1e31d775</slot_id>
      <event_id>607946f8-4df3-4340-83bb-3317adc76c7a</event_id>
      <title>Certified and efficient instruction scheduling</title>
      <room>Online | SPLASH</room>
      <date>2020/11/21</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>01:20</end_time>
      <description>CompCert is a moderately optimizing C compiler with a formal, machine-checked, proof of correctness: after successful compilation, the assembly code has a behavior faithful to the source code. Previously, it only supported target instruction sets with sequential semantics, and did not attempt reordering instructions for optimization.
We present here a CompCert backend for a VLIW core (i.e., with explicit parallelism at the instruction level), the first CompCert backend providing scalable and efficient instruction scheduling. Furthermore, its highly modular implementation can be easily adapted to other VLIW or non-VLIW pipelined processors.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sylvain</first_name>
          <last_name>Boulmé</last_name>
          <affiliation>Grenoble-INP - VERIMAG</affiliation>
          <bio>undefined</bio>
          <person_id>sylvainboulme</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Monniaux</last_name>
          <affiliation>CNRS, VERIMAG</affiliation>
          <bio>David Monniaux obtained his PhD in 2001 in Paris under Prof Patrick Cousot; his dissertation was on the static analysis of probabilistic programs by abstract interpretation. He then joined CNRS as a junior researcher and first worked on the Astrée static analyzer, still in Paris. In 2007 he transferred to VERIMAG in Grenoble, where he works on various aspects of program verification (decision procedures, abstract interpretation…).
He now is a senior researcher at CNRS and an adjunct professor at École polytechnique.</bio>
          <homepage_url>http://www-verimag.imag.fr/~monniaux/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidmonniaux/d285baca-8e32-4918-b3c6-c724e98fc7b3/small.jpg</picture_url>
          <person_id>davidmonniaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Cyril</first_name>
          <last_name>Six</last_name>
          <affiliation>Kalray</affiliation>
          <bio>undefined</bio>
          <person_id>cyrilsix</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d3018d06-e44d-4590-bb68-e331660f970a</subevent_id>
    <title>SPLASH OOPSLA: F-5A</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>c351a54f-bb47-43e6-a491-9c92dccca2f4</slot_id>
      <title>Session: SPLASH OOPSLA - F-5A</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a0ea4912-1fa6-4d0f-8d8c-981c5137c765</slot_id>
      <event_id>88644c6c-8c4f-495f-859b-174d3c0ad26b</event_id>
      <title>Fast Linear Programming through Transprecision Computing on Small and Sparse Data</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>03:40</end_time>
      <description>A plethora of program analysis and optimization techniques rely on linear programming at their heart. However, such techniques are often considered too slow for production use. While today’s best solvers are optimized for complex problems with thousands of dimensions, linear programming, as used in compilers, is typically applied to seemingly trivial problems – but many instances in a single compilation run. As a result, compilers do not benefit from the decades of research on optimizing large-scale linear programming. We design a simplex solver targeted at compilers. A novel theory of transprecison computation applied from individual elements to full data-structures provides the computational foundation. By carefully combining it with optimized representations for small and sparse matrices and specialized small-coefficient algorithms, we (a) reduce memory traffic, (b) exploit wide vectors, and (c) use low-precision arithmetic units effectively. We evaluate our work by embedding our solver into a state-of-the-art integer set library and implement one essential operation, coalescing, on top of our transprecision solver. Our evaluation shows orders-of-magnitude speedup on the core simplex pivot and a 6.3x runtime reduction for the optimized operation. Our results demonstrate that optimizations for low dimensionality and small (often zero) coefficients exploit the wide SIMD instruction of modern microarchitectures effectively. By providing a highly-optimized key operation we lay new foundations for the development of next-generation integer arithmetic libraries that will power future compiler analysis and optimization frameworks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Grosser</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.grosser.es</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tobiasgrosser/1ee43044-14e9-497e-a230-90f96a8da867/small.jpg</picture_url>
          <person_id>tobiasgrosser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Theodoros</first_name>
          <last_name>Theodoridis</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/theodorostheodoridis/910b8757-b907-47c7-967c-de5414cae4b3/small.jpg</picture_url>
          <person_id>theodorostheodoridis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Maxmilian</first_name>
          <last_name>Falkenstein</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>maxmilianfalkenstein</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Pitchanathan</last_name>
          <affiliation>IIIT Hyderabad</affiliation>
          <bio>undefined</bio>
          <person_id>arjunpitchanathan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Kruse</last_name>
          <affiliation>Argonne National Laboratory</affiliation>
          <bio>undefined</bio>
          <person_id>michaelkruse1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Rigger</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>Manuel Rigger is a postdoctoral researcher in the Advanced Software Technologies (AST) Lab at ETH Zurich, mentored by Zhendong Su. He is working on programming language implementation, software reliability, and systems. He completed his PhD at Johannes Kepler University Linz, mentored by Hanspeter Mössenböck, and is known for his work on Sulong to support the safe execution of LLVM-based languages.</bio>
          <homepage_url>http://www.manuelrigger.at/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelrigger/47e268e9-158c-471f-a7e9-442216c54550/small.jpg</picture_url>
          <person_id>manuelrigger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Torsten</first_name>
          <last_name>Hoefler</last_name>
          <affiliation>Department of Computer Science, ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>torstenhoefler1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d544f8b9-dc4e-49bd-b59f-b8a78e23fea5</slot_id>
      <event_id>d2aab79b-b621-41d8-b67d-1273235197f3</event_id>
      <title>Effects as Capabilities: Effect Handlers and Lightweight Effect Polymorphism</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>03:20</end_time>
      <description>Effect handlers have recently gained popularity amongst programming language researchers. Existing type- and effect systems for effect handlers are often complicated and potentially hinder a wide-spread adoption. In this paper, we present the language Effekt with the goal to close the gap between research languages with effect handlers and languages for working programmers. The design of Effekt revolves around a different view of effects and effect types. Traditionally, effect types express which side effects a computation might have. In Effekt, effect types express which capabilities a computation requires from its context. While this new point in the design space of effect systems impedes reasoning about the absense of effects, we demonstrate that it significantly simplifies the treatment of effect polymorphism and the related issues of effect parametricity and effect encapsulation. To guarantee effect safety, we separate functions from values and treat all functions as second-class. We define the semantics of Effekt as a translation to System Xi, a calculus in explicit capability-passing style. We prove soundness of System Xi and of our translation. We present a full implementation together with an IDE integration helping programmers to understand the typing of effectful programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan Immanuel</first_name>
          <last_name>Brachthäuser</last_name>
          <affiliation>University of Tübingen, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanbrachthauser/f9c0b5dc-9b85-444f-baed-e807673f202d/small.jpg</picture_url>
          <person_id>jonathanbrachthauser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Philipp</first_name>
          <last_name>Schuster</last_name>
          <affiliation>University of Tübingen, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/philippschuster/b2af00d9-c827-45e0-9805-0bf508cae083/small.jpg</picture_url>
          <person_id>philippschuster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Klaus</first_name>
          <last_name>Ostermann</last_name>
          <affiliation>University of Tübingen, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ps.informatik.uni-tuebingen.de/team/ostermann/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/klausostermann/3b2188f0-6472-4a18-b97c-765414c990c8/small.jpg</picture_url>
          <person_id>klausostermann</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d5c9f8d3-5d80-4bbe-89bd-0f6b36c261e0</subevent_id>
    <title>SPLASH OOPSLA: T-6B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>f689fbb6-cd1e-4383-8965-c9115d7c702c</slot_id>
      <title>Session: SPLASH OOPSLA - T-6B</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4399c6ea-93e1-4b7b-833d-16c0b480a78d</slot_id>
      <event_id>d9f820f7-6c4c-4457-bbf2-f791d2e1d42d</event_id>
      <title>World Age in Julia: Optimizing Method Dispatch in the Presence of Eval</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>05:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>06:00</end_time>
      <description>Dynamic programming languages face semantic and performance challenges in the presence of features such as eval. The Julia programming language introduces the novel concept of world age to insulate compiled and optimized code from one of the most disruptive side-effects of eval, namely, addition of new methods to an existing function. This paper provides the first formal semantics of world age in a core calculus named Juliette, and shows how world age enables optimization of function calls in the presence of eval.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julia</first_name>
          <last_name>Belyakova</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>Sep 2018 – present: PhD Student, Northeastern University, USA. Sep 2017 – Jul 2018: Researcher, Czech Technical University in Prague, Czech Republic. Jan 2017 – Jun 2017: Research Scientist, Northeastern University, USA. 2014–2016: teaching assistant/lecturer at Southern Federal University, Russia. Received MS in Computer Science from Southern Federal University, Russia in 2014.</bio>
          <homepage_url>https://julbinb.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juliabelyakova/b35236df-c22a-44f1-8048-aecfeba8ac2e/small.jpg</picture_url>
          <person_id>juliabelyakova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Chung</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/benjaminchung/30978af0-bcee-4c1e-9dd1-f2588ea14f38/small.jpg</picture_url>
          <person_id>benjaminchung</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jack</first_name>
          <last_name>Gelinas</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <person_id>jackgelinas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jameson</first_name>
          <last_name>Nash</last_name>
          <affiliation>Julia Computing</affiliation>
          <bio>undefined</bio>
          <person_id>jamesonnash1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ross</first_name>
          <last_name>Tate</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cornell.edu/~ross/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rosstate/cbcbd066-943d-46a2-a301-1f4084076400/small.jpg</picture_url>
          <person_id>rosstate</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4851770d-ae73-4332-b64d-273ee48544a4</slot_id>
      <event_id>c46ee935-d61f-4ade-a84a-9db9d88c737e</event_id>
      <title>Featherweight Go</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>06:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>06:20</end_time>
      <description>We describe a design for generics in Go inspired by previous work on Featherweight Java by Igarashi, Pierce, and Wadler. Whereas subtyping in Java is nominal, in Go it is structural, and whereas generics in Java are defined via erasure, in Go we use monomorphisation. Although monomorphisation is widely used, we are one of the first to formalise it. Our design also supports a solution to The Expression Problem.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Griesemer</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <person_id>robertgriesemer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Raymond</first_name>
          <last_name>Hu</last_name>
          <affiliation>University of Hertfordshire</affiliation>
          <bio>undefined</bio>
          <person_id>raymondhu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Wen</first_name>
          <last_name>Kokke</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wenkokke.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/wenkokke/756e11ff-851e-4355-865b-0b5ce896d4af/small.jpg</picture_url>
          <person_id>wenkokke</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Julien</first_name>
          <last_name>Lange</last_name>
          <affiliation>Royal Holloway, University of London</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.rhul.ac.uk/~jlange</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/julienlange1/7f3ad551-a3e6-46ce-9718-954f3147736b/small.jpg</picture_url>
          <person_id>julienlange1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ian Lance</first_name>
          <last_name>Taylor</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <person_id>ianlancetaylor</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Bernardo</first_name>
          <last_name>Toninho</last_name>
          <affiliation>Universidade Nova de Lisboa and NOVA LINCS</affiliation>
          <bio>I am interested in the application of language-based techniques to the development of more robust and safer concurrent and distributed systems. More specifically, I work within the realm of (substructural) type theory, such as those based on Linear Logic and Session Types, and their applications to concurrent programming. I am also interested in using type and logic-based techniques to verify concurrent programs in real languages such as Go, Rust and Scala.</bio>
          <homepage_url>http://ctp.di.fct.unl.pt/~btoninho/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/bernardotoninho/1125bc54-0549-4ee4-bf19-394d89568c34/small.jpg</picture_url>
          <person_id>bernardotoninho</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Philip</first_name>
          <last_name>Wadler</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>Philip Wadler is Professor of Theoretical Computer Science at the University of Edinburgh. He is an ACM Fellow and a Fellow of the Royal Society of Edinburgh, past chair of ACM SIGPLAN, past holder of a Royal Society-Wolfson Research Merit Fellowship, winner of the SIGPLAN Distinguished Service Award, and a winner of the POPL Most Influential Paper Award. Previously, he worked or studied at Stanford, Xerox Parc, CMU, Oxford, Chalmers, Glasgow, Bell Labs, and Avaya Labs, and visited as a guest professor in Copenhagen, Sydney, and Paris. He has an h-index of 60, with more than 20,000 citations to his work according to Google Scholar. He contributed to the designs of Haskell, Java, and XQuery, and is a co-author of Introduction to Functional Programming (Prentice Hall, 1988), XQuery from the Experts (Addison Wesley, 2004) and Generics and Collections in Java (O’Reilly, 2006). He has delivered invited talks in locations ranging from Aizu to Zurich.</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/wadler/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philipwadler/55a9683e-908b-4052-9d49-20fb795c74cf/small.jpg</picture_url>
          <person_id>philipwadler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9625bccc-0fbf-4906-90e2-e250fd0cf853</slot_id>
      <event_id>9d2e80dd-45d0-4797-be3b-2ed373dc14dd</event_id>
      <title>DynamiTe: Dynamic Termination and Non-termination Proofs</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>05:20</end_time>
      <description>There is growing interest in termination reasoning for non-linear programs and, meanwhile, recent dynamic strategies have shown they are able to infer invariants for such challenging programs. These advances led us to hypothesize that perhaps such dynamic strategies for non-linear invariants could be adapted to learn recurrent sets (for non-termination) and/or ranking functions (for termination).
In this paper, we exploit dynamic analysis and draw termination and non-termination as well as static and dynamic strategies closer together in order to tackle non-linear programs. For termination, our algorithm infers ranking functions from concrete transitive closures, and, for non-termination, the algorithm iteratively collects executions and dynamically learns conditions to refine recurrent sets. Finally, we describe an integrated algorithm that allows these algorithms to mutually inform each other, taking counterexamples from a failed validation in one endeavor and crossing both the static/dynamic and term./non-term.~ lines, to create new execution samples for the other one.
We have implemented these algorithms in a new tool called DynamiTe. For non-linear programs, there are currently no SV-COMP termination benchmarks so we created new sets of 37 terminating and 37 non-terminating programs. Our empirical evaluation shows that we can effectively guess (and sometimes even validate) ranking functions and recurrent sets for programs with non-linear behaviors. Furthermore, we show that counterexamples from one failed validation can be used to generate executions for a dynamic analysis of the opposite property. Although we are focused on non-linear programs, as a point of comparison, we compare DynamiTe’s performance on linear programs with that of the state-of-the-art tool, Ultimate. Although DynamiTe is an order of magnitude slower it is nonetheless somewhat competitive and sometimes finds ranking functions where Ultimate was unable to. Ultimate cannot, however, handle the non-linear programs in our new benchmark suite.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ton Chanh</first_name>
          <last_name>Le</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://chanhle.bitbucket.io/</homepage_url>
          <person_id>tonchanhle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Timos</first_name>
          <last_name>Antonopoulos</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <person_id>timosantonopoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Parisa</first_name>
          <last_name>Fathololumi</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>parisafathololumi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Eric</first_name>
          <last_name>Koskinen</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.stevens.edu/~ejk/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/erickoskinen/3413fc94-5f0f-4855-af65-da2309d2632f/small.jpg</picture_url>
          <person_id>erickoskinen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>ThanhVu</first_name>
          <last_name>Nguyen</last_name>
          <affiliation>University of Nebraska, Lincoln</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cse.unl.edu/~tnguyen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/thanhvunguyen/db337089-c863-4086-ad33-88d7dbfeb025/small.jpg</picture_url>
          <person_id>thanhvunguyen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>beea1f30-7688-4039-a2ee-3027573361d5</slot_id>
      <event_id>df17fa6a-2bc8-41ee-8c02-85f4a68c1db1</event_id>
      <title>Programming and Reasoning with Partial Observability</title>
      <room>Online | SPLASH</room>
      <date>2020/11/18</date>
      <start_time>05:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>05:40</end_time>
      <description>Computer programs are increasingly being deployed in partially-observable environments. A partially observable environment is an environment whose state is not completely visible to the program, but from which the program receives partial information in the form of observations. Developers typically deal with partial observability by writing a state estimator that, given observations, attempts to deduce the hidden state of the environment. In safety-critical domains, to formally verify safety properties developers may write an environment model. The model captures the relationship between observations and hidden states and is used to prove the software correct.
In this paper, we present a new methodology for writing and verifying programs in partially observable environments. We present belief programming, a programming methodology where developers write an environment model that the program runtime automatically uses to perform state estimation. A belief program dynamically updates and queries a belief state that captures the possible states the environment could be in. To enable verification, we present epistemic Hoare logic that reasons about the possible belief states of a belief program the same way that classical Hoare logic reasons about the possible states of a program. We develop these concepts by defining a semantics and a program logic for a simple core language called BLIMP. In a case study, we show how belief programming could be used to write and verify a controller for the Mars Polar Lander in BLIMP.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Atkinson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>ericatkinson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology.
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems.
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ca7f4eff-20cb-4c08-92aa-4b6d08fc0358</subevent_id>
    <title>SPLASH OOPSLA: M-6</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>8df03c02-4d47-4713-a74d-efc4b0f20d55</slot_id>
      <title>Session: SPLASH OOPSLA - M-6</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4139843d-392e-4fdf-93eb-330fe007034e</slot_id>
      <event_id>c241afa2-8ebc-4091-ba8b-11b2acfe950d</event_id>
      <title>Can Advanced Type Systems Be Usable? An Empirical Study of Ownership, Assets, and Typestate in Obsidian</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>17:20</end_time>
      <description>Some blockchain programs (smart contracts) have included serious security vulnerabilities. Obsidian is a new typestate-oriented programming language that uses a strong type system to rule out some of these vulnerabilities. Although Obsidian was designed to promote usability to make it as easy as possible to write programs, strong type systems can cause a language to be difficult to use. In particular, ownership, typestate, and assets, which Obsidian uses to provide safety guarantees, have not seen broad adoption in popular languages and result in significant usability challenges. We performed an empirical study with 20 participants comparing Obsidian to Solidity, which is the language most commonly used for writing smart contracts today. We observed that Obsidian participants were able to successfully complete more of the programming tasks than the Solidity participants. We also found that asset-related bugs, which Obsidian detects at compile time, were commonly accidentally inserted by the Solidity participants.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Coblenz</last_name>
          <affiliation>University of Maryland at College Park, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~mcoblenz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelcoblenz/aa74b306-529b-44d4-987f-a5e4fd6d3ca2/small.jpg</picture_url>
          <person_id>michaelcoblenz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech.
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brad</first_name>
          <last_name>Myers</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~bam/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/bradmyers/7d93ede9-5674-40e8-9ba5-f9dfab4873e1/small.jpg</picture_url>
          <person_id>bradmyers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Sunshine</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jssunshi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joshuasunshine/474067e5-86e8-476c-9622-5c89be145f4b/small.jpg</picture_url>
          <person_id>joshuasunshine</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>593f1ff2-1943-495f-96f7-4d7e0d30f24b</slot_id>
      <event_id>f6dc9ecd-0036-4c59-8d53-f697d30259d2</event_id>
      <title>Geometry Types for Graphics Programming</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>18:00</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>18:20</end_time>
      <description>In domains that deal with physical space and geometry, programmers need to track the coordinate systems that underpin a computation. We identify a class of geometry bugs that arise from confusing which coordinate system a vector belongs to. These bugs are not ruled out by current languages for vector-oriented computing, are difficult to check for at run time, and can generate subtly incorrect output that can be hard to test for.
We introduce a type system and language that prevents geometry bugs by reflecting the coordinate system for each geometric object. A value’s geometry type encodes its reference frame, the kind of geometric object (such as a point or a direction), and the computational representation (such as Cartesian or spherical coordinates). We show how these types can rule out geometrically incorrect operations, and we show how to use them to automatically generate correct-by-construction code to transform vectors between coordinate systems. We implement a language for graphics programming, Gator, that checks geometry types and compiles to OpenGL’s shading language, GLSL. Using case studies, we demonstrate that Gator can raise the level of abstraction for shader programming and prevent common errors without inducing significant annotation overhead or performance cost.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dietrich</first_name>
          <last_name>Geisler</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <person_id>dietrichgeisler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Irene</first_name>
          <last_name>Yoon</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://seas.upenn.edu/~euisuny</homepage_url>
          <person_id>ireneyoon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aditi</first_name>
          <last_name>Kabra</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <person_id>aditikabra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Horace</first_name>
          <last_name>He</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <person_id>horacehe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yinnon</first_name>
          <last_name>Sanders</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <person_id>yinnonsanders</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Adrian</first_name>
          <last_name>Sampson</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://adriansampson.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adriansampson/adaa9202-3352-4410-b03a-1eb4718543d5/small.jpg</picture_url>
          <person_id>adriansampson</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9ae7128d-e138-4f37-9b64-7d397ee6f541</slot_id>
      <event_id>0cc82840-fb71-4f1f-a4cb-a199c7956974</event_id>
      <title>Scalable and Serializable Networked Multi-Actor Programming</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>17:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>17:40</end_time>
      <description>A major challenge in writing applications that execute across hosts, such as distributed online services, is to reconcile (a) parallelism (i.e., allowing components to execute independently on disjoint tasks), and (b)cooperation (i.e., allowing components to work together on common tasks). A good compromise between the two is vital to scalability, a core concern in distributed networked applications.
The actor model of computation is a widely promoted programming model for distributed applications, as actors can execute in individual threads (parallelism) across different hosts and interact via asynchronous message passing (collaboration). However, this makes it hard for programmers to reason about combinations of messages as opposed to individual messages, which is essential in many scenarios.
This paper presents a pragmatic variant of the actor model in which messages can be grouped into units that are executed in a serializable manner, whilst still retaining a high degree of parallelism. In short, our model is based on an orchestration of actors along a directed acyclic graph that supports efficient decentralized synchronization among actors based on their actual interaction. We present the implementation of this model, based on a dynamic DAG-inducing referencing discipline, in the actor-based programming language XYZ. We argue serializability and the absence of deadlocks in our model, and demonstrate its scalability and usability through extensive evaluation and case studies of wide-ranging applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>BO</first_name>
          <last_name>SANG</last_name>
          <affiliation>Purdue University, Ant Financial Services Group</affiliation>
          <bio>undefined</bio>
          <person_id>bosang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Eugster</last_name>
          <affiliation>Universita della Svizzera Italiana, Switzerland</affiliation>
          <bio>Professor Eugster’s research aims at proposing support for developing distributed systems. Particular topics of interest, in the context of distributed settings, include algorithms, middleware, and programming languages, abstractions, and methodologies.
Professor Eugster was educated in Switzerland, and has worked for both Swiss Federal Institutes of Technology in Lausanne (EPFL) and in Zurich (ETHZ), as well as for Sun Microsystems (now Oracle) prior to joining Purdue University. He has authored over 70 refereed articles, and is a member of ACM and IEEE. Among other awards for his research and teaching, Professor Eugster has received an NSF CAREER award (2007) and Experienced Researcher fellowship by the Alexander von Humboldt foundation (2011). He is also a participant of the 2011 DARPA Computer Science Study Panel.</bio>
          <homepage_url>https://www.cs.purdue.edu/people/faculty/peugster/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/patrickeugster/bf8c955c-8902-4678-8c57-4b75cbd4f3c0/small.jpg</picture_url>
          <person_id>patrickeugster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gustavo</first_name>
          <last_name>Petri</last_name>
          <affiliation>Arm Ltd</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gpetri.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gustavopetri/08af6041-7317-4929-9a80-b63b5f03a5b6/small.jpg</picture_url>
          <person_id>gustavopetri</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Srivatsan</first_name>
          <last_name>Ravi</last_name>
          <affiliation>University of Southern California</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.usc.edu/srivatsr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/srivatsanravi/8ec9644c-3166-4f60-b70b-778f80ece302/small.jpg</picture_url>
          <person_id>srivatsanravi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Pierre-Louis</first_name>
          <last_name>Roman</last_name>
          <affiliation>Università della Svizzera italiana</affiliation>
          <bio>undefined</bio>
          <person_id>pierrelouisroman</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d037ea18-5d39-42e8-a13f-469097e87f5b</slot_id>
      <event_id>19e7c385-f2f5-47e8-97a6-7a2e9e7afb77</event_id>
      <title>Designing Types for R, Empirically</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>17:40</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>18:00</end_time>
      <description>The R programming language is widely used in a variety of domains. It was designed to favor an interactive style of programming with minimal syntactic and conceptual overhead. This design is well suited to interactive data analysis, but a bad fit for tools such as compilers or program analyzers which must generate native code or catch programming errors. In particular, R has no type annotations, all operations are dynamically checked at run-time. The starting point for our work are the twin questions, \emph{what expressive power is needed to accurately type R code?} and \emph{which type system is the R community willing to adopt?} Both questions are difficult to answer without actually experimenting with a type system. The goal of this paper is to provide data that can feed into that design process. To this end, we perform a large corpus analysis to gain insights in the degree of polymorphism exhibited by idiomatic R code and explore potential benefits that the R community could accrue from a simple type system. As a starting point, we infer type signatures for 20214 functions from 412 packages among the most widely used open source R libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexi</first_name>
          <last_name>Turcotte</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://reallytg.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexiturcotte/6881a0a0-5145-40cb-aab4-ff41754a0640/small.jpg</picture_url>
          <person_id>alexiturcotte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Filip</first_name>
          <last_name>Krikava</last_name>
          <affiliation>Czech Technical University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fikovnik.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/filipkrikava/12cc1e57-732c-4b7e-880e-ca7b51a07d77/small.jpg</picture_url>
          <person_id>filipkrikava</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>53e63f52-3e97-4d09-a82d-ede718ed81b5</subevent_id>
    <title>SPLASH OOPSLA: F-5B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>447997d6-5c33-4710-b453-bc5617f4e9f3</slot_id>
      <title>Session: SPLASH OOPSLA - F-5B</title>
      <room>Online | SPLASH</room>
      <date>2020/11/21</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5499046c-9114-495c-9253-671395b2ff89</slot_id>
      <event_id>3f3bef96-f531-418a-9389-fe359db5c7a1</event_id>
      <title>Rethinking Safe Consistency in Distributed Object-Oriented Programming</title>
      <room>Online | SPLASH</room>
      <date>2020/11/21</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>03:40</end_time>
      <description>Large scale distributed systems require to embrace the trade off between consistency and availability, accepting lower levels of consistency to guarantee higher availability. Existing programming languages are, however, agnostic to this compromise, resulting in consistency guarantees that are the same for the whole application and are implicitly adopted from the middleware or hardcoded in configuration files.
In this paper, we propose to integrate availability in the design of an object-oriented language, allowing developers to specify different consistency and isolation constraints in the same application at the granularity of single objects. We investigate how availability levels interact with object structure and define a type system that preserves correct program behavior. Our evaluation shows that our solution performs efficiently and improves the design of distributed applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mirko</first_name>
          <last_name>Köhler</last_name>
          <affiliation>Technische Universität Darmstadt</affiliation>
          <bio>undefined</bio>
          <person_id>mirkokohler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nafise</first_name>
          <last_name>Eskandani Masoule</last_name>
          <affiliation>Technical University of Darmstadt</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.stg.tu-darmstadt.de/staff/nafise_eskandani</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nafiseeskandanimasoule/6eac9bf0-bfcf-4440-ba06-24fa9145cb4e/small.jpg</picture_url>
          <person_id>nafiseeskandanimasoule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pascal</first_name>
          <last_name>Weisenburger</last_name>
          <affiliation>Technische Universität Darmstadt</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/pascalweisenburger/bf663f00-24ac-4d12-919b-ef1e2ff8e128/small.jpg</picture_url>
          <person_id>pascalweisenburger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Alessandro</first_name>
          <last_name>Margara</last_name>
          <affiliation>Politecnico di Milano</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://margara.faculty.polimi.it</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alessandromargara/c43a91d0-b824-4046-ab28-23a6ad3c2c3b/small.jpg</picture_url>
          <person_id>alessandromargara</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Guido</first_name>
          <last_name>Salvaneschi</last_name>
          <affiliation>University of St. Gallen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.guidosalvaneschi.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guidosalvaneschi/6f1373d5-57c6-4d68-b6c3-c0a679ee24ed/small.jpg</picture_url>
          <person_id>guidosalvaneschi</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9860d56e-e4f0-4da0-9ee6-0ef6551eda8b</slot_id>
      <event_id>193eb222-e5b0-4ec0-88fe-28f689c66880</event_id>
      <title>Programming at the Edge of Synchrony</title>
      <room>Online | SPLASH</room>
      <date>2020/11/21</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>03:20</end_time>
      <description>Synchronization primitives for fault-tolerant distributed systems that ensure an effective and efficient cooperation among processes are an important challenge in the programming languages community. We present a new programming abstraction, ReSync, for implementing benign and Byzantine fault-tolerant protocols. ReSync has a new round structure that offers a simple abstraction for group communication, like it is customary in synchronous systems, but also allows messages to be received one by one, like in the asynchronous systems. This extension allows implementing network and algorithm-specific policies for the message reception, which is not possible in classic round models.
The execution of ReSync programs is based on a new generic round switch protocol that generalizes the famous theoretical result of Dwork, Lynch and Stockmeyer [1988]. We evaluate experimentally the performance of ReSync’s execution platform, by comparing consensus implementations in ReSync with LibPaxos3, etcd, and Bft-SMaRt, three consensus libraries tolerant to benign, resp. byzantine faults.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cezara</first_name>
          <last_name>Drăgoi</last_name>
          <affiliation>INRIA, ENS, CNRS</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.di.ens.fr/~cezarad/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cezaradragoi/3403e4d3-23e5-41ac-8cf7-48cc033f3d48/small.jpg</picture_url>
          <person_id>cezaradragoi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Josef</first_name>
          <last_name>Widder</last_name>
          <affiliation>Informal Systems</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://forsyte.at/widder</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/josefwidder1/44228499-3e67-4144-be7a-4bcc366c4dd7/small.jpg</picture_url>
          <person_id>josefwidder1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Damien</first_name>
          <last_name>Zufferey</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://dzufferey.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/damienzufferey/5dc321db-5cef-4f4b-bd3c-a5bbb2f11dd1/small.jpg</picture_url>
          <person_id>damienzufferey</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9de56217-3fb6-4c19-9304-0174ecbd0486</slot_id>
      <event_id>67d39e09-ddf4-4c9d-8d1b-b8dffa795e2f</event_id>
      <title>Testing Consensus Implementations Using Communication Closure</title>
      <room>Online | SPLASH</room>
      <date>2020/11/21</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>04:00</end_time>
      <description>Large scale production distributed systems are difficult to design and test. Correctness must be ensured when processes run asynchronously, at arbitrary rates relative to each other, and in the presence of failures, e.g., process crashes or message losses. These conditions create a huge space of executions that is difficult to explore in a principled way. Current testing techniques focus on systematic or randomized exploration of all executions of an implementation while treating the implemented algorithms as black boxes. On the other hand, proofs of correctness of many of the underlying algorithms often exploit semantic properties that reduce reasoning about correctness to a subset of behaviors. For example, the \emph{communication-closure} property, used in many proofs of distributed consensus algorithms, shows that every asynchronous execution of the algorithm is equivalent to a \emph{lossy synchronous} execution, thus reducing the burden of proof to only that subset. In a lossy synchronous execution, processes execute in lock-step rounds, and messages are either received in the same round or lost forever—such executions form a small subset of all asynchronous ones.
We formulate the \emph{communication-closure hypothesis}, which states that bugs in distributed systems implementations will already manifest in lossy synchronous executions and present a testing algorithm based on this hypothesis. We prioritize the search space based on a bound on the number of failures in the execution and the rate at which these failures are recovered. We show that a random testing algorithm based on sampling lossy synchronous executions can empirically find a number of bugs—including previously unknown ones—in production distributed systems such as Zookeeper, Cassandra, and Ratis, and also produce more understandable bug traces.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cezara</first_name>
          <last_name>Drăgoi</last_name>
          <affiliation>INRIA, ENS, CNRS</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.di.ens.fr/~cezarad/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cezaradragoi/3403e4d3-23e5-41ac-8cf7-48cc033f3d48/small.jpg</picture_url>
          <person_id>cezaradragoi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Constantin</first_name>
          <last_name>Enea</last_name>
          <affiliation>IRIF, University Paris Diderot &amp; CNRS</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~cenea/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/constantinenea/2dfe8bfe-ddfe-4012-a2e2-01cc8b953734/small.jpg</picture_url>
          <person_id>constantinenea</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Burcu</first_name>
          <last_name>Kulahcioglu Ozkan</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/burcukulahciogluozkan/4a854b1d-126f-47f5-8935-25d6401437c4/small.jpg</picture_url>
          <person_id>burcukulahciogluozkan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rupak</first_name>
          <last_name>Majumdar</last_name>
          <affiliation>Max Planck Institute for Software Systems (MPI-SWS)</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~rupak</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rupakmajumdar/3289b197-9f9a-4880-94c5-d9cf6d764bb1/small.jpg</picture_url>
          <person_id>rupakmajumdar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Filip</first_name>
          <last_name>Niksic</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://fniksic.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/filipniksic/404f7660-8944-48cb-b97d-7b25a191367c/small.jpg</picture_url>
          <person_id>filipniksic</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>483769f2-9c86-4b77-9eb3-a522d54146e7</subevent_id>
    <title>SPLASH OOPSLA: W-3</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>92eec067-fc85-4306-b4c6-a5dfad021181</slot_id>
      <title>Session: SPLASH OOPSLA - W-3</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0d531532-f581-4229-b750-534b10ec36cf</slot_id>
      <event_id>a67c5220-155d-4d8b-af2a-ba2543bafbfa</event_id>
      <title>Dynamic Dispatch of Context-Sensitive Optimizations</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>00:00</end_time>
      <description>The academia has spent much effort into making context-sensitive analyses practical, with great profit. However, the implementation of context-sensitive optimizations, in contrast to analyses, is still not practical, due to code-size explosion. This growth happens because current technology requires the cloning of full paths in the Calling Context Tree. In this paper, we present a solution to this problem. We combine finite state machines and dynamic dispatching to allow fully context-sensitive specialization while cloning only functions that are effectively optimized. This technique makes it possible to apply very liberal optimizations, such as context-sensitive constant propagation, in large programs – something that could not have been easily done before. We demonstrate the viability of our idea by formalizing it in Prolog, and implementing it in LLVM. As a proof of concept, we have used our state machines to implement context-sensitive constant propagation in LLVM. The binaries produced by traditional full cloning are 2.63 times larger than the binaries that we generate with our state machines.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gabriel</first_name>
          <last_name>Poesia</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>gabrielpoesia1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fernando Magno Quintão</first_name>
          <last_name>Pereira</last_name>
          <affiliation>UFMG</affiliation>
          <bio>Fernando got his Ph.D at UCLA in 2008, under the supervision of Jens Palsberg. He is currently an assistant professor at the Universidade Federal de Minas Gerais, Brazil. His main research interest are in code generation, compiler optimizations and static program analyses.</bio>
          <homepage_url>http://homepages.dcc.ufmg.br/~fernando/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/fernandomagnoquintaopereira/8f86b14f-fbc3-49a4-9f4f-1a8216564d39/small.jpg</picture_url>
          <person_id>fernandomagnoquintaopereira</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>53983365-f2a1-4d90-b180-5d3efb4060cb</slot_id>
      <event_id>9b43b518-879b-4aa7-b841-9f12dc9bcf2a</event_id>
      <title>Automated Policy Synthesis for System Call Sandboxing</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>00:20</end_time>
      <description>System call whitelisting is a powerful sandboxing approach that can significantly reduce the capabilities of an attacker if an application is compromised. Given a \emph{policy} that specifies which system calls can be invoked with what arguments, a sandboxing framework terminates any execution that violates the policy. While this mechanism greatly reduces the attack surface of a system, manually constructing these policies is time-consuming and error-prone. As a result, many applications —including those that take untrusted user input— opt not to use a system call sandbox.
Motivated by this problem, we propose a technique for automatically constructing system call whitelisting policies for a given application and policy DSL. Our method combines static code analysis and program synthesis to construct \emph{sound and precise policies} that never erroneously terminate the application, while restricting the program’s system call usage as much as possible. We have implemented our approach in a tool called Abhaya and experimentally evaluate it 674 Linux and OpenBSD applications by automatically synthesizing Seccomp-bpf and Pledge policies. Our experimental results indicate that Abhaya can efficiently generate useful and precise sandboxes for real-world applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shankara</first_name>
          <last_name>Pailoor</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>shankarapailoor</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xinyu</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://web.eecs.umich.edu/~xwangsd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xinyuwang/ccbe37b1-293c-4205-8386-295e20bce0d7/small.jpg</picture_url>
          <person_id>xinyuwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hovav</first_name>
          <last_name>Shacham</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>hovavshacham</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Isil</first_name>
          <last_name>Dillig</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>Isil Dillig is an Associate Professor of Computer Science at the University of Texas at Austin where she leads the UToPiA research group. Her main research area is programming languages, with a specific emphasis on static analysis, verification, and program synthesis. The techniques developed by her group aim to make software systems more reliable, secure, and easier to build in a robust way. Dr. Dillig is a Sloan Fellow and a recipient of the NSF CAREER award. She obtained all her degrees (BS, MS, and PhD) from Stanford University.</bio>
          <homepage_url>http://www.cs.utexas.edu/~isil/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/isildillig/e4fa3855-0ae4-4638-84e3-1fe224e64e3f/small.jpg</picture_url>
          <person_id>isildillig</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b6631dc5-c143-4626-a825-26fdbc0361ba</slot_id>
      <event_id>36a05e0f-c662-4f1b-b7fa-748674279502</event_id>
      <title>Build Scripts with Perfect Dependencies</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>23:20</end_time>
      <description>Build scripts for most build systems describe the actions to run, and the dependencies between those actions – but often build scripts get those dependencies wrong. Most build scripts have both too few dependencies (leading to incorrect build outputs) and too many dependencies (leading to excessive rebuilds and reduced parallelism). Any programmer who has wondered why a small change led to excess compilation, or who resorted to a “clean” step, has suffered the ill effects of incorrect dependency specification. We outline a build system where dependencies are not specified, but instead captured by tracing execution. The consequence is that dependencies are always correct by construction and build scripts are easier to write. The simplest implementation of our approach would lose parallelism, but we are able to recover parallelism using speculation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sarah</first_name>
          <last_name>Spall</last_name>
          <affiliation>Indiana University</affiliation>
          <bio>undefined</bio>
          <person_id>sarahspall</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Neil</first_name>
          <last_name>Mitchell</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ndmitchell.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/neilmitchell/bcccf5bd-0c3b-4e0e-90c9-ef73780b976c/small.jpg</picture_url>
          <person_id>neilmitchell</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sam</first_name>
          <last_name>Tobin-Hochstadt</last_name>
          <affiliation>Indiana University</affiliation>
          <bio>I am an Assistant Professor in the Department of Computer Science at Indiana University.
Research Interests: my research focuses on the design and analysis of software and programming languages. I am particularly interested in how programs grow from prototype scripts to robust software, and how programming language design can support this process. My research concerns type systems, software contracts, modularity, and extensibility. I’m currently working with the DARPA CRASH program on Racket and with Mozilla Labs on JavaScript.</bio>
          <homepage_url>http://samth.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/samtobinhochstadt/d817e5c9-fe1c-4664-a4d1-6af45d4d4586/small.jpg</picture_url>
          <person_id>samtobinhochstadt</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bedd2c49-96cd-41c5-b30c-1efc75bb23a9</slot_id>
      <event_id>dc2c4321-bace-402b-a2d9-f08a7830e7e5</event_id>
      <title>Random Testing for C and C++ Compilers with YARPGen</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>23:40</end_time>
      <description>Compilers should not crash and they should not miscompile applications. Random testing is an effective method for finding compiler bugs that have escaped other kinds of testing. This paper presents CFuzz, a random test-case generator for C and C++ that we used to find and report more than 220 bugs in GCC, LLVM, and the Intel® C++ Compiler. Our research contributions include a method for generating expressive programs that avoid undefined behavior without using dynamic checks, and \emph{generation policies}, a new mechanism for increasing diversity of generated code and for triggering more optimizations. Generation policies decrease the testing time to find hard-to-trigger compiler bugs and, for the kinds of scalar optimizations CFuzz was designed to stress-test, increase the number of times these optimizations are applied by the compiler by an average of 20% for LLVM and 40% for GCC. We also created tools for automating most of the common tasks related to compiler fuzzing; these tools are also useful for fuzzers other than ours.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vsevolod</first_name>
          <last_name>Livinskii</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
          <person_id>vsevolodlivinskii</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dmitry</first_name>
          <last_name>Babokin</last_name>
          <affiliation>Intel Corporation</affiliation>
          <bio>undefined</bio>
          <person_id>dmitrybabokin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>John</first_name>
          <last_name>Regehr</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.utah.edu/~regehr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnregehr/2cb23ab0-042a-487a-a859-cbd3147a46a7/small.jpg</picture_url>
          <person_id>johnregehr</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b798486d-fefd-4104-a8fe-65a6b3fecd26</subevent_id>
    <title>SPLASH OOPSLA: M-6</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>d575a98a-4f11-49bf-a509-d9036907d7ce</slot_id>
      <title>Session: SPLASH OOPSLA - M-6</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4a2757ce-21d4-4403-9cac-fadeaa2c2147</slot_id>
      <event_id>f6dc9ecd-0036-4c59-8d53-f697d30259d2</event_id>
      <title>Geometry Types for Graphics Programming</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>06:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>06:20</end_time>
      <description>In domains that deal with physical space and geometry, programmers need to track the coordinate systems that underpin a computation. We identify a class of geometry bugs that arise from confusing which coordinate system a vector belongs to. These bugs are not ruled out by current languages for vector-oriented computing, are difficult to check for at run time, and can generate subtly incorrect output that can be hard to test for.
We introduce a type system and language that prevents geometry bugs by reflecting the coordinate system for each geometric object. A value’s geometry type encodes its reference frame, the kind of geometric object (such as a point or a direction), and the computational representation (such as Cartesian or spherical coordinates). We show how these types can rule out geometrically incorrect operations, and we show how to use them to automatically generate correct-by-construction code to transform vectors between coordinate systems. We implement a language for graphics programming, Gator, that checks geometry types and compiles to OpenGL’s shading language, GLSL. Using case studies, we demonstrate that Gator can raise the level of abstraction for shader programming and prevent common errors without inducing significant annotation overhead or performance cost.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dietrich</first_name>
          <last_name>Geisler</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <person_id>dietrichgeisler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Irene</first_name>
          <last_name>Yoon</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://seas.upenn.edu/~euisuny</homepage_url>
          <person_id>ireneyoon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aditi</first_name>
          <last_name>Kabra</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <person_id>aditikabra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Horace</first_name>
          <last_name>He</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <person_id>horacehe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yinnon</first_name>
          <last_name>Sanders</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <person_id>yinnonsanders</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Adrian</first_name>
          <last_name>Sampson</last_name>
          <affiliation>Cornell University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://adriansampson.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/adriansampson/adaa9202-3352-4410-b03a-1eb4718543d5/small.jpg</picture_url>
          <person_id>adriansampson</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9bb76054-5af7-4891-b019-028b3dbb788f</slot_id>
      <event_id>0cc82840-fb71-4f1f-a4cb-a199c7956974</event_id>
      <title>Scalable and Serializable Networked Multi-Actor Programming</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>05:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>05:40</end_time>
      <description>A major challenge in writing applications that execute across hosts, such as distributed online services, is to reconcile (a) parallelism (i.e., allowing components to execute independently on disjoint tasks), and (b)cooperation (i.e., allowing components to work together on common tasks). A good compromise between the two is vital to scalability, a core concern in distributed networked applications.
The actor model of computation is a widely promoted programming model for distributed applications, as actors can execute in individual threads (parallelism) across different hosts and interact via asynchronous message passing (collaboration). However, this makes it hard for programmers to reason about combinations of messages as opposed to individual messages, which is essential in many scenarios.
This paper presents a pragmatic variant of the actor model in which messages can be grouped into units that are executed in a serializable manner, whilst still retaining a high degree of parallelism. In short, our model is based on an orchestration of actors along a directed acyclic graph that supports efficient decentralized synchronization among actors based on their actual interaction. We present the implementation of this model, based on a dynamic DAG-inducing referencing discipline, in the actor-based programming language XYZ. We argue serializability and the absence of deadlocks in our model, and demonstrate its scalability and usability through extensive evaluation and case studies of wide-ranging applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>BO</first_name>
          <last_name>SANG</last_name>
          <affiliation>Purdue University, Ant Financial Services Group</affiliation>
          <bio>undefined</bio>
          <person_id>bosang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Eugster</last_name>
          <affiliation>Universita della Svizzera Italiana, Switzerland</affiliation>
          <bio>Professor Eugster’s research aims at proposing support for developing distributed systems. Particular topics of interest, in the context of distributed settings, include algorithms, middleware, and programming languages, abstractions, and methodologies.
Professor Eugster was educated in Switzerland, and has worked for both Swiss Federal Institutes of Technology in Lausanne (EPFL) and in Zurich (ETHZ), as well as for Sun Microsystems (now Oracle) prior to joining Purdue University. He has authored over 70 refereed articles, and is a member of ACM and IEEE. Among other awards for his research and teaching, Professor Eugster has received an NSF CAREER award (2007) and Experienced Researcher fellowship by the Alexander von Humboldt foundation (2011). He is also a participant of the 2011 DARPA Computer Science Study Panel.</bio>
          <homepage_url>https://www.cs.purdue.edu/people/faculty/peugster/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/patrickeugster/bf8c955c-8902-4678-8c57-4b75cbd4f3c0/small.jpg</picture_url>
          <person_id>patrickeugster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gustavo</first_name>
          <last_name>Petri</last_name>
          <affiliation>Arm Ltd</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gpetri.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gustavopetri/08af6041-7317-4929-9a80-b63b5f03a5b6/small.jpg</picture_url>
          <person_id>gustavopetri</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Srivatsan</first_name>
          <last_name>Ravi</last_name>
          <affiliation>University of Southern California</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.usc.edu/srivatsr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/srivatsanravi/8ec9644c-3166-4f60-b70b-778f80ece302/small.jpg</picture_url>
          <person_id>srivatsanravi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Pierre-Louis</first_name>
          <last_name>Roman</last_name>
          <affiliation>Università della Svizzera italiana</affiliation>
          <bio>undefined</bio>
          <person_id>pierrelouisroman</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a8f4982c-031e-4299-a05a-a8f0eee317d5</slot_id>
      <event_id>19e7c385-f2f5-47e8-97a6-7a2e9e7afb77</event_id>
      <title>Designing Types for R, Empirically</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>05:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>06:00</end_time>
      <description>The R programming language is widely used in a variety of domains. It was designed to favor an interactive style of programming with minimal syntactic and conceptual overhead. This design is well suited to interactive data analysis, but a bad fit for tools such as compilers or program analyzers which must generate native code or catch programming errors. In particular, R has no type annotations, all operations are dynamically checked at run-time. The starting point for our work are the twin questions, \emph{what expressive power is needed to accurately type R code?} and \emph{which type system is the R community willing to adopt?} Both questions are difficult to answer without actually experimenting with a type system. The goal of this paper is to provide data that can feed into that design process. To this end, we perform a large corpus analysis to gain insights in the degree of polymorphism exhibited by idiomatic R code and explore potential benefits that the R community could accrue from a simple type system. As a starting point, we infer type signatures for 20214 functions from 412 packages among the most widely used open source R libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexi</first_name>
          <last_name>Turcotte</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://reallytg.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexiturcotte/6881a0a0-5145-40cb-aab4-ff41754a0640/small.jpg</picture_url>
          <person_id>alexiturcotte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Filip</first_name>
          <last_name>Krikava</last_name>
          <affiliation>Czech Technical University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fikovnik.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/filipkrikava/12cc1e57-732c-4b7e-880e-ca7b51a07d77/small.jpg</picture_url>
          <person_id>filipkrikava</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cf796bd0-c1cb-43e6-9ce2-c919df34f2e0</slot_id>
      <event_id>c241afa2-8ebc-4091-ba8b-11b2acfe950d</event_id>
      <title>Can Advanced Type Systems Be Usable? An Empirical Study of Ownership, Assets, and Typestate in Obsidian</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>05:20</end_time>
      <description>Some blockchain programs (smart contracts) have included serious security vulnerabilities. Obsidian is a new typestate-oriented programming language that uses a strong type system to rule out some of these vulnerabilities. Although Obsidian was designed to promote usability to make it as easy as possible to write programs, strong type systems can cause a language to be difficult to use. In particular, ownership, typestate, and assets, which Obsidian uses to provide safety guarantees, have not seen broad adoption in popular languages and result in significant usability challenges. We performed an empirical study with 20 participants comparing Obsidian to Solidity, which is the language most commonly used for writing smart contracts today. We observed that Obsidian participants were able to successfully complete more of the programming tasks than the Solidity participants. We also found that asset-related bugs, which Obsidian detects at compile time, were commonly accidentally inserted by the Solidity participants.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Coblenz</last_name>
          <affiliation>University of Maryland at College Park, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~mcoblenz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelcoblenz/aa74b306-529b-44d4-987f-a5e4fd6d3ca2/small.jpg</picture_url>
          <person_id>michaelcoblenz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech.
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brad</first_name>
          <last_name>Myers</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~bam/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/bradmyers/7d93ede9-5674-40e8-9ba5-f9dfab4873e1/small.jpg</picture_url>
          <person_id>bradmyers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Sunshine</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jssunshi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joshuasunshine/474067e5-86e8-476c-9622-5c89be145f4b/small.jpg</picture_url>
          <person_id>joshuasunshine</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9bc86e63-1839-4c99-9dae-a56a63348b0a</subevent_id>
    <title>SPLASH OOPSLA: R-6</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>1fac136f-748b-473d-8f34-c30b1f4a34a4</slot_id>
      <title>Session: SPLASH OOPSLA - R-6</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>38bebbe7-6648-409e-a9be-5f1eecc7fa56</slot_id>
      <event_id>46ea216e-db41-4d72-adfd-3e70848f065e</event_id>
      <title>Deductive Optimization of Relational Data Storage</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>17:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>17:40</end_time>
      <description>Optimizing the physical data storage and retrieval of data are two key database management problems. In this paper, we propose a language that can express both a relational query and the layout of its data. Our language can express a wide range of physical database layouts, going well beyond the row- and column-based methods that are widely used in database management systems. We use deductive program synthesis to turn a high-level relational representation of a database query into a highly optimized low-level implementation which operates on a specialized layout of the dataset. We build an optimizing compiler for this language and conduct experiments using a popular database benchmark, which shows that the performance of our specialized queries is better than a state-of-the-art in memory compiled database system while achieving an order-of-magnitude reduction in memory use.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Feser</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>John Feser is a PhD student in the Computer Science and Artificial Intelligence Laboratory at MIT, advised by Armando Solar-Lezama. He is interested in program synthesis and databases.</bio>
          <homepage_url>http://people.csail.mit.edu/feser/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnfeser/edee5cf7-267b-4a87-90ca-94f278378c37/small.jpg</picture_url>
          <person_id>johnfeser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Madden</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>sammadden</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nan</first_name>
          <last_name>Tang</last_name>
          <affiliation>QCRI HBKU</affiliation>
          <bio>undefined</bio>
          <person_id>nantang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Armando</first_name>
          <last_name>Solar-Lezama</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>Armando Solar-Lezama is an associate professor at MIT where he leads the Computer Aided Programming Group. His research interests include software synthesis and its applications in diverse areas such as high-performance computing, information flow security and probabilistic programming.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/armandosolarlezama/7befe52d-6968-4786-9841-408800f80c71/small.jpg</picture_url>
          <person_id>armandosolarlezama</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>83fce247-762b-4ec4-b8f9-2f7f17904070</slot_id>
      <event_id>2abee499-a6aa-4ad2-9126-979e3981f059</event_id>
      <title>Adding Interactive Visual Syntax to Textual Code</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>17:20</end_time>
      <description>Many programming problems call for coding geometrical thoughts: tables, hierarchical structures, nests of objects, trees, forests, graphs, and so on. Linear text does not do justice to such thoughts. But, it has been the dominant programming medium for the past and will remain so for the foreseeable future.
This paper proposes a mechanism for conveniently extending textual programming languages with problem-specific visual syntax. It argues the necessity of this language feature, demonstrates the feasibility with a robust prototype, and sketches a design plan for adapting the idea to other languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Leif</first_name>
          <last_name>Andersen</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/leifandersen/022e7f05-2a9a-4e3d-8be9-418b798e00c0/small.jpg</picture_url>
          <person_id>leifandersen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Ballantyne</last_name>
          <affiliation>PLT @ Northeastern University</affiliation>
          <bio>Michael Ballantyne is a PhD student at the Northeastern University Programming Research Laboratory, advised by Matthias Felleisen. He envisions a future where mainstream programmers regularly create, extend, and fluidly intermix domain-specific languages, with excellent support from their programming language and environment. Recently he’s been developing a formal characterization of macro hygiene that accounts for the full range of program transformations used in embedded DSL implementation, and also improving the type systems as macros approach to integrate macro expansion and typechecking.</bio>
          <homepage_url>http://mballantyne.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelballantyne/0fb0042c-454e-437b-938c-bd6fb195d0cb/small.jpg</picture_url>
          <person_id>michaelballantyne</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Felleisen</last_name>
          <affiliation>PLT @ Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/matthias/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthiasfelleisen/3781509a-02f7-4e22-822d-04481501e833/small.jpg</picture_url>
          <person_id>matthiasfelleisen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ca478550-cb19-4950-9fe7-d1e1c2addbe6</slot_id>
      <event_id>0ec91bc5-4e13-4f05-907b-344b042b9659</event_id>
      <title>Inter-Theory Dependency Analysis for SMT String Solvers</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>17:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>18:00</end_time>
      <description>Solvers in the framework of Satisfiability Modulo Theories (SMT) have been widely successful in practice. Recently there has been an increasing interest in solvers for string constraints to address security issues in web programming, for example. To be practically useful, the solvers need to support an expressive constraint language over \emph{unbounded} strings, and in particular, over string lengths. Satisfiability checking for these formulas, especially in the SMT context, is very hard; it is generally undecidable for a rich fragment. In this paper, we propose a form of dependency analysis for a rich fragment of string constraints including high-level operations such as \emph{length}, \emph{contains}, to deal with their inter-theory interaction so as to solve them more efficiently. We implement our dependency analysis in the string theory of the Z3 solver to obtain a new one, called ZZ. Finally, we demonstrate the superior performance of ZZ over state-of-the-art string solvers such as Z3str3, CVC4, S3P, and Z3 on several large industrial-strength benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thai</first_name>
          <last_name>Trinh</last_name>
          <affiliation>Advanced Digital Sciences Center, Illinois at Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>thaitrinh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Duc-Hiep</first_name>
          <last_name>Chu</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <person_id>duchiepchu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Joxan</first_name>
          <last_name>Jaffar</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>1982-1986: Lecturer, Monash University 1986-1995: Research Staff Member, IBM T.J. Watson Research Center 1995-Present: Professor of Computer Science, National University of Singapore</bio>
          <homepage_url>http://www.comp.nus.edu.sg/~joxan</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joxanjaffar/f391720a-61ea-4df1-ad81-91f5873a342c/small.jpg</picture_url>
          <person_id>joxanjaffar</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fcbff1ba-3936-4d07-a722-b02a49b14198</slot_id>
      <event_id>19758c97-2c7a-4f32-bfb9-cb729a2cc3b8</event_id>
      <title>Macros For Domain-Specific Languages</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>18:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>18:20</end_time>
      <description>Macros provide a powerful means of extending languages. They have proven useful in both general-purpose and domain-specific programming contexts. This paper presents an architecture for implementing macro-extensible DSLs on top of macro-extensible host languages. The macro expanders of these DSLs inherit the syntax system, hygienic expansion, and more from the host. They transform the extensible DSL syntax into a DSL core language. This arrangement has several important consequences. It becomes straightforward to integrate the syntax of various DSLs and the host language when their expanders share these inherited components. Also, a DSL compiler can rely on a fixed core language for compilation, even for an extensible DSL. Finally, macros empower programmers to safely grow DSLs on their own and tailor them to their needs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Ballantyne</last_name>
          <affiliation>PLT @ Northeastern University</affiliation>
          <bio>Michael Ballantyne is a PhD student at the Northeastern University Programming Research Laboratory, advised by Matthias Felleisen. He envisions a future where mainstream programmers regularly create, extend, and fluidly intermix domain-specific languages, with excellent support from their programming language and environment. Recently he’s been developing a formal characterization of macro hygiene that accounts for the full range of program transformations used in embedded DSL implementation, and also improving the type systems as macros approach to integrate macro expansion and typechecking.</bio>
          <homepage_url>http://mballantyne.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelballantyne/0fb0042c-454e-437b-938c-bd6fb195d0cb/small.jpg</picture_url>
          <person_id>michaelballantyne</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexis</first_name>
          <last_name>King</last_name>
          <affiliation>Northwestern University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexisking/4d4403cc-a825-40f3-a69d-089d8403e71a/small.jpg</picture_url>
          <person_id>alexisking</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Felleisen</last_name>
          <affiliation>PLT @ Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/matthias/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthiasfelleisen/3781509a-02f7-4e22-822d-04481501e833/small.jpg</picture_url>
          <person_id>matthiasfelleisen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c2df977f-ef1c-4e30-93c9-a57b3e4711e3</subevent_id>
    <title>SPLASH OOPSLA: M-5</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>b821fe87-f92c-45e5-952a-583b315eb086</slot_id>
      <title>Session: SPLASH OOPSLA - M-5</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1e9d3b91-cb72-4af3-ac17-e850a80f92b5</slot_id>
      <event_id>f94ed25c-81d9-4aad-b499-42ebb3391f9d</event_id>
      <title>CAMP: Cost-Aware Multiparty Session Protocols</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>03:20</end_time>
      <description>This paper presents CAMP, a new static performance analysis framework for message-passing concurrent and distributed systems, based on the theory of multiparty session types (MPST). Understanding the run-time performance of concurrent and distributed systems is of great importance for the identification of bottlenecks and optimisation opportunities. In the message-passing setting, these bottlenecks are generally communication overheads and synchronisation times. Despite its importance, reasoning about these intensional properties of software, such as performance, has received little attention, compared to verifying extensional properties, such as correctness. Behavioural protocol specifications based on sessions types capture not only extensional, but also intensional properties of concurrent and distributed systems. CAMP augments MPST with annotations of communication latency and local computation cost, defined as estimated execution times, that we use to extract cost equations from protocol descriptions. CAMP is also extendable to analyse asynchronous communication optimisation built on a recent advance of session type theories. We apply our tool to different existing benchmarks and usecases in the literature with a wide range of communication protocols, implemented in C, MPI-C, Java, Go and OCaml. Our benchmarks show that, in most of the cases, we predict an upper-bound on the real execution costs with &amp;lt; 15 % error.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Castro</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <person_id>davidcastro</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>20022fad-5474-4068-98bf-7da4cd8a6bb2</slot_id>
      <event_id>41308516-fe76-4573-a027-84e9a6af5694</event_id>
      <title>Multiparty Motion Coordination: From Choreographies to Robotics Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>04:00</end_time>
      <description>We present a programming model and typing discipline for complex multi-robot coordination programming. Our model encompasses both synchronisation through message passing and continuous-time dynamic motion primitives in physical space. We specify continuous-time motion primitives in an assume-guarantee logic that ensures compatibility of motion primitives as well as collision freedom. We specify global behaviour of programs in a choreographic type system that extends multiparty session types with jointly executed motion primitives, predicated refinements, as well as a separating conjunction that allows reasoning about subsets of interacting robots. We describe a notion of well-formedness for global types that ensures motion and communication can be correctly synchronised and provide algorithms for checking well-formedness, projecting a type, and local type checking. A well-typed program is communication safe, motion compatible, and collision free. Our type system provides a compositional approach to ensuring these properties.
We have implemented our model on top of the ROS framework. This allows us to program multi-robot coordination scenarios on top of commercial and custom robotics hardware platforms. We show through case studies that we can model and statically verify quite complex manoeuvres involving multiple manipulators and mobile robots—such examples are beyond the scope of previous approaches.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rupak</first_name>
          <last_name>Majumdar</last_name>
          <affiliation>Max Planck Institute for Software Systems (MPI-SWS)</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~rupak</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rupakmajumdar/3289b197-9f9a-4880-94c5-d9cf6d764bb1/small.jpg</picture_url>
          <person_id>rupakmajumdar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Damien</first_name>
          <last_name>Zufferey</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://dzufferey.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/damienzufferey/5dc321db-5cef-4f4b-bd3c-a5bbb2f11dd1/small.jpg</picture_url>
          <person_id>damienzufferey</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>56a5f7a8-de7c-48a7-8150-e3fd32bc9197</slot_id>
      <event_id>8ec74bdb-391c-4417-a0de-3cfe60039dfb</event_id>
      <title>On the Unusual Effectiveness of Type-aware Operator Mutations for Testing SMT Solvers</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>04:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>04:20</end_time>
      <description>We propose type-aware operator mutation, a simple, but unusually effective approach for testing SMT solvers. The key idea is to mutate operators of conforming types within the seed formulas to generate well-typed mutant formulas. These mutant formulas are then used as the test cases for SMT solvers. We realized type-aware operator mutation within the OpFuzz tool and used it to stress-test Z3 and CVC4, two state-of-the-art SMT solvers. Type-aware operator mutations are unusually effective: During nine months of extensive testing with OpFuzz, we reported 909 bugs in Z3 and CVC4, out of which 632 bugs were confirmed and 531 of the confirmed bugs were fixed by the developers. The detected bugs are highly diverse — we found bugs of many different types (soundness bugs, invalid model bugs, crashes, etc.), logics and solver configurations. We have further conducted an in-depth study on the bugs found by OpFuzz. The study results show that the bugs found by OpFuzz are of high quality. Many of them affect core components of the SMT solvers’ codebases, and some required major changes for the developers to fix. Among the 909 bugs found by OpFuzz, 130 were soundness bugs, the most critical bugs in SMT solvers, and 501 were in the default modes of the solvers. Notably, OpFuzz found 16 critical soundness bugs in CVC4, which has proved to be a very stable SMT solver.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dominik</first_name>
          <last_name>Winterer</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/dominikwinterer/f89f4b13-8156-4541-b618-d5128446e27f/small.jpg</picture_url>
          <person_id>dominikwinterer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chengyu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.chengyuzhang.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/chengyuzhang/eee80413-7fee-43ac-88d2-72212b8b352a/small.jpg</picture_url>
          <person_id>chengyuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>aa587aeb-f856-4a7e-ba3b-e865b0afd81c</slot_id>
      <event_id>d3521f08-1659-438b-8e27-401ba4d8046c</event_id>
      <title>Counterexample-Guided Correlation Algorithm for Translation Validation</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>03:40</end_time>
      <description>Automatic translation validation across the unoptimized intermediate representation (IR) of the original source code and the optimized executable assembly code is a desirable capability, and has the potential to compete with existing approaches to verified compilation such as CompCert [Leroy 2006]. A difficult subproblem is the automatic identification of the correlations across the transitions between the two programs’ respective locations. We present a counterexample-guided algorithm to identify these correlations in a robust and scalable manner. Our algorithm has both theoretical and empirical advantages over prior work in this problem space.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shubhani</first_name>
          <last_name>undefined</last_name>
          <affiliation>Indian Institute of Technology Delhi</affiliation>
          <bio>undefined</bio>
          <person_id>shubhani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Abhishek</first_name>
          <last_name>Rose</last_name>
          <affiliation>Indian Institute of Technology Delhi</affiliation>
          <bio>undefined</bio>
          <person_id>abhishekrose</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sorav</first_name>
          <last_name>Bansal</last_name>
          <affiliation>IIT Delhi, India</affiliation>
          <bio>See http://compiler.ai for recent work</bio>
          <homepage_url>http://www.cse.iitd.ac.in/~sbansal</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/soravbansal1/3bacf39b-3a07-41a7-9acd-f6b4c27d2f89/small.jpg</picture_url>
          <person_id>soravbansal1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>97525099-e787-4fd1-8b76-933dfd5e2afa</subevent_id>
    <title>SPLASH OOPSLA: F-2B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>c43456f3-2dd2-4726-86f6-0ac5545b1c92</slot_id>
      <title>Session: SPLASH OOPSLA - F-2B</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>21:00</start_time>
      <end_time>22:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1895bd73-71c5-4ee6-94f2-ac2b6fc13eb3</slot_id>
      <event_id>aed381e3-4082-4aea-8916-ec4572cabcbf</event_id>
      <title>Testing Differential Privacy with Dual Interpreters</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>21:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>21:40</end_time>
      <description>Applying differential privacy at scale requires convenient ways to check that programs computing with sensitive data appropriately preserve privacy. We propose here a fully automated framework for testing differential privacy, adapting a well-known “pointwise” technique from informal proofs of differential privacy. Our framework, called FuzzDP, requires no programmer annotations, handles all previously verified or tested algorithms, and is the first fully automated framework to distinguish correct and buggy implementations of PrivTree, a probabilistically terminating algorithm that has not previously been mechanically checked.
We analyze the probability of FuzzDP mistakenly accepting a non-private program and prove that, theoretically, the probability of false acceptance can be made exponentially small by suitable choice of test size.
We demonstrate FuzzDP’s utility empirically by implementing all benchmark algorithms from prior work on mechanical verification of differential privacy, plus several others and their incorrect variants, and show FuzzDP accepts the correct implementations and rejects the incorrect variants.
We also demonstrate how FuzzDP can be deployed in a practical workflow to test differentially privacy for the 2020 US Census Disclosure Avoidance System (DAS).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hengchu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <person_id>hengchuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Edo</first_name>
          <last_name>Roth</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <person_id>edoroth</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin C.</first_name>
          <last_name>Pierce</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>Benjamin Pierce is Henry Salvatori Professor of Computer and Information Science at the University of Pennsylvania and a Fellow of the ACM. His research interests include programming languages, type systems, language-based security, computer-assisted formal verification, differential privacy, and synchronization technologies. He is the author of the widely used graduate textbooks Types and Programming Languages and Software Foundations. He has served as co-Editor in Chief of the Journal of Functional Programming, as Managing Editor for Logical Methods in Computer Science, and as editorial board member of Mathematical Structures in Computer Science, Formal Aspects of Computing, and ACM Transactions on Programming Languages and Systems. He is also the lead designer of the popular Unison file synchronizer and co-developer of the Clowdr virtual conference platform.</bio>
          <homepage_url>http://www.cis.upenn.edu/~bcpierce/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/benjamincpierce/f2ee6f41-5bf7-4a0d-9b8d-71de6a666b1b/small.jpg</picture_url>
          <person_id>benjamincpierce</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Roth</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <person_id>aaronroth</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Haeberlen</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <person_id>andreashaeberlen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9daa922c-4573-4c78-a8a5-a97aa118c87c</slot_id>
      <event_id>9759a59c-e7fe-44ff-91d0-9250476fa15d</event_id>
      <title>Differentially-Private Software Frequency Profiling Under Linear Constraints</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>22:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>22:20</end_time>
      <description>Differential privacy has emerged as a leading theoretical framework for privacy-preserving data gathering and analysis. It allows meaningful statistics to be collected for a population without revealing “too much” information about any individual member of the population. For software profiling, this machinery allows profiling data from many users of a deployed software system to be collected and analyzed in a privacy-preserving manner. Such a solution is appealing to many stakeholders, including software users, software developers, infrastructure providers, and government agencies.
We propose an approach for differentially-private collection of frequency vectors from software executions. Frequency information is reported with the addition of random noise drawn from the Laplace distribution. A key observation behind the design of our scheme is that event frequencies are closely correlated due to the static code structure. Differential privacy protections must account for such relationships; otherwise, a seemingly-strong privacy guarantee is actually weaker than it appears. Motivated by this observation, we propose a novel and general differentially-private profiling scheme when correlations between frequencies can be expressed through linear inequalities. Using a linear programming formulation, we show how to determine the magnitude of random noise that should be added to achieve meaningful privacy protections under such linear constraints. Next, we develop an efficient instance of this general machinery for an important subclass of constraints. Instead of LP, our solution uses a reachability analysis of a constraint graph. As an exemplar, we employ this approach to implement differentially-private method frequency profiling for Android apps.
Any differentially-private scheme has to balance two competing aspects: privacy and accuracy. Through an experimental study to characterize these trade-offs, we (1) show that our proposed randomization achieves much higher accuracy compared to related prior work, (2) demonstrate that high accuracy and high privacy protection can be achieved simultaneously, and (3) highlight the importance of linear constraints in the design of the randomization. These promising results provide evidence that our approach is a good candidate for privacy-preserving frequency profiling of deployed software.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hailong</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Fordham University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hailongzhang.com</homepage_url>
          <person_id>hailongzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yu</first_name>
          <last_name>Hao</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>yuhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sufian</first_name>
          <last_name>Latif</last_name>
          <affiliation>Ohio State University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>sufianlatif</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Raef</first_name>
          <last_name>Bassily</last_name>
          <affiliation>Ohio State University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>raefbassily</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Atanas</first_name>
          <last_name>Rountev</last_name>
          <affiliation>Ohio State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.ohio-state.edu/~rountev</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/atanasrountev/57ea0ee0-eebe-48f0-91fe-1ed3a28b5d92/small.jpg</picture_url>
          <person_id>atanasrountev</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a40e0487-786d-4408-8bfe-ea446475b0cd</slot_id>
      <event_id>3d4eac8d-6c79-48a8-b5ab-8b400d1a80ee</event_id>
      <title>Unifying Execution of Imperative Generators and Declarative Specifications</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>21:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>22:00</end_time>
      <description>We present Deuterium—a framework for implementing Java methods as executable contracts. Deuterium introduces a novel, type-safe way to write method contracts entirely in Java, as a combination of imperative generators and declarative specifications (written in a first-order relational logic with transitive closure). Existing approaches are typically based on encoding both the specification and the program heap into a constraint language, and then using an off-the-shelf constraint solver—without any additional guidance—to search for a new program heap that satisfies the specification. Deuterium takes the advantage of user-provided generators to prune the search space and reduce incurred overhead of constraint solving. Deuterium supports two ways to solving declarative constraints: SAT-based and search-based with in-memory state exploration. We evaluate our approach on a suite of data structures, established as a standard benchmark by prior work. Furthermore, we use random and sequence-based test generation to create a new benchmark designed to mimic more realistic execution scenarios. Our results show that generators improve performance of executable contracts and that in-memory state exploration is the algorithm of choice when heap sizes are small.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pengyu</first_name>
          <last_name>Nie</last_name>
          <affiliation>The University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cozy.ece.utexas.edu/~pynie/</homepage_url>
          <person_id>pengyunie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marinela</first_name>
          <last_name>Parovic</last_name>
          <affiliation>The University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>marinelaparovic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhiqiang</first_name>
          <last_name>Zang</last_name>
          <affiliation>The University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>zhiqiangzang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sarfraz</first_name>
          <last_name>Khurshid</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/sarfrazkhurshid/b998e03f-4c99-458b-a9f9-b6c470511e3b/small.jpg</picture_url>
          <person_id>sarfrazkhurshid</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Aleksandar</first_name>
          <last_name>Milicevic</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>aleksandarmilicevic2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Milos</first_name>
          <last_name>Gligoric</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/milosgligoric/4d0671ae-937e-4f08-b499-092379ff7ad3/small.jpg</picture_url>
          <person_id>milosgligoric</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>edd5668a-9973-4a14-a55e-b6a0f0898d6c</slot_id>
      <event_id>cd599ff5-f878-4129-adc0-ffafc2709664</event_id>
      <title>Feedback-Driven Semi-Supervised Synthesis of Program Transformations</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>21:20</end_time>
      <description>It is fairly common for developers to make repeated edits in code that are all instances of a more-general program transformation. Since this process can be tedious and error-prone, we study the problem automatically learning program transformations from past edits, which can then be used to predict future edits. We take the novel view of the problem as a semi-supervised learning problem: apart from the concrete edits that are instances of the general transformation, the learning procedure also exploits access to additional inputs (program subtrees) that are marked as positive or negative depending on whether the transformation applies on those inputs. We present a procedure to solve the semi-supervised transformation learning problem using anti-unification and programming-by-example synthesis technology. To eliminate reliance on access to marked additional inputs, we generalize the semi-supervised learning procedure to a feedback-driven procedure that also generates the marked additional inputs in an iterative loop. We apply these ideas to build and evaluate three applications that use different mechanisms for generating feedback. Compared to existing tools that learn program transformations from edits, our feedback-driven semi-supervised approach is vastly more effective in successfully predicting edits with significantly fewer past edit data.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiang</first_name>
          <last_name>Gao</last_name>
          <affiliation>National University of Singapore, Singapore</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.comp.nus.edu.sg/~gaoxiang/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xianggao/482ff4c5-f003-40e7-90cc-d888adbd1e2f/small.jpg</picture_url>
          <person_id>xianggao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shraddha</first_name>
          <last_name>Barke</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shraddhabarke1/4e11ed13-0f46-4d77-8a6d-dd4c07b7fd4b/small.jpg</picture_url>
          <person_id>shraddhabarke1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Radhakrishna</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://arjunradhakrishna.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjunradhakrishna/5187c933-18de-4045-9119-d97023dd12b7/small.jpg</picture_url>
          <person_id>arjunradhakrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gustavo</first_name>
          <last_name>Soares</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://gustavoasoares.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gustavosoares/fc1e5a17-f939-4c3d-ab30-85467cb2610b/small.jpg</picture_url>
          <person_id>gustavosoares</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Alan</first_name>
          <last_name>Leung</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://alan.leung.work</homepage_url>
          <person_id>alanleung</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Nachiappan</first_name>
          <last_name>Nagappan</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/nachin/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nachiappannagappan/c34b7330-eb7e-4bf2-8d02-32395689de52/small.jpg</picture_url>
          <person_id>nachiappannagappan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Ashish</first_name>
          <last_name>Tiwari</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.csl.sri.com/users/tiwari/</homepage_url>
          <person_id>ashishtiwari</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4a1d6f5a-1a52-4d47-beaa-742a8d77a87c</subevent_id>
    <title>SPLASH OOPSLA: W-5</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>0a443ecf-6ade-4987-ae51-18e28e68b3da</slot_id>
      <title>Session: SPLASH OOPSLA - W-5</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>18642c7e-7897-42e4-a0ad-d08f9968793b</slot_id>
      <event_id>b766280d-c659-44b7-ad70-289237a4edcc</event_id>
      <title>A Model for Detecting Faults in Build Specifications</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>03:20</end_time>
      <description>Incremental and parallel builds are crucial features of modern build systems. Parallelism enables fast builds by running independent tasks simultaneously, while incrementality saves time and computing resources by processing the build operations that were affected by a particular code change. Writing build scripts that lead to error-free incremental and parallel builds is a challenging task. This is mainly because developers are often unable to predict the effects of build operations on the file system and how different build operations interact with each other. Faulty build scripts may seriously degrade the reliability of automated builds, as they cause build failures, and non-deterministic and incorrect outputs.
To reason about arbitrary build executions, we present BuildFS, a generally-applicable model that takes into account the specification (as declared in build scripts) and the actual behavior (low-level file system operation) of build operations. We then formally define different types of faults related to incremental and parallel builds in terms of the conditions under which a file system operation violates the specification of a build operation. Our testing approach, which relies on the proposed model, analyzes the execution of single full build, translates it into BuildFS, and uncovers faults by checking for corresponding violations.
We evaluate the effectiveness, efficiency, and applicability of our approach by examining 612 Make and Gradle projects. Notably, thanks to our treatment of build executions, our method is the first to handle JVM-oriented build systems. The results indicate that our approach is (1) able to uncover several important issues (245 issues found in 45 open-source projects have been confirmed and fixed by the upstream developers), and (2) up to six orders of magnitude faster than a state-of-the-art tool for Make builds.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thodoris</first_name>
          <last_name>Sotiropoulos</last_name>
          <affiliation>Athens University of Economics and Business</affiliation>
          <bio>undefined</bio>
          <person_id>thodorissotiropoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stefanos</first_name>
          <last_name>Chaliasos</last_name>
          <affiliation>Athens University of Economics and Business</affiliation>
          <bio>undefined</bio>
          <person_id>stefanoschaliasos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dimitris</first_name>
          <last_name>Mitropoulos</last_name>
          <affiliation>Athens University of Economics and Business</affiliation>
          <bio>Dimitris Mitropoulos is the Head of the Reliability Engineering Directorate of the Greek National Infrastructures for Research and Technology (GRNET) and a Researcher at the Athens University of Economics and Business. Previously, he has been a Postdoctoral Researcher at the Network Security Laboratory (NSL) of Columbia University in the City of New York. Dimitris holds a PhD in Computer Security from the Athens University of Economics and Business and has been involved in several EU and US funded R&amp;amp;D projects. His research interests include computer security, software reliability, software engineering and applied cryptography. He is a member of ACM, IEEE, SysSec, and an official writer for the ACM Computing Reviews journal.</bio>
          <homepage_url>https://dimitro.gr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/dimitrismitropoulos/a0d64ae8-d979-4ed9-a834-b808d3cc40d2/small.jpg</picture_url>
          <person_id>dimitrismitropoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Diomidis</first_name>
          <last_name>Spinellis</last_name>
          <affiliation>Athens University of Economics and Business</affiliation>
          <bio>Diomidis Spinellis is Professor of Software Engineering, Head of the Department of Management Science and Technology, and director of the Business Analytics Laboratory (BALab), at the Athens University of Economics and Business, Greece. His research interests include software engineering, IT security, and computing systems. He has written two award-winning, widely-translated books: Code Reading and Code Quality: The Open Source Perspective. In 2016 he published the book Effective Debugging: 66 Specific Ways to Debug Software and Systems. Dr. Spinellis has also published more than 300 technical papers in journals and refereed conference proceedings, which have received more than 8000 citations. He served for a decade as a member of the IEEE Software editorial board, authoring the regular “Tools of the Trade” column and for four years at the magazine’s Editor in Chief. He has contributed code that ships with Apple’s macOS and BSD Unix and is the developer of CScout, UMLGraph, dgsh, and other open-source software packages, libraries, and tools. He holds an MEng in Software Engineering and a PhD in Computer Science, both from Imperial College London. Dr. Spinellis has served as an elected member of the IEEE Computer Society Board of Governors (2013–2015), and is a senior member of the ACM and the IEEE.</bio>
          <homepage_url>https://www.dmst.aueb.gr/dds</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/diomidisspinellis/a7f21db5-04c0-4282-85ab-614b4394c90a/small.jpg</picture_url>
          <person_id>diomidisspinellis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a6f648a4-4af7-4f3e-8930-076e14663da9</slot_id>
      <event_id>3861b0b2-0efa-45db-a79a-416ae2de5a28</event_id>
      <title>Statically Verified Refinements for Multiparty Protocols</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>04:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>04:20</end_time>
      <description>With distributed computing becoming ubiquitous in the modern era, safe distributed programming is an open challenge. To address this, multiparty session types (MPST) provide a typing discipline for message-passing concurrency, guaranteeing communication safety properties such as deadlock freedom.
While originally MPST focus on the communication aspects, and employ a simple typing system for communication payloads, communication protocols in the real world usually contain \emph{constraints} on the payload. We introduce \emph{refined multiparty session types (RMPST)}, an extension of MPST, that express data dependent protocols via \emph{refinement types} on the data types.
We provide an implementation of RMPST, in a toolchain called Session*, using Scribble, a multiparty protocol description toolchain, and targeting F*, a verification-oriented functional programming language. Users can describe a protocol in Scribble and implement the endpoints in F* using \emph{refinement-typed} APIs generated from the protocol. The F* compiler can then statically verify the refinements. Moreover, we use a novel approach of callback-styled API generation, providing \emph{static} linearity guarantees with the inversion of control. We evaluate our approach with real world examples and show that it has little overhead compared to a naive implementation, while guaranteeing safety properties from the underlying theory.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fangyi</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/fangyizhou/c1ff2787-4ce8-45c7-a584-0cc8f627722c/small.jpg</picture_url>
          <person_id>fangyizhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Francisco</first_name>
          <last_name>Ferreira</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <person_id>franciscoferreira1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Raymond</first_name>
          <last_name>Hu</last_name>
          <affiliation>University of Hertfordshire</affiliation>
          <bio>undefined</bio>
          <person_id>raymondhu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rumyana</first_name>
          <last_name>Neykova</last_name>
          <affiliation>Brunel University London</affiliation>
          <bio>Rumyana Neykova is a lecturer at Brunel University London, previously completed a PhD degree under the supervision of Prof. Nobuko Yoshida at Imperial College London, where she was also research fellow. Her research interests are in the area of distributed systems and networks, as well as type systems and language design. Her PhD focuses on development and applications of a type theory (called session types) for runtime verification of concurrent and distributed systems.</bio>
          <homepage_url>https://www.brunel.ac.uk/people/rumyana-neykova</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rumyananeykova/66457b0a-8e8b-471e-b278-37d7f4242bcb/small.jpg</picture_url>
          <person_id>rumyananeykova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b8b1ea3d-bf7c-48c9-89bb-f82d341c4201</slot_id>
      <event_id>c5a30df7-cf14-473f-9641-714eedc28464</event_id>
      <title>Structure Interpretation of Text Formats</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>04:00</end_time>
      <description>Data repositories often consist of semi-structured files in a wide range of standard formats, ad-hoc formats, as well as mixtures of formats where data in one format is embedded into other data in a different format. It is therefore a significant challenge to parse these files into a structured tabular form, which is important to enable any downstream data processing.
We present UnRavel, an extensible framework for structure interpretation of ad-hoc formats. UnRavel can automatically, with no user input, extract tabular data from a diverse range of standard, ad-hoc and mixed format files. The framework is also easily extensible to add support for previously unseen formats, and also supports interactivity from the user in terms of examples to guide the system when specialized data extraction is desired. Our key insight is to allow arbitrary combination of extraction and parsing techniques through a concept called partial structures. Partial structures act as a common language through which the file structure can be shared and refined by different techniques. This makes UnRavel more powerful than applying the individual techniques in parallel or sequentially. Further, with this rule-based extensible approach, we introduce the novel notion of re-interpretation where the variety of techniques supported by our system can be exploited to improve accuracy while optimizing for particular quality measures or restricted environments. On our benchmark of 617 text files gathered from a variety of sources, UnRavel is able to extract the intended table in many more cases compared to state-of-the-art techniques.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vu</first_name>
          <last_name>Le</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>I am a Researcher at Microsoft, working on the Microsoft Program Synthesis using Examples (PROSE) framework. I obtained my PhD in 2015 at UC Davis, advised by Zhendong Su and Sumit Gulwani. My research is about developing novel and practical techniques to help improve the quality of critical software (e.g., compilers and database engines) and make programming accessible for end users. My work has led to the discovery of hundreds of bugs in GCC and LLVM, most of which have been fixed, and shipped in various Microsoft products.</bio>
          <homepage_url>http://vuminhle.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vule/8674b9d0-747d-4a80-b8f0-3c7a435cd9b7/small.jpg</picture_url>
          <person_id>vule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Radhakrishna</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://arjunradhakrishna.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjunradhakrishna/5187c933-18de-4045-9119-d97023dd12b7/small.jpg</picture_url>
          <person_id>arjunradhakrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Radiček</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>ivanradicek2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Mohammad</first_name>
          <last_name>Raza</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>mohammadraza</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c60006a2-218a-4e5a-b127-45b4f3f6230b</slot_id>
      <event_id>fb1f6365-ed4d-47f7-b0d5-c96755f131af</event_id>
      <title>Persistent Owicki-Gries Reasoning</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>03:40</end_time>
      <description>The advent of non-volatile memory (NVM) technologies has fundamentally transformed how software systems are structured, making the task of \emph{correct} programming significantly harder. This is because ensuring that memory stores persist in the correct order is challenging, and requires low-level programming to flush the cache at appropriate points. This has in turn resulted in a noticeable \emph{verification} gap.
To address this, we study the verification of NVM programs, and present \emph{Persistent Owicki-Gries} (POG), the first program logic for reasoning about such programs. We prove the soundness of POG over the recent Intel-x86 model, which formalises the out-of-order persistence of memory stores and the semantics of the Intel cache line flush instructions. We then use POG to verify several examples of interacting with the NVM.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Azalea</first_name>
          <last_name>Raad</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.SoundAndComplete.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/azalearaad/180ee602-475f-483f-a01b-ea187c9e8ac1/small.jpg</picture_url>
          <person_id>azalearaad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~orilahav/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/orilahav/89b656f6-7634-49d1-9917-4b74da70a976/small.jpg</picture_url>
          <person_id>orilahav</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Vafeiadis</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>Viktor Vafeiadis is a tenured faculty at the Max Planck Institute for Software Systems (MPI-SWS) in Germany. He got his BA and PhD from the University of Cambridge, and held post-doctoral researcher positions at the University of Cambridge and at Microsoft Research Cambridge before joining MPI-SWS in October 2010.</bio>
          <homepage_url>http://www.mpi-sws.org/~viktor/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/viktorvafeiadis/6a063832-47ca-4c32-8047-4bf4f74ae764/small.jpg</picture_url>
          <person_id>viktorvafeiadis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9da82607-5a93-4e06-8fa7-407486d96040</subevent_id>
    <title>SPLASH OOPSLA: R-6</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>48530c48-a457-4763-b41c-6e93499b24e1</slot_id>
      <title>Session: SPLASH OOPSLA - R-6</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1ad32226-4d5e-4f0a-9888-ed335514f0ae</slot_id>
      <event_id>19758c97-2c7a-4f32-bfb9-cb729a2cc3b8</event_id>
      <title>Macros For Domain-Specific Languages</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>06:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>06:20</end_time>
      <description>Macros provide a powerful means of extending languages. They have proven useful in both general-purpose and domain-specific programming contexts. This paper presents an architecture for implementing macro-extensible DSLs on top of macro-extensible host languages. The macro expanders of these DSLs inherit the syntax system, hygienic expansion, and more from the host. They transform the extensible DSL syntax into a DSL core language. This arrangement has several important consequences. It becomes straightforward to integrate the syntax of various DSLs and the host language when their expanders share these inherited components. Also, a DSL compiler can rely on a fixed core language for compilation, even for an extensible DSL. Finally, macros empower programmers to safely grow DSLs on their own and tailor them to their needs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Ballantyne</last_name>
          <affiliation>PLT @ Northeastern University</affiliation>
          <bio>Michael Ballantyne is a PhD student at the Northeastern University Programming Research Laboratory, advised by Matthias Felleisen. He envisions a future where mainstream programmers regularly create, extend, and fluidly intermix domain-specific languages, with excellent support from their programming language and environment. Recently he’s been developing a formal characterization of macro hygiene that accounts for the full range of program transformations used in embedded DSL implementation, and also improving the type systems as macros approach to integrate macro expansion and typechecking.</bio>
          <homepage_url>http://mballantyne.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelballantyne/0fb0042c-454e-437b-938c-bd6fb195d0cb/small.jpg</picture_url>
          <person_id>michaelballantyne</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexis</first_name>
          <last_name>King</last_name>
          <affiliation>Northwestern University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexisking/4d4403cc-a825-40f3-a69d-089d8403e71a/small.jpg</picture_url>
          <person_id>alexisking</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Felleisen</last_name>
          <affiliation>PLT @ Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/matthias/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthiasfelleisen/3781509a-02f7-4e22-822d-04481501e833/small.jpg</picture_url>
          <person_id>matthiasfelleisen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5dc1f41b-acf2-4586-b757-407a4e5f9269</slot_id>
      <event_id>0ec91bc5-4e13-4f05-907b-344b042b9659</event_id>
      <title>Inter-Theory Dependency Analysis for SMT String Solvers</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>05:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>06:00</end_time>
      <description>Solvers in the framework of Satisfiability Modulo Theories (SMT) have been widely successful in practice. Recently there has been an increasing interest in solvers for string constraints to address security issues in web programming, for example. To be practically useful, the solvers need to support an expressive constraint language over \emph{unbounded} strings, and in particular, over string lengths. Satisfiability checking for these formulas, especially in the SMT context, is very hard; it is generally undecidable for a rich fragment. In this paper, we propose a form of dependency analysis for a rich fragment of string constraints including high-level operations such as \emph{length}, \emph{contains}, to deal with their inter-theory interaction so as to solve them more efficiently. We implement our dependency analysis in the string theory of the Z3 solver to obtain a new one, called ZZ. Finally, we demonstrate the superior performance of ZZ over state-of-the-art string solvers such as Z3str3, CVC4, S3P, and Z3 on several large industrial-strength benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thai</first_name>
          <last_name>Trinh</last_name>
          <affiliation>Advanced Digital Sciences Center, Illinois at Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>thaitrinh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Duc-Hiep</first_name>
          <last_name>Chu</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <person_id>duchiepchu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Joxan</first_name>
          <last_name>Jaffar</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>1982-1986: Lecturer, Monash University 1986-1995: Research Staff Member, IBM T.J. Watson Research Center 1995-Present: Professor of Computer Science, National University of Singapore</bio>
          <homepage_url>http://www.comp.nus.edu.sg/~joxan</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joxanjaffar/f391720a-61ea-4df1-ad81-91f5873a342c/small.jpg</picture_url>
          <person_id>joxanjaffar</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b63ca10e-9ef6-4926-aad7-6c4c448efc7f</slot_id>
      <event_id>46ea216e-db41-4d72-adfd-3e70848f065e</event_id>
      <title>Deductive Optimization of Relational Data Storage</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>05:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>05:40</end_time>
      <description>Optimizing the physical data storage and retrieval of data are two key database management problems. In this paper, we propose a language that can express both a relational query and the layout of its data. Our language can express a wide range of physical database layouts, going well beyond the row- and column-based methods that are widely used in database management systems. We use deductive program synthesis to turn a high-level relational representation of a database query into a highly optimized low-level implementation which operates on a specialized layout of the dataset. We build an optimizing compiler for this language and conduct experiments using a popular database benchmark, which shows that the performance of our specialized queries is better than a state-of-the-art in memory compiled database system while achieving an order-of-magnitude reduction in memory use.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Feser</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>John Feser is a PhD student in the Computer Science and Artificial Intelligence Laboratory at MIT, advised by Armando Solar-Lezama. He is interested in program synthesis and databases.</bio>
          <homepage_url>http://people.csail.mit.edu/feser/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnfeser/edee5cf7-267b-4a87-90ca-94f278378c37/small.jpg</picture_url>
          <person_id>johnfeser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Madden</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>sammadden</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nan</first_name>
          <last_name>Tang</last_name>
          <affiliation>QCRI HBKU</affiliation>
          <bio>undefined</bio>
          <person_id>nantang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Armando</first_name>
          <last_name>Solar-Lezama</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>Armando Solar-Lezama is an associate professor at MIT where he leads the Computer Aided Programming Group. His research interests include software synthesis and its applications in diverse areas such as high-performance computing, information flow security and probabilistic programming.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/armandosolarlezama/7befe52d-6968-4786-9841-408800f80c71/small.jpg</picture_url>
          <person_id>armandosolarlezama</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f975400b-6fbc-4cfc-8c0d-32071080db20</slot_id>
      <event_id>2abee499-a6aa-4ad2-9126-979e3981f059</event_id>
      <title>Adding Interactive Visual Syntax to Textual Code</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>05:20</end_time>
      <description>Many programming problems call for coding geometrical thoughts: tables, hierarchical structures, nests of objects, trees, forests, graphs, and so on. Linear text does not do justice to such thoughts. But, it has been the dominant programming medium for the past and will remain so for the foreseeable future.
This paper proposes a mechanism for conveniently extending textual programming languages with problem-specific visual syntax. It argues the necessity of this language feature, demonstrates the feasibility with a robust prototype, and sketches a design plan for adapting the idea to other languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Leif</first_name>
          <last_name>Andersen</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/leifandersen/022e7f05-2a9a-4e3d-8be9-418b798e00c0/small.jpg</picture_url>
          <person_id>leifandersen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Ballantyne</last_name>
          <affiliation>PLT @ Northeastern University</affiliation>
          <bio>Michael Ballantyne is a PhD student at the Northeastern University Programming Research Laboratory, advised by Matthias Felleisen. He envisions a future where mainstream programmers regularly create, extend, and fluidly intermix domain-specific languages, with excellent support from their programming language and environment. Recently he’s been developing a formal characterization of macro hygiene that accounts for the full range of program transformations used in embedded DSL implementation, and also improving the type systems as macros approach to integrate macro expansion and typechecking.</bio>
          <homepage_url>http://mballantyne.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelballantyne/0fb0042c-454e-437b-938c-bd6fb195d0cb/small.jpg</picture_url>
          <person_id>michaelballantyne</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Felleisen</last_name>
          <affiliation>PLT @ Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/matthias/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/matthiasfelleisen/3781509a-02f7-4e22-822d-04481501e833/small.jpg</picture_url>
          <person_id>matthiasfelleisen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8f0bebf1-2d3e-40df-94a8-ebf198b7ee0e</subevent_id>
    <title>SPLASH OOPSLA: F-3B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>7294a9c0-cfae-427f-afd5-761ea9b8b229</slot_id>
      <title>Session: SPLASH OOPSLA - F-3B</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0b5e2ec2-3f98-4fdb-bf46-0a0700a0d79c</slot_id>
      <event_id>1191b34c-6380-48db-9c47-b8e642e28ee2</event_id>
      <title>ιDOT: A DOT Calculus with Object Initialization</title>
      <room>Online | SPLASH</room>
      <date>2020/11/21</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>00:20</end_time>
      <description>The Dependent Object Types (DOT) calculus serves as a foundation of the Scala programming language, with a machine-verified soundness proof. However, Scala’s type system has been shown to be unsound due to null references, which are used as default values of fields of objects before they have been initialized. This paper proposes ιDOT, an extension of DOT for ensuring safe initialization of objects. DOT was previously extended to κDOT with the addition of mutable fields and constructors. To κDOT, ιDOT adds an initialization effect system that statically prevents the possibility of reading a null reference from an uninitialized object. To design ιDOT, we have reformulated the Freedom Before Commitment object initialization scheme in terms of disjoint subheaps to make it easier to formalize in an effect system and prove sound. Soundness of ιDOT depends on the interplay of three systems of rules: a type system close to that of DOT, an effect system to ensure definite assignment of fields in each constructor, and an initialization system that tracks the initialization status of objects in a stack of subheaps. We have proven the overall system sound and verified the soundness proof using the Coq proof assistant.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ifaz</first_name>
          <last_name>Kabir</last_name>
          <affiliation>University of Alberta, Canada</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/ifazkabir/991cbcab-f46c-4c5e-8b8f-c365d1b11d6b/small.jpg</picture_url>
          <person_id>ifazkabir</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yufeng</first_name>
          <last_name>Li</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>yufengli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>61faefff-83a0-4533-980d-dfaeaacbe39e</slot_id>
      <event_id>275f97bd-396a-4f74-95be-90160be2ffc2</event_id>
      <title>Taming Type Annotations in Gradual Typing</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>23:40</end_time>
      <description>Gradual typing provides a methodology to integrate static and dynamic typing, harmonizing their often conflicting advantages in a single language. When a user wants to enjoy the advantages of static typing, most gradual languages require that they add type annotations. Many nontrivial tasks must be undertaken while adding type annotations, including understanding program behaviors and invariants. Unfortunately, if this is done incorrectly then the added type annotations can be wrong–leading to inconsistencies between the program and the type annotations. Gradual typing implementations detect such inconsistencies at runtime, raise cast errors, and generate messages. However, solely relying on such error messages for understanding and fixing inconsistencies and their resulting cast errors is often insufficient for multiple reasons. One reason is that while such messages cover inconsistencies in one execution path, fixing them often requires reconciling information from multiple paths. Another is that users may add many wrong type annotations that they later find difficult to identify and fix, when considering all added annotations.
Recent studies provide evidence that type annotations added during program migration are often wrong and that many programmers prefer compile-time warnings about wrong annotations. Motivated by these results, we develop exploratory typing to help with the static detection, understanding, and fixing of inconsistencies. The key idea of exploratory typing is that it systematically removes dynamic types and explores alternative types for static type annotations that can remedy inconsistencies. To demonstrate the feasibility of exploratory typing, we have implemented it in PyHound, which targets programs written in Reticulated Python, a gradual variant of Python. We have evaluated PyHound on a set of Python programs, and the evaluation results demonstrate that our idea can effectively detect inconsistencies in 98% of the tested programs and fix 93% of inconsistencies, significantly outperforming pytype, a widely used Python tool for enforcing type annotations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Peter Campora III</last_name>
          <affiliation>University of Louisiana at Lafayette</affiliation>
          <bio>I’m a 3rd year PhD student at ULL advised by Sheng Chen. My current research focus has been improving the usability of gradually typed languages. You can contact me at: petecampora (at) gmail.com.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnpetercamporaiii/62a0c591-991e-49f7-978a-0ecbc5556620/small.jpg</picture_url>
          <person_id>johnpetercamporaiii</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sheng</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Louisiana at Lafayette</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.cmix.louisiana.edu/schen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shengchen1/4561e224-57d6-4243-9b1f-0c895b2c49d7/small.jpg</picture_url>
          <person_id>shengchen1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>88979812-228d-4782-8643-9d58fce37078</slot_id>
      <event_id>49e4b00a-5555-4c4e-8eca-5628b4a98878</event_id>
      <title>Learning Semantic Program Embeddings with Graph Interval Neural Network</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>00:00</end_time>
      <description>Learning distributed representations of source code has been a challenging task for machine learning models. Earlier works treated programs as text so that natural language methods can be readily applied. Unfortunately, such approaches do not capitalize on the rich structural information possessed by source code. Of late, Graph Neural Network (GNN) was proposed to learn embeddings of programs from their graph representations. Due to the homogeneous (i.e. do not take advantage of the program-specific graph characteristics) and expensive (i.e. require heavy information exchange among nodes in the graph) message-passing procedure, GNN can suffer from precision issues, especially when dealing with programs rendered into large graphs. In this paper, we present a new graph neural architecture, called Graph Interval Neural Network (GINN), to tackle the weaknesses of the existing GNN. Unlike the standard GNN, GINN generalizes from a curated graph representation obtained through an abstraction method designed to aid models to learn. In particular, GINN focuses exclusively on intervals (generally manifested in looping construct) for mining the feature representation of a program, furthermore, GINN operates on a hierarchy of intervals for scaling the learning to large graphs.
We evaluate GINN for two popular downstream applications: variable misuse prediction and method name prediction. Results show in both cases GINN outperforms the state-of-the-art models by a comfortable margin. We have also created a neural bug detector based on GINN to catch null pointer deference bugs in Java code. While learning from the same 9,000 methods extracted from 64 projects, GINN-based bug detector significantly outperforms GNN-based bug detector on 13 unseen test projects. Next, we deploy our trained GINN-based bug detector and Facebook Infer, arguably the state-of-the-art static analysis tool, to scan the codebase of 20 highly starred projects on GitHub. Through our manual inspection, we confirm 38 bugs out of 102 warnings raised by GINN-based bug detector compared to 34 bugs out of 129 warnings for Facebook Infer. We have reported 38 bugs GINN caught to developers, among which 11 have been fixed and 12 have been confirmed (fix pending). GINN has shown to be a general, powerful deep neural network for learning precise, semantic program embeddings.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yu</first_name>
          <last_name>Wang</last_name>
          <affiliation>Department of Computer Science and Technology, Nanjing University</affiliation>
          <bio>undefined</bio>
          <person_id>yuwang2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ke</first_name>
          <last_name>Wang</last_name>
          <affiliation>Visa Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kbwang.bitbucket.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/kewang/37ef656e-ca92-475f-8a51-902dbe44fb72/small.jpg</picture_url>
          <person_id>kewang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Fenjuan</first_name>
          <last_name>Gao</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <person_id>fenjuangao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Linzhang</first_name>
          <last_name>Wang</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <person_id>linzhangwang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fdfbddc1-e6b2-4735-bccc-8c527112d5d0</slot_id>
      <event_id>6a3ae3f8-1ca4-44df-b6b1-bb4756927885</event_id>
      <title>Just-in-Time Learning for Bottom-up Enumerative Synthesis</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>23:20</end_time>
      <description>A key challenge in program synthesis is the astronomical size of the search space the synthesizer has to explore. In response to this challenge, recent work proposed to guide synthesis using learned probabilistic models. Obtaining such a model, however, might be infeasible for a problem domain where no high-quality training data is available. In this work we introduce an alternative approach to guided program synthesis: instead of training a model \emph{ahead of time} we show how to bootstrap one \emph{just in time}, during synthesis, by learning from partial solutions encountered along the way. To make the best use of the model, we also propose a new program enumeration algorithm we dub \emph{guided bottom-up search}, which extends the efficient bottom-up search with guidance from probabilistic models.
We implement this approach in a tool called Probe, which targets problems in the popular syntax-guided synthesis (SyGuS) format. We evaluate Probe on benchmarks from the literature and show that it achieves significant performance gains both over unguided bottom-up search and over a state-of-the-art probability-guided synthesizer, which had been trained on a corpus of existing solutions. Moreover, we show that these performance gains do not come at the cost of solution quality: programs generated by Probe are only slightly more verbose than the shortest solutions and perform no unnecessary case-splitting.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shraddha</first_name>
          <last_name>Barke</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shraddhabarke1/4e11ed13-0f46-4d77-8a6d-dd4c07b7fd4b/small.jpg</picture_url>
          <person_id>shraddhabarke1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>050c9673-a337-4734-a069-8fa5298f29b5</subevent_id>
    <title>SPLASH OOPSLA: R-2</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>fb1bd88f-2586-4bbe-8993-2b251f01e6fb</slot_id>
      <title>Session: SPLASH OOPSLA - R-2</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>241ea089-5cb6-4728-9396-db07e244a062</slot_id>
      <event_id>7f5b0b0c-f047-4936-8287-c85d0bbd3581</event_id>
      <title>Do You Have Space for Dessert? A Verified Space Cost Semantics for CakeML Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>09:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>09:40</end_time>
      <description>Garbage collectors relieve the programmer from manual memory management, but lead to compiler-generated machine code that can behave differently (e.g.\ out-of-memory errors) from the source code. To ensure that the generated code behaves exactly like the source code, programmers need a way to answer questions of the form: will this program avoid all out-of-memory errors if given this much memory?
This paper develops a cost semantics that can positively answer such questions for CakeML programs. The work described in this paper is the first to be able to answer such questions with proofs in the context of a language that depends on garbage collection. We demonstrate that positive answers can be used to transfer liveness results proved for the source code to liveness guarantees about the generated machine code. Without guarantees about space usage, only safety results can be transferred from source to machine code.
Our cost semantics is phrased in terms of an abstract intermediate language of the CakeML compiler, but results proved at that level map directly to the space cost of the compiler-generated machine code. All of the work described in this paper has been developed in the HOL4 theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alejandro</first_name>
          <last_name>Gómez-Londoño</last_name>
          <affiliation>Chalmers University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>alejandrogomezlondono</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Johannes</first_name>
          <last_name>Åman Pohjola</last_name>
          <affiliation>CSIRO's Data61/University of New South Wales</affiliation>
          <bio>undefined</bio>
          <person_id>johannesamanpohjola</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hira Taqdees</first_name>
          <last_name>Syeda</last_name>
          <affiliation>Chalmers University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>hirataqdeessyeda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Magnus O.</first_name>
          <last_name>Myreen</last_name>
          <affiliation>Chalmers University of Technology, Sweden</affiliation>
          <bio>I did a B.A. in Computer Science at the University of Oxford, tutored by Dr Jeff Sanders.
I completed my Ph.D. on program verification in 2009 at the University of Cambridge, supervised by Prof. Mike Gordon. My PhD dissertation was selected as the winner of the BCS Distinguished Dissertation Competition 2010.
In 2012, I became a Royal Society Research Fellow, UK.
In 2014, I moved to Chalmers where I became a tenured Associate Professor in 2015.</bio>
          <homepage_url>http://www.cse.chalmers.se/~myreen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusomyreen/ccd5e9cd-2811-4ef2-a9f0-3dd7802233ca/small.jpg</picture_url>
          <person_id>magnusomyreen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yong Kiam</first_name>
          <last_name>Tan</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.cmu.edu/~yongkiat/</homepage_url>
          <person_id>yongkiamtan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>60275e1d-95c9-457c-bcf4-d0964110a6b3</slot_id>
      <event_id>9796e9aa-1b8d-46b7-8c85-2c6427f306de</event_id>
      <title>Towards a Formal Foundation of Intermittent Computing</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>10:20</end_time>
      <description>Intermittently powered devices enable new applications in harsh or inaccessible environments, such as space or in-body implants, but also introduce problems in programmability and correctness. Researchers have developed programming models to ensure that programs make progress and do not produce erroneous results due to memory inconsistencies caused by intermittent executions. As the technology has matured, more and more features are added to intermittently powered devices, such as I/O. Prior work has shown that all existing intermittent execution models have problems with repeated device or sensor inputs (RIO). RIOs could leave intermittent executions in an inconsistent state. Such problems and the proliferation of existing intermittent execution models necessitate a formal foundation for intermittent computing.
In this paper, we formalize intermittent execution models, their correctness properties with respect to memory consistency and inputs, and identify the invariants needed to prove systems correct. We prove equivalence between several existing intermittent systems. To address RIO problems, we define an algorithm for identifying variables affected by RIOs that need to be restored after reboot and prove the algorithm correct. Finally, we implement the algorithm in a novel intermittent runtime system that is correct with respect to input operations and evaluate its performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Milijana</first_name>
          <last_name>Surbatovich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>milijanasurbatovich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Brandon</first_name>
          <last_name>Lucia</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Brandon is a Professor at Carnegie Mellon University working on hardware and software computer systems to answer the question: “How capable can a computing system be, given physical restrictions on its form factor, input power, energy storage, or other resource constraints?” His research has been recognized with 8 best paper awards, the 2019 IEEE TCCA Young Computer Architect Award and the 2015 Bell Labs Prize.</bio>
          <homepage_url>http://brandonlucia.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brandonlucia/e10fc900-d74f-44e7-a793-5e2f21a7dd0b/small.jpg</picture_url>
          <person_id>brandonlucia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Limin</first_name>
          <last_name>Jia</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.andrew.cmu.edu/user/liminjia/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/liminjia/6bc50ee1-2333-4b59-bc4f-3bf74d1e3b64/small.jpg</picture_url>
          <person_id>liminjia</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>94cfe3fe-3ec9-4905-bf1a-a86f598e1f5a</slot_id>
      <event_id>85b0bc7f-a107-41e9-9836-f25f8409f19f</event_id>
      <title>Verifying Replicated Data Types with Typeclass Refinements in Liquid Haskell</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>10:00</end_time>
      <description>This paper presents an extension to Liquid Haskell that facilitates stating and semi-automatically proving properties of typeclasses. Liquid Haskell augments Haskell with refinement types—our work allows such types to be attached to typeclass method declarations, and ensures that instance implementations respect these types. The engineering of this extension is a modular interaction between GHC, the Glasgow Haskell Compiler, and Liquid Haskell’s core proof infrastructure. The design sheds light on the interplay between modular proofs and typeclass resolution, which in Haskell is coherent by default, but in other dependently typed languages is not.
We demonstrate the utility of our extension by using Liquid Haskell to modularly verify that 34 instances satisfy the laws of five standard typeclasses. More substantially, we implement a framework for programming distributed applications based on conflict-free replicated data types (CRDTs). We define a typeclass whose Liquid Haskell type captures the mathematical properties CRDTs should satisfy; prove in Liquid Haskell that these properties are sufficient to ensure that replicas’ states converge despite out-of-order update delivery; implement (and prove correct) several instances of our CRDT typeclass; and use them to build two realistic applications, a multi-user calendar event planner and a collaborative text editor.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yiyun</first_name>
          <last_name>Liu</last_name>
          <affiliation>University of Maryland, College Park, USA</affiliation>
          <bio>undefined</bio>
          <person_id>yiyunliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>James</first_name>
          <last_name>Parker</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
          <person_id>jamesparker</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Redmond</last_name>
          <affiliation>University of California, Santa Cruz, USA</affiliation>
          <bio>undefined</bio>
          <person_id>patrickredmond</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lindsey</first_name>
          <last_name>Kuper</last_name>
          <affiliation>University of California, Santa Cruz</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://users.soe.ucsc.edu/~lkuper/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lindseykuper/f5b1f248-82e4-45ec-ab90-1d543b02d204/small.jpg</picture_url>
          <person_id>lindseykuper</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Hicks</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>Michael Hicks is a Professor in the Computer Science department and UMIACS at the University of Maryland, where he co-directs the laboratory for Programming Languages research (PLUM); he is the former Director of the Maryland Cybersecurity Center (MC2) and the Past Chair of ACM SIGPLAN.
His research focuses on using programming languages and analyses to improve the security, reliability, and availability of software. He is perhaps best known for his work exploring dynamic software updating, a technique with which software can be updated without shutting it down. He has explored the design of new programming languages and analysis tools for helping programmers find bugs and software vulnerabilities, and for identifying suspicious or incorrect program executions. He was worked has combined ideas from PL and cryptography, e.g., to ensure privacy preserving computations. He also leads the development of a new security-oriented programming contest, “build-it, break-it, fix-it,” which has been offered to the public and to students in his Coursera class on software security. He has recently begun to explore programming languages for quantum computation.
He is the editor of the Programming Languages Enthusiast blog and Tweets at @michael_w_hicks.</bio>
          <homepage_url>http://www.cs.umd.edu/~mwh/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelhicks/aa64e3c6-3516-4e13-affe-77bc32c40565/small.jpg</picture_url>
          <person_id>michaelhicks</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Niki</first_name>
          <last_name>Vazou</last_name>
          <affiliation>IMDEA Software Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://nikivazou.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nikivazou/8cc6ddec-154b-47e9-b40d-c66e78476391/small.jpg</picture_url>
          <person_id>nikivazou</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d7cde522-7c12-4ac2-9a7e-b61bb2e11d21</slot_id>
      <event_id>90cce21d-a854-4f50-b7f1-09a1af23e318</event_id>
      <title>Automatic and Efficient Variability-Aware Lifting of Functional Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>09:20</end_time>
      <description>A software analysis is a computer program that takes some representation of a software product as input and produces some useful information about that product as output. A software product line encompasses \emph{many} software product variants, and thus existing analyses can be applied to each of the product variations individually, but not to the entire product line as a whole. Enumerating all product variants and analyzing them one by one is usually intractable due to the combinatorial explosion of the number of product variants with respect to product line features. Several software analyses (e.g., type checkers, model checkers, data flow analyses) have been redesigned/re-implemented to support variability. This usually requires a lot of time and effort, and the variability-aware version of the analysis might have new errors/bugs that do not exist in the original one.
Given an analysis program written in a functional language based on PCF, in this paper we present two approaches to transforming (lifting) it into a semantically equivalent variability-aware analysis. A light-weight approach (referred to as \emph{shallow lifting}) wraps the analysis program into a variability-aware version, exploring all combinations of its input arguments. Deep lifting, on the other hand, is a program rewriting mechanism where the syntactic constructs of the input program are rewritten into their variability-aware counterparts. Compositionally this results in an efficient program semantically equivalent to the input program, modulo variability.
We present the correctness criteria for functional program lifting, together with correctness proof sketches of our program transformations. We evaluate our approach on a set of program analyses applied to the BusyBox C-language product line.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ramy</first_name>
          <last_name>Shahin</last_name>
          <affiliation>University of Toronto</affiliation>
          <bio>undefined</bio>
          <person_id>ramyshahin1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marsha</first_name>
          <last_name>Chechik</last_name>
          <affiliation>University of Toronto</affiliation>
          <bio>Marsha Chechik is Professor in the Department of Computer Science at the University of Toronto. She received her Ph.D. from the University of Maryland in 1996. Prof. Chechik’s research interests are in the application of formal methods to improve the quality of software. She has authored numerous papers in formal methods, software specification and verification, computer safety and security and requirements engineering. In 2002-2003, Prof. Chechik was a visiting scientist at Lucent Technologies in Murray Hill, NY and at Imperial College, London UK, and in 2013 – at Stonybrook University. She is a member of IFIP WG 2.9 on Requirements Engineering and an Associate Editor in Chief of Journal on Software and Systems Modeling. She is has been an associate editor of IEEE Transactions on Software Engineering 2003-2007, 2010-2013. She regularly serves on program committees of international conferences in the areas of software engineering and automated verification. Marsha Chechik has been Program Committee Co-Chair of the 2018 International Conference in Software Engineering (ICSE18), 2016 International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS’16), the 2016 Working Conference on Verified Software: Theories, Tools, and Experiments (VSTTE16), the 2014 International Conference on Automated Software Engineering (ASE’14), the 2008 International Conference on Concurrency Theory (CONCUR’08), the 2008 International Conference on Computer Science and Software Engineering (CASCON’08), and the 2009 International Conference on Formal Aspects of Software Engineering (FASE’09). She will be PC Co-Chair of ESEC/FSE’2021. She is a Member of ACM SIGSOFT and the IEEE Computer Society.</bio>
          <homepage_url>http://www.cs.toronto.edu/~chechik</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/marshachechik/779292d1-7e1c-4bb1-9f30-e36ee949bd9a/small.jpg</picture_url>
          <person_id>marshachechik</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d36f76a9-54e2-4d4b-ae3f-bcb6e4c04529</subevent_id>
    <title>SPLASH OOPSLA: F-4A</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>b8e83015-ac42-46fb-a8c0-471c5e08e174</slot_id>
      <title>Session: SPLASH OOPSLA - F-4A</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>56ef819d-27b5-4731-a6eb-0b248d0c915f</slot_id>
      <event_id>b9adaa2c-cdbd-450c-bb15-daa638849bd3</event_id>
      <title>Digging for Fold: Synthesis-Aided API Discovery for Haskell</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>14:20</end_time>
      <description>We present Hoogle+, a component-based synthesizer for Haskell that takes as input a specification in the form of a type, a set of input-output tests, or both, and returns a list of candidate programs composed of functions from popular Haskell libraries. Hoogle+ focuses on the end-to-end usability of synthesis: i.e., how to help programmers solve their tasks faster. Usability depends crucially on whether and how the programmer can specify their own intent and comprehend the tools results. Hoogle+ addresses the specification problem by allowing the user to specify goals via tests from which it automatically infers type signatures that facilitate rapid synthesis. Hoogle+ uses property based testing to ensure the user only sees _useful and _unique candidates, and generates example usages to illustrate the _functionality of each candidate to help the user comprehend their semantics in order to choose the right result. We evaluate the usability of Hoogle+, with a user study with 30 participants of varying Haskell proficiency,that shows that programmers generally solve tasks faster with Hoogle+, and that they were able to solve 50% more tasks when equipped with Hoogle+.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael B.</first_name>
          <last_name>James</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>Michael James is a 3rd year PhD student at University of California, San Diego studying programming languages and program synthesis under Nadia Polikarpova. He worked as a software engineer for three years before starting his degree. His experience has guided him to research topics that will ultimately flow back to help other engineers and make programming easier for all.</bio>
          <homepage_url>http://michaelbjames.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelbjames/8360df32-2f8d-4f7c-99c1-523f1f811bec/small.jpg</picture_url>
          <person_id>michaelbjames</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zheng</first_name>
          <last_name>Guo</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>zhengguo1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziteng</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wzt.me/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zitengwang/bf349a37-8935-4553-bcf7-c78094e369c5/small.jpg</picture_url>
          <person_id>zitengwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Shivani</first_name>
          <last_name>Doshi</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>Current Cornell Tech MEng Student, UC San Diego 2020 BS in CS graduate.</bio>
          <homepage_url>https://shivanidoshi26.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shivanidoshi/a3bdf8b0-e4df-4be6-8c43-1cd1aee38f69/small.jpg</picture_url>
          <person_id>shivanidoshi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Ranjit</first_name>
          <last_name>Jhala</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>Nom nom. Chomp. Burp.</bio>
          <homepage_url>http://ranjitjhala.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ranjitjhala/afbdab69-ed23-4022-b7a4-2c57128f20ec/small.jpg</picture_url>
          <person_id>ranjitjhala</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>82ae8c46-b73f-4d4c-8c9c-5b641325edb7</slot_id>
      <event_id>535250d1-14d9-4fb4-b418-2ad1ae511d91</event_id>
      <title>Scaling Exact Inference for Discrete Probabilistic Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>14:00</end_time>
      <description>Probabilistic programming languages (PPLs) are an expressive means of representing and reasoning about probabilistic models. The computational challenge of probabilistic inference remains the primary roadblock for applying PPLs in practice. Inference is fundamentally hard, so there is no one-size-fits all solution. In this work, we target scalable inference for an important class of probabilistic programs: those whose probability distributions are discrete. Discrete distributions are common in many fields, including text analysis, network verification, artificial intelligence, and graph analysis, but they prove to be challenging for existing PPLs.
We develop a domain-specific probabilistic programming language called Dice that features a new approach to exact discrete probabilistic program inference. Dice exploits program structure in order to factorize inference, enabling us to perform exact inference on probabilistic programs with hundreds of thousands of random variables. Our key technical contribution is a new reduction from discrete probabilistic programs to weighted model counting (WMC). This reduction separates the structure of the distribution from its parameters, enabling logical reasoning tools to exploit that structure for probabilistic inference. We (1) show how to compositionally reduce Dice inference to WMC, (2) prove this compilation correct with respect to a denotational semantics, (3) empirically demonstrate the performance benefits over prior approaches, and (4) analyze the types of structure that allow Dice to scale to large probabilistic programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Steven</first_name>
          <last_name>Holtzen</last_name>
          <affiliation>University of California, Los Angeles</affiliation>
          <bio>I am a PhD. student at U.C.L.A., co-advised by Guy Van den Broeck and Todd Millstein.</bio>
          <homepage_url>http://web.cs.ucla.edu/~sholtzen</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stevenholtzen/db2263a6-7a88-4167-9d73-86a4d4b97fc9/small.jpg</picture_url>
          <person_id>stevenholtzen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guy</first_name>
          <last_name>Van den Broeck</last_name>
          <affiliation>University of California, Los Angeles</affiliation>
          <bio>I am an Associate Professor and Samueli Fellow at UCLA, in the Computer Science Department. My research interests are in Machine Learning (Statistical Relational Learning), Knowledge Representation and Reasoning (Graphical Models, Lifted Probabilistic Inference), Applications of Probabilistic Reasoning and Learning (Probabilistic Programming, Probabilistic Databases), and Artificial Intelligence in general. I previously was a postdoctoral researcher at UCLA’s Automated Reasoning lab and KU Leuven’s Declarative Languages and Artificial Intelligence lab.</bio>
          <homepage_url>http://web.cs.ucla.edu/~guyvdb/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guyvandenbroeck/4c8a474f-a124-4434-a370-43b4892bbe2c/small.jpg</picture_url>
          <person_id>guyvandenbroeck</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Todd</first_name>
          <last_name>Millstein</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am a Professor in the Computer Science Department at the University of California, Los Angeles (UCLA).
I was the Program Chair for OOPSLA 2014.</bio>
          <homepage_url>http://www.cs.ucla.edu/~todd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/toddmillstein/03692d64-e4ad-4fb1-a2b0-9271ce27715c/small.jpg</picture_url>
          <person_id>toddmillstein</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e1fbf6c2-b392-4b2c-9690-cfc1f9dae955</slot_id>
      <event_id>e202e9a0-8e64-4364-82a0-a1d2b41e4b74</event_id>
      <title>Interactive Synthesis of Temporal Specifications from Examples and Natural Language</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>13:40</end_time>
      <description>Motivated by applications in robotics, we consider the task of synthesizing linear temporal logic (LTL) specifications based on examples and natural language descriptions. While LTL is a flexible, expressive, and unambiguous language to describe robotic tasks, it is often challenging for non-expert users.
In this paper, we present an interactive method for synthesizing LTL specifications from a single example trace and a natural language description. The interaction is limited to showing a small number of behavioral examples to the user who decides whether or not they exhibit the original intent. Our approach generates candidate LTL specifications and distinguishing examples using an encoding into optimization modulo theories problems.
Additionally, we use a grammar extension mechanism and a semantic parser to generalize synthesized specifications to parametric task descriptions for subsequent use. Our implementation in the tool LtlTalk starts with a domain-specific language that maps to a fragment of LTL and expands it through example-based user interactions, thus enabling natural language-like robot programming, while maintaining the expressive power and precision of a formal language. Our experiments show that the synthesis method is precise, quick, and asks only a few questions to the users, and we demonstrate in a case study how LtlTalk generalizes from the synthesized tasks to other, yet unseen, tasks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Gavran</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
          <person_id>ivangavran</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eva</first_name>
          <last_name>Darulova</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mpi-sws.org/~eva/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/evadarulova/0d98744b-ec94-4a27-b1c0-0d728d54bdb7/small.jpg</picture_url>
          <person_id>evadarulova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rupak</first_name>
          <last_name>Majumdar</last_name>
          <affiliation>Max Planck Institute for Software Systems (MPI-SWS)</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~rupak</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rupakmajumdar/3289b197-9f9a-4880-94c5-d9cf6d764bb1/small.jpg</picture_url>
          <person_id>rupakmajumdar</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e6143390-4919-4dfa-aa51-f1f188bebfd5</slot_id>
      <event_id>74c28b24-629b-4e90-837d-28d2c9d362d6</event_id>
      <title>A Modular Cost Analysis for Probabilistic Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>13:20</end_time>
      <description>We present a novel methodology for the automated resource analysis of non-deterministic, probabilistic imperative programs, based on three ingredients: (i) a refinement of the theory of probabilistic abstract rewrite systems, providing the basis for a neat and compact operational semantics; (ii) an alternating expected cost and expected value analysis, establishing modularity of the analyis; and (iii) painstaking attention to detail in the implementation with a focus on efficiency.
All in all, this gives rise to a unique \emph{modular approach} to the problem at hand. Program fragments are analysed in full independence. Further, the results established allow us to incorporate sampling from \emph{dynamic distributions}, making our analysis applicable to realistic examples.
We have implemented our contributions exploiting a constraint-solver over iterative refineable cost functions facilitated by off-the-shelf SMT-solvers. We provide ample experimental evidence of its algorithmic superiority. Our experiments show that our tool runs on average \emph{orders of magnitude faster} than comparable tools: \MA{ensure; verify} execution times of seconds become milliseconds. At the same time we retain the precision of existing tools.
The extensions in applicability and the greater efficiency of our prototype, yield scalabilty of the tool. This effects into more realistic examples, whose expected cost analysis can be thus performed fully automatically. In particular, our tool is the first establishing an automated analysis of the \emph{Coupon Collector’s problem}.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Avanzini</last_name>
          <affiliation>INRIA Sophia Antipolis, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-sop.inria.fr/members/Martin.Avanzini/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/martinavanzini1/6a7bba4f-db11-478c-9d7c-2dabe34811bc/small.jpg</picture_url>
          <person_id>martinavanzini1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Georg</first_name>
          <last_name>Moser</last_name>
          <affiliation>University of Innsbruck</affiliation>
          <bio>undefined</bio>
          <person_id>georgmoser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Schaper</last_name>
          <affiliation>University of Innsbruck</affiliation>
          <bio>undefined</bio>
          <person_id>michaelschaper1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0d72e49a-00b5-4f91-8e57-ab80f273669c</subevent_id>
    <title>SPLASH OOPSLA: T-5</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>a883fab3-e389-4ac0-973b-190d6c540ff1</slot_id>
      <title>Session: SPLASH OOPSLA - T-5</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>923c0e0f-fcf2-435b-ac8f-aafaaebe0611</slot_id>
      <event_id>b7403f22-9ce1-4712-b204-3d56213b53b9</event_id>
      <title>Regex Matching with Counting-Set Automata</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>16:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>16:20</end_time>
      <description>We propose a solution to the problem of efficient matching regular expressions (regexes) with bounded repetition, such as $\mathtt{(ab){1,100}}$, using deterministic automata. For this, we introduce novel \emph{counting set automata (CsAs)}, automata with registers that can hold sets of bounded integers and can be manipulated by a limited portfolio of constant-time operations. We present an algorithm that compiles a large sub-class of regexes to deterministic CsAs. This includes (1) a novel Antimirov-style translation of regexes with counting to \emph{counting automata (CAs)}, nondeterministic automata with bounded counters, and (2) our main technical contribution, a determinization of CAs that outputs CsAs. The main advantage of this workflow is that the size of the produced CsAs does not depend on the repetition bounds used in the regex (while the size of the DFA is exponential to them). Our experimental results confirm that deterministic CsAs produced from practical regexes with repetition are indeed vastly smaller than the corresponding DFAs. More importantly, our prototype matcher based on CsA simulation handles practical regexes with repetition regardless of sizes of counter bounds. It easily copes with regexes with repetition where state-of-the-art matchers struggle.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lukáš</first_name>
          <last_name>Holík</last_name>
          <affiliation>Brno University of Technology, Czechia</affiliation>
          <bio>undefined</bio>
          <person_id>lukasholik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondrej</first_name>
          <last_name>Lengal</last_name>
          <affiliation>Brno University of Technology </affiliation>
          <bio>Ph.D. (2015) Brno University of Technology</bio>
          <homepage_url>http://www.fit.vutbr.cz/~lengal</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlengal/3f99d935-777e-4b43-9494-5cfc0fe8894b/small.jpg</picture_url>
          <person_id>ondrejlengal</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Olli</first_name>
          <last_name>Saarikivi</last_name>
          <affiliation>MSR Redmond</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/ollisaarikivi2/3e6d3eb8-2ea9-456c-9c3d-76fe37bd855c/small.jpg</picture_url>
          <person_id>ollisaarikivi2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lenka</first_name>
          <last_name>Turonova</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>lenkatoronova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Margus</first_name>
          <last_name>Veanes</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/margusveanes/a5174253-0401-46f7-aff1-e92a3a3ace77/small.jpg</picture_url>
          <person_id>margusveanes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tomas</first_name>
          <last_name>Vojnar</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fit.vutbr.cz/~vojnar</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomasvojnar/6b1ea9ee-acf7-413d-be4d-431c460af426/small.jpg</picture_url>
          <person_id>tomasvojnar</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>af6e8f92-5439-432c-b032-05229e644fa4</slot_id>
      <event_id>d0b39515-659e-4855-a1b2-516ee32b0539</event_id>
      <title>Knowing When to Ask: Sound Scheduling of Name Resolution in Type Checkers Derived from Declarative Specifications</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>15:40</end_time>
      <description>There is a large gap between the specification of type systems and the implementation of their type checkers, which impedes reasoning about the soundness of the type checker with respect to the specification. A vision to close this gap involves automatically obtaining type checkers from declarative programming language specifications. This moves the burden of proving correctness from a case-by-case basis for concrete languages, to a single correctness proof for the specification language.
This vision is obstructed by an aspect common to all programming languages: name resolution. Naming and scoping are pervasive and complex aspects of the static semantics of programming languages. Implementations of type checkers for languages with name binding features such as modules, imports, classes, and inheritance interleave collection of binding information (i.e., declarations, scoping structure, and imports) and querying that information. This requires scheduling those two aspects in such a way that query answers are stable—i.e., they are computed only after all relevant binding structure has been collected. Type checkers for concrete languages accomplish stability using language-specific knowledge about the type system.
In this paper we give a language independent characterization of necessary and sufficient conditions to guarantee stability of name and type queries during type checking in terms of critical edges in an incomplete scope graph. We use critical edges to give a formal small-step operational semantics to a declarative specification language for type systems, delaying queries that may depend on missing information. This yields type checkers for the specified languages that are safe-by-construction—i.e., they safely schedule queries and only accept programs that are name- and type-correct according to the declarative language specification. We implement this approach, and evaluate it against specifications of a small module and record language, as well as subsets of Java and Scala.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Arjen</first_name>
          <last_name>Rouvoet</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ajrouvoet.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjenrouvoet/72c0e303-43d5-4252-a170-5b61600fac4d/small.jpg</picture_url>
          <person_id>arjenrouvoet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hendrik</first_name>
          <last_name>van Antwerpen</last_name>
          <affiliation>TU Delft</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hendrik.van-antwerpen.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hendrikvanantwerpen/2d3f530b-7183-483e-b3b6-80dd4159a4bd/small.jpg</picture_url>
          <person_id>hendrikvanantwerpen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Casper</first_name>
          <last_name>Bach Poulsen</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://casperbp.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/casperbachpoulsen/2cddd6a9-d920-4f73-9fcf-f4d9462eb0e3/small.jpg</picture_url>
          <person_id>casperbachpoulsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Robbert</first_name>
          <last_name>Krebbers</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://robbertkrebbers.nl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/robbertkrebbers/7c0562b5-da08-4f27-aa28-918e54dcaf3d/small.jpg</picture_url>
          <person_id>robbertkrebbers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science at Delft University of Technology. He received a master’s and doctorate in computer science from the University of Amsterdam in 1993 and 1997, respectively. Previously he served as postdoc at the Oregon Graduate Institute, as Assistant Professor at Utrecht University, and as Associate Professor at TU Delft.
His research interests include programming languages, software language engineering, domain-specific programming languages, program transformation, syntax definition, and parsing. With his students he has designed and implemented the Spoofax language workbench, as well as many domain-specific languages, including DSLs for syntax definition (SDF2, SDF3), program transformation (Stratego), static semantics (NaBL, Statix), dynamic semantics (DynSem), software deployment (Nix), web application development (WebDSL), and mobile phone applications (mobl). In the language designer’s workbench project he is pursuing high-level declarative language definition that serves for language implementation and verification.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bccbe5dd-a2fc-4efc-a764-365a9a389151</slot_id>
      <event_id>5566f7eb-c8ea-4651-9ed7-30715f447f33</event_id>
      <title>Actor Concurrency Bugs: A Comprehensive Study on Symptoms, Root Causes, API Usages, and Differences</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>15:20</end_time>
      <description>Actor concurrency is becoming increasingly important in the development of real-world software systems. Although actor concurrency may be less susceptible to some multithreaded concurrency bugs, such as low-level data races and deadlocks, it comes with its own bugs that may be different. However, the fundamental characteristics of actor concurrency bugs, including their symptoms, root causes, API usages, examples, and differences when they come from different sources are still largely unknown. Actor software development can significantly benefit from a comprehensive qualitative and quantitative understanding of these characteristics, which is the focus of this work, to foster better API documentations, development practices, testing, debugging, repairing, and verification frameworks. To conduct this study, we take the following major steps. First, we construct a set of 184 real-world Stackoverflow and Github actor bugs by manual analysis of 3,924 Stackoverflow questions, answers, and comments and 3,315 Github commits, messages, original and modified code snippets, issues, and pull requests. Second, we manually study these actor bugs and their fixes to understand and classify their symptoms, root causes, and API usages. Third, we study the differences between the commonalities and distributions of symptoms, root causes, and API usages of Stackoverflow and Github actor bugs. Fourth, we discuss real-world examples of bugs with these root causes and symptoms. Finally, we investigate the relation of our findings with the findings of previous work and discuss the implications of our findings using the anecdotal evidence of our actor bug examples. A few findings of our study are: (1) Symptoms of actor bugs can be classified into 5 categories with Error and Incorrect Exceptions being the most and least common symptoms (2) Root causes of actor bugs can be classified into 10 categories with Logic and Untyped Communication being the most and least common root causes (3) A small number of API packages are responsible for most of API usages by actor bugs (4) Stackoverflow and Github actors can differ significantly in the commonality and distribution of symptoms, root causes, and API usages (5) Actor developers may need help not only with complex, unknown, or semantic bugs in the development code but also with simple, well-known, well-documented, or syntactic bugs in the test code. While some of our findings are in agreement with the findings of the previous work, others are in sharp contrast.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mehdi</first_name>
          <last_name>Bagherzadeh</last_name>
          <affiliation>Oakland University</affiliation>
          <bio>Assistant Professor, Department of Computer Science and Engineering</bio>
          <homepage_url>https://mbagherz.bitbucket.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mehdibagherzadeh/95dc6f53-51a0-4bf1-b822-7bbe8c4d223a/small.jpg</picture_url>
          <person_id>mehdibagherzadeh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nicholas</first_name>
          <last_name>Fireman</last_name>
          <affiliation>Oakland University</affiliation>
          <bio>undefined</bio>
          <person_id>nicholasfireman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anas</first_name>
          <last_name>Shawesh</last_name>
          <affiliation>Oakland University</affiliation>
          <bio>undefined</bio>
          <person_id>anasshawesh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Raffi</first_name>
          <last_name>Khatchadourian</last_name>
          <affiliation>City University of New York (CUNY) Hunter College</affiliation>
          <bio>I am an Assistant Professor in the Department of Computer Science at Hunter College and the Graduate Center of the City University of New York (CUNY). My research is centered on techniques for automated software evolution, particularly those related to automated refactoring and source code recommendation systems. My goal is to ease the burden associated with correctly and efficiently evolving large and complex software by providing automated tools that can be easily used by developers. I am also interested in the automated analysis of Object-Oriented and Aspect-Oriented programs.
I received my MS and Ph.D. degrees in Computer Science from Ohio State University and my BS degree in Computer Science from Monmouth University in New Jersey. Prior to joining CUNY, I was a Software Engineer at Apple, Inc. in Cupertino, California, where I worked on Digital Rights Management (DRM) for iTunes, iBooks, and the App store. I also developed distributed software that tested various features of iPhones, iPads, and iPods. You may also find more information about me by visiting my CUNY Academic Commons profile, my vita, GitHub, and my blog (you can subscribe for updates here).</bio>
          <homepage_url>http://cs.hunter.cuny.edu/~Raffi.Khatchadourian99</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/raffikhatchadourian/5c884f46-e4aa-4dc5-b581-2e37f77d320a/small.jpg</picture_url>
          <person_id>raffikhatchadourian</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c2d8b749-d9ec-49af-a159-c056f705cc51</slot_id>
      <event_id>52f9bfff-ac06-47f4-98ba-4a5085ecbf7b</event_id>
      <title>Fuzzing Channel-based Concurrency Runtimes Using Types and Effects</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>16:00</end_time>
      <description>Modern programming languages support concurrent programming based on channels and processes. Channels enable synchronous and asynchronous message-passing between independent light-weight processes making it easy to express common concurrency patterns.
The implementation of channels and processes in compilers and language runtimes is a difficult task that relies heavily on traditional and error-prone low-level concurrency primitives, raising concerns about correctness and reliability.
In this paper, we present a program generation technique to test such programming language implementations. We define a type and effect system for programs that communicate over channels and where every execution is guaranteed to eventually terminate. We can automatically generate and run such programs, and if a program fails to terminate, we have found a bug in the programming language implementation.
We implement such an automatic program generator and apply it to Go, Kotlin, Crystal, and Flix. We find two new bugs in Flix, and reproduce two bugs; one in Crystal and one in Kotlin.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Quentin</first_name>
          <last_name>Stiévenart</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/~qstieven</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/quentinstievenart/7d195a5f-4ea9-4d26-a55f-2b8d1c5853b8/small.jpg</picture_url>
          <person_id>quentinstievenart</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8a0672f8-701c-47f6-bb2c-44dd10c7aa56</subevent_id>
    <title>SPLASH OOPSLA: W-3</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>4b2d9525-6290-41a7-b659-49f6778277ec</slot_id>
      <title>Session: SPLASH OOPSLA - W-3</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1f83748d-3cd8-4864-8fdc-fdaf37d2dd8d</slot_id>
      <event_id>9b43b518-879b-4aa7-b841-9f12dc9bcf2a</event_id>
      <title>Automated Policy Synthesis for System Call Sandboxing</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>12:20</end_time>
      <description>System call whitelisting is a powerful sandboxing approach that can significantly reduce the capabilities of an attacker if an application is compromised. Given a \emph{policy} that specifies which system calls can be invoked with what arguments, a sandboxing framework terminates any execution that violates the policy. While this mechanism greatly reduces the attack surface of a system, manually constructing these policies is time-consuming and error-prone. As a result, many applications —including those that take untrusted user input— opt not to use a system call sandbox.
Motivated by this problem, we propose a technique for automatically constructing system call whitelisting policies for a given application and policy DSL. Our method combines static code analysis and program synthesis to construct \emph{sound and precise policies} that never erroneously terminate the application, while restricting the program’s system call usage as much as possible. We have implemented our approach in a tool called Abhaya and experimentally evaluate it 674 Linux and OpenBSD applications by automatically synthesizing Seccomp-bpf and Pledge policies. Our experimental results indicate that Abhaya can efficiently generate useful and precise sandboxes for real-world applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shankara</first_name>
          <last_name>Pailoor</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>shankarapailoor</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xinyu</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://web.eecs.umich.edu/~xwangsd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xinyuwang/ccbe37b1-293c-4205-8386-295e20bce0d7/small.jpg</picture_url>
          <person_id>xinyuwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hovav</first_name>
          <last_name>Shacham</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>hovavshacham</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Isil</first_name>
          <last_name>Dillig</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>Isil Dillig is an Associate Professor of Computer Science at the University of Texas at Austin where she leads the UToPiA research group. Her main research area is programming languages, with a specific emphasis on static analysis, verification, and program synthesis. The techniques developed by her group aim to make software systems more reliable, secure, and easier to build in a robust way. Dr. Dillig is a Sloan Fellow and a recipient of the NSF CAREER award. She obtained all her degrees (BS, MS, and PhD) from Stanford University.</bio>
          <homepage_url>http://www.cs.utexas.edu/~isil/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/isildillig/e4fa3855-0ae4-4638-84e3-1fe224e64e3f/small.jpg</picture_url>
          <person_id>isildillig</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>43708714-1490-4645-bb2d-780e47d35e71</slot_id>
      <event_id>dc2c4321-bace-402b-a2d9-f08a7830e7e5</event_id>
      <title>Random Testing for C and C++ Compilers with YARPGen</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>11:40</end_time>
      <description>Compilers should not crash and they should not miscompile applications. Random testing is an effective method for finding compiler bugs that have escaped other kinds of testing. This paper presents CFuzz, a random test-case generator for C and C++ that we used to find and report more than 220 bugs in GCC, LLVM, and the Intel® C++ Compiler. Our research contributions include a method for generating expressive programs that avoid undefined behavior without using dynamic checks, and \emph{generation policies}, a new mechanism for increasing diversity of generated code and for triggering more optimizations. Generation policies decrease the testing time to find hard-to-trigger compiler bugs and, for the kinds of scalar optimizations CFuzz was designed to stress-test, increase the number of times these optimizations are applied by the compiler by an average of 20% for LLVM and 40% for GCC. We also created tools for automating most of the common tasks related to compiler fuzzing; these tools are also useful for fuzzers other than ours.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vsevolod</first_name>
          <last_name>Livinskii</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
          <person_id>vsevolodlivinskii</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dmitry</first_name>
          <last_name>Babokin</last_name>
          <affiliation>Intel Corporation</affiliation>
          <bio>undefined</bio>
          <person_id>dmitrybabokin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>John</first_name>
          <last_name>Regehr</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.utah.edu/~regehr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnregehr/2cb23ab0-042a-487a-a859-cbd3147a46a7/small.jpg</picture_url>
          <person_id>johnregehr</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>514b9f20-75a0-4ee0-8075-198a32c41c7f</slot_id>
      <event_id>a67c5220-155d-4d8b-af2a-ba2543bafbfa</event_id>
      <title>Dynamic Dispatch of Context-Sensitive Optimizations</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>12:00</end_time>
      <description>The academia has spent much effort into making context-sensitive analyses practical, with great profit. However, the implementation of context-sensitive optimizations, in contrast to analyses, is still not practical, due to code-size explosion. This growth happens because current technology requires the cloning of full paths in the Calling Context Tree. In this paper, we present a solution to this problem. We combine finite state machines and dynamic dispatching to allow fully context-sensitive specialization while cloning only functions that are effectively optimized. This technique makes it possible to apply very liberal optimizations, such as context-sensitive constant propagation, in large programs – something that could not have been easily done before. We demonstrate the viability of our idea by formalizing it in Prolog, and implementing it in LLVM. As a proof of concept, we have used our state machines to implement context-sensitive constant propagation in LLVM. The binaries produced by traditional full cloning are 2.63 times larger than the binaries that we generate with our state machines.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gabriel</first_name>
          <last_name>Poesia</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>gabrielpoesia1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fernando Magno Quintão</first_name>
          <last_name>Pereira</last_name>
          <affiliation>UFMG</affiliation>
          <bio>Fernando got his Ph.D at UCLA in 2008, under the supervision of Jens Palsberg. He is currently an assistant professor at the Universidade Federal de Minas Gerais, Brazil. His main research interest are in code generation, compiler optimizations and static program analyses.</bio>
          <homepage_url>http://homepages.dcc.ufmg.br/~fernando/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/fernandomagnoquintaopereira/8f86b14f-fbc3-49a4-9f4f-1a8216564d39/small.jpg</picture_url>
          <person_id>fernandomagnoquintaopereira</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9eb7a250-a334-400d-b204-0ec814e48a4c</slot_id>
      <event_id>36a05e0f-c662-4f1b-b7fa-748674279502</event_id>
      <title>Build Scripts with Perfect Dependencies</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>11:20</end_time>
      <description>Build scripts for most build systems describe the actions to run, and the dependencies between those actions – but often build scripts get those dependencies wrong. Most build scripts have both too few dependencies (leading to incorrect build outputs) and too many dependencies (leading to excessive rebuilds and reduced parallelism). Any programmer who has wondered why a small change led to excess compilation, or who resorted to a “clean” step, has suffered the ill effects of incorrect dependency specification. We outline a build system where dependencies are not specified, but instead captured by tracing execution. The consequence is that dependencies are always correct by construction and build scripts are easier to write. The simplest implementation of our approach would lose parallelism, but we are able to recover parallelism using speculation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sarah</first_name>
          <last_name>Spall</last_name>
          <affiliation>Indiana University</affiliation>
          <bio>undefined</bio>
          <person_id>sarahspall</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Neil</first_name>
          <last_name>Mitchell</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ndmitchell.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/neilmitchell/bcccf5bd-0c3b-4e0e-90c9-ef73780b976c/small.jpg</picture_url>
          <person_id>neilmitchell</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sam</first_name>
          <last_name>Tobin-Hochstadt</last_name>
          <affiliation>Indiana University</affiliation>
          <bio>I am an Assistant Professor in the Department of Computer Science at Indiana University.
Research Interests: my research focuses on the design and analysis of software and programming languages. I am particularly interested in how programs grow from prototype scripts to robust software, and how programming language design can support this process. My research concerns type systems, software contracts, modularity, and extensibility. I’m currently working with the DARPA CRASH program on Racket and with Mozilla Labs on JavaScript.</bio>
          <homepage_url>http://samth.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/samtobinhochstadt/d817e5c9-fe1c-4664-a4d1-6af45d4d4586/small.jpg</picture_url>
          <person_id>samtobinhochstadt</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e2b151e3-5650-423f-bfba-20eb0205f6b3</subevent_id>
    <title>SPLASH OOPSLA: R-2</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>eb993289-bf96-4291-89d7-cbcc9e338b2d</slot_id>
      <title>Session: SPLASH OOPSLA - R-2</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>21:00</start_time>
      <end_time>22:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>45c0bea4-a043-4912-b554-a9bf6c5a1ce7</slot_id>
      <event_id>7f5b0b0c-f047-4936-8287-c85d0bbd3581</event_id>
      <title>Do You Have Space for Dessert? A Verified Space Cost Semantics for CakeML Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>21:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>21:40</end_time>
      <description>Garbage collectors relieve the programmer from manual memory management, but lead to compiler-generated machine code that can behave differently (e.g.\ out-of-memory errors) from the source code. To ensure that the generated code behaves exactly like the source code, programmers need a way to answer questions of the form: will this program avoid all out-of-memory errors if given this much memory?
This paper develops a cost semantics that can positively answer such questions for CakeML programs. The work described in this paper is the first to be able to answer such questions with proofs in the context of a language that depends on garbage collection. We demonstrate that positive answers can be used to transfer liveness results proved for the source code to liveness guarantees about the generated machine code. Without guarantees about space usage, only safety results can be transferred from source to machine code.
Our cost semantics is phrased in terms of an abstract intermediate language of the CakeML compiler, but results proved at that level map directly to the space cost of the compiler-generated machine code. All of the work described in this paper has been developed in the HOL4 theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alejandro</first_name>
          <last_name>Gómez-Londoño</last_name>
          <affiliation>Chalmers University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>alejandrogomezlondono</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Johannes</first_name>
          <last_name>Åman Pohjola</last_name>
          <affiliation>CSIRO's Data61/University of New South Wales</affiliation>
          <bio>undefined</bio>
          <person_id>johannesamanpohjola</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hira Taqdees</first_name>
          <last_name>Syeda</last_name>
          <affiliation>Chalmers University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>hirataqdeessyeda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Magnus O.</first_name>
          <last_name>Myreen</last_name>
          <affiliation>Chalmers University of Technology, Sweden</affiliation>
          <bio>I did a B.A. in Computer Science at the University of Oxford, tutored by Dr Jeff Sanders.
I completed my Ph.D. on program verification in 2009 at the University of Cambridge, supervised by Prof. Mike Gordon. My PhD dissertation was selected as the winner of the BCS Distinguished Dissertation Competition 2010.
In 2012, I became a Royal Society Research Fellow, UK.
In 2014, I moved to Chalmers where I became a tenured Associate Professor in 2015.</bio>
          <homepage_url>http://www.cse.chalmers.se/~myreen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusomyreen/ccd5e9cd-2811-4ef2-a9f0-3dd7802233ca/small.jpg</picture_url>
          <person_id>magnusomyreen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yong Kiam</first_name>
          <last_name>Tan</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.cmu.edu/~yongkiat/</homepage_url>
          <person_id>yongkiamtan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4bf9bec3-9bd2-4fda-b411-d85e70d68954</slot_id>
      <event_id>85b0bc7f-a107-41e9-9836-f25f8409f19f</event_id>
      <title>Verifying Replicated Data Types with Typeclass Refinements in Liquid Haskell</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>21:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>22:00</end_time>
      <description>This paper presents an extension to Liquid Haskell that facilitates stating and semi-automatically proving properties of typeclasses. Liquid Haskell augments Haskell with refinement types—our work allows such types to be attached to typeclass method declarations, and ensures that instance implementations respect these types. The engineering of this extension is a modular interaction between GHC, the Glasgow Haskell Compiler, and Liquid Haskell’s core proof infrastructure. The design sheds light on the interplay between modular proofs and typeclass resolution, which in Haskell is coherent by default, but in other dependently typed languages is not.
We demonstrate the utility of our extension by using Liquid Haskell to modularly verify that 34 instances satisfy the laws of five standard typeclasses. More substantially, we implement a framework for programming distributed applications based on conflict-free replicated data types (CRDTs). We define a typeclass whose Liquid Haskell type captures the mathematical properties CRDTs should satisfy; prove in Liquid Haskell that these properties are sufficient to ensure that replicas’ states converge despite out-of-order update delivery; implement (and prove correct) several instances of our CRDT typeclass; and use them to build two realistic applications, a multi-user calendar event planner and a collaborative text editor.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yiyun</first_name>
          <last_name>Liu</last_name>
          <affiliation>University of Maryland, College Park, USA</affiliation>
          <bio>undefined</bio>
          <person_id>yiyunliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>James</first_name>
          <last_name>Parker</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
          <person_id>jamesparker</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Redmond</last_name>
          <affiliation>University of California, Santa Cruz, USA</affiliation>
          <bio>undefined</bio>
          <person_id>patrickredmond</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lindsey</first_name>
          <last_name>Kuper</last_name>
          <affiliation>University of California, Santa Cruz</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://users.soe.ucsc.edu/~lkuper/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/lindseykuper/f5b1f248-82e4-45ec-ab90-1d543b02d204/small.jpg</picture_url>
          <person_id>lindseykuper</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Hicks</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>Michael Hicks is a Professor in the Computer Science department and UMIACS at the University of Maryland, where he co-directs the laboratory for Programming Languages research (PLUM); he is the former Director of the Maryland Cybersecurity Center (MC2) and the Past Chair of ACM SIGPLAN.
His research focuses on using programming languages and analyses to improve the security, reliability, and availability of software. He is perhaps best known for his work exploring dynamic software updating, a technique with which software can be updated without shutting it down. He has explored the design of new programming languages and analysis tools for helping programmers find bugs and software vulnerabilities, and for identifying suspicious or incorrect program executions. He was worked has combined ideas from PL and cryptography, e.g., to ensure privacy preserving computations. He also leads the development of a new security-oriented programming contest, “build-it, break-it, fix-it,” which has been offered to the public and to students in his Coursera class on software security. He has recently begun to explore programming languages for quantum computation.
He is the editor of the Programming Languages Enthusiast blog and Tweets at @michael_w_hicks.</bio>
          <homepage_url>http://www.cs.umd.edu/~mwh/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelhicks/aa64e3c6-3516-4e13-affe-77bc32c40565/small.jpg</picture_url>
          <person_id>michaelhicks</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Niki</first_name>
          <last_name>Vazou</last_name>
          <affiliation>IMDEA Software Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://nikivazou.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nikivazou/8cc6ddec-154b-47e9-b40d-c66e78476391/small.jpg</picture_url>
          <person_id>nikivazou</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c75362d3-e972-4e28-a790-2508d4de2cac</slot_id>
      <event_id>9796e9aa-1b8d-46b7-8c85-2c6427f306de</event_id>
      <title>Towards a Formal Foundation of Intermittent Computing</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>22:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>22:20</end_time>
      <description>Intermittently powered devices enable new applications in harsh or inaccessible environments, such as space or in-body implants, but also introduce problems in programmability and correctness. Researchers have developed programming models to ensure that programs make progress and do not produce erroneous results due to memory inconsistencies caused by intermittent executions. As the technology has matured, more and more features are added to intermittently powered devices, such as I/O. Prior work has shown that all existing intermittent execution models have problems with repeated device or sensor inputs (RIO). RIOs could leave intermittent executions in an inconsistent state. Such problems and the proliferation of existing intermittent execution models necessitate a formal foundation for intermittent computing.
In this paper, we formalize intermittent execution models, their correctness properties with respect to memory consistency and inputs, and identify the invariants needed to prove systems correct. We prove equivalence between several existing intermittent systems. To address RIO problems, we define an algorithm for identifying variables affected by RIOs that need to be restored after reboot and prove the algorithm correct. Finally, we implement the algorithm in a novel intermittent runtime system that is correct with respect to input operations and evaluate its performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Milijana</first_name>
          <last_name>Surbatovich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>milijanasurbatovich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Brandon</first_name>
          <last_name>Lucia</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Brandon is a Professor at Carnegie Mellon University working on hardware and software computer systems to answer the question: “How capable can a computing system be, given physical restrictions on its form factor, input power, energy storage, or other resource constraints?” His research has been recognized with 8 best paper awards, the 2019 IEEE TCCA Young Computer Architect Award and the 2015 Bell Labs Prize.</bio>
          <homepage_url>http://brandonlucia.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brandonlucia/e10fc900-d74f-44e7-a793-5e2f21a7dd0b/small.jpg</picture_url>
          <person_id>brandonlucia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Limin</first_name>
          <last_name>Jia</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.andrew.cmu.edu/user/liminjia/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/liminjia/6bc50ee1-2333-4b59-bc4f-3bf74d1e3b64/small.jpg</picture_url>
          <person_id>liminjia</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fc3324eb-e719-4e94-9994-8d33988181a8</slot_id>
      <event_id>90cce21d-a854-4f50-b7f1-09a1af23e318</event_id>
      <title>Automatic and Efficient Variability-Aware Lifting of Functional Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>21:20</end_time>
      <description>A software analysis is a computer program that takes some representation of a software product as input and produces some useful information about that product as output. A software product line encompasses \emph{many} software product variants, and thus existing analyses can be applied to each of the product variations individually, but not to the entire product line as a whole. Enumerating all product variants and analyzing them one by one is usually intractable due to the combinatorial explosion of the number of product variants with respect to product line features. Several software analyses (e.g., type checkers, model checkers, data flow analyses) have been redesigned/re-implemented to support variability. This usually requires a lot of time and effort, and the variability-aware version of the analysis might have new errors/bugs that do not exist in the original one.
Given an analysis program written in a functional language based on PCF, in this paper we present two approaches to transforming (lifting) it into a semantically equivalent variability-aware analysis. A light-weight approach (referred to as \emph{shallow lifting}) wraps the analysis program into a variability-aware version, exploring all combinations of its input arguments. Deep lifting, on the other hand, is a program rewriting mechanism where the syntactic constructs of the input program are rewritten into their variability-aware counterparts. Compositionally this results in an efficient program semantically equivalent to the input program, modulo variability.
We present the correctness criteria for functional program lifting, together with correctness proof sketches of our program transformations. We evaluate our approach on a set of program analyses applied to the BusyBox C-language product line.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ramy</first_name>
          <last_name>Shahin</last_name>
          <affiliation>University of Toronto</affiliation>
          <bio>undefined</bio>
          <person_id>ramyshahin1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marsha</first_name>
          <last_name>Chechik</last_name>
          <affiliation>University of Toronto</affiliation>
          <bio>Marsha Chechik is Professor in the Department of Computer Science at the University of Toronto. She received her Ph.D. from the University of Maryland in 1996. Prof. Chechik’s research interests are in the application of formal methods to improve the quality of software. She has authored numerous papers in formal methods, software specification and verification, computer safety and security and requirements engineering. In 2002-2003, Prof. Chechik was a visiting scientist at Lucent Technologies in Murray Hill, NY and at Imperial College, London UK, and in 2013 – at Stonybrook University. She is a member of IFIP WG 2.9 on Requirements Engineering and an Associate Editor in Chief of Journal on Software and Systems Modeling. She is has been an associate editor of IEEE Transactions on Software Engineering 2003-2007, 2010-2013. She regularly serves on program committees of international conferences in the areas of software engineering and automated verification. Marsha Chechik has been Program Committee Co-Chair of the 2018 International Conference in Software Engineering (ICSE18), 2016 International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS’16), the 2016 Working Conference on Verified Software: Theories, Tools, and Experiments (VSTTE16), the 2014 International Conference on Automated Software Engineering (ASE’14), the 2008 International Conference on Concurrency Theory (CONCUR’08), the 2008 International Conference on Computer Science and Software Engineering (CASCON’08), and the 2009 International Conference on Formal Aspects of Software Engineering (FASE’09). She will be PC Co-Chair of ESEC/FSE’2021. She is a Member of ACM SIGSOFT and the IEEE Computer Society.</bio>
          <homepage_url>http://www.cs.toronto.edu/~chechik</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/marshachechik/779292d1-7e1c-4bb1-9f30-e36ee949bd9a/small.jpg</picture_url>
          <person_id>marshachechik</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6ea314e2-282c-4014-8d0b-fa0c3a939812</subevent_id>
    <title>SPLASH OOPSLA: R-4</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>cd2cda48-c3ec-4a5b-a8a9-997f95f219d7</slot_id>
      <title>Session: SPLASH OOPSLA - R-4</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1fe76e34-a448-44ce-909c-90d1f249626a</slot_id>
      <event_id>0484f76d-7e8f-42de-be40-69afe1f78f7d</event_id>
      <title>Dataflow-based Pruning for Speeding up Superoptimization</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>13:40</end_time>
      <description>Superoptimization is a compilation strategy that uses search to improve code quality, rather than relying on a canned sequence of transformations, as traditional optimizing compilers do. This search can be seen as a program synthesis problem: from unoptimized code serving as a specification, the synthesis procedure attempts to create a more efficient implementation. An important family of synthesis algorithms works by enumerating candidates and then successively checking if each refines the specification, using an SMT solver. The contribution of this paper is a pruning technique which reduces the enumerative search space using fast dataflow-based techniques to discard synthesis candidates that contain symbolic constants and uninstantiated instructions. We demonstrate the effectiveness of this technique by improving the runtime of an enumerative synthesis procedure in the Souper superoptimizer for the LLVM intermediate representation. The techniques presented in this paper eliminate 65% of the solver calls made by Souper, making it 2.32x faster (14.54 hours vs 33.76 hours baseline, on a large multicore) at solving all 269,113 synthesis problems that Souper encounters when optimizing the C and C++ programs from SPEC CPU 2017.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manasij</first_name>
          <last_name>Mukherjee</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
          <person_id>manasijmukherjee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pranav</first_name>
          <last_name>Kant</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
          <person_id>pranavkant</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhengyang</first_name>
          <last_name>Liu</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.utah.edu/~liuz/</homepage_url>
          <person_id>zhengyangliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>John</first_name>
          <last_name>Regehr</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.utah.edu/~regehr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnregehr/2cb23ab0-042a-487a-a859-cbd3147a46a7/small.jpg</picture_url>
          <person_id>johnregehr</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7f47ee80-2b41-44fd-b79f-0bfe212d2f81</slot_id>
      <event_id>e9ae4c19-f50c-4f0d-b1e6-3e733890b7c4</event_id>
      <title>Enabling Accuracy-Aware Quantum Compilers Using Symbolic Resource Estimation</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>14:00</end_time>
      <description>Approximation errors must be taken into account when compiling programs for fault-tolerant quantum computers. We present a methodology that tracks such errors automatically and then optimizes accuracy parameters to guarantee a specified overall accuracy while aiming to minimize the implementation cost in terms of quantum gates. The core idea of our approach is to extract functions that specify the optimization problem directly from the high-level description of the quantum program. Then, custom compiler passes optimize these functions, turning them into (near-)symbolic expressions for (1) the total error and (2) the implementation cost (e.g., total quantum gate count). All unspecified parameters of the quantum program will show up as variables in these expressions, including accuracy parameters. After solving the corresponding optimization problem, a circuit can be instantiated from the found solution. We develop two prototype implementations, one in C++ based on Clang/LLVM, and another using the Q# compiler infrastructure. We benchmark our prototypes on typical quantum computing programs, including the quantum Fourier transform, quantum phase estimation, and Shor’s algorithm.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Giulia</first_name>
          <last_name>Meuli</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
          <person_id>giuliameuli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mathias</first_name>
          <last_name>Soeken</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>mathiassoeken</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Martin</first_name>
          <last_name>Roetteler</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>martinroetteler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Häner</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>thomashaner</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a02b87db-c6d1-4a08-9b16-e880048dd07c</slot_id>
      <event_id>c500592f-2d9a-4056-99b3-b5e5865667b4</event_id>
      <title>Assertion-based optimization of quantum programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>13:20</end_time>
      <description>Quantum computers promise to perform certain computations exponentially faster than any classical device. Precise control over their physical implementation and proper shielding from unwanted interactions with the environment become more difficult as the space/time volume of the computation grows. Code optimization is thus crucial in order to reduce resource requirements to the greatest extent possible. Besides manual optimization, previous work has adapted classical methods such as constant-folding and common subexpression elimination to the quantum domain. However, such classically-inspired methods fail to exploit certain optimization opportunities across subroutine boundaries, limiting the effectiveness of software reuse. To address this insufficiency, we introduce an optimization methodology which employs annotations that describe how subsystems are entangled in order to exploit these optimization opportunities. We formalize our approach, prove its correctness, and present benchmarks: Without any prior manual optimization, our methodology is able to reduce, e.g., the qubit requirements of a 64-bit floating-point subroutine by 34×.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Häner</last_name>
          <affiliation>ETH Zürich</affiliation>
          <bio>undefined</bio>
          <person_id>thomashaner1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Troyer</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>matthiastroyer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Torsten</first_name>
          <last_name>Hoefler</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>Torsten is an Assistant Professor of Computer Science at ETH Zürich, Switzerland. Before joining ETH, he led the performance modeling and simulation efforts of parallel petascale applications for the NSF-funded Blue Waters project at NCSA/UIUC. He is also a key member of the Message Passing Interface (MPI) Forum where he chairs the “Collective Operations and Topologies” working group. Torsten won best paper awards at the ACM/IEEE Supercomputing Conference 2010 (SC10), EuroMPI 2013, ACM/IEEE Supercomputing Conference 2013 (SC13), and other conferences. He published numerous peer-reviewed scientific conference and journal articles and authored chapters of the MPI-2.2 and MPI-3.0 standards. For his work, Torsten received the SIAM SIAG/Supercomputing Junior Scientist Prize in 2012 and the IEEE TCSC Young Achievers in Scalable Computing Award in 2013. Following his Ph.D., the received the Young Alumni Award 2014 from Indiana University. Torsten was elected into the first steering committee of ACM’s SIGHPC in 2013. His research interests revolve around the central topic of “Performance-centric Software Development” and include scalable networks, parallel programming techniques, and performance modeling. Additional information about Torsten can be found on his homepage at htor.inf.ethz.ch.</bio>
          <homepage_url>http://htor.inf.ethz.ch/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/torstenhoefler/b570b3f0-a91f-4651-8a80-cfde60d06190/small.jpg</picture_url>
          <person_id>torstenhoefler</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e0a12082-c401-4675-8143-3a5c9eb89020</slot_id>
      <event_id>f2d61eb0-5d2c-45d9-81c7-1137a585afca</event_id>
      <title>Eliminating Abstraction Overhead of Java Stream Pipelines using Ahead-of-Time Program Optimization</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>14:20</end_time>
      <description>Java 8 introduced streams that allow developers to work with collections of data using functional-style operations. Streams are often used in pipelines of operations for processing the data elements, which leads to concise and elegant program code. However, the declarative data processing style comes at a cost. Compared to processing the data with traditional imperative language mechanisms, constructing stream pipelines requires extra heap objects and virtual method calls, which often results in significant run-time overheads.
In this work we investigate how to mitigate these overheads to enable processing data in the declarative style without sacrificing performance. We argue that ahead-of-time bytecode-to-bytecode transformation is a suitable approach to optimization of stream pipelines, and we present a static analysis that is designed to guide such transformations. Experimental results show a significant performance gain, and that the technique works for realistic stream pipelines. For 10 of 11 micro-benchmarks, the optimizer is able to produce bytecode that is as effective as hand-written imperative-style code. Additionally, 73% of 6586 stream pipelines found in real-world Java programs are optimized successfully.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anders</first_name>
          <last_name>Møller</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
          <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
          <person_id>andersmoller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Oskar</first_name>
          <last_name>Haarklou Veileborg</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/oskarhaarklouveileborg/4b1f271b-c619-4096-8218-ae034b3a1da9/small.jpg</picture_url>
          <person_id>oskarhaarklouveileborg</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>aa3f4162-269f-44a3-a4f2-f476980697ee</subevent_id>
    <title>SPLASH OOPSLA: F-1B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>9f4aced6-1908-456a-add0-5ca50befc252</slot_id>
      <title>Session: SPLASH OOPSLA - F-1B</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>19:00</start_time>
      <end_time>20:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3e48ecad-7841-481f-815a-66e118189a37</slot_id>
      <event_id>256ca32c-494b-45db-903d-d2bbabbfbd1b</event_id>
      <title>Guiding Dynamic Programing via Structural Probability for Accelerating Programming by Example</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>20:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>20:20</end_time>
      <description>Programming by example (PBE) is an important subproblem of program synthesis and the techniques of PBE have been applied to many domains. Though many techniques for accelerating PBE systems have been explored, the scalability remains one of the main challenges: there is still a gap between the performances of state-of-the-art synthesizers and the industrial requirement. To further speed up solving PBE tasks, in this paper we propose a novel PBE framework MaxFlash, which uses the naturalness of programs to guide a search based on dynamic programming, such that the search will focus on subproblems that form more natural programs, and avoid unnatural programs. Our evaluation shows that MaxFlash achieves $\times 5.097- \times 2321$ speed-ups against state-of-the-art solvers on $244$ real-world tasks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ruyi</first_name>
          <last_name>Ji</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <person_id>ruyiji</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yican</first_name>
          <last_name>Sun</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>yicansun1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yingfei</first_name>
          <last_name>Xiong</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>Associate Professor</bio>
          <homepage_url>http://sei.pku.edu.cn/~xiongyf04/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yingfeixiong/18fb7368-4f14-462a-b038-9990eebb7a9c/small.jpg</picture_url>
          <person_id>yingfeixiong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhenjiang</first_name>
          <last_name>Hu</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sei.pku.edu.cn/~hu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhenjianghu/5d426480-5589-46be-b4f6-f98cf2acc80e/small.jpg</picture_url>
          <person_id>zhenjianghu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ae530ffd-560a-4206-87da-26475c51153a</slot_id>
      <event_id>29356edb-fec4-4b97-9278-0bf447a06e5d</event_id>
      <title>TacTok: Semantics-Aware Proof Synthesis</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>19:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>20:00</end_time>
      <description>Formally verifying software correctness is a highly manual process. However, because verification proofs often share structure, it is possible to learn from existing proofs to fully automate some formal verification. The goal of this paper is to improve proof synthesis and enable fully automating more verification. Interactive theorem provers, such as the Coq proof assistant, allow developers to write partial proofs, observe the semantics of the proof state thus far, and then attempt more progress. Knowing the proof state semantics is a significant aid. Recent research has shown that the proof state can help predict the next step. In this paper, we present TacTok, the first technique that attempts to fully automate proof synthesis by modeling proofs using both the partial proof written thus far and the semantics of the proof state. Thus, TacTok more completely models the information the developer has access to when writing proofs manually. TacTok is open-source. We evaluate TacTok on a benchmark of 26 software projects in Coq, consisting of over 10 thousand theorems. We compare our approach to two tools, CoqHammer, the state-of-the-art proof synthesis technique, and ASTactic, a proof synthesis technique that models proof state. We find that TacTok is complementary to CoqHammer and ASTactic: for 24 out of the 26 projects, TacTok can synthesize proofs for some theorems prior tools cannot. Together with TacTok, 11.5% more theorems can be proven automatically than by CoqHammer alone, and 20.0% than by ASTactic alone. Compared to a combination of CoqHammer and ASTactic, TacTok can prove an additional 3.6% more theorems, proving 115 theorems no tool could previously prove. Overall, our experiments provide evidence that partial proof and proof state semantics, together, provide useful information for proof modeling.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Emily</first_name>
          <last_name>First</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>undefined</bio>
          <person_id>emilyfirst</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yuriy</first_name>
          <last_name>Brun</last_name>
          <affiliation>University of Massachusetts at Amherst, USA</affiliation>
          <bio>My research is in software engineering. I am interested in improving our ability to build systems that are smart, and self-adapt to their environment. I am particularly interested in ensuring fairness in software systems. Watch a video describing my latest work on software fairness testing here: http://tinyurl.com/FairnessVideo</bio>
          <homepage_url>http://people.cs.umass.edu/~brun/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yuriybrun/15eff225-fb71-4b2c-9925-a0d731136238/small.jpg</picture_url>
          <person_id>yuriybrun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Guha</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cics.umass.edu/~arjun</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjunguha/284e0782-ec24-4ad9-b6a4-b6a1d0e2fe9a/small.jpg</picture_url>
          <person_id>arjunguha</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b6e155fa-44ef-413b-824f-9d23df63213f</slot_id>
      <event_id>8068ce72-3e63-4d39-8209-298d9b3bc05d</event_id>
      <title>Learning Graph-based Heuristics for Pointer Analysis without Handcrafting Application-Specific Features</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>19:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>19:40</end_time>
      <description>We present Graphick, a new technique for automatically learning graph-based heuristics for pointer analysis. Striking a balance between precision and scalability of pointer analysis requires designing good analysis heuristics. For example, because applying context sensitivity to all methods in a real-world program is impractical, pointer analysis typically uses a heuristic to employ context sensitivity only when it is necessary. Past research has shown that exploiting the program’s graph structure is a promising way of developing cost-effective analysis heuristics, promoting the recent trend of ``graph-based heuristics'' that work on the graph representations of programs obtained from a pre-analysis. Although promising, developing such heuristics manually remains challenging, requiring a great deal of expertise and laborious effort. In this paper, we aim to reduce this burden by learning graph-based heuristics automatically, in particular without hand-crafted application-specific features. To do so, we present a general feature language to describe graph structures and an algorithm for learning analysis heuristics within the language. We implemented Graphick on top of Doop and learned graph-based heuristics for context sensitivity and heap abstraction. The evaluation results show that our approach is general and can effectively generate high-quality heuristics; for both instances, the learned heuristics are as competitive as the existing state-of-the-art heuristics designed manually by analysis experts.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Minseok</first_name>
          <last_name>Jeon</last_name>
          <affiliation>Korea University, South Korea</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://prl.korea.ac.kr/~minseok/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/minseokjeon/69505413-080b-41a8-8714-56f24d788995/small.jpg</picture_url>
          <person_id>minseokjeon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Myungho</first_name>
          <last_name>Lee</last_name>
          <affiliation>Korea University</affiliation>
          <bio>undefined</bio>
          <person_id>myungholee1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hakjoo</first_name>
          <last_name>Oh</last_name>
          <affiliation>Korea University, South Korea</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://prl.korea.ac.kr</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hakjoooh/d607b778-78f3-41c4-84d9-4693c8923bc3/small.jpg</picture_url>
          <person_id>hakjoooh</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bfc45d64-2336-40ce-8762-b3fcd5a2ff6a</slot_id>
      <event_id>fd3d1690-7023-4d0a-a100-6ba2b8f4497c</event_id>
      <title>Incremental Predicate Analysis for Regression Verification</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>19:20</end_time>
      <description>Software products are evolving during their life cycles. Ideally, every revision need be formally verified to ensure software quality. Yet repeated formal verification requires significant computing resources. Verifying each and every revision can be very challenging. It is desirable to ameliorate regression verification for practical purposes. In this paper, we regard predicate analysis as a process of assertion annotation. We propose to reuse the previously-yielded assertion annotation in regression verification. A light-weight impact-analysis technique is proposed to analyze the reusability of assertions. A novel assertion strengthening technique is furthermore developed to improve reusability of annotation. With these techniques, we present an incremental predicate analysis technique for regression verification. Correctness of our incremental technique is formally proved. We performed comprehensive experiments on revisions of Linux kernel device drivers. Our technique outperforms the state-of-the-art program verification tool CPAchecker by getting x1.4 speedup in analysis time and solving additional 78 tasks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Qianshan</first_name>
          <last_name>Yu</last_name>
          <affiliation>Tsinghua University</affiliation>
          <bio>undefined</bio>
          <person_id>qianshanyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fei</first_name>
          <last_name>He</last_name>
          <affiliation>Tsinghua University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://feihe.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/feihe/8546030e-3821-4cb3-8f33-23a258579461/small.jpg</picture_url>
          <person_id>feihe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bow-Yaw</first_name>
          <last_name>Wang</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <person_id>bowyawwang1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4a3195ef-0362-4884-91a7-7f4796acd6df</subevent_id>
    <title>SPLASH OOPSLA: F-4B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>9a2af04b-9f08-4ea2-9fbb-ad39dd5dd123</slot_id>
      <title>Session: SPLASH OOPSLA - F-4B</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>81527de7-221f-44b5-a907-12c21c7069f1</slot_id>
      <event_id>607946f8-4df3-4340-83bb-3317adc76c7a</event_id>
      <title>Certified and efficient instruction scheduling</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>13:20</end_time>
      <description>CompCert is a moderately optimizing C compiler with a formal, machine-checked, proof of correctness: after successful compilation, the assembly code has a behavior faithful to the source code. Previously, it only supported target instruction sets with sequential semantics, and did not attempt reordering instructions for optimization.
We present here a CompCert backend for a VLIW core (i.e., with explicit parallelism at the instruction level), the first CompCert backend providing scalable and efficient instruction scheduling. Furthermore, its highly modular implementation can be easily adapted to other VLIW or non-VLIW pipelined processors.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sylvain</first_name>
          <last_name>Boulmé</last_name>
          <affiliation>Grenoble-INP - VERIMAG</affiliation>
          <bio>undefined</bio>
          <person_id>sylvainboulme</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Monniaux</last_name>
          <affiliation>CNRS, VERIMAG</affiliation>
          <bio>David Monniaux obtained his PhD in 2001 in Paris under Prof Patrick Cousot; his dissertation was on the static analysis of probabilistic programs by abstract interpretation. He then joined CNRS as a junior researcher and first worked on the Astrée static analyzer, still in Paris. In 2007 he transferred to VERIMAG in Grenoble, where he works on various aspects of program verification (decision procedures, abstract interpretation…).
He now is a senior researcher at CNRS and an adjunct professor at École polytechnique.</bio>
          <homepage_url>http://www-verimag.imag.fr/~monniaux/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/davidmonniaux/d285baca-8e32-4918-b3c6-c724e98fc7b3/small.jpg</picture_url>
          <person_id>davidmonniaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Cyril</first_name>
          <last_name>Six</last_name>
          <affiliation>Kalray</affiliation>
          <bio>undefined</bio>
          <person_id>cyrilsix</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c2ad7159-9b45-442a-b8ec-e5bc584593fa</slot_id>
      <event_id>ec90eddc-d967-43e8-8847-c0b006802b6a</event_id>
      <title>Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>13:40</end_time>
      <description>Lighthouse projects such as CompCert, seL4, IronFleet, and DeepSpec have demonstrated that full verification of entire systems is feasible by establishing a refinement relation between an abstract system specification and an executable implementation. Existing approaches however impose severe restrictions on either the abstract system specifications due to their limited expressiveness or versatility, or on the executable code due to their reliance on suboptimal code extraction or inexpressive program logics.
We propose a novel methodology that combines the compositional refinement of abstract, event-based models of distributed systems with the verification of full-fledged program code using expressive separation logics, which support features of realistic programming languages like mutable heap data structures and concurrency. The main technical contribution of our work is a formal framework that soundly relates event-based system models to program specifications in separation logics, such that successful verification establishes a refinement relation between the model and the code. We formalized our framework, \emph{Igloo}, in Isabelle/HOL.
Our approach leverages existing program verifiers. We report on three case studies, a leader election protocol, a replication protocol, and a security protocol, for which we refine formal requirements into program specifications that we implement in Java and Python and prove correct using the VeriFast and Nagini tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Sprenger</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>christophsprenger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Klenze</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>tobiasklenze</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marco</first_name>
          <last_name>Eilers</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch/people/personal/meilers-pers.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/marcoeilers/fbfa4a0a-c277-440b-af64-20c5dbf19d0c/small.jpg</picture_url>
          <person_id>marcoeilers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Felix</first_name>
          <last_name>Wolf</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>felixwolf2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Peter</first_name>
          <last_name>Müller</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/petermller/aeb8e276-62cb-4ad1-aa7d-96f76c0c405d/small.jpg</picture_url>
          <person_id>petermller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Martin</first_name>
          <last_name>Clochard</last_name>
          <affiliation>ETH Zürich</affiliation>
          <bio>undefined</bio>
          <person_id>martinclochard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>David</first_name>
          <last_name>Basin</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>davidbasin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d4ecabd4-5c59-45b4-b90a-d5e08fb054af</slot_id>
      <event_id>cb73d5d3-92d2-4ee8-bb13-8a1b4731e3a3</event_id>
      <title>Termination Analysis for Evolving Programs</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>14:20</end_time>
      <description>Research on program termination has a long tradition. However, most of the existing techniques target a single program only. We propose in this paper an incremental termination analysis approach by reusing certified modules across different program versions. A transformation-based procedure is further developed to increase the reusability of certified modules. The proposed approach has wide applicability, applicable to various program changes. The proposed technique, to the best of our knowledge, represents a novel attempt to the termination analysis of evolving programs. We implemented the approach on top of \textsc{Ultimate Automizer}. Experimental results show dramatic improvement of our approach over the state-of-the-art tool.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fei</first_name>
          <last_name>He</last_name>
          <affiliation>Tsinghua University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://feihe.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/feihe/8546030e-3821-4cb3-8f33-23a258579461/small.jpg</picture_url>
          <person_id>feihe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jitao</first_name>
          <last_name>Han</last_name>
          <affiliation>School of Software, Tsinghua University</affiliation>
          <bio>undefined</bio>
          <person_id>jitaohan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f65e816c-9101-460a-964b-12a9b29ecf22</slot_id>
      <event_id>88401ded-3b58-4749-8aef-7b24b61ab09f</event_id>
      <title>Neural Reverse Engineering of Stripped Binaries using Augmented Control Flow Graphs</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>14:00</end_time>
      <description>We address the problem of reverse engineering of stripped executables, which contain no debug information. This is a challenging problem because of the low amount of syntactic information available in stripped executables, and the diverse assembly code patterns arising from compiler optimizations.
We present a novel approach for predicting procedure names in stripped executables. Our approach combines static analysis with neural models. The main idea is to use static analysis to obtain augmented representations of call sites; encode the structure of these call sites using the control-flow graph (CFG) and finally, generate a target name while attending to these call sites. We use our representation to drive graph-based, LSTM-based and Transformer-based architectures.
Our evaluation shows that our models produce predictions that are difficult and time consuming for humans, while improving on existing methods by 28% and by 100% over state-of-the-art neural textual models that do not use any static analysis. Code and data for this evaluation are available at https://github.com/tech-srl/Nero .</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yaniv</first_name>
          <last_name>David</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://yanivd.cswp.cs.technion.ac.il</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yanivdavid/83ffa94a-79ef-4627-b213-9d48cfeac290/small.jpg</picture_url>
          <person_id>yanivdavid</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Uri</first_name>
          <last_name>Alon</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~urialon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/urialon/a0488e4f-5173-472b-af25-10666c27e3d4/small.jpg</picture_url>
          <person_id>urialon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion</affiliation>
          <bio>Eran Yahav is an associate professor at the Computer Science Department, Technion, Israel. Prior to that, he was a research staff member at the IBM T.J. Watson Research Center (2004-2010). He received his Ph.D. from Tel Aviv University (2005) and his B.Sc. from the Technion in 1996. His research interests include program analysis, program synthesis and program verification. Eran is a recipient of the prestigious Alon Fellowship for Outstanding Young Researchers, the Andre Deloro Career Advancement Chair in Engineering, the ERC Consolidator Grant as well as multiple best paper awards at various conferences.</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
          <person_id>eranyahav</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>307a8b34-7172-4e69-bd67-b4f4b92c989b</subevent_id>
    <title>SPLASH OOPSLA: R-3</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>76f60a28-06d4-4f6f-9557-7835a186ccbb</slot_id>
      <title>Session: SPLASH OOPSLA - R-3</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2f984058-29f9-4c66-9b1f-6182cd2c73f6</slot_id>
      <event_id>a3ab81c8-640a-4a08-9893-24582fac04f3</event_id>
      <title>Compiling Symbolic Execution with Staging and Algebraic Effects</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>11:20</end_time>
      <description>Building effective symbolic execution engines poses challenges in multiple dimensions: an engine must correctly model the program semantics, provide flexibility in symbolic execution strategies, and execute them efficiently.
This paper proposes a principled approach to building correct, flexible, and efficient symbolic execution engines, directly rooted in the semantics of the underlying language in terms of a high-level definitional interpreter. The definitional interpreter induces algebraic effects to abstract over semantic variants of symbolic execution, e.g., collecting path conditions as a state effect and path exploration as a nondeterminism effect. Different handlers of these effects give rise to different symbolic execution strategies, making execution strategies orthogonal to the symbolic execution semantics, thus improving flexibility. Furthermore, by annotating the symbolic definitional interpreter with binding-times and specializing it to the input program via the first Futamura projection, we obtain a “symbolic compiler”, generating efficient instrumented code having the symbolic execution semantics. Our work reconciles the interpretation- and instrumentation-based approaches to building symbolic execution engines in a uniform framework.
We illustrate our approach on a simple imperative language step-by-step and then scale up to a significant subset of LLVM IR. We also show effect handlers for common path selection strategies. Evaluating our prototype’s performance shows speedups of 10~30x over the unstaged counterpart, and ~2x over KLEE, a state-of-the-art symbolic interpreter for LLVM IR.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guannan</first_name>
          <last_name>Wei</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://continuation.passing.style</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guannanwei/e1971b4b-ebd3-429b-b28c-0c2cfb0f0289/small.jpg</picture_url>
          <person_id>guannanwei</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Oliver</first_name>
          <last_name>Bračevac</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://bracevac.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/oliverbracevac/17c0ac71-a156-4868-8df9-d4ae4cd669e7/small.jpg</picture_url>
          <person_id>oliverbracevac</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Shangyin</first_name>
          <last_name>Tan</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shangyintan/05c3151d-071e-451a-9863-639fc66108ca/small.jpg</picture_url>
          <person_id>shangyintan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
          <person_id>tiarkrompf</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>905e2126-2764-419d-a012-7aa0896ac80d</slot_id>
      <event_id>5b2281e0-6ffc-4b3a-976f-ae840b9db5fd</event_id>
      <title>SATUNE: Synthesizing Efficient SAT Encoders</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>12:00</end_time>
      <description>Modern SAT solvers are extremely efficient at solving boolean satisfiability problems, enabling a wide spectrum of techniques for checking, verifying, and validating real-world programs. What remains challenging, though, is how to encode a domain problem (e.g., model checking) into a SAT formula because the same problem can have multiple distinct encodings, which can yield performance results that are orders-of-magnitude apart, regardless of the underlying solvers used. We develop SATUNE, a tool that can automatically synthesize SAT encoders for different problem domains. SATUNE employs a DSL that allows developers to express domain problems at a high level and a search algorithm that can effectively find efficient solutions. The search process is guided by observations made over example encodings and their performance for the domain and hence SATUNE can quickly synthesize a high-performance encoder by incorporating patterns from examples that yield good performance. A thorough evaluation with JMCR, SyPet, Dirk, Hexiom, Sudoku, and KillerSudoku demonstrates that SATUNE can easily synthesize high-performance encoders for different domains including model checking, synthesis, and games. These encodings generate constraint problems that are often several orders of magnitude faster to solve than the original encodings used by the tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hamed</first_name>
          <last_name>Gorjiara</last_name>
          <affiliation>University of California at Irvine, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gorjiara.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hamedgorjiara/ac3c3dcb-0d83-409b-91a3-d369cd445f3b/small.jpg</picture_url>
          <person_id>hamedgorjiara</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guoqing Harry</first_name>
          <last_name>Xu</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am an Associate Professor of Computer Science at University of California, Los Angeles (UCLA). I am interested broadly in software and hardware systems — including programming languages, compilers, big data analytics, distributed systems, and computer architecture.</bio>
          <homepage_url>http://web.cs.ucla.edu/~harryxu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/harryxu/5d680c47-2b02-4f5f-a2fb-55c72b5d63ed/small.jpg</picture_url>
          <person_id>harryxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brian</first_name>
          <last_name>Demsky</last_name>
          <affiliation>University of California at Irvine, USA</affiliation>
          <bio>undefined</bio>
          <person_id>briandemsky</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9c11641e-6c93-4cd4-9202-b9a896ac990c</slot_id>
      <event_id>fcea71f9-9bb0-4209-a01f-13ad1fb54e32</event_id>
      <title>The Anchor Verifier for Blocking and Non-Blocking Concurrent Software</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>12:20</end_time>
      <description>Verifying the correctness of performance critical concurrent software with subtle synchronization is notoriously challenging, and many existing verifiers are either inadequately expressive or excessively burdensome to use. We present the Anchor verifier, which is based on a new, expressive formalism for specifying synchronization disciplines that naturally matches how programmers should think about reduction-based correctness arguments. Anchor proves concurrent components are race-free; do not go wrong; respect their synchronization disciplines; and are preemptive/cooperative equivalent, meaning that thread interference only happens at explicit yield annotations. Experiments on textbook concurrent data structures and the FastTrack analysis demonstrate that Anchor significantly reduces the burden of concurrent verification.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Freund</last_name>
          <affiliation>Williams College</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/stephenfreund/0b468f46-1f87-41c4-bcff-4321da9869c2/small.jpg</picture_url>
          <person_id>stephenfreund</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Cormac</first_name>
          <last_name>Flanagan</last_name>
          <affiliation>University of California, Santa Cruz</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://users.soe.ucsc.edu/~cormac/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cormacflanagan/fd454a8e-4230-4fa5-a4da-1d16a1027de3/small.jpg</picture_url>
          <person_id>cormacflanagan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f246d6b5-79e8-4039-8162-eadd2cd337cf</slot_id>
      <event_id>b9042a01-7709-4b12-9a6d-e627f04668a5</event_id>
      <title>Projection-based Runtime Assertions for Testing and Debugging Quantum Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>11:40</end_time>
      <description>In this paper, we propose Proq, a runtime assertion scheme for testing and debugging quantum programs on a quantum computer. The predicates in Proq are represented by projections (or equivalently, closed subspaces of the state space), following Birkhoff-von Neumann quantum logic. The satisfaction of a projection by a quantum state can be directly checked upon a small number of projective measurements rather than a large number of repeated executions. On the theory side, we rigorously prove that checking projection-based assertions can help locate bugs or statistically assure that the semantic function of the tested program is close to what we expect, for both exact and approximate quantum programs. On the practice side, we consider hardware constraints and introduce several techniques to transform the assertions, making them directly executable on the measurement-restricted quantum computers. We also propose to achieve simplified assertion implementation using local projection technique with soundness guaranteed. We compare Proq with existing quantum program assertions and demonstrate the effectiveness and efficiency of Proq by its applications to assert two ingenious quantum algorithms, the Harrow-Hassidim-Lloyd algorithm and Shor’s algorithm.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gushu</first_name>
          <last_name>Li</last_name>
          <affiliation>University of California, Santa Barbara</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.google.com/view/gushuli</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gushuli/5cdbca43-a9df-483d-aa77-d44bad9a5dc3/small.jpg</picture_url>
          <person_id>gushuli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Li</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Max Planck Institute for Security and Privacy/Tsinghua University</affiliation>
          <bio>undefined</bio>
          <person_id>lizhou1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nengkun</first_name>
          <last_name>Yu</last_name>
          <affiliation>University of Technology Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <person_id>nengkunyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yufei</first_name>
          <last_name>Ding</last_name>
          <affiliation>UCSB</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ucsb.edu/~yufeiding/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yufeiding/c37f32e5-103b-4441-891c-b82fc8e9640a/small.jpg</picture_url>
          <person_id>yufeiding</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Mingsheng</first_name>
          <last_name>Ying</last_name>
          <affiliation>University of Technology Sydney, Australia / Institute of Software at Chinese Academy of Sciences, China/ Department of Computer Science and Technology, Tsinghua University.</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://quantum-lab.org/mingsheng/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mingshengying/955ed532-f014-4273-965a-4906017b4b8d/small.jpg</picture_url>
          <person_id>mingshengying</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Yuan</first_name>
          <last_name>Xie</last_name>
          <affiliation>University of California, Santa Barbara</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ece.ucsb.edu/~yuanxie/</homepage_url>
          <person_id>yuanxie</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>930c7498-8bf6-41e1-a992-0fa6d1565376</subevent_id>
    <title>SPLASH OOPSLA: T-4</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>32c05868-bc5e-404d-b835-35804d7d1538</slot_id>
      <title>Session: SPLASH OOPSLA - T-4</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0ae64c62-37ee-4421-8dc9-1d0b09cab129</slot_id>
      <event_id>a4f48195-d136-4257-a4b0-1e97c5e1b2b3</event_id>
      <title>A Systematic Approach to Deriving Incremental Type Checkers</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:40</end_time>
      <description>Static typing can guide programmers if feedback is immediate. Therefore, all major IDEs incrementalize type checking in some way. However, prior approaches to incremental type checking are often specialized and hard to transfer to new type systems. In this paper, we propose a systematic approach for deriving incremental type checkers from textbook-style type system specifications. Our approach is based on compiling inference rules to Datalog, a carefully limited logic programming language for which incremental solvers exist. The key contribution of this paper is to discover an encoding of the infinite typing relation as a finite Datalog relation in a way that yields efficient incremental updates. We implemented the compiler as part of a type system DSL and show that it supports simple types, some local type inference, operator overloading, and universal types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>André</first_name>
          <last_name>Pacak</last_name>
          <affiliation>JGU Mainz</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/andrepacak/7e35f14d-4d06-4a19-8ab8-bc24c2ce8145/small.jpg</picture_url>
          <person_id>andrepacak</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sebastian</first_name>
          <last_name>Erdweg</last_name>
          <affiliation>JGU Mainz</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.pl.informatik.uni-mainz.de/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sebastianerdweg/cc4515b1-cefa-4dee-a915-3242f337c8d8/small.jpg</picture_url>
          <person_id>sebastianerdweg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tamás</first_name>
          <last_name>Szabó</last_name>
          <affiliation>itemis / JGU Mainz</affiliation>
          <bio>Tamás Szabó works as a Software Engineer for itemis in Stuttgart, and he is a PhD student at JGU Mainz. His focus is on DSLs, incremental computing, and static program analysis.</bio>
          <homepage_url>https://szabta89.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tamasszabo/545a3e41-bc8c-47e6-b801-caf7074137ce/small.jpg</picture_url>
          <person_id>tamasszabo</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4d15f386-fbe8-470a-ae21-4fa812e38b3f</slot_id>
      <event_id>b4bfae0b-6b5f-4ee8-9432-65f91d8c51a9</event_id>
      <title>A Structural Model for Contextual Code Changes</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:20</end_time>
      <description>We address the problem of predicting edit completions based on a learned model that was trained on past edits. Given a code snippet that is partially edited, our goal is to predict a completion of the edit for the rest of the snippet. We refer to this task as the Edit Completion task and present a novel approach for tackling it. e The main idea is to directly represent structural edits. This allows us to model the likelihood of the edit itself, rather than learning the likelihood of the edited code. We represent an edit operation as a path in the program’s Abstract Syntax Tree (AST), originating from the source of the edit to the target of the edit. Using this representation, we present a powerful and lightweight neural model for the Edit Completion task.
We conduct a thorough evaluation, comparing our approach to a variety of representation and modeling approaches that are driven by multiple strong models such as LSTMs, Transformers, and neural CRFs. Our experiments show that our model achieves 28% relative gain over state-of-the-art sequential models and 2x higher accuracy than syntactic models that learn to generate the edited code instead of modeling the edits directly. We make our code, dataset, and trained models publicly available at https://github.com/tech-srl/c3po/ .</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shaked</first_name>
          <last_name>Brody</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/people/shakedbr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shakedbrody/54e00e02-0977-4227-be70-21858a5e5626/small.jpg</picture_url>
          <person_id>shakedbrody</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Uri</first_name>
          <last_name>Alon</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~urialon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/urialon/a0488e4f-5173-472b-af25-10666c27e3d4/small.jpg</picture_url>
          <person_id>urialon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion</affiliation>
          <bio>Eran Yahav is an associate professor at the Computer Science Department, Technion, Israel. Prior to that, he was a research staff member at the IBM T.J. Watson Research Center (2004-2010). He received his Ph.D. from Tel Aviv University (2005) and his B.Sc. from the Technion in 1996. His research interests include program analysis, program synthesis and program verification. Eran is a recipient of the prestigious Alon Fellowship for Outstanding Young Researchers, the Andre Deloro Career Advancement Chair in Engineering, the ERC Consolidator Grant as well as multiple best paper awards at various conferences.</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
          <person_id>eranyahav</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>796c14f4-5186-4a91-ad57-55512b4f4fef</slot_id>
      <event_id>4a70ed09-84fe-4afe-8c78-338a350d3ab8</event_id>
      <title>Detecting Locations in JavaScript Programs Affected by Breaking Library Changes</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>14:00</end_time>
      <description>JavaScript libraries are widely used and evolve rapidly. Adapting client code to non-backwards compatible changes in libraries is a difficult manual task. In this paper we address the challenge of how to locate affected API uses in client code, by the use of a simple pattern language for expressing API access points and a pattern-matching tool based on lightweight static analysis.
Experimental evaluation on 15 popular npm packages shows that typical breaking changes are easy to express as patterns. Running the static analysis on 265 clients of these packages shows that it is accurate and efficient: it reveals usages of breaking APIs with only 14% false positives and no false negatives, and takes less than a second per client on average. In addition, the analysis is able to report its confidence, which makes it easier to identify the false positives. These results suggest that the approach, despite its simplicity, can reduce the manual effort of the client developers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anders</first_name>
          <last_name>Møller</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
          <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
          <person_id>andersmoller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Benjamin Barslev</first_name>
          <last_name>Nielsen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/benjaminbarslevnielsen/7c6acacc-eb83-4ad2-8f27-d9a7ce64e58e/small.jpg</picture_url>
          <person_id>benjaminbarslevnielsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Martin</first_name>
          <last_name>Toldam Torp</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/martintoldamtorp/692a65a1-9fc3-4bbf-920b-3b1f2c438848/small.jpg</picture_url>
          <person_id>martintoldamtorp</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e2bacf67-89d8-4ff1-b670-07da55823b60</slot_id>
      <event_id>64606eb7-ae14-4006-a27c-2e3b6b5b5c6c</event_id>
      <title>A Type-and-Effect System for Object Initialization</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>14:20</end_time>
      <description>Every newly created object goes through several initialization states: starting from a state where all fields are uninitialized until all of them are assigned. Any operation on the object during its initialization process, which usually happens in the constructor via \emph{this}, has to observe the initialization states of the object for correctness, i.e.~only initialized fields may be used. Checking safe usage of \emph{this} statically, without manual annotation of initialization states in source code, is a challenge, due to aliasing and virtual method calls on \emph{this}.
Mainstream languages either do not check initialization errors, like Java, C++, Scala, or they defend against them by not supporting useful initialization patterns, such as Swift. In parallel, past research has shown that safe initialization can be achieved for varying degrees of expressiveness but by sacrificing syntactic simplicity.
We approach the problem by upholding \emph{local reasoning} of initialization which avoids whole-program analysis, and we achieve \emph{typestate polymorphism} via subtyping. On this basis, we put forward a novel type-and-effect system that can effectively ensure initialization safety while allowing flexible initialization patterns with almost zero annotation burden.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fengyun</first_name>
          <last_name>Liu</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>I’m a PhD student at EPFL, working on Scala.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/fengyunliu/7967ca32-789c-44f7-a256-c5eae78909c1/small.jpg</picture_url>
          <person_id>fengyunliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aggelos</first_name>
          <last_name>Biboudis</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>Software engineer and computer science addict; researcher at heart, excited about extensibility of software, code generation and performance

 Working on frameworks and tools for Data, Analytics &amp;amp; AI @Swisscom
 Ex-researcher on Scala 3 @ LAMP/@EPFL
 PhD from @dit_uoa

@biboudis</bio>
          <homepage_url>http://biboudis.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aggelosbiboudis/89ee406d-41be-466b-a4e8-bf4c6aef486d/small.jpg</picture_url>
          <person_id>aggelosbiboudis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Paolo G.</first_name>
          <last_name>Giarrusso</last_name>
          <affiliation>BedRock Systems</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/paologgiarrusso/e3132edd-aa91-4b50-bd1f-5c280e08256c/small.jpg</picture_url>
          <person_id>paologgiarrusso</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Martin</first_name>
          <last_name>Odersky</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>Martin Odersky is a professor at EPFL in Lausanne, Switzerland. He has been working on programming languages for most of his career. He first studied structured and object-oriented programming as a PhD student of Niklaus Wirth, then fell in love with functional programming while working as a post doc at IBM and Yale. When Java came out, he started to add functional programming constructs to the new platform. This led to Pizza and GJ and eventually to Java 5 with generics. During that time he also developed javac, the current reference compiler for Java.
Over the last 10 years, Martin worked on unifying object-oriented and functional programming in the Scala language. Scala quickly escaped from the research lab and became a popular open source tool and industrial language. He now oversees development of Scala as head of the programming group at EPFL and as academic director of the Scala center.</bio>
          <homepage_url>http://lampwww.epfl.ch/~odersky/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/martinodersky/fc1dd696-d0d4-47cb-9d9a-bba012d98f9e/small.jpg</picture_url>
          <person_id>martinodersky</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f48e8510-6c51-40d5-9190-e731d1ed3cbe</subevent_id>
    <title>SPLASH OOPSLA: T-6B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>e195dfce-f831-4ce7-8730-f29fce360c59</slot_id>
      <title>Session: SPLASH OOPSLA - T-6B</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>611207e7-2a2f-4c07-aff9-b31143c3f4a8</slot_id>
      <event_id>d9f820f7-6c4c-4457-bbf2-f791d2e1d42d</event_id>
      <title>World Age in Julia: Optimizing Method Dispatch in the Presence of Eval</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>17:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>18:00</end_time>
      <description>Dynamic programming languages face semantic and performance challenges in the presence of features such as eval. The Julia programming language introduces the novel concept of world age to insulate compiled and optimized code from one of the most disruptive side-effects of eval, namely, addition of new methods to an existing function. This paper provides the first formal semantics of world age in a core calculus named Juliette, and shows how world age enables optimization of function calls in the presence of eval.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julia</first_name>
          <last_name>Belyakova</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>Sep 2018 – present: PhD Student, Northeastern University, USA. Sep 2017 – Jul 2018: Researcher, Czech Technical University in Prague, Czech Republic. Jan 2017 – Jun 2017: Research Scientist, Northeastern University, USA. 2014–2016: teaching assistant/lecturer at Southern Federal University, Russia. Received MS in Computer Science from Southern Federal University, Russia in 2014.</bio>
          <homepage_url>https://julbinb.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/juliabelyakova/b35236df-c22a-44f1-8048-aecfeba8ac2e/small.jpg</picture_url>
          <person_id>juliabelyakova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Chung</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/benjaminchung/30978af0-bcee-4c1e-9dd1-f2588ea14f38/small.jpg</picture_url>
          <person_id>benjaminchung</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jack</first_name>
          <last_name>Gelinas</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <person_id>jackgelinas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jameson</first_name>
          <last_name>Nash</last_name>
          <affiliation>Julia Computing</affiliation>
          <bio>undefined</bio>
          <person_id>jamesonnash1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ross</first_name>
          <last_name>Tate</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cornell.edu/~ross/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rosstate/cbcbd066-943d-46a2-a301-1f4084076400/small.jpg</picture_url>
          <person_id>rosstate</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>68625d2d-4816-435c-af09-e21a3482e96b</slot_id>
      <event_id>9d2e80dd-45d0-4797-be3b-2ed373dc14dd</event_id>
      <title>DynamiTe: Dynamic Termination and Non-termination Proofs</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>17:20</end_time>
      <description>There is growing interest in termination reasoning for non-linear programs and, meanwhile, recent dynamic strategies have shown they are able to infer invariants for such challenging programs. These advances led us to hypothesize that perhaps such dynamic strategies for non-linear invariants could be adapted to learn recurrent sets (for non-termination) and/or ranking functions (for termination).
In this paper, we exploit dynamic analysis and draw termination and non-termination as well as static and dynamic strategies closer together in order to tackle non-linear programs. For termination, our algorithm infers ranking functions from concrete transitive closures, and, for non-termination, the algorithm iteratively collects executions and dynamically learns conditions to refine recurrent sets. Finally, we describe an integrated algorithm that allows these algorithms to mutually inform each other, taking counterexamples from a failed validation in one endeavor and crossing both the static/dynamic and term./non-term.~ lines, to create new execution samples for the other one.
We have implemented these algorithms in a new tool called DynamiTe. For non-linear programs, there are currently no SV-COMP termination benchmarks so we created new sets of 37 terminating and 37 non-terminating programs. Our empirical evaluation shows that we can effectively guess (and sometimes even validate) ranking functions and recurrent sets for programs with non-linear behaviors. Furthermore, we show that counterexamples from one failed validation can be used to generate executions for a dynamic analysis of the opposite property. Although we are focused on non-linear programs, as a point of comparison, we compare DynamiTe’s performance on linear programs with that of the state-of-the-art tool, Ultimate. Although DynamiTe is an order of magnitude slower it is nonetheless somewhat competitive and sometimes finds ranking functions where Ultimate was unable to. Ultimate cannot, however, handle the non-linear programs in our new benchmark suite.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ton Chanh</first_name>
          <last_name>Le</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://chanhle.bitbucket.io/</homepage_url>
          <person_id>tonchanhle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Timos</first_name>
          <last_name>Antonopoulos</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <person_id>timosantonopoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Parisa</first_name>
          <last_name>Fathololumi</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>parisafathololumi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Eric</first_name>
          <last_name>Koskinen</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.stevens.edu/~ejk/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/erickoskinen/3413fc94-5f0f-4855-af65-da2309d2632f/small.jpg</picture_url>
          <person_id>erickoskinen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>ThanhVu</first_name>
          <last_name>Nguyen</last_name>
          <affiliation>University of Nebraska, Lincoln</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cse.unl.edu/~tnguyen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/thanhvunguyen/db337089-c863-4086-ad33-88d7dbfeb025/small.jpg</picture_url>
          <person_id>thanhvunguyen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e96dcbdc-5663-40c0-b4fc-fdc3042423c6</slot_id>
      <event_id>df17fa6a-2bc8-41ee-8c02-85f4a68c1db1</event_id>
      <title>Programming and Reasoning with Partial Observability</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>17:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>17:40</end_time>
      <description>Computer programs are increasingly being deployed in partially-observable environments. A partially observable environment is an environment whose state is not completely visible to the program, but from which the program receives partial information in the form of observations. Developers typically deal with partial observability by writing a state estimator that, given observations, attempts to deduce the hidden state of the environment. In safety-critical domains, to formally verify safety properties developers may write an environment model. The model captures the relationship between observations and hidden states and is used to prove the software correct.
In this paper, we present a new methodology for writing and verifying programs in partially observable environments. We present belief programming, a programming methodology where developers write an environment model that the program runtime automatically uses to perform state estimation. A belief program dynamically updates and queries a belief state that captures the possible states the environment could be in. To enable verification, we present epistemic Hoare logic that reasons about the possible belief states of a belief program the same way that classical Hoare logic reasons about the possible states of a program. We develop these concepts by defining a semantics and a program logic for a simple core language called BLIMP. In a case study, we show how belief programming could be used to write and verify a controller for the Mars Polar Lander in BLIMP.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Atkinson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>ericatkinson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology.
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems.
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fa780211-58c4-4eca-9a78-439375c966a2</slot_id>
      <event_id>c46ee935-d61f-4ade-a84a-9db9d88c737e</event_id>
      <title>Featherweight Go</title>
      <room>Online | SPLASH</room>
      <date>2020/11/17</date>
      <start_time>18:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>18:20</end_time>
      <description>We describe a design for generics in Go inspired by previous work on Featherweight Java by Igarashi, Pierce, and Wadler. Whereas subtyping in Java is nominal, in Go it is structural, and whereas generics in Java are defined via erasure, in Go we use monomorphisation. Although monomorphisation is widely used, we are one of the first to formalise it. Our design also supports a solution to The Expression Problem.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Griesemer</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <person_id>robertgriesemer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Raymond</first_name>
          <last_name>Hu</last_name>
          <affiliation>University of Hertfordshire</affiliation>
          <bio>undefined</bio>
          <person_id>raymondhu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Wen</first_name>
          <last_name>Kokke</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wenkokke.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/wenkokke/756e11ff-851e-4355-865b-0b5ce896d4af/small.jpg</picture_url>
          <person_id>wenkokke</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Julien</first_name>
          <last_name>Lange</last_name>
          <affiliation>Royal Holloway, University of London</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.rhul.ac.uk/~jlange</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/julienlange1/7f3ad551-a3e6-46ce-9718-954f3147736b/small.jpg</picture_url>
          <person_id>julienlange1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ian Lance</first_name>
          <last_name>Taylor</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <person_id>ianlancetaylor</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Bernardo</first_name>
          <last_name>Toninho</last_name>
          <affiliation>Universidade Nova de Lisboa and NOVA LINCS</affiliation>
          <bio>I am interested in the application of language-based techniques to the development of more robust and safer concurrent and distributed systems. More specifically, I work within the realm of (substructural) type theory, such as those based on Linear Logic and Session Types, and their applications to concurrent programming. I am also interested in using type and logic-based techniques to verify concurrent programs in real languages such as Go, Rust and Scala.</bio>
          <homepage_url>http://ctp.di.fct.unl.pt/~btoninho/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/bernardotoninho/1125bc54-0549-4ee4-bf19-394d89568c34/small.jpg</picture_url>
          <person_id>bernardotoninho</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Philip</first_name>
          <last_name>Wadler</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>Philip Wadler is Professor of Theoretical Computer Science at the University of Edinburgh. He is an ACM Fellow and a Fellow of the Royal Society of Edinburgh, past chair of ACM SIGPLAN, past holder of a Royal Society-Wolfson Research Merit Fellowship, winner of the SIGPLAN Distinguished Service Award, and a winner of the POPL Most Influential Paper Award. Previously, he worked or studied at Stanford, Xerox Parc, CMU, Oxford, Chalmers, Glasgow, Bell Labs, and Avaya Labs, and visited as a guest professor in Copenhagen, Sydney, and Paris. He has an h-index of 60, with more than 20,000 citations to his work according to Google Scholar. He contributed to the designs of Haskell, Java, and XQuery, and is a co-author of Introduction to Functional Programming (Prentice Hall, 1988), XQuery from the Experts (Addison Wesley, 2004) and Generics and Collections in Java (O’Reilly, 2006). He has delivered invited talks in locations ranging from Aizu to Zurich.</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/wadler/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/philipwadler/55a9683e-908b-4052-9d49-20fb795c74cf/small.jpg</picture_url>
          <person_id>philipwadler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e07e42e5-e07a-4c98-9486-1bc09733092a</subevent_id>
    <title>SPLASH OOPSLA: W-6</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>880b3411-9ab7-495f-9c93-9e571d964bf2</slot_id>
      <title>Session: SPLASH OOPSLA - W-6</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>05:00</start_time>
      <end_time>06:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2f5f7c3e-d7eb-4169-bfeb-f4de31ea32bd</slot_id>
      <event_id>5ded2007-1aa2-4b18-800b-2c660a495cca</event_id>
      <title>CompCertELF: Verified Separate Compilation of C Programs into ELF Object Files</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>06:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>06:20</end_time>
      <description>We present CompCertELF, the first extension to CompCert that supports verified compilation from C programs all the way to a standard binary file format, i.e., the ELF object format. Previous work on Stack-Aware CompCert provides a verified compilation chain from C programs to assembly programs with a realistic machine memory model. We build CompCertELF by modifying and extending this compilation chain with a verified assembler which further transforms assembly programs into ELF object files.
CompCert supports large-scale verification via verified separate compilation: C modules can be written and compiled separately, and then linked together to get a target program that refines the semantics of the program linked from the source modules. However, verified separate compilation in CompCert only works for compilation to assembly programs, not to object files. For the latter, the main difficulty is to bridge the two different views of linking: one for CompCert’s programs that allows arbitrary shuffling of global definitions by linking and the other for ELF object files that treats blocks of encoded definitions as unanalyzable and indivisible units.
We propose a lightweight approach that solves the above problem without any modification to CompCert’s framework for verified separate compilation: by introducing a notion of syntactical equivalence between programs and proving the commutativity between syntactical equivalence and the two different kinds of linking, we are able to transit from the more abstract linking operation in CompCert to the more concrete one for ELF object files. By applying this approach to CompCertELF, we obtain the first compiler that supports verified separate compilation of C programs into ELF object files.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuting</first_name>
          <last_name>Wang</last_name>
          <affiliation>Shanghai Jiao Tong University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jhc.sjtu.edu.cn/~yutingwang/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yutingwang/963979f5-1f61-418e-9435-0abbb408ef37/small.jpg</picture_url>
          <person_id>yutingwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xiangzhe</first_name>
          <last_name>Xu</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <person_id>xiangzhexu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pierre</first_name>
          <last_name>WILKE</last_name>
          <affiliation>CentraleSupelec Rennes</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pwilke.fr/pwilke-en.html</homepage_url>
          <person_id>pierrewilke1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhong</first_name>
          <last_name>Shao</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/shao/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhongshao/18a2973a-020f-46ed-9073-85bd70626116/small.jpg</picture_url>
          <person_id>zhongshao</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6262dca6-b624-4ac2-a735-3aec7b558e96</slot_id>
      <event_id>7d597c02-ff5f-4db1-a3f8-2f251a9ca0a5</event_id>
      <title>Sound Garbage Collection for C Using Pointer Provenance</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>05:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>05:40</end_time>
      <description>Garbage collection (GC) support for unmanaged languages can reduce programming burden in reasoning about liveness of dynamic objects. It also avoids temporal memory safety violations and memory leaks. Sound GC for weakly-typed languages such as C/C++, however, remains an unsolved problem. Current value-based GC solutions examine values of memory locations to discover the pointers, and the objects they point-to. The approach is inherently unsound in the presence of arbitrary type casts and pointer manipulations, which are legal in C/C++. Such language features are regularly used, especially in low-level systems code.
In this paper, we propose Dynamic Pointer Provenance Tracking to realize sound GC. We observe that pointers cannot be created out-of-thin-air, and they must have provenance to at least one valid allocation. Therefore, by tracking pointer provenance from the source (e.g., malloc) through both explicit data-flow and implicit control-flow, our GC has sound and precise information to compute the set of all reachable objects at any program state. We discuss several static analysis optimizations to significantly reduce the overhead of dynamic provenance tracking from nearly 8x to 16%. Pointer provenance based sound GC invocation is also 13% faster and reclaims 6% more memory on average, compared to an unsound value-based GC.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Subarno</first_name>
          <last_name>Banerjee</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.eecs.umich.edu/~subarno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/subarnobanerjee/56075c15-14b6-4177-b624-840d0b02cf22/small.jpg</picture_url>
          <person_id>subarnobanerjee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Devecsery</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>daviddevecsery</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter M.</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Michigan, USA</affiliation>
          <bio>undefined</bio>
          <person_id>petermchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Satish</first_name>
          <last_name>Narayanasamy</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.eecs.umich.edu/~nsatish/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/satishnarayanasamy/cedfbed8-4f1b-40b0-afdd-135766659f94/small.jpg</picture_url>
          <person_id>satishnarayanasamy</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c00e2959-97c4-4755-9428-2dd43b6fd83f</slot_id>
      <event_id>4d0f5a86-a761-438e-b9c1-1c44f16d89f9</event_id>
      <title>Semiring Optimizations: Dynamic Elision of Expressions with Identity and Absorbing Elements</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>05:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>06:00</end_time>
      <description>This paper describes a compiler optimization to eliminates dynamic occurrences of expressions in the format $a = a \oplus b \otimes c$. The operation $\oplus$ must admit an identity element $z$, such that $a \oplus z = a$. Also, $z$ must be the absorbing element of $\otimes$, such that $b \otimes z = z \otimes c = z$. Semirings where $\oplus$ is the additive operator and $\otimes$ is the multiplicative operator meet this contract. This pattern is common in high-performance benchmarks—its canonical representative being the multiply-add operation $a = a + b \times c$. However, several other expressions involving arithmetic and logic operations satisfy the required algebra. We show that the runtime elimination of such assignments can be implemented in a performance-safe way via in-loco profiling. The elimination of dynamic redundancies involving identity and absorbing elements in the LLVM test suite brings an average speedup of 6% (geo-mean) and 19% (arith-mean) over clang -O3. When added onto clang, semiring optimizations approximates it to TACO, a specialized tensor compiler.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guilherme</first_name>
          <last_name>Leobas</last_name>
          <affiliation>Universidade Federal de Minas Gerais</affiliation>
          <bio>undefined</bio>
          <person_id>guilhermeleobas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fernando Magno Quintão</first_name>
          <last_name>Pereira</last_name>
          <affiliation>UFMG</affiliation>
          <bio>Fernando got his Ph.D at UCLA in 2008, under the supervision of Jens Palsberg. He is currently an assistant professor at the Universidade Federal de Minas Gerais, Brazil. His main research interest are in code generation, compiler optimizations and static program analyses.</bio>
          <homepage_url>http://homepages.dcc.ufmg.br/~fernando/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/fernandomagnoquintaopereira/8f86b14f-fbc3-49a4-9f4f-1a8216564d39/small.jpg</picture_url>
          <person_id>fernandomagnoquintaopereira</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fb5f5644-bc1f-4b5f-80fe-d2982ae0d407</slot_id>
      <event_id>1ba9a54b-ae12-41da-8d16-8c37c6ab299d</event_id>
      <title>Programming with a Read-Eval-Synth Loop</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>05:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>05:20</end_time>
      <description>A frequent programming pattern for small tasks, especially expressions, is to repeatedly evaluate the program on an input as its editing progresses. The Read-Eval-Print Loop (REPL) interaction model has been a successful model for this programming pattern. We present the new notion of Read-Eval-Synth Loop (RESL) that extends REPL by providing in-place synthesis on parts of the expression marked by the user. RESL eases programming by synthesizing parts of a required solution. The underlying synthesizer relies on a partial solution from the programmer and a few examples.
RESL hinges on bottom-up synthesis with general predicates and sketching, generalizing programming by example. To make RESL practical, we present a formal framework that extends observational equivalence to non-example specifications.
We show the value of RESL by conducting a controlled within-subjects user-study on 19 programmers from 8 companies, where programmers are asked to solve a small but challenging set of competitive programming problems. We find that programmers using RESL solve these problems with far less need to edit the code themselves and by browsing documentation far less. In addition, they are less likely to leave a task unfinished and more likely to be correct.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roi</first_name>
          <last_name>Gabay</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <person_id>roigabay</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Shachar</first_name>
          <last_name>Itzhaky</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~shachari</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shacharitzhaky/649d5921-4057-4ac3-8fc7-75471ee8527b/small.jpg</picture_url>
          <person_id>shacharitzhaky</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion</affiliation>
          <bio>Eran Yahav is an associate professor at the Computer Science Department, Technion, Israel. Prior to that, he was a research staff member at the IBM T.J. Watson Research Center (2004-2010). He received his Ph.D. from Tel Aviv University (2005) and his B.Sc. from the Technion in 1996. His research interests include program analysis, program synthesis and program verification. Eran is a recipient of the prestigious Alon Fellowship for Outstanding Young Researchers, the Andre Deloro Career Advancement Chair in Engineering, the ERC Consolidator Grant as well as multiple best paper awards at various conferences.</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
          <person_id>eranyahav</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>23f2e99f-8c5e-478e-b2cb-27de9e275008</subevent_id>
    <title>SPLASH OOPSLA: T-5</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>3a1528a0-9458-49d9-b097-4bbfd79fa0eb</slot_id>
      <title>Session: SPLASH OOPSLA - T-5</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>47fbf813-ea4a-4456-8e48-84bea0c9c182</slot_id>
      <event_id>52f9bfff-ac06-47f4-98ba-4a5085ecbf7b</event_id>
      <title>Fuzzing Channel-based Concurrency Runtimes Using Types and Effects</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>04:00</end_time>
      <description>Modern programming languages support concurrent programming based on channels and processes. Channels enable synchronous and asynchronous message-passing between independent light-weight processes making it easy to express common concurrency patterns.
The implementation of channels and processes in compilers and language runtimes is a difficult task that relies heavily on traditional and error-prone low-level concurrency primitives, raising concerns about correctness and reliability.
In this paper, we present a program generation technique to test such programming language implementations. We define a type and effect system for programs that communicate over channels and where every execution is guaranteed to eventually terminate. We can automatically generate and run such programs, and if a program fails to terminate, we have found a bug in the programming language implementation.
We implement such an automatic program generator and apply it to Go, Kotlin, Crystal, and Flix. We find two new bugs in Flix, and reproduce two bugs; one in Crystal and one in Kotlin.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Quentin</first_name>
          <last_name>Stiévenart</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/~qstieven</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/quentinstievenart/7d195a5f-4ea9-4d26-a55f-2b8d1c5853b8/small.jpg</picture_url>
          <person_id>quentinstievenart</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4fbe8ed9-8e8f-4e41-a602-f2bdeea416f7</slot_id>
      <event_id>b7403f22-9ce1-4712-b204-3d56213b53b9</event_id>
      <title>Regex Matching with Counting-Set Automata</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>04:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>04:20</end_time>
      <description>We propose a solution to the problem of efficient matching regular expressions (regexes) with bounded repetition, such as $\mathtt{(ab){1,100}}$, using deterministic automata. For this, we introduce novel \emph{counting set automata (CsAs)}, automata with registers that can hold sets of bounded integers and can be manipulated by a limited portfolio of constant-time operations. We present an algorithm that compiles a large sub-class of regexes to deterministic CsAs. This includes (1) a novel Antimirov-style translation of regexes with counting to \emph{counting automata (CAs)}, nondeterministic automata with bounded counters, and (2) our main technical contribution, a determinization of CAs that outputs CsAs. The main advantage of this workflow is that the size of the produced CsAs does not depend on the repetition bounds used in the regex (while the size of the DFA is exponential to them). Our experimental results confirm that deterministic CsAs produced from practical regexes with repetition are indeed vastly smaller than the corresponding DFAs. More importantly, our prototype matcher based on CsA simulation handles practical regexes with repetition regardless of sizes of counter bounds. It easily copes with regexes with repetition where state-of-the-art matchers struggle.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lukáš</first_name>
          <last_name>Holík</last_name>
          <affiliation>Brno University of Technology, Czechia</affiliation>
          <bio>undefined</bio>
          <person_id>lukasholik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondrej</first_name>
          <last_name>Lengal</last_name>
          <affiliation>Brno University of Technology </affiliation>
          <bio>Ph.D. (2015) Brno University of Technology</bio>
          <homepage_url>http://www.fit.vutbr.cz/~lengal</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlengal/3f99d935-777e-4b43-9494-5cfc0fe8894b/small.jpg</picture_url>
          <person_id>ondrejlengal</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Olli</first_name>
          <last_name>Saarikivi</last_name>
          <affiliation>MSR Redmond</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/ollisaarikivi2/3e6d3eb8-2ea9-456c-9c3d-76fe37bd855c/small.jpg</picture_url>
          <person_id>ollisaarikivi2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lenka</first_name>
          <last_name>Turonova</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>lenkatoronova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Margus</first_name>
          <last_name>Veanes</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/margusveanes/a5174253-0401-46f7-aff1-e92a3a3ace77/small.jpg</picture_url>
          <person_id>margusveanes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tomas</first_name>
          <last_name>Vojnar</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fit.vutbr.cz/~vojnar</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomasvojnar/6b1ea9ee-acf7-413d-be4d-431c460af426/small.jpg</picture_url>
          <person_id>tomasvojnar</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8292c782-368f-4b84-8a0d-0b13e3a9dde5</slot_id>
      <event_id>d0b39515-659e-4855-a1b2-516ee32b0539</event_id>
      <title>Knowing When to Ask: Sound Scheduling of Name Resolution in Type Checkers Derived from Declarative Specifications</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>03:40</end_time>
      <description>There is a large gap between the specification of type systems and the implementation of their type checkers, which impedes reasoning about the soundness of the type checker with respect to the specification. A vision to close this gap involves automatically obtaining type checkers from declarative programming language specifications. This moves the burden of proving correctness from a case-by-case basis for concrete languages, to a single correctness proof for the specification language.
This vision is obstructed by an aspect common to all programming languages: name resolution. Naming and scoping are pervasive and complex aspects of the static semantics of programming languages. Implementations of type checkers for languages with name binding features such as modules, imports, classes, and inheritance interleave collection of binding information (i.e., declarations, scoping structure, and imports) and querying that information. This requires scheduling those two aspects in such a way that query answers are stable—i.e., they are computed only after all relevant binding structure has been collected. Type checkers for concrete languages accomplish stability using language-specific knowledge about the type system.
In this paper we give a language independent characterization of necessary and sufficient conditions to guarantee stability of name and type queries during type checking in terms of critical edges in an incomplete scope graph. We use critical edges to give a formal small-step operational semantics to a declarative specification language for type systems, delaying queries that may depend on missing information. This yields type checkers for the specified languages that are safe-by-construction—i.e., they safely schedule queries and only accept programs that are name- and type-correct according to the declarative language specification. We implement this approach, and evaluate it against specifications of a small module and record language, as well as subsets of Java and Scala.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Arjen</first_name>
          <last_name>Rouvoet</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ajrouvoet.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjenrouvoet/72c0e303-43d5-4252-a170-5b61600fac4d/small.jpg</picture_url>
          <person_id>arjenrouvoet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hendrik</first_name>
          <last_name>van Antwerpen</last_name>
          <affiliation>TU Delft</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hendrik.van-antwerpen.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hendrikvanantwerpen/2d3f530b-7183-483e-b3b6-80dd4159a4bd/small.jpg</picture_url>
          <person_id>hendrikvanantwerpen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Casper</first_name>
          <last_name>Bach Poulsen</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://casperbp.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/casperbachpoulsen/2cddd6a9-d920-4f73-9fcf-f4d9462eb0e3/small.jpg</picture_url>
          <person_id>casperbachpoulsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Robbert</first_name>
          <last_name>Krebbers</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://robbertkrebbers.nl</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/robbertkrebbers/7c0562b5-da08-4f27-aa28-918e54dcaf3d/small.jpg</picture_url>
          <person_id>robbertkrebbers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science at Delft University of Technology. He received a master’s and doctorate in computer science from the University of Amsterdam in 1993 and 1997, respectively. Previously he served as postdoc at the Oregon Graduate Institute, as Assistant Professor at Utrecht University, and as Associate Professor at TU Delft.
His research interests include programming languages, software language engineering, domain-specific programming languages, program transformation, syntax definition, and parsing. With his students he has designed and implemented the Spoofax language workbench, as well as many domain-specific languages, including DSLs for syntax definition (SDF2, SDF3), program transformation (Stratego), static semantics (NaBL, Statix), dynamic semantics (DynSem), software deployment (Nix), web application development (WebDSL), and mobile phone applications (mobl). In the language designer’s workbench project he is pursuing high-level declarative language definition that serves for language implementation and verification.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ed682cc6-49fc-44b8-a0b8-f0ae97c8a189</slot_id>
      <event_id>5566f7eb-c8ea-4651-9ed7-30715f447f33</event_id>
      <title>Actor Concurrency Bugs: A Comprehensive Study on Symptoms, Root Causes, API Usages, and Differences</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>03:20</end_time>
      <description>Actor concurrency is becoming increasingly important in the development of real-world software systems. Although actor concurrency may be less susceptible to some multithreaded concurrency bugs, such as low-level data races and deadlocks, it comes with its own bugs that may be different. However, the fundamental characteristics of actor concurrency bugs, including their symptoms, root causes, API usages, examples, and differences when they come from different sources are still largely unknown. Actor software development can significantly benefit from a comprehensive qualitative and quantitative understanding of these characteristics, which is the focus of this work, to foster better API documentations, development practices, testing, debugging, repairing, and verification frameworks. To conduct this study, we take the following major steps. First, we construct a set of 184 real-world Stackoverflow and Github actor bugs by manual analysis of 3,924 Stackoverflow questions, answers, and comments and 3,315 Github commits, messages, original and modified code snippets, issues, and pull requests. Second, we manually study these actor bugs and their fixes to understand and classify their symptoms, root causes, and API usages. Third, we study the differences between the commonalities and distributions of symptoms, root causes, and API usages of Stackoverflow and Github actor bugs. Fourth, we discuss real-world examples of bugs with these root causes and symptoms. Finally, we investigate the relation of our findings with the findings of previous work and discuss the implications of our findings using the anecdotal evidence of our actor bug examples. A few findings of our study are: (1) Symptoms of actor bugs can be classified into 5 categories with Error and Incorrect Exceptions being the most and least common symptoms (2) Root causes of actor bugs can be classified into 10 categories with Logic and Untyped Communication being the most and least common root causes (3) A small number of API packages are responsible for most of API usages by actor bugs (4) Stackoverflow and Github actors can differ significantly in the commonality and distribution of symptoms, root causes, and API usages (5) Actor developers may need help not only with complex, unknown, or semantic bugs in the development code but also with simple, well-known, well-documented, or syntactic bugs in the test code. While some of our findings are in agreement with the findings of the previous work, others are in sharp contrast.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mehdi</first_name>
          <last_name>Bagherzadeh</last_name>
          <affiliation>Oakland University</affiliation>
          <bio>Assistant Professor, Department of Computer Science and Engineering</bio>
          <homepage_url>https://mbagherz.bitbucket.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mehdibagherzadeh/95dc6f53-51a0-4bf1-b822-7bbe8c4d223a/small.jpg</picture_url>
          <person_id>mehdibagherzadeh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nicholas</first_name>
          <last_name>Fireman</last_name>
          <affiliation>Oakland University</affiliation>
          <bio>undefined</bio>
          <person_id>nicholasfireman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anas</first_name>
          <last_name>Shawesh</last_name>
          <affiliation>Oakland University</affiliation>
          <bio>undefined</bio>
          <person_id>anasshawesh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Raffi</first_name>
          <last_name>Khatchadourian</last_name>
          <affiliation>City University of New York (CUNY) Hunter College</affiliation>
          <bio>I am an Assistant Professor in the Department of Computer Science at Hunter College and the Graduate Center of the City University of New York (CUNY). My research is centered on techniques for automated software evolution, particularly those related to automated refactoring and source code recommendation systems. My goal is to ease the burden associated with correctly and efficiently evolving large and complex software by providing automated tools that can be easily used by developers. I am also interested in the automated analysis of Object-Oriented and Aspect-Oriented programs.
I received my MS and Ph.D. degrees in Computer Science from Ohio State University and my BS degree in Computer Science from Monmouth University in New Jersey. Prior to joining CUNY, I was a Software Engineer at Apple, Inc. in Cupertino, California, where I worked on Digital Rights Management (DRM) for iTunes, iBooks, and the App store. I also developed distributed software that tested various features of iPhones, iPads, and iPods. You may also find more information about me by visiting my CUNY Academic Commons profile, my vita, GitHub, and my blog (you can subscribe for updates here).</bio>
          <homepage_url>http://cs.hunter.cuny.edu/~Raffi.Khatchadourian99</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/raffikhatchadourian/5c884f46-e4aa-4dc5-b581-2e37f77d320a/small.jpg</picture_url>
          <person_id>raffikhatchadourian</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>21b4a9a4-f224-4bd8-b5ba-0905f46a83cb</subevent_id>
    <title>SPLASH OOPSLA: T-2</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>f470986b-2a5a-40f0-bd9b-2f2df1ff7e96</slot_id>
      <title>Session: SPLASH OOPSLA - T-2</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>21:00</start_time>
      <end_time>22:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>809f470f-4e1d-4f3b-8fc2-11fffe24e5be</slot_id>
      <event_id>93f41bfd-9988-4002-8de8-22ce8bf00c55</event_id>
      <title>A Large-Scale Longitudinal Study of Flaky Tests</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>21:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>21:40</end_time>
      <description>Flaky tests are tests that can non-deterministically pass or fail for the same code version. These tests undermine regression testing efficiency, because developers cannot easily identify whether a test fails due to their recent changes or due to flakiness. Ideally, one would detect flaky tests right when flakiness is introduced, so that developers can then immediately remove the flakiness. Some software organizations, e.g., Mozilla and Netflix, run some tools—detectors—to detect flaky tests as soon as possible. However, detecting flaky tests is costly due to their inherent non-determinism, so even state-of-the-art detectors are often impractical to be used on all tests for each project change. To combat the high cost of applying detectors, these organizations typically run a detector solely on newly added or directly modified tests, i.e., not on unmodified tests or when other changes occur (including changes to the test suite, the code under test, and library dependencies). However, it is unclear how many flaky tests can be detected or missed by applying detectors in only these limited circumstances.
To better understand this problem, we conduct a large-scale longitudinal study of flaky tests to determine when flaky tests become flaky and what changes cause them to become flaky. We apply two state-of-theart detectors to 55 Java projects, identifying a total of 245 flaky tests that can be compiled and run in the code version where each test was added. We find that 75% of flaky tests (184 out of 245) are flaky when added, indicating substantial potential value for developers to run detectors specifically on newly added tests. However, running detectors solely on newly added tests would still miss detecting 25% of flaky tests. The percentage of flaky tests that can be detected does increase to 85% when detectors are run on newly added or directly modified tests. The remaining 15% of flaky tests become flaky due to other changes and can be detected only when detectors are always applied to all tests. Our study is the first to empirically evaluate when tests become flaky and to recommend guidelines for applying detectors in the future.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wing</first_name>
          <last_name>Lam</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://winglam2.web.engr.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/winglam/4052f462-6ac0-4252-8c59-92a77a7c33dc/small.jpg</picture_url>
          <person_id>winglam</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stefan</first_name>
          <last_name>Winter</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>I am a postdoctoral researcher at TU Darmstadt in Germany, from where I previously obtained a Ph.D. in computer science. My research interests span a variety of topics related to the design and analysis of dependable software systems from operating system design to system-level test efficiency.</bio>
          <homepage_url>http://www.stefan-winter.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stefanwinter/b2ba53f2-c875-4cd6-b938-2152649c47bb/small.jpg</picture_url>
          <person_id>stefanwinter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anjiang</first_name>
          <last_name>Wei</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/anjiangwei/680e5627-484e-433a-be11-7fcc497f7075/small.jpg</picture_url>
          <person_id>anjiangwei</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tao</first_name>
          <last_name>Xie</last_name>
          <affiliation>Peking University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://taoxiease.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/taoxie/14ae8022-1dd6-4455-a54f-157c86bc406d/small.jpg</picture_url>
          <person_id>taoxie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Darko</first_name>
          <last_name>Marinov</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>Please see my website</bio>
          <homepage_url>http://mir.cs.illinois.edu/marinov</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/darkomarinov/715fd20e-8e93-48b7-8f26-4e80ed2aeab5/small.jpg</picture_url>
          <person_id>darkomarinov</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Bell</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Jon is an Assistant Professor directing research in Software Engineering and Software Systems at Northeastern University. His research makes it easier for developers to create reliable and secure software by improving software testing and program analysis. Jon’s work on accelerating software testing has been recognized with an ACM SIGSOFT Distinguished Paper Award (ICSE ’14 – Unit Test Virtualization with VMVM), and was the basis for an industrial collaboration with Electric Cloud. His program analysis research has resulted in several widely adopted runtime systems for the JVM, including the Phosphor taint tracking system (OOPSLA ’14) and CROCHET checkpoint/rollback tool (ECOOP ’18). His research has been funded by the NSA and the NSF, and he is the recipient of the NSF CAREER award. At George Mason, Jon taught courses in distributed systems, web development, and program analysis. His teaching at GMU has been recognized with a departmental award. Jon serves on a variety of program committees and was recently co-chair of the PLDI 2020 Artifact Evaluation Committee. As part of his efforts to broaden the participation of underrepresented groups in computing, Jon co-organizes the PL/SE mentoring workshop at SPLASH (in 2017, 2018, 2019 and 2020).</bio>
          <homepage_url>http://jonbell.net/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanbell/1ef3641d-0ed6-4021-aab6-b13b53962e3d/small.jpg</picture_url>
          <person_id>jonathanbell</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ccf74489-f632-41f2-8183-7028eebbcebb</slot_id>
      <event_id>5d1aeb28-75c6-4924-8e7a-5cbbe33cfacd</event_id>
      <title>Formulog: Datalog for SMT-based Static Analysis</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>21:20</end_time>
      <description>Satisfiability modulo theories (SMT) solving has become a critical part of many static analyses, including symbolic execution, refinement type checking, and model checking. We propose Formulog, a domain-specific language that makes it possible to write a range of SMT-based static analyses in a way that is both close to their formal specifications and amenable to high-level optimizations and efficient evaluation.
Formulog extends the logic programming language Datalog with a first-order functional language and mechanisms for representing and reasoning about SMT formulas; a novel type system supports the construction of expressive formulas, while ensuring that neither normal evaluation nor SMT solving goes wrong. Our case studies demonstrate that a range of SMT-based analyses can naturally and concisely be encoded in Formulog, and that — thanks to this encoding — high-level Datalog-style optimizations can be automatically and advantageously applied to these analyses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Bembenek</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>Aaron Bembenek is currently a computer science PhD candidate at Harvard University working under Stephen Chong. He previously earned an undergraduate degree in classics from Princeton University.</bio>
          <homepage_url>http://people.seas.harvard.edu/~bembenek/index.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aaronbembenek/def526d3-8049-43ee-a891-2437ec903da6/small.jpg</picture_url>
          <person_id>aaronbembenek</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Greenberg</last_name>
          <affiliation>Pomona College</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.pomona.edu/~michael/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
          <person_id>michaelgreenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chong</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>Stephen Chong is a Gordon McKay Professor of Computer Science in the Harvard John A. Paulson School of Engineering and Applied Sciences. Steve’s research focuses on programming languages, information security, and the intersection of these two areas. He is the recipient of an NSF CAREER award, an AFOSR Young Investigator award, and a Sloan Research Fellowship. He received a PhD from Cornell University, and a bachelor’s degree from Victoria University of Wellington, New Zealand.</bio>
          <homepage_url>https://people.seas.harvard.edu/~chong/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stephenchong/91e43651-bcd6-40dc-b231-4c92711b0e95/small.jpg</picture_url>
          <person_id>stephenchong</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e32b7341-b29d-46a0-8e72-be60dbd55ba8</slot_id>
      <event_id>b5281650-dcac-4963-b682-1fed545a5e0a</event_id>
      <title>WATCHER: In-Situ Failure Diagnosis</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>22:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>22:20</end_time>
      <description>Diagnosing in-production software failures is important but notoriously challenging. Existing work either requires extensive manual effort, imposes a serious privacy concern, or cannot report sufficient information for bug fixes.
This paper presents a novel diagnosis system, named WATCHER, that can pinpoint root causes of program failures within the failing process (“in-situ”), eliminating the privacy concern. It combines identical record-and-replay, binary analysis, dynamic analysis, and hardware support together to perform the diagnosis without human involvement. It further proposes two optimizations to reduce the diagnosis time and diagnose failures with control flow hijacks. WATCHER can be easily deployed, without requiring custom hardware, operating system, program modification, or recompilation. We evaluate WATCHER with 24 program failures in real-world deployed software, including large-scale applications, such as Memcached, SQLite, and OpenJPEG. Experimental results show that WATCHER can accurately identify the real root causes in only a few seconds.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hongyu</first_name>
          <last_name>Liu</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://liuhycs.github.io/</homepage_url>
          <person_id>hongyuliu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Silvestro</last_name>
          <affiliation>University of Texas at San Antonio, USA</affiliation>
          <bio>undefined</bio>
          <person_id>samsilvestro</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xiangyu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/xyzhang/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xiangyuzhang/57d4d88e-c02e-41fc-836c-0e22cdf6b3b8/small.jpg</picture_url>
          <person_id>xiangyuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jian</first_name>
          <last_name>Huang</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jianh.web.engr.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jianhuang/f6e25055-585a-40e2-89ae-b28280a62eab/small.jpg</picture_url>
          <person_id>jianhuang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Tongping</first_name>
          <last_name>Liu</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>undefined</bio>
          <person_id>tongpingliu1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f1d9ff58-07e3-4db2-a961-80e7f3cfb9f4</slot_id>
      <event_id>bf240e74-90f0-407b-8552-d2d71c9c86e4</event_id>
      <title>Handling Bidirectional Control Flow</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>21:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>22:00</end_time>
      <description>Pressed by the difficulty of writing asynchronous, event-driven code, it has become popular for mainstream languages to build in support for a variety of advanced control-flow features. Meanwhile recent, experimental language designs have suggested effect handlers as a unifying solution to programmer-defined control effects, subsuming exceptions, generators, and async–await. However, despite these trends, complex control flow—in particular, control flow that exhibits a bidirectional pattern—remains challenging to manage.
We introduce bidirectional algebraic effects, a new programming abstraction that supports bidirectional control transfer in a more natural way. Handlers of bidirectional effects can raise further effects to transfer control back to the site where the initiating effect was raised, and can use themselves to handle their own effects. We present applications of this expressive power, which falls out naturally as we push toward the unification of effectful programming with object-oriented programming. We pin down the mechanism and the unification formally using a core language that makes generalizations to effect operations and effect handlers.
The usual propagation semantics of control effects such as exceptions conflicts with modular reasoning in the presence of effect polymorphism—it breaks parametricity. Bidirectionality exacerbates the problem. Hence, we set out to show the core language, which builds on the existing tunneling semantics for algebraic effects, is not only type-safe (no effects go unhandled), but also abstraction-safe (no effects are accidentally handled). We devise a step-indexed logical-relations model, and construct its parametricity and soundness proofs. These core results are fully mechanized in Coq. While a full-featured compiler is left to future work, experiments show that as a first-class language feature, bidirectional handlers can be implemented efficiently.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yizhou</first_name>
          <last_name>Zhang</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.uwaterloo.ca/~yizhou</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yizhouzhang/0629b9fd-c9c0-44e9-ac08-6760a0b35950/small.jpg</picture_url>
          <person_id>yizhouzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guido</first_name>
          <last_name>Salvaneschi</last_name>
          <affiliation>University of St. Gallen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.guidosalvaneschi.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guidosalvaneschi/6f1373d5-57c6-4d68-b6c3-c0a679ee24ed/small.jpg</picture_url>
          <person_id>guidosalvaneschi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Myers</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>Andrew Myers is a Professor in the Department of Computer Science at Cornell University in Ithaca, NY. His research interests include programming languages, computer security, and distributed and persistent programming systems. Myers is an ACM Fellow. He has received awards for papers appearing in POPL’99, SOSP’01, SOSP’07, CIDR’13, PLDI’13, and PLDI’15. Myers is currently the Editor-in-Chief for ACM Transactions on Programming Languages and Systems (TOPLAS). He has also served as program chair or co-chair for a few conferences: ACM POPL 2018, ACM CCS 2016, POST 2014, IEEE CSF 2010, and IEEE S&amp;amp;P 2009.</bio>
          <homepage_url>http://www.cs.cornell.edu/andru</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andrewmyers/88baadd2-5ed8-4687-b205-3cbbe8b1a848/small.jpg</picture_url>
          <person_id>andrewmyers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>20cc3f73-2788-4cf8-9efa-2cd9aa9c8f78</subevent_id>
    <title>SPLASH OOPSLA: F-2A</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>a75fbdcb-f5fd-4cdf-86c1-fb613c03d565</slot_id>
      <title>Session: SPLASH OOPSLA - F-2A</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>21:00</start_time>
      <end_time>22:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>05ca0578-2be0-4f8b-9f11-8d3258c5945f</slot_id>
      <event_id>fc13e2b3-604c-4954-9997-35f41f87ef1f</event_id>
      <title>Towards A Unified Proof Framework for Automated Fixpoint Reasoning Using Matching Logic</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>22:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>22:20</end_time>
      <description>Automation of fixpoint reasoning has been extensively studied for various mathematical structures, logical formalisms, and computational domains, resulting in specialized fixpoint provers for heaps, for streams, for term algebras, for temporal properties, for program correctness, and for many other formal systems and inductive and coinductive properties. However, in spite of great theoretical and practical interest, there is no unified framework for automated fixpoint reasoning. Although several attempts have been made, there is no evidence that such a unified framework is possible, or practical. In this paper, we propose a candidate based on matching logic, a formalism that is recently shown to theoretically unify the above mentioned formal systems. Unfortunately, the Knaster-Tarski proof rule of matching logic, which enables inductive reasoning, is not syntax-driven. Worse, it can be applied at any step during a proof, making automation seem hopeless. Inspired by recent advances in automation of inductive proofs in separation logic, we propose an alternative proof system for matching logic, which is amenable for automation. We then discuss our implementation of it, which although not superior to specialized state-of-the-art automated provers for specific domains, we believe brings some evidence and hope that a unified framework for automated reasoning is not out of reach.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiaohong</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsl.cs.illinois.edu/~xchen</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xiaohongchen1/e982c014-9fda-495c-93d6-b5fdc8158320/small.jpg</picture_url>
          <person_id>xiaohongchen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thai</first_name>
          <last_name>Trinh</last_name>
          <affiliation>Advanced Digital Sciences Center, Illinois at Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>thaitrinh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nishant</first_name>
          <last_name>Rodrigues</last_name>
          <affiliation>University of Illinois Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>nishantrodrigues</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lucas</first_name>
          <last_name>Peña</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>lucaspena</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Grigore</first_name>
          <last_name>Rosu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsl.cs.illinois.edu/index.php/Grigore_Rosu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/grigorerosu/5d2acd04-bb45-46a0-a743-4826f3d8086c/small.jpg</picture_url>
          <person_id>grigorerosu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>95386c15-d7dc-413f-88c9-4986f90d665d</slot_id>
      <event_id>7907d076-ba43-4ab2-87fb-41a41db9c572</event_id>
      <title>Resolution as Intersection Subtyping via Modus Ponens</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>21:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>21:40</end_time>
      <description>Resolution and subtyping are two common mechanisms in programming languages. Resolution is used by features such as type classes or Scala-style implicits to synthesize values automatically from contextual type information. Subtyping is commonly used to automatically convert the type of a value into another compatible type. So far the two mechanisms have been considered independently of each other. This paper shows that, with a small extension, subtyping with intersection types can subsume resolution. This has three main consequences. Firstly, resolution does not need to be implemented as a separate mechanism. Secondly, the interaction between resolution and subtyping becomes apparent. Finally, the integration of resolution into subtyping enables first-class (implicit) environments. The extension that recovers the power of resolution via subtyping is the modus ponens rule of propositional logic. While it is easily added to declarative subtyping, significant care needs to be taken to retain desirable properties, such as transitivity and decidability of algorithmic subtyping, and coherence. To materialize these ideas we develop λ_MP, a calculus that extends a previous calculus with disjoint intersection types, and develop its metatheory in the Coq theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Klara</first_name>
          <last_name>Mardirosian</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/klaramardirosian/15cf04a1-de90-4f6d-b88d-cd1a230da0e4/small.jpg</picture_url>
          <person_id>klaramardirosian</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>The University of Hong Kong, Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Georgios</first_name>
          <last_name>Karachalias</last_name>
          <affiliation>Tweag I/O</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://gkaracha.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/georgekarachalias/cb10a8f5-6b72-4883-aef0-c9978070378a/small.jpg</picture_url>
          <person_id>georgekarachalias</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a83b7817-d541-46f7-a076-24d71e3f8948</slot_id>
      <event_id>0cd262dc-3c5c-498c-814d-952a4abeecf6</event_id>
      <title>Guided Linking: Dynamic Linking Without the Costs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>21:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>22:00</end_time>
      <description>Dynamic linking is extremely common in modern software systems, thanks to the flexibility and space savings it offers. However, this flexibility comes at a cost: every library call has an extra layer of indirection, and it’s impossible to perform interprocedural optimizations that involve calls to a dynamic library. The basic problem is that the run-time behavior of the dynamic linker can’t be predicted at compile time, so the compiler can make no assumptions about how external calls will behave.
This paper introduces guided linking, a technique for optimizing dynamically linked software when some information about the dynamic linker’s behavior is known in advance. The developer provides an arbitrary set of programs, libraries, and plugins to our tool, along with constraints that limit the possible dynamic linking behavior of the software. Given a software set and a list of constraints, our tool takes advantage of the constraints to optimize the software for speed and size. For example, the “no dynamic redefinitions” constraint can be applied to a function when the developer knows the function will never be unexpectedly overridden with a different definition at run time; this constraint allows dynamic references between libraries in the set to be resolved to static references, which can then be optimized with standard link-time optimizations. As an additional optimization, we deduplicate identical functions that appear anywhere in the software set.
By applying guided linking to a dynamically linked distribution of Clang and LLVM, and using the constraint that no other software will use the LLVM libraries, we can increase speed by 6% and reduce file size by 11%. If we relax the constraint to allow other software to use the LLVM libraries, we can still increase speed by 5.5% and reduce file size by 3%. If we apply guided linking to the Python interpreter and a set of loadable Python modules, applying the constraint that no other programs or modules will be used, we can increase speed by an average of 6.6%. If we use guided linking to combine 11 different versions of the Boost library, applying minimal constraints, we can reduce the total library size by 57%.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sean</first_name>
          <last_name>Bartell</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>seanbartell</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Will</first_name>
          <last_name>Dietz</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wdtz.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/willdietz/f5b6948e-d200-44b1-ba05-8d21549414f8/small.jpg</picture_url>
          <person_id>willdietz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Vikram S.</first_name>
          <last_name>Adve</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>Vikram Adve is the Donald B. Gillies Professor of Computer Science at the University of Illinois at Urbana-Champaign and a Professor in Electrical and Computer Engineering. He is a Co-founder and Co-Director of the Center for Digital Agriculture and leads AIFARMS, a $20M National Artificial Intelligence Research Institute funded by NIFA and NSF. Adve’s research interests lie in developing and using compiler techniques to improve the performance, programmability and reliability of computer systems. Adve and his Ph.D. student, Chris Lattner, co-designed the LLVM Compiler Infrastructure, which enables a novel approach to “lifelong compilation” of programs in a wide range of general-purpose programming languages. For example, most mobile apps for the iPhone, iPad, Apple Watch and Apple TV are shipped by developers to Apple in the LLVM compiler representation called “LLVM bitcode” and then compiled and specialized for the various end-user devices. LLVM is widely used in industry today, ranging from mobile devices (e.g., iOS and Android) to supercomputers (e.g., at NVIDIA, Cray, IBM and Intel) to data centers (e.g., at Google). Adve, Lattner and Evan Cheng received the ACM Software System Award in 2012 for co-developing LLVM. Adve has won a ten-year-retrospective Most Influential Paper award at CGO 2004, and distinguished paper awards at several conferences including PLDI 2005, SOSP 2007 and ICSE 2011. He has served as the Associate Editor for the ACM Transactions on Programming Languages and Systems, and co-chaired the Program Committees for ASPLOS 2010, VEE 2008, and LCPC 2007. One of Adve’s Ph.D. students, Robert Bocchino, won the 2010 ACM SIGPLAN Outstanding Dissertation Award and another student, John Criswell, won Honorable Mentions for both the 2014 ACM SIGOPS Dissertation Award and the 2014 ACM Doctoral Dissertation Award. Adve is a Fellow of the ACM and was named a University Scholar at the University of Illinois in 2015. He served as Interim Head of the Computer Science Department from 2017 to 2019.</bio>
          <homepage_url>http://vikram.cs.illinois.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vikramadve/a99a9248-20e3-4738-9200-173c353c5fcb/small.jpg</picture_url>
          <person_id>vikramadve</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b45b208d-b6de-42ab-9545-9822f4d06f25</slot_id>
      <event_id>834d57b9-2ff5-4c19-86bb-2d5b6188d63e</event_id>
      <title>A Sparse Iteration Space Transformation Framework for Sparse Tensor Algebra</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>21:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>21:20</end_time>
      <description>We address the problem of optimizing sparse tensor algebra in a compiler and show how to define standard loop transformations—split, collapse, and reorder—on sparse iteration spaces. The key idea is to track the transformation functions that map the original iteration space to derived iteration spaces. These functions are needed by the code generator to emit code that maps coordinates between iteration spaces at runtime, since the coordinates in the sparse data structures remain in the original iteration space. We further demonstrate that derived iteration spaces can tile both the universe of coordinates and the subset of nonzero coordinates: the former is analogous to tiling dense iteration spaces, while the latter tiles sparse iteration spaces into statically load-balanced blocks of nonzeros. Tiling the space of nonzeros lets the generated code efficiently exploit heterogeneous compute resources such as threads, vector units, and GPUs.
We implement these concepts by extending the sparse iteration theory implementation in the TACO system. The associated scheduling API can be used by performance engineers or it can be the target of an automatic scheduling system. We outline one heuristic autoscheduling system, but other systems are possible. Using the scheduling API, we show how to optimize mixed sparse-dense tensor algebra expressions on CPUs and GPUs. Our results show that the sparse transformations are sufficient to generate code with competitive performance to hand-optimized implementations from the literature, while generalizing to all of the tensor algebra.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ryan</first_name>
          <last_name>Senanayake</last_name>
          <affiliation>Reservoir Labs</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.RSenApps.com</homepage_url>
          <person_id>ryansenanayake</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Changwan</first_name>
          <last_name>Hong</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>changwanhong2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziheng</first_name>
          <last_name>Wang</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>zihengwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Amalee</first_name>
          <last_name>Wilson</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>amaleewilson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chou</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/s3chou</homepage_url>
          <person_id>stephenchou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Shoaib</first_name>
          <last_name>Kamil</last_name>
          <affiliation>Adobe</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shoaibkamil/2bc60aee-bda5-437e-9e74-e00f5a55c9ef/small.jpg</picture_url>
          <person_id>shoaibkamil</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Saman</first_name>
          <last_name>Amarasinghe</last_name>
          <affiliation>MIT</affiliation>
          <bio>Prof. Saman Amarasinghe leads the Commit compiler research group in MIT’s Computer Science &amp;amp; Artificial Intelligence Laboratory (CSAIL), which focuses on programming languages and compilers that maximize application performance on modern computing platforms. He is a world leader in the field of high-performance domain-specific languages. Prof. Amarasinghe’s group developed the Halide, TACO, Simit, StreamIt, StreamJIT, PetaBricks, MILK, Cimple, and GraphIt domain-specific languages and compilers, all of which combine language design and sophisticated compilation techniques to deliver unprecedented performance for targeted application domains such as image processing, stream computations, and graph analytics. Dr. Amarasinghe also pioneered the application of machine learning for compiler optimizations, from Meta optimization in 2003 to OpenTuner extendable autotuner today. With professor Anant Agarwal, he co-led the Raw architecture project, which did pioneering work on scalable multicores. Prof. Amarasinghe’s entrepreneurship activities include founding Determina, Inc. (acquired by VMWare) based on computer security research pioneered in his research group at MIT and co-founding Lanka Internet Services, Ltd., the first Internet Service Provider in Sri Lanka. Prof. Amarasinghe is also the faculty director of MIT Global Startup Labs, whose summer programs in 17 countries have helped to create more than 20 thriving startups. Prof. Amarasinghe developed the popular Performance Engineering of Software Systems (6.172) class with Professor Charles Leiserson. He also created individualized software project classes such as the Open Source Software Project Lab, the Open Source Entrepreneurship Lab, and the Bring Your Own Software Project Lab.</bio>
          <homepage_url>http://people.csail.mit.edu/saman</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/samanamarasinghe/9e4ed1ad-ff3e-468e-b1a8-36ffb2c882ef/small.jpg</picture_url>
          <person_id>samanamarasinghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>02ccad03-6734-4d65-9628-f81c25f1872e</subevent_id>
    <title>SPLASH OOPSLA: T-3</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>3df3e93d-1303-4a51-96be-9fc9db55cacc</slot_id>
      <title>Session: SPLASH OOPSLA - T-3</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>16f2c9fd-522e-4847-922e-339d712a2e46</slot_id>
      <event_id>b926e1ec-10a6-4b30-9b63-77836ac884b7</event_id>
      <title>Koord: a language for programming and verifying distributed robotics applications</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>23:20</end_time>
      <description>A robot’s code needs to sense the environment, control the hardware, and communicate with other robots. Cur- rent programming languages do not provide the necessary hardware platform-independent abstractions, and therefore, developing robot applications require detailed knowledge of signal processing, control, path plan- ning, network protocols, and various platform-specific details. Further, porting applications across hardware platforms becomes tedious. We present Koord—a domain specific language for distributed robotics—which abstracts platform-specific functions for sensing, communication, and low-level control. Koord makes the platform-independent control and coordination code portable and modularly verifiable. It raises the level of abstraction in programming by providing distributed shared memory for coordination and port interfaces for sensing and control. We have developed the formal executable semantics of Koord in the K framework. With this symbolic execution engine, we can identify assumptions (proof obligations) needed for gaining high assurance from Koord applications. We illustrate the power of Koord through three applications: formation flight, distributed delivery, and distributed mapping. We also use the formation flight and distributed delivery applications to demonstrate how platform-independent proof obligations can be discharged using the Koord Prover while platform-specific proof obligations can be checked by verifying the obligations using physics-based models and hybrid verification tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ritwika</first_name>
          <last_name>Ghosh</last_name>
          <affiliation>UIUC</affiliation>
          <bio>undefined</bio>
          <person_id>ritwikaghosh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chiao</first_name>
          <last_name>Hsieh</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>chiaohsieh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sasa</first_name>
          <last_name>Misailovic</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://misailo.cs.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sasamisailovic/6e3299c7-e0f5-4e78-a5f3-7ea49e488545/small.jpg</picture_url>
          <person_id>sasamisailovic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>sayan</first_name>
          <last_name>mitra</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>Sayan Mitra is a Professor of Electrical and Computer Engineering at the University of Illinois at Urbana-Champaign. His research interests are in formal verification, autonomous systems, and robotics. He holds a PhD from MIT, MSc from the Indian Institute of Science, Bangalore, and an undergraduate degree in Electrical Engineering from Jadavpur University, Kolkata. He was a postdoctoral fellow at the Center for Mathematics of Information of CalTech, and held visiting faculty positions at Oxford University and Kirtland Air Force Research Laboratory. Sayan received the National Science Foundation’s CAREER Award in 2011, AFOSR Young Investigator Research Program Award in 2012, IEEE-HKN C. Holmes MacDonald Outstanding Teaching Award (2013), a RiSE Fellowship from TU Vienna, and several best paper awards.</bio>
          <homepage_url>http://mitras.ece.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sayanmitra/62982710-8e2c-4be7-98f8-068227c8a067/small.jpg</picture_url>
          <person_id>sayanmitra</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>63777313-d9b3-4e71-a636-24117533937e</slot_id>
      <event_id>de7d97dc-0089-49e1-bfce-2e7b14b648ee</event_id>
      <title>LiveDroid: Identifying and Preserving Mobile App State in Volatile Runtime Environments</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>00:00</end_time>
      <description>Mobile operating systems, especially Android, expose apps to a volatile runtime environment. The app state that reflects past user interaction and system environment updates (e.g., battery status changes) can be destroyed implicitly, in response to runtime configuration changes (e.g., screen rotations) or memory pressure. Developers are therefore responsible for identifying app state affected by volatility and preserving it across app lifecycles. When handled inappropriately, the app may lose state or end up in an inconsistent state after a runtime configuration change or when users return to the app.
To free developers from this tedious and error-prone task, we propose a systematic solution, LiveDroid, which precisely identifies the necessary part of the app state that needs to be preserved across app lifecycles, and automatically saves and restores it. LiveDroid consists of: (i) a static analyzer that reasons about app source code and resource files to pinpoint the program variables and GUI properties that represent the necessary app state, and (ii) a runtime system that manages the state saving and recovering. We implemented LiveDroid as a plugin in Android Studio and a patching tool for APKs. Our evaluation shows that LiveDroid can be successfully applied to 966 Android apps. A focused study with 36 Android apps shows that LiveDroid identifies app state much more precisely than an existing solution that includes all mutable program variables but ignores GUI properties. As a result, on average, LiveDroid is able to reduce the costs of state saving and restoring by 16.6X (1.7X - 141.1X) and 9.5X (1.1X - 43.8X), respectively. Furthermore, compared with the manual state handling performed by developers, our analysis reveals a set of 46 issues due to incomplete state saving/restoring, all of which can be successfully eliminated by LiveDroid.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Umar</first_name>
          <last_name>Farooq</last_name>
          <affiliation>University of California Riverside</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.ucr.edu/~ufaro001/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/umarfarooq2/e0d30810-d987-42da-b3cb-576592015d8d/small.jpg</picture_url>
          <person_id>umarfarooq2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zhijia</first_name>
          <last_name>Zhao</last_name>
          <affiliation>UC Riverside</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ucr.edu/~zhijia/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhijiazhao/5e266673-0c51-4bfe-bc81-2fb37155ad8b/small.jpg</picture_url>
          <person_id>zhijiazhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Manu</first_name>
          <last_name>Sridharan</last_name>
          <affiliation>University of California Riverside</affiliation>
          <bio>I work on developing tools and techniques to make large-scale software more reliable, performant, secure, and maintainable. For more details, see my homepage.</bio>
          <homepage_url>http://manu.sridharan.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manusridharan/00859147-2155-45a9-9a48-7565ce5356ac/small.jpg</picture_url>
          <person_id>manusridharan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Iulian</first_name>
          <last_name>Neamtiu</last_name>
          <affiliation>New Jersey Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://web.njit.edu/~ineamtiu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/iulianneamtiu/59a11852-72df-4d67-9331-8720d3d19a64/small.jpg</picture_url>
          <person_id>iulianneamtiu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6a2c1fa9-6ff4-437a-b112-b9ef447f9f99</slot_id>
      <event_id>72a7c48b-8eba-4f07-b5bc-03af82474540</event_id>
      <title>Shiftry: RNN Inference in 2KB of RAM</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>00:20</end_time>
      <description>Traditionally, IoT devices send collected sensor data to an intelligent cloud where machine learning (ML) inference happens. However, this course is rapidly changing and there is a recent trend to run ML on the edge IoT devices themselves. An intelligent edge is attractive because it saves network round trip (efficiency) and keeps user data at the source (privacy). However, the IoT devices are much more resource constrained than the cloud, which makes running ML on them challenging. Specifically, consider Arduino Uno, a commonly used board, that has 2KB of RAM and 32KB of read-only Flash memory. Although recent breakthroughs in ML have created novel recurrent neural network (RNN) models that provide good accuracy with KB-sized models, deploying them on tiny devices with such hard memory requirements has remained elusive.
We provide, Shiftry, an automatic compiler from high-level floating-point ML models to fixed-point C-programs with 8-bit and 16-bit integers, which have significantly lower memory requirements. For this conversion, Shiftry uses a data-driven float-to-fixed procedure and a RAM management mechanism. These techniques enable us to provide first empirical evaluation of RNNs running on tiny edge devices. On simpler ML models that prior work could handle, Shiftry-generated code has lower latency and higher accuracy.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aayan</first_name>
          <last_name>Kumar</last_name>
          <affiliation>Microsoft Research India</affiliation>
          <bio>undefined</bio>
          <person_id>aayankumar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vivek</first_name>
          <last_name>Seshadri</last_name>
          <affiliation>Microsoft Research, India</affiliation>
          <bio>undefined</bio>
          <person_id>vivekseshadri</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rahul</first_name>
          <last_name>Sharma</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Rahul Sharma is a researcher at Microsoft Research India. He received a Ph.D. in Computer Science from Stanford University, where he was advised by Prof. Alex Aiken. Before Stanford, he graduated with a B.Tech. from IIT Delhi. His research interests include program analysis, compilers, machine learning, and secure cloud computing.</bio>
          <homepage_url>http://cs.stanford.edu/people/sharmar</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rahulsharma/6d60eca8-356f-4141-af5d-4c6af0fadcd8/small.jpg</picture_url>
          <person_id>rahulsharma</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>99b7ae06-430b-4b21-90dd-3b80c530a347</slot_id>
      <event_id>7425f134-286b-4c4d-998b-71b90c993ce0</event_id>
      <title>Learning-based Controlled Concurrency Testing</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>23:40</end_time>
      <description>Concurrency bugs are notoriously hard to detect and reproduce. Controlled concurrency testing (CCT) techniques aim to offer a solution, where a scheduler explores the space of possible interleavings of a concurrent program looking for bugs. Since the set of possible interleavings is typically very large, these schedulers employ heuristics that prioritize the search to ``interesting'' subspaces. However, current heuristics are typically tuned to specific bug patterns, which limits their effectiveness in practice.
In this paper, we present $\mathtt{QL}$, a learning-based CCT framework where the likelihood of an action being selected by the scheduler is influenced by earlier explorations. We leverage the classical Q-learning algorithm to explore the space of possible interleavings, allowing the exploration to adapt to the program under test, unlike previous techniques. We have implemented and evaluated $\mathtt{QL}$ on a set of microbenchmarks, complex protocols, as well as production cloud services. In our experiments, we found $\mathtt{QL}$ to consistently outperform the state-of-the-art in CCT.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Suvam</first_name>
          <last_name>Mukherjee</last_name>
          <affiliation>Microsoft Research India</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://suvamm.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/suvammukherjee1/0b04e282-4b61-4f63-9abf-4d9516cf0b1e/small.jpg</picture_url>
          <person_id>suvammukherjee1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pantazis</first_name>
          <last_name>Deligiannis</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pdeligia.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/pantazisdeligiannis/a2d73510-7695-48bd-9b09-2ce6ec50b5d1/small.jpg</picture_url>
          <person_id>pantazisdeligiannis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arpita</first_name>
          <last_name>Biswas</last_name>
          <affiliation>Indian Institute of Science</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.google.com/view/arpitabiswas</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arpitabiswas/c7b67b3e-4a6b-4a0c-8139-6cc114ed3ea1/small.jpg</picture_url>
          <person_id>arpitabiswas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Akash</first_name>
          <last_name>Lal</last_name>
          <affiliation>Microsoft Research India</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.microsoft.com/en-us/people/akashl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/akashlal/96032ffc-99b4-4b90-b99d-01b1f833751a/small.jpg</picture_url>
          <person_id>akashlal</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2e25f672-eab0-4b3c-ab58-ecbd3997af93</subevent_id>
    <title>SPLASH OOPSLA: F-3B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>9eaf970b-65ba-41e3-a308-7321c3e86b49</slot_id>
      <title>Session: SPLASH OOPSLA - F-3B</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>14140688-2baa-4cdf-8839-20311cc02ace</slot_id>
      <event_id>49e4b00a-5555-4c4e-8eca-5628b4a98878</event_id>
      <title>Learning Semantic Program Embeddings with Graph Interval Neural Network</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>12:00</end_time>
      <description>Learning distributed representations of source code has been a challenging task for machine learning models. Earlier works treated programs as text so that natural language methods can be readily applied. Unfortunately, such approaches do not capitalize on the rich structural information possessed by source code. Of late, Graph Neural Network (GNN) was proposed to learn embeddings of programs from their graph representations. Due to the homogeneous (i.e. do not take advantage of the program-specific graph characteristics) and expensive (i.e. require heavy information exchange among nodes in the graph) message-passing procedure, GNN can suffer from precision issues, especially when dealing with programs rendered into large graphs. In this paper, we present a new graph neural architecture, called Graph Interval Neural Network (GINN), to tackle the weaknesses of the existing GNN. Unlike the standard GNN, GINN generalizes from a curated graph representation obtained through an abstraction method designed to aid models to learn. In particular, GINN focuses exclusively on intervals (generally manifested in looping construct) for mining the feature representation of a program, furthermore, GINN operates on a hierarchy of intervals for scaling the learning to large graphs.
We evaluate GINN for two popular downstream applications: variable misuse prediction and method name prediction. Results show in both cases GINN outperforms the state-of-the-art models by a comfortable margin. We have also created a neural bug detector based on GINN to catch null pointer deference bugs in Java code. While learning from the same 9,000 methods extracted from 64 projects, GINN-based bug detector significantly outperforms GNN-based bug detector on 13 unseen test projects. Next, we deploy our trained GINN-based bug detector and Facebook Infer, arguably the state-of-the-art static analysis tool, to scan the codebase of 20 highly starred projects on GitHub. Through our manual inspection, we confirm 38 bugs out of 102 warnings raised by GINN-based bug detector compared to 34 bugs out of 129 warnings for Facebook Infer. We have reported 38 bugs GINN caught to developers, among which 11 have been fixed and 12 have been confirmed (fix pending). GINN has shown to be a general, powerful deep neural network for learning precise, semantic program embeddings.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yu</first_name>
          <last_name>Wang</last_name>
          <affiliation>Department of Computer Science and Technology, Nanjing University</affiliation>
          <bio>undefined</bio>
          <person_id>yuwang2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ke</first_name>
          <last_name>Wang</last_name>
          <affiliation>Visa Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kbwang.bitbucket.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/kewang/37ef656e-ca92-475f-8a51-902dbe44fb72/small.jpg</picture_url>
          <person_id>kewang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Fenjuan</first_name>
          <last_name>Gao</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <person_id>fenjuangao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Linzhang</first_name>
          <last_name>Wang</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <person_id>linzhangwang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>300cf933-3384-48fc-90ff-22d87f35da06</slot_id>
      <event_id>6a3ae3f8-1ca4-44df-b6b1-bb4756927885</event_id>
      <title>Just-in-Time Learning for Bottom-up Enumerative Synthesis</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>11:20</end_time>
      <description>A key challenge in program synthesis is the astronomical size of the search space the synthesizer has to explore. In response to this challenge, recent work proposed to guide synthesis using learned probabilistic models. Obtaining such a model, however, might be infeasible for a problem domain where no high-quality training data is available. In this work we introduce an alternative approach to guided program synthesis: instead of training a model \emph{ahead of time} we show how to bootstrap one \emph{just in time}, during synthesis, by learning from partial solutions encountered along the way. To make the best use of the model, we also propose a new program enumeration algorithm we dub \emph{guided bottom-up search}, which extends the efficient bottom-up search with guidance from probabilistic models.
We implement this approach in a tool called Probe, which targets problems in the popular syntax-guided synthesis (SyGuS) format. We evaluate Probe on benchmarks from the literature and show that it achieves significant performance gains both over unguided bottom-up search and over a state-of-the-art probability-guided synthesizer, which had been trained on a corpus of existing solutions. Moreover, we show that these performance gains do not come at the cost of solution quality: programs generated by Probe are only slightly more verbose than the shortest solutions and perform no unnecessary case-splitting.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shraddha</first_name>
          <last_name>Barke</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shraddhabarke1/4e11ed13-0f46-4d77-8a6d-dd4c07b7fd4b/small.jpg</picture_url>
          <person_id>shraddhabarke1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>37f9968e-8ec8-4555-8c3b-01043eb73ef2</slot_id>
      <event_id>1191b34c-6380-48db-9c47-b8e642e28ee2</event_id>
      <title>ιDOT: A DOT Calculus with Object Initialization</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>12:20</end_time>
      <description>The Dependent Object Types (DOT) calculus serves as a foundation of the Scala programming language, with a machine-verified soundness proof. However, Scala’s type system has been shown to be unsound due to null references, which are used as default values of fields of objects before they have been initialized. This paper proposes ιDOT, an extension of DOT for ensuring safe initialization of objects. DOT was previously extended to κDOT with the addition of mutable fields and constructors. To κDOT, ιDOT adds an initialization effect system that statically prevents the possibility of reading a null reference from an uninitialized object. To design ιDOT, we have reformulated the Freedom Before Commitment object initialization scheme in terms of disjoint subheaps to make it easier to formalize in an effect system and prove sound. Soundness of ιDOT depends on the interplay of three systems of rules: a type system close to that of DOT, an effect system to ensure definite assignment of fields in each constructor, and an initialization system that tracks the initialization status of objects in a stack of subheaps. We have proven the overall system sound and verified the soundness proof using the Coq proof assistant.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ifaz</first_name>
          <last_name>Kabir</last_name>
          <affiliation>University of Alberta, Canada</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/ifazkabir/991cbcab-f46c-4c5e-8b8f-c365d1b11d6b/small.jpg</picture_url>
          <person_id>ifazkabir</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yufeng</first_name>
          <last_name>Li</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>yufengli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5fb954b7-9168-42eb-9226-cc67e1456b99</slot_id>
      <event_id>275f97bd-396a-4f74-95be-90160be2ffc2</event_id>
      <title>Taming Type Annotations in Gradual Typing</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>11:40</end_time>
      <description>Gradual typing provides a methodology to integrate static and dynamic typing, harmonizing their often conflicting advantages in a single language. When a user wants to enjoy the advantages of static typing, most gradual languages require that they add type annotations. Many nontrivial tasks must be undertaken while adding type annotations, including understanding program behaviors and invariants. Unfortunately, if this is done incorrectly then the added type annotations can be wrong–leading to inconsistencies between the program and the type annotations. Gradual typing implementations detect such inconsistencies at runtime, raise cast errors, and generate messages. However, solely relying on such error messages for understanding and fixing inconsistencies and their resulting cast errors is often insufficient for multiple reasons. One reason is that while such messages cover inconsistencies in one execution path, fixing them often requires reconciling information from multiple paths. Another is that users may add many wrong type annotations that they later find difficult to identify and fix, when considering all added annotations.
Recent studies provide evidence that type annotations added during program migration are often wrong and that many programmers prefer compile-time warnings about wrong annotations. Motivated by these results, we develop exploratory typing to help with the static detection, understanding, and fixing of inconsistencies. The key idea of exploratory typing is that it systematically removes dynamic types and explores alternative types for static type annotations that can remedy inconsistencies. To demonstrate the feasibility of exploratory typing, we have implemented it in PyHound, which targets programs written in Reticulated Python, a gradual variant of Python. We have evaluated PyHound on a set of Python programs, and the evaluation results demonstrate that our idea can effectively detect inconsistencies in 98% of the tested programs and fix 93% of inconsistencies, significantly outperforming pytype, a widely used Python tool for enforcing type annotations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Peter Campora III</last_name>
          <affiliation>University of Louisiana at Lafayette</affiliation>
          <bio>I’m a 3rd year PhD student at ULL advised by Sheng Chen. My current research focus has been improving the usability of gradually typed languages. You can contact me at: petecampora (at) gmail.com.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnpetercamporaiii/62a0c591-991e-49f7-978a-0ecbc5556620/small.jpg</picture_url>
          <person_id>johnpetercamporaiii</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sheng</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Louisiana at Lafayette</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.cmix.louisiana.edu/schen/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shengchen1/4561e224-57d6-4243-9b1f-0c895b2c49d7/small.jpg</picture_url>
          <person_id>shengchen1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>83dee1df-08a1-4401-803f-754d7c76b66e</subevent_id>
    <title>SPLASH OOPSLA: W-4</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>32f87215-2ae1-4eff-af7c-9d336c53696f</slot_id>
      <title>Session: SPLASH OOPSLA - W-4</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>13:00</start_time>
      <end_time>14:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>33e1d675-3439-4c2a-bfba-fb598beb63e8</slot_id>
      <event_id>dba90368-d2da-4b07-8bd6-dc1e3f236813</event_id>
      <title>How Do Programmers Use Unsafe Rust?</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>14:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>14:20</end_time>
      <description>Rust’s ownership type system enforces a strict discipline on how memory locations are accessed and shared. This discipline allows the compiler to statically prevent memory errors, data races, inadvertent side effects through aliasing, and other errors that occur frequently in conventional imperative programs. However, the restrictions imposed by Rust’s type system make it difficult or impossible to implement certain designs, such as data structures that require aliasing (e.g., doubly-linked lists and shared caches). To work around this limitation, Rust allows code blocks to be declared as unsafe and thereby exempted from certain restrictions of the type system, for instance, to manipulate C-style raw pointers. Ensuring the safety of unsafe code is the responsibility of the programmer. However, a important assumption of the Rust language, which we dub the Rust hypothesis, is that programmers use Rust by following three main principles: use unsafe sparingly, make it easy to review, and hide behind a safe abstraction such that client code can be written in safe Rust.
Understanding how Rust programmers use unsafe code and, in particular, whether the Rust hypothesis holds is essential for Rust developers and testers, language and library designers, as well as tool developers. This paper studies empirically how unsafe code is used in practice by analyzing a large corpus of Rust projects to assess the validity of the Rust hypothesis and to classify the purpose of unsafe code. We identify queries that can be answered by automatically inspecting the program structure, its intermediate representation MIR, as well as type information provided by the Rust compiler, and complement the results by manual code inspection. Our study supports the Rust hypothesis partially: While most unsafe code is simple and well-encapsulated, unsafe features are used extensively, especially for interoperability with other languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vytautas</first_name>
          <last_name>Astrauskas</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>vytautasastrauskas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Matheja</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>christophmatheja1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Federico</first_name>
          <last_name>Poli</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>federicopoli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Peter</first_name>
          <last_name>Müller</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/petermller/aeb8e276-62cb-4ad1-aa7d-96f76c0c405d/small.jpg</picture_url>
          <person_id>petermller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Alexander J.</first_name>
          <last_name>Summers</last_name>
          <affiliation>The University of British Columbia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.inf.ethz.ch/summersa/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexanderjsummers/f97b84a8-d46a-4e76-aa73-cc4b38c4ec41/small.jpg</picture_url>
          <person_id>alexanderjsummers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7de19414-abdf-41f2-900b-b92265caf425</slot_id>
      <event_id>c3abeda5-100d-409c-8506-b3ec6c6db79f</event_id>
      <title>Finding Bugs in Database Systems via Query Partitioning</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>13:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>13:40</end_time>
      <description>Logic bugs in Database Management Systems (DBMS) are bugs that cause an incorrect result for a given query (e.g., by omitting a row that should be fetched). These bugs are critical, since they are likely to go unnoticed by users. We propose Query Partitioning, a general and effective approach for finding logic bugs in DBMS. The core idea of Query Partitioning is to, starting from a given original query, derive multiple, more complex queries (called partitioning queries), each of which computes a partition of the result. The individual partitions are then composed to compute a result set that must be equivalent to the original query’s result set. A bug in the DBMS is detected when these result sets differ. Our intuition is that due to the increased complexity, the partitioning queries are more likely to stress the DBMS and trigger a logic bug than the original query. As a concrete instance of a partitioning strategy, we propose Ternary Logic Partitioning (TLP), which is based on the observation that a boolean predicate p can either evaluate to TRUE, FALSE, or NULL. Accordingly, a query can be decomposed to three partitioning queries, each of which computes its result on rows or intermediate results for which p, NOT p, and p IS NULL hold. This technique is versatile, and can be used to test WHERE, GROUP BY, as well as HAVING clauses, aggregate functions, and DISTINCT queries. As part of an extensive testing campaign, we found 175 bugs in widely-used DBMS such as MySQL, TiDB, SQLite, and CockroachDB, 123 of which have been fixed. Notably, 77 of these were logic bugs, while the remaining error and crash bugs. We expect that the effectiveness and wide applicability of Query Partitioning will lead to its broad adoption in practice, and the formulation of additional partitioning strategies.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Rigger</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>Manuel Rigger is a postdoctoral researcher in the Advanced Software Technologies (AST) Lab at ETH Zurich, mentored by Zhendong Su. He is working on programming language implementation, software reliability, and systems. He completed his PhD at Johannes Kepler University Linz, mentored by Hanspeter Mössenböck, and is known for his work on Sulong to support the safe execution of LLVM-based languages.</bio>
          <homepage_url>http://www.manuelrigger.at/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelrigger/47e268e9-158c-471f-a7e9-442216c54550/small.jpg</picture_url>
          <person_id>manuelrigger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a7364c47-e51b-450e-9d04-34f056fa402b</slot_id>
      <event_id>9609351d-7346-41c3-a781-926327d9a68c</event_id>
      <title>Proving Highly-Concurrent Traversals Correct</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>13:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>14:00</end_time>
      <description>Modern highly-concurrent search data structures, such as search trees, obtain multi-core scalability and performance by having operations traverse the data structure without any synchronization. As a result, however, these algorithms are notoriously difficult to prove linearizable, which requires identifying a point in time in which the traversal’s result is correct. The problem is that traversing the data structure as it undergoes modifications leads to complex behaviors, requiring intricate reasoning about all interleavings of reads by traversals and writes mutating the data structure.
In this paper, we present a general proof technique for proving unsynchronized traversals correct in a significantly simpler manner, compared to typical concurrent reasoning and prior proof techniques. Our framework relies only on \emph{sequential properties} of traversals and on a conceptually simple and widely-applicable condition about the ways an algorithm’s writes mutate the data structure. Establishing that a target data structure satisfies our condition requires only simple concurrent reasoning, without considering interactions of writes and reads. This reasoning can be further simplified by using our framework.
To demonstrate our technique, we apply it to prove several interesting and challenging concurrent binary search trees: the logical-ordering AVL tree, the Citrus tree, and the full contention-friendly tree. Both the logical-ordering tree and the full contention-friendly tree are beyond the reach of previous approaches targeted at simplifying linearizability proofs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yotam</first_name>
          <last_name>Feldman</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/research/yotam.feldman/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yotamfeldman/ed864714-e66c-4ec1-a171-8c2ac69d62a1/small.jpg</picture_url>
          <person_id>yotamfeldman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Artem</first_name>
          <last_name>Khyzha</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <person_id>artemkhyzha1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Constantin</first_name>
          <last_name>Enea</last_name>
          <affiliation>IRIF, University Paris Diderot &amp; CNRS</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~cenea/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/constantinenea/2dfe8bfe-ddfe-4012-a2e2-01cc8b953734/small.jpg</picture_url>
          <person_id>constantinenea</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Adam</first_name>
          <last_name>Morrison</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~mad</homepage_url>
          <person_id>adammorrison1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Aleksandar</first_name>
          <last_name>Nanevski</last_name>
          <affiliation>IMDEA Software Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://software.imdea.org/~aleks</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aleksandarnanevski/6612f235-0493-478f-9ecd-d86045a7619a/small.jpg</picture_url>
          <person_id>aleksandarnanevski</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Noam</first_name>
          <last_name>Rinetzky</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~maon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/noamrinetzky/1ea9bd0d-bd16-4b15-bb66-a8a576ffaa40/small.jpg</picture_url>
          <person_id>noamrinetzky</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Sharon</first_name>
          <last_name>Shoham</last_name>
          <affiliation>Tel Aviv university</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.tau.ac.il/~sharonshoham/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sharonshoham/52ca243a-805e-43b9-9f5a-bd1bae25fccb/small.jpg</picture_url>
          <person_id>sharonshoham</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ca42eea0-c832-4cc0-bb9f-31c317ea3502</slot_id>
      <event_id>589e08b8-be04-449c-9c40-7dc3797f2c0b</event_id>
      <title>Adversarial Examples for Models of Code</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>13:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>13:20</end_time>
      <description>Neural models of code have shown impressive performance for tasks such as predicting method names and identifying certain kinds of bugs. In this paper, we show that these models are vulnerable to adversarial examples, and introduce a novel approach for attacking trained models of code with adversarial examples. The main idea is to force a given trained model to make an incorrect prediction as specified by the adversary, by introducing small perturbations that do not change the program’s semantics. To find such perturbations, we present a new technique for Discrete Adversarial Manipulation of Programs (DAMP). DAMP works by deriving the desired prediction with respect to the model’s inputs while holding the model weights constant, and following the gradients to slightly modify the input code.
We show that our DAMP attack is effective across three neural architectures: code2vec, GGNN, and GNN-FiLM, in both Java and C#. We show that DAMP has up to 89% success rate in changing a prediction to the adversary’s choice (“targeted attack”), and a success rate of up to 94% in changing a given prediction to any incorrect prediction (“non-targeted attack”). To defend a model against such attacks, we examine a variety of possible defenses empirically and discuss their trade-offs. We show that some of these defenses drop the success rate of the attacker drastically, with a minor penalty of 2% relative degradation in accuracy while not performing under attack.
Our code, data, and trained models are available at https://github.com/tech-srl/adversarial-examples .</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Noam</first_name>
          <last_name>Yefet</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <person_id>noamyefet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Uri</first_name>
          <last_name>Alon</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~urialon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/urialon/a0488e4f-5173-472b-af25-10666c27e3d4/small.jpg</picture_url>
          <person_id>urialon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion</affiliation>
          <bio>Eran Yahav is an associate professor at the Computer Science Department, Technion, Israel. Prior to that, he was a research staff member at the IBM T.J. Watson Research Center (2004-2010). He received his Ph.D. from Tel Aviv University (2005) and his B.Sc. from the Technion in 1996. His research interests include program analysis, program synthesis and program verification. Eran is a recipient of the prestigious Alon Fellowship for Outstanding Young Researchers, the Andre Deloro Career Advancement Chair in Engineering, the ERC Consolidator Grant as well as multiple best paper awards at various conferences.</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
          <person_id>eranyahav</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3adf108f-e665-4b8f-8f31-4432f14d77e4</subevent_id>
    <title>SPLASH OOPSLA: F-4A</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>2fab182b-e18d-4337-a886-ff6285eec8b4</slot_id>
      <title>Session: SPLASH OOPSLA - F-4A</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>21abcd88-7657-4302-bb2d-3685dddf7f1d</slot_id>
      <event_id>535250d1-14d9-4fb4-b418-2ad1ae511d91</event_id>
      <title>Scaling Exact Inference for Discrete Probabilistic Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>02:00</end_time>
      <description>Probabilistic programming languages (PPLs) are an expressive means of representing and reasoning about probabilistic models. The computational challenge of probabilistic inference remains the primary roadblock for applying PPLs in practice. Inference is fundamentally hard, so there is no one-size-fits all solution. In this work, we target scalable inference for an important class of probabilistic programs: those whose probability distributions are discrete. Discrete distributions are common in many fields, including text analysis, network verification, artificial intelligence, and graph analysis, but they prove to be challenging for existing PPLs.
We develop a domain-specific probabilistic programming language called Dice that features a new approach to exact discrete probabilistic program inference. Dice exploits program structure in order to factorize inference, enabling us to perform exact inference on probabilistic programs with hundreds of thousands of random variables. Our key technical contribution is a new reduction from discrete probabilistic programs to weighted model counting (WMC). This reduction separates the structure of the distribution from its parameters, enabling logical reasoning tools to exploit that structure for probabilistic inference. We (1) show how to compositionally reduce Dice inference to WMC, (2) prove this compilation correct with respect to a denotational semantics, (3) empirically demonstrate the performance benefits over prior approaches, and (4) analyze the types of structure that allow Dice to scale to large probabilistic programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Steven</first_name>
          <last_name>Holtzen</last_name>
          <affiliation>University of California, Los Angeles</affiliation>
          <bio>I am a PhD. student at U.C.L.A., co-advised by Guy Van den Broeck and Todd Millstein.</bio>
          <homepage_url>http://web.cs.ucla.edu/~sholtzen</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/stevenholtzen/db2263a6-7a88-4167-9d73-86a4d4b97fc9/small.jpg</picture_url>
          <person_id>stevenholtzen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guy</first_name>
          <last_name>Van den Broeck</last_name>
          <affiliation>University of California, Los Angeles</affiliation>
          <bio>I am an Associate Professor and Samueli Fellow at UCLA, in the Computer Science Department. My research interests are in Machine Learning (Statistical Relational Learning), Knowledge Representation and Reasoning (Graphical Models, Lifted Probabilistic Inference), Applications of Probabilistic Reasoning and Learning (Probabilistic Programming, Probabilistic Databases), and Artificial Intelligence in general. I previously was a postdoctoral researcher at UCLA’s Automated Reasoning lab and KU Leuven’s Declarative Languages and Artificial Intelligence lab.</bio>
          <homepage_url>http://web.cs.ucla.edu/~guyvdb/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guyvandenbroeck/4c8a474f-a124-4434-a370-43b4892bbe2c/small.jpg</picture_url>
          <person_id>guyvandenbroeck</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Todd</first_name>
          <last_name>Millstein</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am a Professor in the Computer Science Department at the University of California, Los Angeles (UCLA).
I was the Program Chair for OOPSLA 2014.</bio>
          <homepage_url>http://www.cs.ucla.edu/~todd/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/toddmillstein/03692d64-e4ad-4fb1-a2b0-9271ce27715c/small.jpg</picture_url>
          <person_id>toddmillstein</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>752143a7-e4f2-46de-b1f7-b641ab1a3c04</slot_id>
      <event_id>74c28b24-629b-4e90-837d-28d2c9d362d6</event_id>
      <title>A Modular Cost Analysis for Probabilistic Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>01:20</end_time>
      <description>We present a novel methodology for the automated resource analysis of non-deterministic, probabilistic imperative programs, based on three ingredients: (i) a refinement of the theory of probabilistic abstract rewrite systems, providing the basis for a neat and compact operational semantics; (ii) an alternating expected cost and expected value analysis, establishing modularity of the analyis; and (iii) painstaking attention to detail in the implementation with a focus on efficiency.
All in all, this gives rise to a unique \emph{modular approach} to the problem at hand. Program fragments are analysed in full independence. Further, the results established allow us to incorporate sampling from \emph{dynamic distributions}, making our analysis applicable to realistic examples.
We have implemented our contributions exploiting a constraint-solver over iterative refineable cost functions facilitated by off-the-shelf SMT-solvers. We provide ample experimental evidence of its algorithmic superiority. Our experiments show that our tool runs on average \emph{orders of magnitude faster} than comparable tools: \MA{ensure; verify} execution times of seconds become milliseconds. At the same time we retain the precision of existing tools.
The extensions in applicability and the greater efficiency of our prototype, yield scalabilty of the tool. This effects into more realistic examples, whose expected cost analysis can be thus performed fully automatically. In particular, our tool is the first establishing an automated analysis of the \emph{Coupon Collector’s problem}.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Avanzini</last_name>
          <affiliation>INRIA Sophia Antipolis, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-sop.inria.fr/members/Martin.Avanzini/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/martinavanzini1/6a7bba4f-db11-478c-9d7c-2dabe34811bc/small.jpg</picture_url>
          <person_id>martinavanzini1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Georg</first_name>
          <last_name>Moser</last_name>
          <affiliation>University of Innsbruck</affiliation>
          <bio>undefined</bio>
          <person_id>georgmoser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Schaper</last_name>
          <affiliation>University of Innsbruck</affiliation>
          <bio>undefined</bio>
          <person_id>michaelschaper1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c213a6b6-12b8-4c25-a8ac-085c09363945</slot_id>
      <event_id>b9adaa2c-cdbd-450c-bb15-daa638849bd3</event_id>
      <title>Digging for Fold: Synthesis-Aided API Discovery for Haskell</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>02:20</end_time>
      <description>We present Hoogle+, a component-based synthesizer for Haskell that takes as input a specification in the form of a type, a set of input-output tests, or both, and returns a list of candidate programs composed of functions from popular Haskell libraries. Hoogle+ focuses on the end-to-end usability of synthesis: i.e., how to help programmers solve their tasks faster. Usability depends crucially on whether and how the programmer can specify their own intent and comprehend the tools results. Hoogle+ addresses the specification problem by allowing the user to specify goals via tests from which it automatically infers type signatures that facilitate rapid synthesis. Hoogle+ uses property based testing to ensure the user only sees _useful and _unique candidates, and generates example usages to illustrate the _functionality of each candidate to help the user comprehend their semantics in order to choose the right result. We evaluate the usability of Hoogle+, with a user study with 30 participants of varying Haskell proficiency,that shows that programmers generally solve tasks faster with Hoogle+, and that they were able to solve 50% more tasks when equipped with Hoogle+.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael B.</first_name>
          <last_name>James</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>Michael James is a 3rd year PhD student at University of California, San Diego studying programming languages and program synthesis under Nadia Polikarpova. He worked as a software engineer for three years before starting his degree. His experience has guided him to research topics that will ultimately flow back to help other engineers and make programming easier for all.</bio>
          <homepage_url>http://michaelbjames.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/michaelbjames/8360df32-2f8d-4f7c-99c1-523f1f811bec/small.jpg</picture_url>
          <person_id>michaelbjames</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zheng</first_name>
          <last_name>Guo</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>zhengguo1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziteng</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wzt.me/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zitengwang/bf349a37-8935-4553-bcf7-c78094e369c5/small.jpg</picture_url>
          <person_id>zitengwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Shivani</first_name>
          <last_name>Doshi</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>Current Cornell Tech MEng Student, UC San Diego 2020 BS in CS graduate.</bio>
          <homepage_url>https://shivanidoshi26.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shivanidoshi/a3bdf8b0-e4df-4be6-8c43-1cd1aee38f69/small.jpg</picture_url>
          <person_id>shivanidoshi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Ranjit</first_name>
          <last_name>Jhala</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>Nom nom. Chomp. Burp.</bio>
          <homepage_url>http://ranjitjhala.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ranjitjhala/afbdab69-ed23-4022-b7a4-2c57128f20ec/small.jpg</picture_url>
          <person_id>ranjitjhala</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e9a66a3b-9cd8-4caf-87b3-fae4df74f0b6</slot_id>
      <event_id>e202e9a0-8e64-4364-82a0-a1d2b41e4b74</event_id>
      <title>Interactive Synthesis of Temporal Specifications from Examples and Natural Language</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>01:40</end_time>
      <description>Motivated by applications in robotics, we consider the task of synthesizing linear temporal logic (LTL) specifications based on examples and natural language descriptions. While LTL is a flexible, expressive, and unambiguous language to describe robotic tasks, it is often challenging for non-expert users.
In this paper, we present an interactive method for synthesizing LTL specifications from a single example trace and a natural language description. The interaction is limited to showing a small number of behavioral examples to the user who decides whether or not they exhibit the original intent. Our approach generates candidate LTL specifications and distinguishing examples using an encoding into optimization modulo theories problems.
Additionally, we use a grammar extension mechanism and a semantic parser to generalize synthesized specifications to parametric task descriptions for subsequent use. Our implementation in the tool LtlTalk starts with a domain-specific language that maps to a fragment of LTL and expands it through example-based user interactions, thus enabling natural language-like robot programming, while maintaining the expressive power and precision of a formal language. Our experiments show that the synthesis method is precise, quick, and asks only a few questions to the users, and we demonstrate in a case study how LtlTalk generalizes from the synthesized tasks to other, yet unseen, tasks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Gavran</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
          <person_id>ivangavran</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eva</first_name>
          <last_name>Darulova</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mpi-sws.org/~eva/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/evadarulova/0d98744b-ec94-4a27-b1c0-0d728d54bdb7/small.jpg</picture_url>
          <person_id>evadarulova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rupak</first_name>
          <last_name>Majumdar</last_name>
          <affiliation>Max Planck Institute for Software Systems (MPI-SWS)</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~rupak</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rupakmajumdar/3289b197-9f9a-4880-94c5-d9cf6d764bb1/small.jpg</picture_url>
          <person_id>rupakmajumdar</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8c341dd6-a43b-4c21-a90b-82308ca6e070</subevent_id>
    <title>SPLASH OOPSLA: F-3A</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>75bf2d47-560f-4724-8b5e-13d2941970c8</slot_id>
      <title>Session: SPLASH OOPSLA - F-3A</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>560c9e06-ccb7-4600-9b24-5eefb3879b81</slot_id>
      <event_id>50c0fcb1-ef71-4df6-9d10-ebeddb89add2</event_id>
      <title>Polymorphic Types and Effects with Boolean Unification</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>00:20</end_time>
      <description>We present a simple, practical, and expressive type and effect system based on Boolean constraints. The effect system extends the Hindley-Milner type system, supports parametric polymorphism, and preserves principal types modulo Boolean equivalence. We show how to support type inference by extending Algorithm W with Boolean unification based on the successive variable elimination algorithm.
We implement the type and effect system in the Flix programming language. We perform an in-depth evaluation on the impact of Boolean unification on type inference time and end-to-end compilation time. While the computational complexity of boolean unification is NP-hard, the experimental results demonstrate that it works well in practice. We find that the impact on type inference time is on average a 1.4x slowdown and the overall impact on end-to-end compilation time is a 1.1x slowdown.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jaco</first_name>
          <last_name>van de Pol</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>Jaco van de Pol started his research in Utrecht on rewrite systems, in particular termination of higher-order rewrite systems. At CWI Amsterdam, he published several papers on theorem proving and model checking for concurrent systems in process algebra and contributed to the µCRL toolset. In Twente, he started a new research line on parallel model checking algorithms. This resulted in the LTSmin toolset for high-performance model checking. He worked on applications in embedded systems, safety &amp;amp; security and systems biology. He published ~25 journal papers, ~100 conference papers, and edited ~10 volumes. Publications at Google Scholar and DBLP.
Affiliations:

 MSc Utrecht University (supervisor Hans Zantema)
 PhD Utrecht University (supervisor Jan Bergstra)
 Research Assistant LMU Mathematisches Institute Munich (with Helmut Schwichtenberg)
 Postdoc Technical University of Eindhoven (with Jozef Hooman)
 Senior Researcher CWI (1999-2007)
 Associate Professor Technical University of Eindhoven (2004-2007, 20%)
 Professor Formal Methods and Tools at University of Twente (2007-2018; from Nov 2018 10%)
 Professor Computer Science at Aarhus University (from Nov 2018)
          </bio>
          <homepage_url>http://fmt.cs.utwente.nl/~vdpol/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jacovandepol/b053e08d-fe52-46a9-b4cd-b863ea6c9c07/small.jpg</picture_url>
          <person_id>jacovandepol</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>774389c4-670d-4c1a-b771-fc63423da52d</slot_id>
      <event_id>c3da127b-d137-44d6-888b-a9da4ddc54a5</event_id>
      <title>Verifying and Improving Halide’s Term Rewriting System with Program Synthesis</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>00:00</end_time>
      <description>Halide is a domain-specific language for high-performance image processing and tensor computations, widely adopted in industry. Internally, the Halide compiler relies on a term rewriting system to prove properties of code required for efficient and correct compilation. This rewrite system is a collection of handwritten transformation rules that incrementally rewrite expressions into simpler forms; the system requires high performance in both time and memory usage to keep compile times low. In this work, we apply formal techniques to prove the correctness of existing rewrite rules and provide a guarantee of termination. Then, we build an automatic program synthesis system that operates over the undecidable theory of integers in order to craft new, provably correct rules from failure cases where the compiler was unable to prove properties. We identify and fix 5 incorrect rules as well as 8 rules which could give rise to infinite rewriting loops. We demonstrate that the synthesizer can produce better rules than hand-authored ones in five bug fixes, and describe four cases in which it has served as an assistant to a human compiler engineer. We further show that it can proactively improve weaknesses in the compiler by synthesizing a large number of rules without human supervision and showing that the enhanced ruleset lowers peak memory usage of compiled code without appreciably increasing compilation times.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julie L.</first_name>
          <last_name>Newcomb</last_name>
          <affiliation>University of California at Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jn80842.github.io/</homepage_url>
          <person_id>julielnewcomb</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Adams</last_name>
          <affiliation>Adobe</affiliation>
          <bio>undefined</bio>
          <person_id>andrewadams</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Steven</first_name>
          <last_name>Johnson</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <person_id>stevenjohnson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rastislav</first_name>
          <last_name>Bodik</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://homes.cs.washington.edu/~bodik</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rastislavbodik/ae16ae8e-9d00-41c4-9067-0c37da65dde7/small.jpg</picture_url>
          <person_id>rastislavbodik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Shoaib</first_name>
          <last_name>Kamil</last_name>
          <affiliation>Adobe</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shoaibkamil/2bc60aee-bda5-437e-9e74-e00f5a55c9ef/small.jpg</picture_url>
          <person_id>shoaibkamil</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c548632f-d7df-4952-bdc2-1202e7fc9977</slot_id>
      <event_id>8cf8faa8-1f32-4ec8-b6ba-b5a6fc13efef</event_id>
      <title>Contextual Dispatch for Function Specialization</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>23:20</end_time>
      <description>In order to generate efficient code for dynamic languages, compilers often need information not readily available in the source code. Leveraging a mixture of static and dynamic information, just-in-time compilers can speculate on the missing information. Within one compilation unit, code is specialized to the observed behaviors. We propose an approach to further the specialization, by disentangling classes of behaviors into separate optimization units. With contextual dispatch, functions are versioned and each version is compiled under different assumptions. When a function is invoked, the implementation dispatches to a version that was optimized under assumptions matching the dynamic context of the call. As a proof-of-concept, we describe a compiler for the R language which uses this approach. We evaluate contextual dispatch on a set of benchmarks and compare to traditional speculation with deoptimization techniques. Our implementation is, on average, 1.7× faster than the GNU R reference implementation, and contextual dispatch contributes to the performance significantly in 18 of 46 programs in our benchmark suite.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Flückiger</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.o1o.ch</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/olivierfluckiger/6051271d-0eac-48f3-b931-bff878bbce61/small.jpg</picture_url>
          <person_id>olivierfluckiger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guido</first_name>
          <last_name>Chari</last_name>
          <affiliation>ASAPP Inc</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://charig.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guidochari/a0147ecd-ef4f-404e-ba4a-ffa5894e8830/small.jpg</picture_url>
          <person_id>guidochari</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ming-Ho</first_name>
          <last_name>Yee</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>I’m currently a Ph.D. student in computer science at Northeastern University in Boston, Massachusetts. I work on programming language design and implementation with Jan Vitek.</bio>
          <homepage_url>http://mhyee.com</homepage_url>
          <person_id>minghoyee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jan</first_name>
          <last_name>Jecmen</last_name>
          <affiliation>Czech Technical University</affiliation>
          <bio>undefined</bio>
          <person_id>janjecmen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jakob</first_name>
          <last_name>Hain</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.linkedin.com/in/jakobeha/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jakobhain/d10d3ad5-e905-4e33-93d6-7d1545e3ab22/small.jpg</picture_url>
          <person_id>jakobhain</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ed2a5cb8-35ad-4f8e-8c8b-f01d399f8841</slot_id>
      <event_id>8d09d351-1484-4e6f-a97b-31fc3a8589f5</event_id>
      <title>Fixpoints for the Masses: Programming with First-class Datalog Constraints</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>23:40</end_time>
      <description>Datalog is a declarative logic programming language that has been used in a variety of applications, including big-data analytics, language processing, networking and distributed systems, and program analysis.
In this paper, we propose first-class Datalog constraints as a mechanism to construct, compose, and solve Datalog programs at run time. The benefits are twofold: We gain the full power of a functional programming language to operate on Datalog constraints-as-values, while simultaneously we can use Datalog where it really shines: to declaratively express and solve fixpoint problems.
We present an extension of the lambda calculus with first-class Datalog constraints, including its semantics and a type system with row polymorphism based on Hindley-Milner. We prove soundness of the type system and implement it as an extension of the Flix programming language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>30ccda91-da2d-4258-b786-5b066a131cf8</subevent_id>
    <title>SPLASH OOPSLA: R-5</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>cb2e5aff-9e63-4caf-9039-5a36c0de666b</slot_id>
      <title>Session: SPLASH OOPSLA - R-5</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>486d2d98-a5e2-4d91-af13-39cfcbfcf81e</slot_id>
      <event_id>762acf95-3734-44cf-94f3-333cf54f7969</event_id>
      <title>Precise Static Modeling of Ethereum ``Memory''</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>15:20</end_time>
      <description>Static analysis of smart contracts as-deployed on the Ethereum blockchain has received much recent attention. However, high-precision analyses currently face significant challenges when dealing with the Ethereum VM (EVM) execution model. A major such challenge is the modeling of low-level, transient “memory” (as opposed to persistent, on-blockchain “storage”) that smart contracts employ. Statically understanding the usage patterns of memory is non-trivial, due to the dynamic allocation nature of in-memory buffers. We offer an analysis that models EVM memory, recovering high-level concepts (e.g., arrays, buffers, call arguments) via deep modeling of the flow of values. Our analysis opens the door to Ethereum static analyses with drastically increased precision. One such analysis detects the extraction of ERC20 tokens by unauthorized users. For another practical vulnerability (redundant calls, possibly used as an attack vector), our memory modeling yields analysis precision of 89%, compared to 16% for a state-of-the-art tool without precise memory modeling. Additionally, precise memory modeling enables the static computation of a contract’s gas cost. This gas-cost analysis has recently been instrumental in the evaluation of the impact of the EIP-1884 repricing (in terms of gas costs) of EVM operations, leading to a reward and significant publicity from the Ethereum Foundation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sifis</first_name>
          <last_name>Lagouvardos</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/sifislagouvardos/7bff730b-e719-4f0c-935c-245291f18d9d/small.jpg</picture_url>
          <person_id>sifislagouvardos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Neville</first_name>
          <last_name>Grech</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.nevillegrech.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nevillegrech/e0405613-3240-4ef2-a51f-cb7536870dc5/small.jpg</picture_url>
          <person_id>nevillegrech</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ilias</first_name>
          <last_name>Tsatiris</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/iliastsatiris/b33fd835-f771-4b76-b5e8-00452e460cf7/small.jpg</picture_url>
          <person_id>iliastsatiris</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>Research Interests: programming languages and software engineering

 Program analysis (static analysis, test generation, invariant inference, symbolic execution)
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming)
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality)
          </bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
          <person_id>yannissmaragdakis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>757cfdaa-103f-4f80-a0e0-ce84ef8de68e</slot_id>
      <event_id>e19d9707-bf19-4fc6-a3cd-80b6c920be7f</event_id>
      <title>Exposing Cache Timing Side-channel Leaks through Out-of-order Symbolic Execution</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>16:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>16:20</end_time>
      <description>Out-of-order execution, as one of the fundamental microarchitectural optimizations in modern processors, boosts the pipeline throughput by executing independent instructions in parallel rather than in their program orders. However, due to the side effects from out-of-order execution to the CPU cache, secret-critical applications may suffer from cache timing side-channel leaks. This paper presents a symbolic execution-based technique, named SymO3, for exposing timing leaks under the context of out-of-order execution. SymO3 owns synergetic new components targeting the modeling, reduction, and reasoning challenges of accomodating program analysis methods to the out-of-order behaviors of software programs. We implemented SymO3 upon KLEE and conducted three groups of evaluations on it. Experimental results show that SymO3 successfully uncovers from 31 to 242 cache timing leaks in 3 real-world cipher programs. Also, SymO3 shows that program transformation from aggressive compiler optimizations increases the surface to timing leaks. Furthermore, augmented with speculative modeling, SymO3 identifies five more leaky programs based on a compound analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shengjian</first_name>
          <last_name>Guo</last_name>
          <affiliation>Baidu X-Lab</affiliation>
          <bio>undefined</bio>
          <person_id>shengjianguo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yueqi</first_name>
          <last_name>Chen</last_name>
          <affiliation>The Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <person_id>yueqichen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jiyong</first_name>
          <last_name>Yu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>jiyongyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Meng</first_name>
          <last_name>Wu</last_name>
          <affiliation>Ant Financial</affiliation>
          <bio>undefined</bio>
          <person_id>mengwu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Zhiqiang</first_name>
          <last_name>Zuo</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://zuozhiqiang.bitbucket.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhiqiangzuo/deb374c0-3456-4c74-b48d-8f855a64643c/small.jpg</picture_url>
          <person_id>zhiqiangzuo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Peng</first_name>
          <last_name>Li</last_name>
          <affiliation>Baidu X-Lab</affiliation>
          <bio>undefined</bio>
          <person_id>pengli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Yueqiang</first_name>
          <last_name>Cheng</last_name>
          <affiliation>Baidu Security</affiliation>
          <bio>Yueqiang Cheng is a Senior Staff Security Scientist at Baidu Research and Baidu Security. His research interests are in the areas of data security and privacy, hardware security, and system security. His works have been published on top academic conferences, e.g., IEEE TDSC, ASPLOS, Usenix Security, NDSS, and ICSE.</bio>
          <homepage_url>https://sites.google.com/site/strongerwillcheng/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yueqiangcheng1/62c07e08-2bfd-49de-84a3-43049547d1d7/small.jpg</picture_url>
          <person_id>yueqiangcheng1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ea0d8b9b-7584-492c-85fb-f5918ec2f725</slot_id>
      <event_id>d6245b1d-c06a-4095-a451-8337b829c6c7</event_id>
      <title>Perfectly Parallel Fairness Certification of Neural Networks</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>15:40</end_time>
      <description>Recently, there is growing concern that machine-learning models, which currently assist or even automate decision making, reproduce, and in the worst case reinforce, bias of the training data. The development of tools and techniques for certifying fairness of these models or describing their biased behavior is, therefore, critical. In this paper, we propose a perfectly parallel static analysis for certifying causal fairness of feed-forward neural networks used for classification of tabular data. When certification succeeds, our approach provides definite guarantees, otherwise, it describes and quantifies the biased behavior. We design the analysis to be sound, in practice also exact, and configurable in terms of scalability and precision, thereby enabling pay-as-you-go certification. We implement our approach in an open-source tool and demonstrate its effectiveness on models trained with popular datasets.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Caterina</first_name>
          <last_name>Urban</last_name>
          <affiliation>INRIA &amp; École Normale Supérieure</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://caterinaurban.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/caterinaurban1/a945f9bd-bc13-4fe2-945a-59528d7d7e2a/small.jpg</picture_url>
          <person_id>caterinaurban1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Maria</first_name>
          <last_name>Christakis</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mariachris.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mariachristakis/b7bf39cc-368b-44aa-bbcb-c83734e1e8fa/small.jpg</picture_url>
          <person_id>mariachristakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Valentin</first_name>
          <last_name>Wüstholz</last_name>
          <affiliation>ConsenSys, Germany</affiliation>
          <bio>Valentin is a software security researcher at ConsenSys Diligence and has held positions both in academia (at ETH Zürich and UT Austin) and in industry (at Microsoft and Google). He is passionate about developing tools and techniques that allow us to produce more reliable and correct software.</bio>
          <homepage_url>http://www.wuestholz.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/valentinwustholz/c6ff5691-4f3e-472c-8454-168eaaebb7eb/small.jpg</picture_url>
          <person_id>valentinwustholz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Fuyuan</first_name>
          <last_name>Zhang</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
          <person_id>fuyuanzhang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f4f0fc68-04ed-42b3-8acf-32a00bf9ee21</slot_id>
      <event_id>8f64a7c7-6637-4768-a862-bef448adb89f</event_id>
      <title>Taming Callbacks for Smart Contract Modularity</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>16:00</end_time>
      <description>Callbacks are an effective programming discipline for implementing event-driven programming, especially in environments like Ethereum which forbid shared global state and concurrency. Callbacks allow a callee to delegate the execution back to the caller. Though effective, they can lead to subtle mistakes principally in open environments where callbacks can be added in a new code. Indeed, several high profile bugs in smart contracts exploit callbacks. We present the first static technique ensuring \emph{modularity} in the presence of callbacks and apply it to verify prominent smart contracts. Modularity ensures that external calls to other contracts cannot affect the behavior of the contract. Importantly, modularity is guaranteed without restricting programming.
In general, checking modularity is undecidable—even for programs without loops. This paper describes an effective technique for soundly ensuring modularity harnessing SMT solvers. The main idea is to define a constructive version of modularity using \emph{commutativity} and \emph{projection} operations on program segments. We believe that this approach is also accessible to programmers, since counterexamples to modularity can be generated automatically by the SMT solvers, allowing programmers to understand and fix the error.
We implemented our approach in order to demonstrate the precision of the modularity analysis and applied it to real smart contracts, including a subset of the 150 most active contracts in Ethereum. Our implementation decompiles bytecode programs into an intermediate representation and then implements the modularity checking using SMT queries. Overall, we argue that our experimental results indicate that the method can be applied to many realistic contracts, and that it is able to prove modularity where other methods fail.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Elvira</first_name>
          <last_name>Albert</last_name>
          <affiliation>Complutense University of Madrid</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/elviraalbert1/9c4fd401-4969-4cc6-ba12-d79d92acee62/small.jpg</picture_url>
          <person_id>elviraalbert1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shelly</first_name>
          <last_name>Grossman</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shellygrossman/c4b389a6-6165-44ef-a938-4b1acbecaaa8/small.jpg</picture_url>
          <person_id>shellygrossman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Noam</first_name>
          <last_name>Rinetzky</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~maon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/noamrinetzky/1ea9bd0d-bd16-4b15-bb66-a8a576ffaa40/small.jpg</picture_url>
          <person_id>noamrinetzky</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Clara</first_name>
          <last_name>Rodríguez</last_name>
          <affiliation>Complutense University of Madrid</affiliation>
          <bio>undefined</bio>
          <person_id>clararodriguez</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Albert</first_name>
          <last_name>Rubio</last_name>
          <affiliation>Complutense University of Madrid</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://costa.fdi.ucm.es/~arubio/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/albertrubio1/effd4c9a-16fb-4d5d-83cb-a32d83d40c47/small.jpg</picture_url>
          <person_id>albertrubio1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Mooly</first_name>
          <last_name>Sagiv</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>My research focuses on easing the task of developing reliable and efficient software systems. I am particularly interested in static program analysis which combines two disciplines: automated theorem proving and abstract interpretation. In the next decade, I am hoping to develop useful techniques in order to change the ways modern software is built. I am particularly interested in proof automation, given a program and a requirement, automatically prove or disprove that all executions of the program satisfy the requirements. This problem is in general undecidable and untractable. I am interested in developing practical solutions to proof-automation by: (i) exploring modularity of the system and (ii) relying on semi-automatic and interactive process, where the user manually and interactively guides the proof automation, and (iii) simplifying the verification task by using domain-specific abstractions expressed in a decidable logic. I am applying these techniques to verify safety of liveness of distributed systems.</bio>
          <homepage_url>http://www.cs.tau.ac.il/~msagiv/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/moolysagiv/5ff34ce2-4812-410c-aa6d-e1457fc2f1ac/small.jpg</picture_url>
          <person_id>moolysagiv</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f808aa73-9cc1-41d5-bf89-5dd19de1a31a</subevent_id>
    <title>SPLASH OOPSLA: F-2B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>847782a8-b7b2-4e93-869f-b44df20d8889</slot_id>
      <title>Session: SPLASH OOPSLA - F-2B</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1e451afe-cdf6-4c0d-aedc-d976c7a047f5</slot_id>
      <event_id>cd599ff5-f878-4129-adc0-ffafc2709664</event_id>
      <title>Feedback-Driven Semi-Supervised Synthesis of Program Transformations</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>09:20</end_time>
      <description>It is fairly common for developers to make repeated edits in code that are all instances of a more-general program transformation. Since this process can be tedious and error-prone, we study the problem automatically learning program transformations from past edits, which can then be used to predict future edits. We take the novel view of the problem as a semi-supervised learning problem: apart from the concrete edits that are instances of the general transformation, the learning procedure also exploits access to additional inputs (program subtrees) that are marked as positive or negative depending on whether the transformation applies on those inputs. We present a procedure to solve the semi-supervised transformation learning problem using anti-unification and programming-by-example synthesis technology. To eliminate reliance on access to marked additional inputs, we generalize the semi-supervised learning procedure to a feedback-driven procedure that also generates the marked additional inputs in an iterative loop. We apply these ideas to build and evaluate three applications that use different mechanisms for generating feedback. Compared to existing tools that learn program transformations from edits, our feedback-driven semi-supervised approach is vastly more effective in successfully predicting edits with significantly fewer past edit data.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiang</first_name>
          <last_name>Gao</last_name>
          <affiliation>National University of Singapore, Singapore</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.comp.nus.edu.sg/~gaoxiang/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xianggao/482ff4c5-f003-40e7-90cc-d888adbd1e2f/small.jpg</picture_url>
          <person_id>xianggao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shraddha</first_name>
          <last_name>Barke</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shraddhabarke1/4e11ed13-0f46-4d77-8a6d-dd4c07b7fd4b/small.jpg</picture_url>
          <person_id>shraddhabarke1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Radhakrishna</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://arjunradhakrishna.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjunradhakrishna/5187c933-18de-4045-9119-d97023dd12b7/small.jpg</picture_url>
          <person_id>arjunradhakrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gustavo</first_name>
          <last_name>Soares</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://gustavoasoares.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gustavosoares/fc1e5a17-f939-4c3d-ab30-85467cb2610b/small.jpg</picture_url>
          <person_id>gustavosoares</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Alan</first_name>
          <last_name>Leung</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://alan.leung.work</homepage_url>
          <person_id>alanleung</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Nachiappan</first_name>
          <last_name>Nagappan</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/nachin/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nachiappannagappan/c34b7330-eb7e-4bf2-8d02-32395689de52/small.jpg</picture_url>
          <person_id>nachiappannagappan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Ashish</first_name>
          <last_name>Tiwari</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.csl.sri.com/users/tiwari/</homepage_url>
          <person_id>ashishtiwari</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5bc75700-b762-4b5c-8286-28456ab6e56b</slot_id>
      <event_id>aed381e3-4082-4aea-8916-ec4572cabcbf</event_id>
      <title>Testing Differential Privacy with Dual Interpreters</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>09:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>09:40</end_time>
      <description>Applying differential privacy at scale requires convenient ways to check that programs computing with sensitive data appropriately preserve privacy. We propose here a fully automated framework for testing differential privacy, adapting a well-known “pointwise” technique from informal proofs of differential privacy. Our framework, called FuzzDP, requires no programmer annotations, handles all previously verified or tested algorithms, and is the first fully automated framework to distinguish correct and buggy implementations of PrivTree, a probabilistically terminating algorithm that has not previously been mechanically checked.
We analyze the probability of FuzzDP mistakenly accepting a non-private program and prove that, theoretically, the probability of false acceptance can be made exponentially small by suitable choice of test size.
We demonstrate FuzzDP’s utility empirically by implementing all benchmark algorithms from prior work on mechanical verification of differential privacy, plus several others and their incorrect variants, and show FuzzDP accepts the correct implementations and rejects the incorrect variants.
We also demonstrate how FuzzDP can be deployed in a practical workflow to test differentially privacy for the 2020 US Census Disclosure Avoidance System (DAS).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hengchu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <person_id>hengchuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Edo</first_name>
          <last_name>Roth</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <person_id>edoroth</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin C.</first_name>
          <last_name>Pierce</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>Benjamin Pierce is Henry Salvatori Professor of Computer and Information Science at the University of Pennsylvania and a Fellow of the ACM. His research interests include programming languages, type systems, language-based security, computer-assisted formal verification, differential privacy, and synchronization technologies. He is the author of the widely used graduate textbooks Types and Programming Languages and Software Foundations. He has served as co-Editor in Chief of the Journal of Functional Programming, as Managing Editor for Logical Methods in Computer Science, and as editorial board member of Mathematical Structures in Computer Science, Formal Aspects of Computing, and ACM Transactions on Programming Languages and Systems. He is also the lead designer of the popular Unison file synchronizer and co-developer of the Clowdr virtual conference platform.</bio>
          <homepage_url>http://www.cis.upenn.edu/~bcpierce/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/benjamincpierce/f2ee6f41-5bf7-4a0d-9b8d-71de6a666b1b/small.jpg</picture_url>
          <person_id>benjamincpierce</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Roth</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <person_id>aaronroth</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Haeberlen</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <person_id>andreashaeberlen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bceecc5f-13d0-48be-b3ad-dea83c68bfad</slot_id>
      <event_id>9759a59c-e7fe-44ff-91d0-9250476fa15d</event_id>
      <title>Differentially-Private Software Frequency Profiling Under Linear Constraints</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>10:20</end_time>
      <description>Differential privacy has emerged as a leading theoretical framework for privacy-preserving data gathering and analysis. It allows meaningful statistics to be collected for a population without revealing “too much” information about any individual member of the population. For software profiling, this machinery allows profiling data from many users of a deployed software system to be collected and analyzed in a privacy-preserving manner. Such a solution is appealing to many stakeholders, including software users, software developers, infrastructure providers, and government agencies.
We propose an approach for differentially-private collection of frequency vectors from software executions. Frequency information is reported with the addition of random noise drawn from the Laplace distribution. A key observation behind the design of our scheme is that event frequencies are closely correlated due to the static code structure. Differential privacy protections must account for such relationships; otherwise, a seemingly-strong privacy guarantee is actually weaker than it appears. Motivated by this observation, we propose a novel and general differentially-private profiling scheme when correlations between frequencies can be expressed through linear inequalities. Using a linear programming formulation, we show how to determine the magnitude of random noise that should be added to achieve meaningful privacy protections under such linear constraints. Next, we develop an efficient instance of this general machinery for an important subclass of constraints. Instead of LP, our solution uses a reachability analysis of a constraint graph. As an exemplar, we employ this approach to implement differentially-private method frequency profiling for Android apps.
Any differentially-private scheme has to balance two competing aspects: privacy and accuracy. Through an experimental study to characterize these trade-offs, we (1) show that our proposed randomization achieves much higher accuracy compared to related prior work, (2) demonstrate that high accuracy and high privacy protection can be achieved simultaneously, and (3) highlight the importance of linear constraints in the design of the randomization. These promising results provide evidence that our approach is a good candidate for privacy-preserving frequency profiling of deployed software.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hailong</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Fordham University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hailongzhang.com</homepage_url>
          <person_id>hailongzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yu</first_name>
          <last_name>Hao</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>yuhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sufian</first_name>
          <last_name>Latif</last_name>
          <affiliation>Ohio State University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>sufianlatif</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Raef</first_name>
          <last_name>Bassily</last_name>
          <affiliation>Ohio State University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>raefbassily</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Atanas</first_name>
          <last_name>Rountev</last_name>
          <affiliation>Ohio State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.ohio-state.edu/~rountev</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/atanasrountev/57ea0ee0-eebe-48f0-91fe-1ed3a28b5d92/small.jpg</picture_url>
          <person_id>atanasrountev</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f2b57e56-2c01-4dcf-a2fb-3bfccb7a24f0</slot_id>
      <event_id>3d4eac8d-6c79-48a8-b5ab-8b400d1a80ee</event_id>
      <title>Unifying Execution of Imperative Generators and Declarative Specifications</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>10:00</end_time>
      <description>We present Deuterium—a framework for implementing Java methods as executable contracts. Deuterium introduces a novel, type-safe way to write method contracts entirely in Java, as a combination of imperative generators and declarative specifications (written in a first-order relational logic with transitive closure). Existing approaches are typically based on encoding both the specification and the program heap into a constraint language, and then using an off-the-shelf constraint solver—without any additional guidance—to search for a new program heap that satisfies the specification. Deuterium takes the advantage of user-provided generators to prune the search space and reduce incurred overhead of constraint solving. Deuterium supports two ways to solving declarative constraints: SAT-based and search-based with in-memory state exploration. We evaluate our approach on a suite of data structures, established as a standard benchmark by prior work. Furthermore, we use random and sequence-based test generation to create a new benchmark designed to mimic more realistic execution scenarios. Our results show that generators improve performance of executable contracts and that in-memory state exploration is the algorithm of choice when heap sizes are small.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pengyu</first_name>
          <last_name>Nie</last_name>
          <affiliation>The University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cozy.ece.utexas.edu/~pynie/</homepage_url>
          <person_id>pengyunie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marinela</first_name>
          <last_name>Parovic</last_name>
          <affiliation>The University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>marinelaparovic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhiqiang</first_name>
          <last_name>Zang</last_name>
          <affiliation>The University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>zhiqiangzang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sarfraz</first_name>
          <last_name>Khurshid</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/sarfrazkhurshid/b998e03f-4c99-458b-a9f9-b6c470511e3b/small.jpg</picture_url>
          <person_id>sarfrazkhurshid</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Aleksandar</first_name>
          <last_name>Milicevic</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>aleksandarmilicevic2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Milos</first_name>
          <last_name>Gligoric</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/milosgligoric/4d0671ae-937e-4f08-b499-092379ff7ad3/small.jpg</picture_url>
          <person_id>milosgligoric</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0dea8e8b-8f06-4175-8904-47d820bd3113</subevent_id>
    <title>SPLASH OOPSLA: W-1</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>eafa6481-2c1c-43a9-ba74-08c92809bcc2</slot_id>
      <title>Session: SPLASH OOPSLA - W-1</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>07:00</start_time>
      <end_time>08:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>71b50b13-174a-44ce-baaa-328c8c04482e</slot_id>
      <event_id>ab26b4f9-908b-48a6-88f1-36f0a94e32cc</event_id>
      <title>Mossad: Defeating Software Plagiarism Detection</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>07:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>07:20</end_time>
      <description>Automatic software plagiarism detection tools are widely used in educational settings to ensure that submitted work was not copied. Reliance on these tools has grown along with enrollments in computer science programs and the widespread availability of code on-line. A key requirement of plagiarism detectors is that the effort required to evade detection must be as high as the effort required to actually do the assigned work.
This paper demonstrates an entirely automatic program transformation approach that defeats popular software plagiarism detection tools. We present Mossad, a framework that couples techniques inspired by genetic programming with domain-specific knowledge to effectively undermine plagiarism detectors. Mossad is effective at defeating three plagiarism detectors, including Moss and JPlag. We show that Mossad is both fast and effective. It can, in minutes, generate modified versions of programs that are likely to escape detection. More insidiously, because of its non-deterministic approach, Mossad can, from a single program, generate dozens of variants, which are classified as no more suspicious than legitimate assignments. We present a detailed study of Mossad across a corpus of real student assignments, demonstrating its efficacy at evading detection. We perform a user study and find that graduate student assistants consistently rate Mossad-generated code as just as readable as authentic student code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Breanna</first_name>
          <last_name>Devore-McDonald</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>undefined</bio>
          <person_id>breannadevoremcdonald</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Emery</first_name>
          <last_name>Berger</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>Emery is a Professor at the University of Massachusetts Amherst. He researches languages, runtime systems, and operating systems, with a particular focus on systems that transparently improve reliability, security, and performance. Emery and friends have created Hoard, the first scalable memory manager (malloc), on which the Mac OS X memory manager is based; DieHard, an error-avoiding memory manager that directly influenced the design of the Windows 7 Fault-Tolerant Heap; DieHarder, a secure memory manager that was an inspiration for hardening changes made to the Windows 8 heap; the Coz profiler, which ships with modern Linux distros; and more. He was named an ACM Fellow in 2019.</bio>
          <homepage_url>http://www.emeryberger.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/emeryberger/6187feeb-700c-48d5-aceb-6d7b87490a7a/small.jpg</picture_url>
          <person_id>emeryberger</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8d96bdf5-144b-44ef-884f-b0eb117fd24f</slot_id>
      <event_id>fcd71652-1e16-475e-bda3-bcb0432637a2</event_id>
      <title>Program Equivalence for Assisted Grading of Functional Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>07:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>08:00</end_time>
      <description>Courses that grade programming assignments are frequently forced to compromise between scale and quality of feedback. Human graders give useful feedback but have difficulty consistently grading many programs while automatic graders can scale well but are limited in the feedback they can provide. While there are many efforts to improve the feedback quality of automatic graders, research into building tools for assisting human grading of programs is limited. We propose a technique for identifying equivalences between student submissions to enable human graders to give targeted feedback for multiple student submissions at once. Our technique is conservative in two ways. First, our technique identifies equivalence between submissions by finding equivalences between each submissions’ subexpressions, so the technique only identifies equivalence between submissions when they are algorithmically similar. Second, our technique uses formal methods to identify equivalence pairwise rather than using standard clustering algorithms from the machine learning literature. This allows us to prove a soundness result that guarantees that submissions will never be clustered together in error. Despite only reporting equivalence when there is algorithmic similarity and the ability to formally prove equivalence, we show that our technique can significantly reduce grading time for thousands of programming submissions from an introductory functional programming course.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Clune</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>joshuaclune</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vijay</first_name>
          <last_name>Ramamurthy</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>vijayramamurthy</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ruben</first_name>
          <last_name>Martins</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Ruben Martins is a Systems Scientist at the Carnegie Mellon University. Prior to joining CMU, he was a postdoctoral researcher at UT Austin where he pushed the frontiers of program synthesis and security with constraint solving. Before UT Austin, he was a postdoctoral researcher at the University of Oxford, UK where he worked on CBMC for software verification. He received his PhD with honors from the University of Lisbon, Portugal in 2013. His research aims to improve constraint solvers and broaden their applicability in program analysis, synthesis, and security. Dr. Martins has developed several award winning solvers and has consistently improved the state-of-the-art in MaxSAT solving. He is currently the main developer of Open-WBO: an open source MaxSAT solver that won several awards in the MaxSAT competitions.</bio>
          <homepage_url>https://sat-group.github.io/ruben/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rubenmartins/6cfee429-6785-4395-bcf6-ddb6dd674d58/small.jpg</picture_url>
          <person_id>rubenmartins</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Umut A.</first_name>
          <last_name>Acar</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/umutacar/645140f1-714c-4def-ab34-8c78d85a50bf/small.jpg</picture_url>
          <person_id>umutacar</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ec9e935a-4be4-4acd-bf43-2d1fee10ca06</slot_id>
      <event_id>15674d02-5f12-493f-b843-8068fb89ee09</event_id>
      <title>Revisiting Iso-Recursive Subtyping</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>08:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>08:20</end_time>
      <description>The Amber rules are well-known and widely used for subtyping iso-recursive types. They were first briefly and informally introduced in 1985 by Cardelli in a manuscript describing the Amber language. Despite their use over many years, important aspects of the metatheory of the iso-recursive style Amber rules have not been studied in depth or turn out to be quite challenging to formalize. This paper aims to revisit the problem of subtyping iso-recursive types. We start by introducing a novel declarative specification that we believe captures the “spirit” of Amber-style iso-recursive subtyping. Informally, the specification states that two recursive types are subtypes \emph{if all their finite unfoldings are subtypes}. The Amber rules are shown to be sound with respect to this declarative specification. We then derive a \emph{sound}, \emph{complete} and \emph{decidable} algorithmic formulation of subtyping that employs a novel \emph{double unfolding} rule. Compared to the Amber rules, the double unfolding rule has the advantage of: 1) \emph{being modular}; 2) \emph{not requiring reflexivity} to be built in; and 3) leading to an \emph{easy proof of transitivity of subtyping}. This work sheds new insights on the theory of subtyping iso-recursive types, and the new double unfolding rule has important advantages over the original Amber rules for both implementations and metatheoretical studies involving recursive types. All results are mechanically formalized in the Coq theorem prover. Furthermore, as far as we know, this is the first comprehensive treatment of iso-recursive subtyping in a theorem prover, which can deal with \emph{unrestricted} recursive types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yaoda</first_name>
          <last_name>Zhou</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <person_id>yaodazhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>The University of Hong Kong, Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jinxu</first_name>
          <last_name>Zhao</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <person_id>jinxuzhao</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ece7329c-1b58-4a64-a100-9eb5c38195bb</slot_id>
      <event_id>68a84a17-ccd2-48b6-9085-63301738428f</event_id>
      <title>Precise Inference of Expressive Units of Measurement Types</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>07:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>07:40</end_time>
      <description>Ensuring computations are unit-wise consistent is an important task in software development. Numeric computations are usually performed with primitive types instead of abstract data types, which results in very weak static guarantees about correct usage and conversion of units. This paper presents PUnits, a pluggable type system for expressive units of measurement types and a precise, whole-program inference approach for these types. PUnits can be used in three modes: (1) modularly check the correctness of a program, (2) ensure a possible unit typing exist, (3) annotate a program with units. Annotation mode allows human inspection and is essential since having a valid typing does not guarantee that the inferred specification expresses design intent. PUnits is the first units type system with this capability. Compared to prior work, PUnits strikes a novel balance between expressiveness, inference complexity, and annotation effort. We implement PUnits for Java and evaluate it by specifying the correct usage of frequently used JDK methods. We analyzed 234k lines of code from eight open-source scientific computing projects with PUnits, which inferred 87 scientific units and generated well-specified applications. The experiments show that PUnits provides an effective, sound, and scalable alternative to using encapsulation-based units APIs (like javax.measure), enabling Java developers to reap the performance benefits of using primitive types instead of abstract data types for unit-wise consistent scientific computations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tongtong</first_name>
          <last_name>Xiang</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>tongtongxiang1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jeff</first_name>
          <last_name>Luo</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>jeffluo1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Werner</first_name>
          <last_name>Dietl</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ece.uwaterloo.ca/~wdietl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/wernerdietl/f6ddc3ef-7134-4260-a182-a71ed88842cb/small.jpg</picture_url>
          <person_id>wernerdietl</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>be31db10-0385-4df5-946a-6f8a8275e9d4</subevent_id>
    <title>SPLASH OOPSLA: W-4</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>f6016ecb-9d16-4158-af26-47eac54700b7</slot_id>
      <title>Session: SPLASH OOPSLA - W-4</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1de870e1-2600-4470-b0ff-459a82a1ab96</slot_id>
      <event_id>589e08b8-be04-449c-9c40-7dc3797f2c0b</event_id>
      <title>Adversarial Examples for Models of Code</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>01:20</end_time>
      <description>Neural models of code have shown impressive performance for tasks such as predicting method names and identifying certain kinds of bugs. In this paper, we show that these models are vulnerable to adversarial examples, and introduce a novel approach for attacking trained models of code with adversarial examples. The main idea is to force a given trained model to make an incorrect prediction as specified by the adversary, by introducing small perturbations that do not change the program’s semantics. To find such perturbations, we present a new technique for Discrete Adversarial Manipulation of Programs (DAMP). DAMP works by deriving the desired prediction with respect to the model’s inputs while holding the model weights constant, and following the gradients to slightly modify the input code.
We show that our DAMP attack is effective across three neural architectures: code2vec, GGNN, and GNN-FiLM, in both Java and C#. We show that DAMP has up to 89% success rate in changing a prediction to the adversary’s choice (“targeted attack”), and a success rate of up to 94% in changing a given prediction to any incorrect prediction (“non-targeted attack”). To defend a model against such attacks, we examine a variety of possible defenses empirically and discuss their trade-offs. We show that some of these defenses drop the success rate of the attacker drastically, with a minor penalty of 2% relative degradation in accuracy while not performing under attack.
Our code, data, and trained models are available at https://github.com/tech-srl/adversarial-examples .</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Noam</first_name>
          <last_name>Yefet</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <person_id>noamyefet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Uri</first_name>
          <last_name>Alon</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~urialon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/urialon/a0488e4f-5173-472b-af25-10666c27e3d4/small.jpg</picture_url>
          <person_id>urialon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion</affiliation>
          <bio>Eran Yahav is an associate professor at the Computer Science Department, Technion, Israel. Prior to that, he was a research staff member at the IBM T.J. Watson Research Center (2004-2010). He received his Ph.D. from Tel Aviv University (2005) and his B.Sc. from the Technion in 1996. His research interests include program analysis, program synthesis and program verification. Eran is a recipient of the prestigious Alon Fellowship for Outstanding Young Researchers, the Andre Deloro Career Advancement Chair in Engineering, the ERC Consolidator Grant as well as multiple best paper awards at various conferences.</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
          <person_id>eranyahav</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>599b99ef-463c-4756-9056-3672194b0c04</slot_id>
      <event_id>c3abeda5-100d-409c-8506-b3ec6c6db79f</event_id>
      <title>Finding Bugs in Database Systems via Query Partitioning</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>01:40</end_time>
      <description>Logic bugs in Database Management Systems (DBMS) are bugs that cause an incorrect result for a given query (e.g., by omitting a row that should be fetched). These bugs are critical, since they are likely to go unnoticed by users. We propose Query Partitioning, a general and effective approach for finding logic bugs in DBMS. The core idea of Query Partitioning is to, starting from a given original query, derive multiple, more complex queries (called partitioning queries), each of which computes a partition of the result. The individual partitions are then composed to compute a result set that must be equivalent to the original query’s result set. A bug in the DBMS is detected when these result sets differ. Our intuition is that due to the increased complexity, the partitioning queries are more likely to stress the DBMS and trigger a logic bug than the original query. As a concrete instance of a partitioning strategy, we propose Ternary Logic Partitioning (TLP), which is based on the observation that a boolean predicate p can either evaluate to TRUE, FALSE, or NULL. Accordingly, a query can be decomposed to three partitioning queries, each of which computes its result on rows or intermediate results for which p, NOT p, and p IS NULL hold. This technique is versatile, and can be used to test WHERE, GROUP BY, as well as HAVING clauses, aggregate functions, and DISTINCT queries. As part of an extensive testing campaign, we found 175 bugs in widely-used DBMS such as MySQL, TiDB, SQLite, and CockroachDB, 123 of which have been fixed. Notably, 77 of these were logic bugs, while the remaining error and crash bugs. We expect that the effectiveness and wide applicability of Query Partitioning will lead to its broad adoption in practice, and the formulation of additional partitioning strategies.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Rigger</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>Manuel Rigger is a postdoctoral researcher in the Advanced Software Technologies (AST) Lab at ETH Zurich, mentored by Zhendong Su. He is working on programming language implementation, software reliability, and systems. He completed his PhD at Johannes Kepler University Linz, mentored by Hanspeter Mössenböck, and is known for his work on Sulong to support the safe execution of LLVM-based languages.</bio>
          <homepage_url>http://www.manuelrigger.at/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manuelrigger/47e268e9-158c-471f-a7e9-442216c54550/small.jpg</picture_url>
          <person_id>manuelrigger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8f15d83b-6d81-4b50-9275-c4f59a5fd856</slot_id>
      <event_id>dba90368-d2da-4b07-8bd6-dc1e3f236813</event_id>
      <title>How Do Programmers Use Unsafe Rust?</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>02:20</end_time>
      <description>Rust’s ownership type system enforces a strict discipline on how memory locations are accessed and shared. This discipline allows the compiler to statically prevent memory errors, data races, inadvertent side effects through aliasing, and other errors that occur frequently in conventional imperative programs. However, the restrictions imposed by Rust’s type system make it difficult or impossible to implement certain designs, such as data structures that require aliasing (e.g., doubly-linked lists and shared caches). To work around this limitation, Rust allows code blocks to be declared as unsafe and thereby exempted from certain restrictions of the type system, for instance, to manipulate C-style raw pointers. Ensuring the safety of unsafe code is the responsibility of the programmer. However, a important assumption of the Rust language, which we dub the Rust hypothesis, is that programmers use Rust by following three main principles: use unsafe sparingly, make it easy to review, and hide behind a safe abstraction such that client code can be written in safe Rust.
Understanding how Rust programmers use unsafe code and, in particular, whether the Rust hypothesis holds is essential for Rust developers and testers, language and library designers, as well as tool developers. This paper studies empirically how unsafe code is used in practice by analyzing a large corpus of Rust projects to assess the validity of the Rust hypothesis and to classify the purpose of unsafe code. We identify queries that can be answered by automatically inspecting the program structure, its intermediate representation MIR, as well as type information provided by the Rust compiler, and complement the results by manual code inspection. Our study supports the Rust hypothesis partially: While most unsafe code is simple and well-encapsulated, unsafe features are used extensively, especially for interoperability with other languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vytautas</first_name>
          <last_name>Astrauskas</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>vytautasastrauskas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Matheja</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>christophmatheja1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Federico</first_name>
          <last_name>Poli</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <person_id>federicopoli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Peter</first_name>
          <last_name>Müller</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/petermller/aeb8e276-62cb-4ad1-aa7d-96f76c0c405d/small.jpg</picture_url>
          <person_id>petermller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Alexander J.</first_name>
          <last_name>Summers</last_name>
          <affiliation>The University of British Columbia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.inf.ethz.ch/summersa/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alexanderjsummers/f97b84a8-d46a-4e76-aa73-cc4b38c4ec41/small.jpg</picture_url>
          <person_id>alexanderjsummers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f596b67d-f56e-4446-b8b1-cf6b32dc1681</slot_id>
      <event_id>9609351d-7346-41c3-a781-926327d9a68c</event_id>
      <title>Proving Highly-Concurrent Traversals Correct</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>02:00</end_time>
      <description>Modern highly-concurrent search data structures, such as search trees, obtain multi-core scalability and performance by having operations traverse the data structure without any synchronization. As a result, however, these algorithms are notoriously difficult to prove linearizable, which requires identifying a point in time in which the traversal’s result is correct. The problem is that traversing the data structure as it undergoes modifications leads to complex behaviors, requiring intricate reasoning about all interleavings of reads by traversals and writes mutating the data structure.
In this paper, we present a general proof technique for proving unsynchronized traversals correct in a significantly simpler manner, compared to typical concurrent reasoning and prior proof techniques. Our framework relies only on \emph{sequential properties} of traversals and on a conceptually simple and widely-applicable condition about the ways an algorithm’s writes mutate the data structure. Establishing that a target data structure satisfies our condition requires only simple concurrent reasoning, without considering interactions of writes and reads. This reasoning can be further simplified by using our framework.
To demonstrate our technique, we apply it to prove several interesting and challenging concurrent binary search trees: the logical-ordering AVL tree, the Citrus tree, and the full contention-friendly tree. Both the logical-ordering tree and the full contention-friendly tree are beyond the reach of previous approaches targeted at simplifying linearizability proofs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yotam</first_name>
          <last_name>Feldman</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/research/yotam.feldman/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yotamfeldman/ed864714-e66c-4ec1-a171-8c2ac69d62a1/small.jpg</picture_url>
          <person_id>yotamfeldman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Artem</first_name>
          <last_name>Khyzha</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <person_id>artemkhyzha1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Constantin</first_name>
          <last_name>Enea</last_name>
          <affiliation>IRIF, University Paris Diderot &amp; CNRS</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~cenea/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/constantinenea/2dfe8bfe-ddfe-4012-a2e2-01cc8b953734/small.jpg</picture_url>
          <person_id>constantinenea</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Adam</first_name>
          <last_name>Morrison</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~mad</homepage_url>
          <person_id>adammorrison1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Aleksandar</first_name>
          <last_name>Nanevski</last_name>
          <affiliation>IMDEA Software Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://software.imdea.org/~aleks</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aleksandarnanevski/6612f235-0493-478f-9ecd-d86045a7619a/small.jpg</picture_url>
          <person_id>aleksandarnanevski</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Noam</first_name>
          <last_name>Rinetzky</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~maon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/noamrinetzky/1ea9bd0d-bd16-4b15-bb66-a8a576ffaa40/small.jpg</picture_url>
          <person_id>noamrinetzky</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Sharon</first_name>
          <last_name>Shoham</last_name>
          <affiliation>Tel Aviv university</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.tau.ac.il/~sharonshoham/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sharonshoham/52ca243a-805e-43b9-9f5a-bd1bae25fccb/small.jpg</picture_url>
          <person_id>sharonshoham</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2454dc0e-cdf4-42ed-a692-ef9118122ca9</subevent_id>
    <title>SPLASH OOPSLA: W-1</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>a4cc183c-b9c9-4e29-a6ed-46d15cd2ec44</slot_id>
      <title>Session: SPLASH OOPSLA - W-1</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>19:00</start_time>
      <end_time>20:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>30ff694a-ce3a-4378-9a3f-dcd9c431b282</slot_id>
      <event_id>15674d02-5f12-493f-b843-8068fb89ee09</event_id>
      <title>Revisiting Iso-Recursive Subtyping</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>20:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>20:20</end_time>
      <description>The Amber rules are well-known and widely used for subtyping iso-recursive types. They were first briefly and informally introduced in 1985 by Cardelli in a manuscript describing the Amber language. Despite their use over many years, important aspects of the metatheory of the iso-recursive style Amber rules have not been studied in depth or turn out to be quite challenging to formalize. This paper aims to revisit the problem of subtyping iso-recursive types. We start by introducing a novel declarative specification that we believe captures the “spirit” of Amber-style iso-recursive subtyping. Informally, the specification states that two recursive types are subtypes \emph{if all their finite unfoldings are subtypes}. The Amber rules are shown to be sound with respect to this declarative specification. We then derive a \emph{sound}, \emph{complete} and \emph{decidable} algorithmic formulation of subtyping that employs a novel \emph{double unfolding} rule. Compared to the Amber rules, the double unfolding rule has the advantage of: 1) \emph{being modular}; 2) \emph{not requiring reflexivity} to be built in; and 3) leading to an \emph{easy proof of transitivity of subtyping}. This work sheds new insights on the theory of subtyping iso-recursive types, and the new double unfolding rule has important advantages over the original Amber rules for both implementations and metatheoretical studies involving recursive types. All results are mechanically formalized in the Coq theorem prover. Furthermore, as far as we know, this is the first comprehensive treatment of iso-recursive subtyping in a theorem prover, which can deal with \emph{unrestricted} recursive types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yaoda</first_name>
          <last_name>Zhou</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <person_id>yaodazhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>The University of Hong Kong, Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jinxu</first_name>
          <last_name>Zhao</last_name>
          <affiliation>The University of Hong Kong</affiliation>
          <bio>undefined</bio>
          <person_id>jinxuzhao</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7dd4dd57-0180-4966-a2cb-c7b9ba64cbac</slot_id>
      <event_id>68a84a17-ccd2-48b6-9085-63301738428f</event_id>
      <title>Precise Inference of Expressive Units of Measurement Types</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>19:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>19:40</end_time>
      <description>Ensuring computations are unit-wise consistent is an important task in software development. Numeric computations are usually performed with primitive types instead of abstract data types, which results in very weak static guarantees about correct usage and conversion of units. This paper presents PUnits, a pluggable type system for expressive units of measurement types and a precise, whole-program inference approach for these types. PUnits can be used in three modes: (1) modularly check the correctness of a program, (2) ensure a possible unit typing exist, (3) annotate a program with units. Annotation mode allows human inspection and is essential since having a valid typing does not guarantee that the inferred specification expresses design intent. PUnits is the first units type system with this capability. Compared to prior work, PUnits strikes a novel balance between expressiveness, inference complexity, and annotation effort. We implement PUnits for Java and evaluate it by specifying the correct usage of frequently used JDK methods. We analyzed 234k lines of code from eight open-source scientific computing projects with PUnits, which inferred 87 scientific units and generated well-specified applications. The experiments show that PUnits provides an effective, sound, and scalable alternative to using encapsulation-based units APIs (like javax.measure), enabling Java developers to reap the performance benefits of using primitive types instead of abstract data types for unit-wise consistent scientific computations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tongtong</first_name>
          <last_name>Xiang</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>tongtongxiang1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jeff</first_name>
          <last_name>Luo</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>jeffluo1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Werner</first_name>
          <last_name>Dietl</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ece.uwaterloo.ca/~wdietl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/wernerdietl/f6ddc3ef-7134-4260-a182-a71ed88842cb/small.jpg</picture_url>
          <person_id>wernerdietl</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>81ff04ab-ce8d-4ca5-9277-9ca366d7dc0c</slot_id>
      <event_id>fcd71652-1e16-475e-bda3-bcb0432637a2</event_id>
      <title>Program Equivalence for Assisted Grading of Functional Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>19:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>20:00</end_time>
      <description>Courses that grade programming assignments are frequently forced to compromise between scale and quality of feedback. Human graders give useful feedback but have difficulty consistently grading many programs while automatic graders can scale well but are limited in the feedback they can provide. While there are many efforts to improve the feedback quality of automatic graders, research into building tools for assisting human grading of programs is limited. We propose a technique for identifying equivalences between student submissions to enable human graders to give targeted feedback for multiple student submissions at once. Our technique is conservative in two ways. First, our technique identifies equivalence between submissions by finding equivalences between each submissions’ subexpressions, so the technique only identifies equivalence between submissions when they are algorithmically similar. Second, our technique uses formal methods to identify equivalence pairwise rather than using standard clustering algorithms from the machine learning literature. This allows us to prove a soundness result that guarantees that submissions will never be clustered together in error. Despite only reporting equivalence when there is algorithmic similarity and the ability to formally prove equivalence, we show that our technique can significantly reduce grading time for thousands of programming submissions from an introductory functional programming course.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Clune</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>joshuaclune</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vijay</first_name>
          <last_name>Ramamurthy</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>vijayramamurthy</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ruben</first_name>
          <last_name>Martins</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Ruben Martins is a Systems Scientist at the Carnegie Mellon University. Prior to joining CMU, he was a postdoctoral researcher at UT Austin where he pushed the frontiers of program synthesis and security with constraint solving. Before UT Austin, he was a postdoctoral researcher at the University of Oxford, UK where he worked on CBMC for software verification. He received his PhD with honors from the University of Lisbon, Portugal in 2013. His research aims to improve constraint solvers and broaden their applicability in program analysis, synthesis, and security. Dr. Martins has developed several award winning solvers and has consistently improved the state-of-the-art in MaxSAT solving. He is currently the main developer of Open-WBO: an open source MaxSAT solver that won several awards in the MaxSAT competitions.</bio>
          <homepage_url>https://sat-group.github.io/ruben/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rubenmartins/6cfee429-6785-4395-bcf6-ddb6dd674d58/small.jpg</picture_url>
          <person_id>rubenmartins</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Umut A.</first_name>
          <last_name>Acar</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/umutacar/645140f1-714c-4def-ab34-8c78d85a50bf/small.jpg</picture_url>
          <person_id>umutacar</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>934f158e-86aa-43d9-8883-82369f71dc33</slot_id>
      <event_id>ab26b4f9-908b-48a6-88f1-36f0a94e32cc</event_id>
      <title>Mossad: Defeating Software Plagiarism Detection</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>19:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>19:20</end_time>
      <description>Automatic software plagiarism detection tools are widely used in educational settings to ensure that submitted work was not copied. Reliance on these tools has grown along with enrollments in computer science programs and the widespread availability of code on-line. A key requirement of plagiarism detectors is that the effort required to evade detection must be as high as the effort required to actually do the assigned work.
This paper demonstrates an entirely automatic program transformation approach that defeats popular software plagiarism detection tools. We present Mossad, a framework that couples techniques inspired by genetic programming with domain-specific knowledge to effectively undermine plagiarism detectors. Mossad is effective at defeating three plagiarism detectors, including Moss and JPlag. We show that Mossad is both fast and effective. It can, in minutes, generate modified versions of programs that are likely to escape detection. More insidiously, because of its non-deterministic approach, Mossad can, from a single program, generate dozens of variants, which are classified as no more suspicious than legitimate assignments. We present a detailed study of Mossad across a corpus of real student assignments, demonstrating its efficacy at evading detection. We perform a user study and find that graduate student assistants consistently rate Mossad-generated code as just as readable as authentic student code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Breanna</first_name>
          <last_name>Devore-McDonald</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>undefined</bio>
          <person_id>breannadevoremcdonald</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Emery</first_name>
          <last_name>Berger</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>Emery is a Professor at the University of Massachusetts Amherst. He researches languages, runtime systems, and operating systems, with a particular focus on systems that transparently improve reliability, security, and performance. Emery and friends have created Hoard, the first scalable memory manager (malloc), on which the Mac OS X memory manager is based; DieHard, an error-avoiding memory manager that directly influenced the design of the Windows 7 Fault-Tolerant Heap; DieHarder, a secure memory manager that was an inspiration for hardening changes made to the Windows 8 heap; the Coz profiler, which ships with modern Linux distros; and more. He was named an ACM Fellow in 2019.</bio>
          <homepage_url>http://www.emeryberger.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/emeryberger/6187feeb-700c-48d5-aceb-6d7b87490a7a/small.jpg</picture_url>
          <person_id>emeryberger</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6d204bc8-3eb1-4e6e-a743-f6ac402b00aa</subevent_id>
    <title>SPLASH OOPSLA: T-4</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>ccd89aaf-1e40-433f-bfaf-0eea1cea8d1b</slot_id>
      <title>Session: SPLASH OOPSLA - T-4</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>533b1adb-2cc7-4fd4-b7b5-8e5a1e5b367c</slot_id>
      <event_id>64606eb7-ae14-4006-a27c-2e3b6b5b5c6c</event_id>
      <title>A Type-and-Effect System for Object Initialization</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>02:20</end_time>
      <description>Every newly created object goes through several initialization states: starting from a state where all fields are uninitialized until all of them are assigned. Any operation on the object during its initialization process, which usually happens in the constructor via \emph{this}, has to observe the initialization states of the object for correctness, i.e.~only initialized fields may be used. Checking safe usage of \emph{this} statically, without manual annotation of initialization states in source code, is a challenge, due to aliasing and virtual method calls on \emph{this}.
Mainstream languages either do not check initialization errors, like Java, C++, Scala, or they defend against them by not supporting useful initialization patterns, such as Swift. In parallel, past research has shown that safe initialization can be achieved for varying degrees of expressiveness but by sacrificing syntactic simplicity.
We approach the problem by upholding \emph{local reasoning} of initialization which avoids whole-program analysis, and we achieve \emph{typestate polymorphism} via subtyping. On this basis, we put forward a novel type-and-effect system that can effectively ensure initialization safety while allowing flexible initialization patterns with almost zero annotation burden.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fengyun</first_name>
          <last_name>Liu</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>I’m a PhD student at EPFL, working on Scala.</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/fengyunliu/7967ca32-789c-44f7-a256-c5eae78909c1/small.jpg</picture_url>
          <person_id>fengyunliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aggelos</first_name>
          <last_name>Biboudis</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>Software engineer and computer science addict; researcher at heart, excited about extensibility of software, code generation and performance

 Working on frameworks and tools for Data, Analytics &amp;amp; AI @Swisscom
 Ex-researcher on Scala 3 @ LAMP/@EPFL
 PhD from @dit_uoa

@biboudis</bio>
          <homepage_url>http://biboudis.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/aggelosbiboudis/89ee406d-41be-466b-a4e8-bf4c6aef486d/small.jpg</picture_url>
          <person_id>aggelosbiboudis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Paolo G.</first_name>
          <last_name>Giarrusso</last_name>
          <affiliation>BedRock Systems</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/paologgiarrusso/e3132edd-aa91-4b50-bd1f-5c280e08256c/small.jpg</picture_url>
          <person_id>paologgiarrusso</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Martin</first_name>
          <last_name>Odersky</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>Martin Odersky is a professor at EPFL in Lausanne, Switzerland. He has been working on programming languages for most of his career. He first studied structured and object-oriented programming as a PhD student of Niklaus Wirth, then fell in love with functional programming while working as a post doc at IBM and Yale. When Java came out, he started to add functional programming constructs to the new platform. This led to Pizza and GJ and eventually to Java 5 with generics. During that time he also developed javac, the current reference compiler for Java.
Over the last 10 years, Martin worked on unifying object-oriented and functional programming in the Scala language. Scala quickly escaped from the research lab and became a popular open source tool and industrial language. He now oversees development of Scala as head of the programming group at EPFL and as academic director of the Scala center.</bio>
          <homepage_url>http://lampwww.epfl.ch/~odersky/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/martinodersky/fc1dd696-d0d4-47cb-9d9a-bba012d98f9e/small.jpg</picture_url>
          <person_id>martinodersky</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9c5d4c56-bc85-48a1-ad4c-39c686c7a97f</slot_id>
      <event_id>a4f48195-d136-4257-a4b0-1e97c5e1b2b3</event_id>
      <title>A Systematic Approach to Deriving Incremental Type Checkers</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:40</end_time>
      <description>Static typing can guide programmers if feedback is immediate. Therefore, all major IDEs incrementalize type checking in some way. However, prior approaches to incremental type checking are often specialized and hard to transfer to new type systems. In this paper, we propose a systematic approach for deriving incremental type checkers from textbook-style type system specifications. Our approach is based on compiling inference rules to Datalog, a carefully limited logic programming language for which incremental solvers exist. The key contribution of this paper is to discover an encoding of the infinite typing relation as a finite Datalog relation in a way that yields efficient incremental updates. We implemented the compiler as part of a type system DSL and show that it supports simple types, some local type inference, operator overloading, and universal types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>André</first_name>
          <last_name>Pacak</last_name>
          <affiliation>JGU Mainz</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/andrepacak/7e35f14d-4d06-4a19-8ab8-bc24c2ce8145/small.jpg</picture_url>
          <person_id>andrepacak</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sebastian</first_name>
          <last_name>Erdweg</last_name>
          <affiliation>JGU Mainz</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.pl.informatik.uni-mainz.de/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sebastianerdweg/cc4515b1-cefa-4dee-a915-3242f337c8d8/small.jpg</picture_url>
          <person_id>sebastianerdweg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tamás</first_name>
          <last_name>Szabó</last_name>
          <affiliation>itemis / JGU Mainz</affiliation>
          <bio>Tamás Szabó works as a Software Engineer for itemis in Stuttgart, and he is a PhD student at JGU Mainz. His focus is on DSLs, incremental computing, and static program analysis.</bio>
          <homepage_url>https://szabta89.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tamasszabo/545a3e41-bc8c-47e6-b801-caf7074137ce/small.jpg</picture_url>
          <person_id>tamasszabo</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>aeb06990-e2c4-4098-b5d9-5b15aeaa68cd</slot_id>
      <event_id>4a70ed09-84fe-4afe-8c78-338a350d3ab8</event_id>
      <title>Detecting Locations in JavaScript Programs Affected by Breaking Library Changes</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>02:00</end_time>
      <description>JavaScript libraries are widely used and evolve rapidly. Adapting client code to non-backwards compatible changes in libraries is a difficult manual task. In this paper we address the challenge of how to locate affected API uses in client code, by the use of a simple pattern language for expressing API access points and a pattern-matching tool based on lightweight static analysis.
Experimental evaluation on 15 popular npm packages shows that typical breaking changes are easy to express as patterns. Running the static analysis on 265 clients of these packages shows that it is accurate and efficient: it reveals usages of breaking APIs with only 14% false positives and no false negatives, and takes less than a second per client on average. In addition, the analysis is able to report its confidence, which makes it easier to identify the false positives. These results suggest that the approach, despite its simplicity, can reduce the manual effort of the client developers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anders</first_name>
          <last_name>Møller</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
          <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
          <person_id>andersmoller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Benjamin Barslev</first_name>
          <last_name>Nielsen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/benjaminbarslevnielsen/7c6acacc-eb83-4ad2-8f27-d9a7ce64e58e/small.jpg</picture_url>
          <person_id>benjaminbarslevnielsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Martin</first_name>
          <last_name>Toldam Torp</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/martintoldamtorp/692a65a1-9fc3-4bbf-920b-3b1f2c438848/small.jpg</picture_url>
          <person_id>martintoldamtorp</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>de99acbd-6b0f-4bb1-929e-b079f3d2f10c</slot_id>
      <event_id>b4bfae0b-6b5f-4ee8-9432-65f91d8c51a9</event_id>
      <title>A Structural Model for Contextual Code Changes</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:20</end_time>
      <description>We address the problem of predicting edit completions based on a learned model that was trained on past edits. Given a code snippet that is partially edited, our goal is to predict a completion of the edit for the rest of the snippet. We refer to this task as the Edit Completion task and present a novel approach for tackling it. e The main idea is to directly represent structural edits. This allows us to model the likelihood of the edit itself, rather than learning the likelihood of the edited code. We represent an edit operation as a path in the program’s Abstract Syntax Tree (AST), originating from the source of the edit to the target of the edit. Using this representation, we present a powerful and lightweight neural model for the Edit Completion task.
We conduct a thorough evaluation, comparing our approach to a variety of representation and modeling approaches that are driven by multiple strong models such as LSTMs, Transformers, and neural CRFs. Our experiments show that our model achieves 28% relative gain over state-of-the-art sequential models and 2x higher accuracy than syntactic models that learn to generate the edited code instead of modeling the edits directly. We make our code, dataset, and trained models publicly available at https://github.com/tech-srl/c3po/ .</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shaked</first_name>
          <last_name>Brody</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/people/shakedbr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shakedbrody/54e00e02-0977-4227-be70-21858a5e5626/small.jpg</picture_url>
          <person_id>shakedbrody</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Uri</first_name>
          <last_name>Alon</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~urialon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/urialon/a0488e4f-5173-472b-af25-10666c27e3d4/small.jpg</picture_url>
          <person_id>urialon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion</affiliation>
          <bio>Eran Yahav is an associate professor at the Computer Science Department, Technion, Israel. Prior to that, he was a research staff member at the IBM T.J. Watson Research Center (2004-2010). He received his Ph.D. from Tel Aviv University (2005) and his B.Sc. from the Technion in 1996. His research interests include program analysis, program synthesis and program verification. Eran is a recipient of the prestigious Alon Fellowship for Outstanding Young Researchers, the Andre Deloro Career Advancement Chair in Engineering, the ERC Consolidator Grant as well as multiple best paper awards at various conferences.</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
          <person_id>eranyahav</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5e4bdfb0-84b7-4749-9c39-21010f2315c9</subevent_id>
    <title>SPLASH OOPSLA: T-3</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>861f45b3-6495-4444-a453-f73e81b58c65</slot_id>
      <title>Session: SPLASH OOPSLA - T-3</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>11:00</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3d53ab84-1ff2-418b-be19-dddf9133857d</slot_id>
      <event_id>7425f134-286b-4c4d-998b-71b90c993ce0</event_id>
      <title>Learning-based Controlled Concurrency Testing</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>11:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>11:40</end_time>
      <description>Concurrency bugs are notoriously hard to detect and reproduce. Controlled concurrency testing (CCT) techniques aim to offer a solution, where a scheduler explores the space of possible interleavings of a concurrent program looking for bugs. Since the set of possible interleavings is typically very large, these schedulers employ heuristics that prioritize the search to ``interesting'' subspaces. However, current heuristics are typically tuned to specific bug patterns, which limits their effectiveness in practice.
In this paper, we present $\mathtt{QL}$, a learning-based CCT framework where the likelihood of an action being selected by the scheduler is influenced by earlier explorations. We leverage the classical Q-learning algorithm to explore the space of possible interleavings, allowing the exploration to adapt to the program under test, unlike previous techniques. We have implemented and evaluated $\mathtt{QL}$ on a set of microbenchmarks, complex protocols, as well as production cloud services. In our experiments, we found $\mathtt{QL}$ to consistently outperform the state-of-the-art in CCT.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Suvam</first_name>
          <last_name>Mukherjee</last_name>
          <affiliation>Microsoft Research India</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://suvamm.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/suvammukherjee1/0b04e282-4b61-4f63-9abf-4d9516cf0b1e/small.jpg</picture_url>
          <person_id>suvammukherjee1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pantazis</first_name>
          <last_name>Deligiannis</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pdeligia.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/pantazisdeligiannis/a2d73510-7695-48bd-9b09-2ce6ec50b5d1/small.jpg</picture_url>
          <person_id>pantazisdeligiannis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arpita</first_name>
          <last_name>Biswas</last_name>
          <affiliation>Indian Institute of Science</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.google.com/view/arpitabiswas</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arpitabiswas/c7b67b3e-4a6b-4a0c-8139-6cc114ed3ea1/small.jpg</picture_url>
          <person_id>arpitabiswas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Akash</first_name>
          <last_name>Lal</last_name>
          <affiliation>Microsoft Research India</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.microsoft.com/en-us/people/akashl/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/akashlal/96032ffc-99b4-4b90-b99d-01b1f833751a/small.jpg</picture_url>
          <person_id>akashlal</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6149a84c-dcda-4f36-9756-5e1fd5ed92b2</slot_id>
      <event_id>de7d97dc-0089-49e1-bfce-2e7b14b648ee</event_id>
      <title>LiveDroid: Identifying and Preserving Mobile App State in Volatile Runtime Environments</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>11:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>12:00</end_time>
      <description>Mobile operating systems, especially Android, expose apps to a volatile runtime environment. The app state that reflects past user interaction and system environment updates (e.g., battery status changes) can be destroyed implicitly, in response to runtime configuration changes (e.g., screen rotations) or memory pressure. Developers are therefore responsible for identifying app state affected by volatility and preserving it across app lifecycles. When handled inappropriately, the app may lose state or end up in an inconsistent state after a runtime configuration change or when users return to the app.
To free developers from this tedious and error-prone task, we propose a systematic solution, LiveDroid, which precisely identifies the necessary part of the app state that needs to be preserved across app lifecycles, and automatically saves and restores it. LiveDroid consists of: (i) a static analyzer that reasons about app source code and resource files to pinpoint the program variables and GUI properties that represent the necessary app state, and (ii) a runtime system that manages the state saving and recovering. We implemented LiveDroid as a plugin in Android Studio and a patching tool for APKs. Our evaluation shows that LiveDroid can be successfully applied to 966 Android apps. A focused study with 36 Android apps shows that LiveDroid identifies app state much more precisely than an existing solution that includes all mutable program variables but ignores GUI properties. As a result, on average, LiveDroid is able to reduce the costs of state saving and restoring by 16.6X (1.7X - 141.1X) and 9.5X (1.1X - 43.8X), respectively. Furthermore, compared with the manual state handling performed by developers, our analysis reveals a set of 46 issues due to incomplete state saving/restoring, all of which can be successfully eliminated by LiveDroid.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Umar</first_name>
          <last_name>Farooq</last_name>
          <affiliation>University of California Riverside</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.ucr.edu/~ufaro001/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/umarfarooq2/e0d30810-d987-42da-b3cb-576592015d8d/small.jpg</picture_url>
          <person_id>umarfarooq2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zhijia</first_name>
          <last_name>Zhao</last_name>
          <affiliation>UC Riverside</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ucr.edu/~zhijia/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhijiazhao/5e266673-0c51-4bfe-bc81-2fb37155ad8b/small.jpg</picture_url>
          <person_id>zhijiazhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Manu</first_name>
          <last_name>Sridharan</last_name>
          <affiliation>University of California Riverside</affiliation>
          <bio>I work on developing tools and techniques to make large-scale software more reliable, performant, secure, and maintainable. For more details, see my homepage.</bio>
          <homepage_url>http://manu.sridharan.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/manusridharan/00859147-2155-45a9-9a48-7565ce5356ac/small.jpg</picture_url>
          <person_id>manusridharan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Iulian</first_name>
          <last_name>Neamtiu</last_name>
          <affiliation>New Jersey Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://web.njit.edu/~ineamtiu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/iulianneamtiu/59a11852-72df-4d67-9331-8720d3d19a64/small.jpg</picture_url>
          <person_id>iulianneamtiu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c664d262-2bd0-4fba-a1f7-579d1c5a50f6</slot_id>
      <event_id>b926e1ec-10a6-4b30-9b63-77836ac884b7</event_id>
      <title>Koord: a language for programming and verifying distributed robotics applications</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>11:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>11:20</end_time>
      <description>A robot’s code needs to sense the environment, control the hardware, and communicate with other robots. Cur- rent programming languages do not provide the necessary hardware platform-independent abstractions, and therefore, developing robot applications require detailed knowledge of signal processing, control, path plan- ning, network protocols, and various platform-specific details. Further, porting applications across hardware platforms becomes tedious. We present Koord—a domain specific language for distributed robotics—which abstracts platform-specific functions for sensing, communication, and low-level control. Koord makes the platform-independent control and coordination code portable and modularly verifiable. It raises the level of abstraction in programming by providing distributed shared memory for coordination and port interfaces for sensing and control. We have developed the formal executable semantics of Koord in the K framework. With this symbolic execution engine, we can identify assumptions (proof obligations) needed for gaining high assurance from Koord applications. We illustrate the power of Koord through three applications: formation flight, distributed delivery, and distributed mapping. We also use the formation flight and distributed delivery applications to demonstrate how platform-independent proof obligations can be discharged using the Koord Prover while platform-specific proof obligations can be checked by verifying the obligations using physics-based models and hybrid verification tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ritwika</first_name>
          <last_name>Ghosh</last_name>
          <affiliation>UIUC</affiliation>
          <bio>undefined</bio>
          <person_id>ritwikaghosh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chiao</first_name>
          <last_name>Hsieh</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>chiaohsieh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sasa</first_name>
          <last_name>Misailovic</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://misailo.cs.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sasamisailovic/6e3299c7-e0f5-4e78-a5f3-7ea49e488545/small.jpg</picture_url>
          <person_id>sasamisailovic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>sayan</first_name>
          <last_name>mitra</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>Sayan Mitra is a Professor of Electrical and Computer Engineering at the University of Illinois at Urbana-Champaign. His research interests are in formal verification, autonomous systems, and robotics. He holds a PhD from MIT, MSc from the Indian Institute of Science, Bangalore, and an undergraduate degree in Electrical Engineering from Jadavpur University, Kolkata. He was a postdoctoral fellow at the Center for Mathematics of Information of CalTech, and held visiting faculty positions at Oxford University and Kirtland Air Force Research Laboratory. Sayan received the National Science Foundation’s CAREER Award in 2011, AFOSR Young Investigator Research Program Award in 2012, IEEE-HKN C. Holmes MacDonald Outstanding Teaching Award (2013), a RiSE Fellowship from TU Vienna, and several best paper awards.</bio>
          <homepage_url>http://mitras.ece.illinois.edu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sayanmitra/62982710-8e2c-4be7-98f8-068227c8a067/small.jpg</picture_url>
          <person_id>sayanmitra</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f6a8a9ec-f5a4-43a5-903e-b1bfbf22d3b1</slot_id>
      <event_id>72a7c48b-8eba-4f07-b5bc-03af82474540</event_id>
      <title>Shiftry: RNN Inference in 2KB of RAM</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>12:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>12:20</end_time>
      <description>Traditionally, IoT devices send collected sensor data to an intelligent cloud where machine learning (ML) inference happens. However, this course is rapidly changing and there is a recent trend to run ML on the edge IoT devices themselves. An intelligent edge is attractive because it saves network round trip (efficiency) and keeps user data at the source (privacy). However, the IoT devices are much more resource constrained than the cloud, which makes running ML on them challenging. Specifically, consider Arduino Uno, a commonly used board, that has 2KB of RAM and 32KB of read-only Flash memory. Although recent breakthroughs in ML have created novel recurrent neural network (RNN) models that provide good accuracy with KB-sized models, deploying them on tiny devices with such hard memory requirements has remained elusive.
We provide, Shiftry, an automatic compiler from high-level floating-point ML models to fixed-point C-programs with 8-bit and 16-bit integers, which have significantly lower memory requirements. For this conversion, Shiftry uses a data-driven float-to-fixed procedure and a RAM management mechanism. These techniques enable us to provide first empirical evaluation of RNNs running on tiny edge devices. On simpler ML models that prior work could handle, Shiftry-generated code has lower latency and higher accuracy.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aayan</first_name>
          <last_name>Kumar</last_name>
          <affiliation>Microsoft Research India</affiliation>
          <bio>undefined</bio>
          <person_id>aayankumar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vivek</first_name>
          <last_name>Seshadri</last_name>
          <affiliation>Microsoft Research, India</affiliation>
          <bio>undefined</bio>
          <person_id>vivekseshadri</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rahul</first_name>
          <last_name>Sharma</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Rahul Sharma is a researcher at Microsoft Research India. He received a Ph.D. in Computer Science from Stanford University, where he was advised by Prof. Alex Aiken. Before Stanford, he graduated with a B.Tech. from IIT Delhi. His research interests include program analysis, compilers, machine learning, and secure cloud computing.</bio>
          <homepage_url>http://cs.stanford.edu/people/sharmar</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rahulsharma/6d60eca8-356f-4141-af5d-4c6af0fadcd8/small.jpg</picture_url>
          <person_id>rahulsharma</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2d10e572-29fd-487f-b370-76c7e62a20d6</subevent_id>
    <title>SPLASH OOPSLA: R-4</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>83dc2e9c-0c83-423f-8f58-4981c4f0f018</slot_id>
      <title>Session: SPLASH OOPSLA - R-4</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>01:00</start_time>
      <end_time>02:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9fcd4830-690f-45ab-ba13-e5df0d62eec6</slot_id>
      <event_id>f2d61eb0-5d2c-45d9-81c7-1137a585afca</event_id>
      <title>Eliminating Abstraction Overhead of Java Stream Pipelines using Ahead-of-Time Program Optimization</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>02:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>02:20</end_time>
      <description>Java 8 introduced streams that allow developers to work with collections of data using functional-style operations. Streams are often used in pipelines of operations for processing the data elements, which leads to concise and elegant program code. However, the declarative data processing style comes at a cost. Compared to processing the data with traditional imperative language mechanisms, constructing stream pipelines requires extra heap objects and virtual method calls, which often results in significant run-time overheads.
In this work we investigate how to mitigate these overheads to enable processing data in the declarative style without sacrificing performance. We argue that ahead-of-time bytecode-to-bytecode transformation is a suitable approach to optimization of stream pipelines, and we present a static analysis that is designed to guide such transformations. Experimental results show a significant performance gain, and that the technique works for realistic stream pipelines. For 10 of 11 micro-benchmarks, the optimizer is able to produce bytecode that is as effective as hand-written imperative-style code. Additionally, 73% of 6586 stream pipelines found in real-world Java programs are optimized successfully.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anders</first_name>
          <last_name>Møller</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
          <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
          <person_id>andersmoller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Oskar</first_name>
          <last_name>Haarklou Veileborg</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/oskarhaarklouveileborg/4b1f271b-c619-4096-8218-ae034b3a1da9/small.jpg</picture_url>
          <person_id>oskarhaarklouveileborg</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a39b5465-f98c-4e65-83cd-e69c8c51140d</slot_id>
      <event_id>c500592f-2d9a-4056-99b3-b5e5865667b4</event_id>
      <title>Assertion-based optimization of quantum programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>01:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>01:20</end_time>
      <description>Quantum computers promise to perform certain computations exponentially faster than any classical device. Precise control over their physical implementation and proper shielding from unwanted interactions with the environment become more difficult as the space/time volume of the computation grows. Code optimization is thus crucial in order to reduce resource requirements to the greatest extent possible. Besides manual optimization, previous work has adapted classical methods such as constant-folding and common subexpression elimination to the quantum domain. However, such classically-inspired methods fail to exploit certain optimization opportunities across subroutine boundaries, limiting the effectiveness of software reuse. To address this insufficiency, we introduce an optimization methodology which employs annotations that describe how subsystems are entangled in order to exploit these optimization opportunities. We formalize our approach, prove its correctness, and present benchmarks: Without any prior manual optimization, our methodology is able to reduce, e.g., the qubit requirements of a 64-bit floating-point subroutine by 34×.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Häner</last_name>
          <affiliation>ETH Zürich</affiliation>
          <bio>undefined</bio>
          <person_id>thomashaner1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Troyer</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>matthiastroyer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Torsten</first_name>
          <last_name>Hoefler</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>Torsten is an Assistant Professor of Computer Science at ETH Zürich, Switzerland. Before joining ETH, he led the performance modeling and simulation efforts of parallel petascale applications for the NSF-funded Blue Waters project at NCSA/UIUC. He is also a key member of the Message Passing Interface (MPI) Forum where he chairs the “Collective Operations and Topologies” working group. Torsten won best paper awards at the ACM/IEEE Supercomputing Conference 2010 (SC10), EuroMPI 2013, ACM/IEEE Supercomputing Conference 2013 (SC13), and other conferences. He published numerous peer-reviewed scientific conference and journal articles and authored chapters of the MPI-2.2 and MPI-3.0 standards. For his work, Torsten received the SIAM SIAG/Supercomputing Junior Scientist Prize in 2012 and the IEEE TCSC Young Achievers in Scalable Computing Award in 2013. Following his Ph.D., the received the Young Alumni Award 2014 from Indiana University. Torsten was elected into the first steering committee of ACM’s SIGHPC in 2013. His research interests revolve around the central topic of “Performance-centric Software Development” and include scalable networks, parallel programming techniques, and performance modeling. Additional information about Torsten can be found on his homepage at htor.inf.ethz.ch.</bio>
          <homepage_url>http://htor.inf.ethz.ch/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/torstenhoefler/b570b3f0-a91f-4651-8a80-cfde60d06190/small.jpg</picture_url>
          <person_id>torstenhoefler</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c241f786-2cb3-4e38-a17e-d2301ba5c3fb</slot_id>
      <event_id>0484f76d-7e8f-42de-be40-69afe1f78f7d</event_id>
      <title>Dataflow-based Pruning for Speeding up Superoptimization</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>01:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>01:40</end_time>
      <description>Superoptimization is a compilation strategy that uses search to improve code quality, rather than relying on a canned sequence of transformations, as traditional optimizing compilers do. This search can be seen as a program synthesis problem: from unoptimized code serving as a specification, the synthesis procedure attempts to create a more efficient implementation. An important family of synthesis algorithms works by enumerating candidates and then successively checking if each refines the specification, using an SMT solver. The contribution of this paper is a pruning technique which reduces the enumerative search space using fast dataflow-based techniques to discard synthesis candidates that contain symbolic constants and uninstantiated instructions. We demonstrate the effectiveness of this technique by improving the runtime of an enumerative synthesis procedure in the Souper superoptimizer for the LLVM intermediate representation. The techniques presented in this paper eliminate 65% of the solver calls made by Souper, making it 2.32x faster (14.54 hours vs 33.76 hours baseline, on a large multicore) at solving all 269,113 synthesis problems that Souper encounters when optimizing the C and C++ programs from SPEC CPU 2017.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manasij</first_name>
          <last_name>Mukherjee</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
          <person_id>manasijmukherjee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pranav</first_name>
          <last_name>Kant</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
          <person_id>pranavkant</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhengyang</first_name>
          <last_name>Liu</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.utah.edu/~liuz/</homepage_url>
          <person_id>zhengyangliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>John</first_name>
          <last_name>Regehr</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.utah.edu/~regehr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johnregehr/2cb23ab0-042a-487a-a859-cbd3147a46a7/small.jpg</picture_url>
          <person_id>johnregehr</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e3ab10fd-8ebf-478e-86c6-aa53c4bac261</slot_id>
      <event_id>e9ae4c19-f50c-4f0d-b1e6-3e733890b7c4</event_id>
      <title>Enabling Accuracy-Aware Quantum Compilers Using Symbolic Resource Estimation</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>01:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>02:00</end_time>
      <description>Approximation errors must be taken into account when compiling programs for fault-tolerant quantum computers. We present a methodology that tracks such errors automatically and then optimizes accuracy parameters to guarantee a specified overall accuracy while aiming to minimize the implementation cost in terms of quantum gates. The core idea of our approach is to extract functions that specify the optimization problem directly from the high-level description of the quantum program. Then, custom compiler passes optimize these functions, turning them into (near-)symbolic expressions for (1) the total error and (2) the implementation cost (e.g., total quantum gate count). All unspecified parameters of the quantum program will show up as variables in these expressions, including accuracy parameters. After solving the corresponding optimization problem, a circuit can be instantiated from the found solution. We develop two prototype implementations, one in C++ based on Clang/LLVM, and another using the Q# compiler infrastructure. We benchmark our prototypes on typical quantum computing programs, including the quantum Fourier transform, quantum phase estimation, and Shor’s algorithm.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Giulia</first_name>
          <last_name>Meuli</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
          <person_id>giuliameuli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mathias</first_name>
          <last_name>Soeken</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>mathiassoeken</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Martin</first_name>
          <last_name>Roetteler</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>martinroetteler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Häner</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>thomashaner</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>718b1d8d-3571-44b5-a702-222564e4d1a3</subevent_id>
    <title>SPLASH OOPSLA: T-6A</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>bf921f3b-52a5-4671-adbe-e0b071fa8759</slot_id>
      <title>Session: SPLASH OOPSLA - T-6A</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>33ace67f-0a6c-4a7c-bad9-0b41cb19858e</slot_id>
      <event_id>a1340467-2468-4939-918c-5b03056c26fd</event_id>
      <title>FlowCFL: Generalized Type-based Reachability Analysis</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>17:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>17:40</end_time>
      <description>Reachability analysis is a fundamental program analysis with a wide variety of applications. We present FlowCFL, a framework for type-based reachability analysis in the presence of mutable data. Interestingly, the underlying semantics of FlowCFL is CFL-reachability.
We make three contributions. First, we define a dynamic semantics that captures the notion of flow commonly used in reachability analysis. Second, we establish correctness of CFL-reachability over graphs with \emph{inverse} edges (inverse edges are necessary for the handling of mutable heap data). Our approach combines CFL-reachability with \emph{reference immutability} to avoid the addition of certain infeasible inverse edges and we demonstrate empirically that avoiding those edges results in precision improvement. Our formal account of correctness extends to this case as well. Third, we present a type-based reachability analysis and establish equivalence between a certain CFL-reachability analysis and the type-based analysis, thus proving correctness of the type-based analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ana</first_name>
          <last_name>Milanova</last_name>
          <affiliation>Rensselaer Polytechnic Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.rpi.edu/~milanova/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/anamilanova/4fa9038c-d0e6-44ca-b1b7-2420329714f4/small.jpg</picture_url>
          <person_id>anamilanova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b9d95123-48d8-4e1a-badd-922990e91ed1</slot_id>
      <event_id>bebba2c1-25ac-4031-96fd-49f091a06a15</event_id>
      <title>Flow2Vec: Value-Flow-Based Precise Code Embedding</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>17:20</end_time>
      <description>Code embedding, as an emerging paradigm for source code analysis, has attracted much attention over the past few years. It aims to represent code semantics through distributed vector representations, which can be used to support a variety of program analysis tasks (e.g., code summarization and semantic labeling). However, existing code embedding approaches are intraprocedural, alias-unaware and ignoring the asymmetric transitivity of directed graphs abstracted from source code, thus they are still ineffective in preserving the structural information of code.
This paper presents Flow2Vec, a new code embedding approach that precisely preserves interprocedural program dependence (a.k.a value-flows). By approximating the high-order proximity, i.e., the asymmetric transitivity of value-flows, Flow2Vec embeds control-flows and alias-aware data-flows of a program in a low-dimensional vector space. Our value-flow embedding is formulated as matrix multiplication to preserve context-sensitive transitivity through CFL reachability by filtering out infeasible value-flow paths.
We have evaluated Flow2Vec using 32 popular open-source projects. Results from our experiments show that Flow2Vec successfully boosts the performance of two recent code embedding approaches code2vec and code2seq for two client applications, i.e., code classification and code summarization. For code classification, Flow2Vec improves code2vec with an average increase of 21.2%, 20.1% and 20.7% in precision, recall and F1, respectively. For code summarization, Flow2Vec outperforms code2seq by an average of 13.2%, 18.8% and 16.0% in precision, recall and F1, respectively.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yulei</first_name>
          <last_name>Sui</last_name>
          <affiliation>University of Technology Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuleisui.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yuleisui/e6ce6e88-3cd8-4595-9c61-a8da6f7319f6/small.jpg</picture_url>
          <person_id>yuleisui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xiao</first_name>
          <last_name>Cheng</last_name>
          <affiliation>Beijing University of Posts and Telecommunications</affiliation>
          <bio>undefined</bio>
          <person_id>xiaocheng</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Guanqin</first_name>
          <last_name>Zhang</last_name>
          <affiliation>University of Technology Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>guanqinzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Haoyu</first_name>
          <last_name>Wang</last_name>
          <affiliation>Beijing University of Posts and Telecommunications, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://howiepku.github.io/</homepage_url>
          <person_id>haoyuwang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e2b5a2ba-21f5-4d47-9c68-2ff57c9aebda</slot_id>
      <event_id>71956917-c601-44ae-8f7c-0e7327f4fa45</event_id>
      <title>Gradual Verification of Recursive Heap Data Structures</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>18:00</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>18:20</end_time>
      <description>Current static verification techniques do not provide good support for incrementality, making it difficult for developers to focus their limited effort on specifying and verifying the properties and components that are most important. Dynamic verification approaches support incrementality, but cannot provide static guarantees. To bridge this gap, prior work proposed gradual verification, which supports incrementality by allowing every assertion to be complete, partial, or omitted, and provides sound verification that smoothly scales from dynamic to static checking. The prior approach to gradual verification, however, was limited to toy programs without recursive data structures. This paper extends gradual verification to realistic programs that manipulate recursive, mutable data structures on the heap. We solve key technical challenges, semantically connecting iso- and equi-recursive interpretations of abstract predicates as well as gradual verification of heap ownership. Our work thus lays the foundation for future tools that work on realistic programs and support verification within an engineering process in which cost-benefit trade-offs can be made.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jenna</first_name>
          <last_name>Wise</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jlwise/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jennawise/614a00d0-d8ab-4b2f-8ec7-96abcb5c3d5b/small.jpg</picture_url>
          <person_id>jennawise</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Johannes</first_name>
          <last_name>Bader</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.johannes-bader.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/johannesbader/0b7e635c-fba7-4113-a53d-4451edd44ca5/small.jpg</picture_url>
          <person_id>johannesbader</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Cameron</first_name>
          <last_name>Wong</last_name>
          <affiliation>Jane Street</affiliation>
          <bio>Wannabe type theorist.</bio>
          <homepage_url>https://camdar.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cameronwong/1e4412d3-e79b-4f6a-8465-6b756986e1d0/small.jpg</picture_url>
          <person_id>cameronwong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech.
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
          <person_id>etanter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Sunshine</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jssunshi/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/joshuasunshine/474067e5-86e8-476c-9622-5c89be145f4b/small.jpg</picture_url>
          <person_id>joshuasunshine</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f2baf200-f36b-46aa-aca2-bf9e8bc288a7</slot_id>
      <event_id>970b6051-9a69-4c86-97a5-c53ea48536a0</event_id>
      <title>Hidden Inheritance: An Inline Caching Design for TypeScript Performance</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>17:40</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>18:00</end_time>
      <description>TypeScript is a dynamically-typed language widely used to develop large-scale mobile applications nowadays. These applications are usually designed with complex class or interface hierarchy. These object-oriented (OO) features will lead to inefficient inline caches (ICs) or trigger deoptimizations, and impact the performance of TypeScript applications. To address this problem, we introduce an enhanced inline caching design called hidden inheritance (HI). The basic idea of HI is to cache the static class/interface hierarchy information into extended hidden classes (EHCs), and generate enhanced inline caches (EICs) to reduce IC misses or deoptimizations for OO-style TypeScript programs. The HI technique is implemented in a TypeScript engine (including a static compiler and a runtime) called STSC. STSC not only statically generates EHCs and EICs but also applies them to generate specialized machine code via ahead-of-time compilation (AOTC) or just-in-time compilation (JITC). To demonstrate the efficiency of this technique, we implement STSC on a state-of-the-art JavaScript Engine V8 and demonstrate performance improvements on industrial benchmarks and applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zhefeng</first_name>
          <last_name>Wu</last_name>
          <affiliation>Alibaba Group</affiliation>
          <bio>undefined</bio>
          <person_id>zhefengwu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zhe</first_name>
          <last_name>Sun</last_name>
          <affiliation>Alibaba Group</affiliation>
          <bio>undefined</bio>
          <person_id>zhesun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kai</first_name>
          <last_name>Gong</last_name>
          <affiliation>Alibaba Group</affiliation>
          <bio>undefined</bio>
          <person_id>kaigong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>lingyun</first_name>
          <last_name>Chen</last_name>
          <affiliation>Alibaba Group</affiliation>
          <bio>undefined</bio>
          <person_id>lingyunchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Bin</first_name>
          <last_name>Liao</last_name>
          <affiliation>Alibaba Group</affiliation>
          <bio>undefined</bio>
          <person_id>binliao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Yihua</first_name>
          <last_name>Jin</last_name>
          <affiliation>Alibaba Group</affiliation>
          <bio>undefined</bio>
          <person_id>yihuajin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1e365d45-f79d-4003-821d-1e4a7e5c3be7</subevent_id>
    <title>SPLASH OOPSLA: F-2A</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>ae524bfb-1f36-4d89-bff7-3f71e48778c4</slot_id>
      <title>Session: SPLASH OOPSLA - F-2A</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bff26a75-db43-4e11-9682-a824900c1936</slot_id>
      <event_id>834d57b9-2ff5-4c19-86bb-2d5b6188d63e</event_id>
      <title>A Sparse Iteration Space Transformation Framework for Sparse Tensor Algebra</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>09:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>09:20</end_time>
      <description>We address the problem of optimizing sparse tensor algebra in a compiler and show how to define standard loop transformations—split, collapse, and reorder—on sparse iteration spaces. The key idea is to track the transformation functions that map the original iteration space to derived iteration spaces. These functions are needed by the code generator to emit code that maps coordinates between iteration spaces at runtime, since the coordinates in the sparse data structures remain in the original iteration space. We further demonstrate that derived iteration spaces can tile both the universe of coordinates and the subset of nonzero coordinates: the former is analogous to tiling dense iteration spaces, while the latter tiles sparse iteration spaces into statically load-balanced blocks of nonzeros. Tiling the space of nonzeros lets the generated code efficiently exploit heterogeneous compute resources such as threads, vector units, and GPUs.
We implement these concepts by extending the sparse iteration theory implementation in the TACO system. The associated scheduling API can be used by performance engineers or it can be the target of an automatic scheduling system. We outline one heuristic autoscheduling system, but other systems are possible. Using the scheduling API, we show how to optimize mixed sparse-dense tensor algebra expressions on CPUs and GPUs. Our results show that the sparse transformations are sufficient to generate code with competitive performance to hand-optimized implementations from the literature, while generalizing to all of the tensor algebra.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ryan</first_name>
          <last_name>Senanayake</last_name>
          <affiliation>Reservoir Labs</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.RSenApps.com</homepage_url>
          <person_id>ryansenanayake</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Changwan</first_name>
          <last_name>Hong</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>changwanhong2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziheng</first_name>
          <last_name>Wang</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>zihengwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Amalee</first_name>
          <last_name>Wilson</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>amaleewilson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chou</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/s3chou</homepage_url>
          <person_id>stephenchou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Shoaib</first_name>
          <last_name>Kamil</last_name>
          <affiliation>Adobe</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shoaibkamil/2bc60aee-bda5-437e-9e74-e00f5a55c9ef/small.jpg</picture_url>
          <person_id>shoaibkamil</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Saman</first_name>
          <last_name>Amarasinghe</last_name>
          <affiliation>MIT</affiliation>
          <bio>Prof. Saman Amarasinghe leads the Commit compiler research group in MIT’s Computer Science &amp;amp; Artificial Intelligence Laboratory (CSAIL), which focuses on programming languages and compilers that maximize application performance on modern computing platforms. He is a world leader in the field of high-performance domain-specific languages. Prof. Amarasinghe’s group developed the Halide, TACO, Simit, StreamIt, StreamJIT, PetaBricks, MILK, Cimple, and GraphIt domain-specific languages and compilers, all of which combine language design and sophisticated compilation techniques to deliver unprecedented performance for targeted application domains such as image processing, stream computations, and graph analytics. Dr. Amarasinghe also pioneered the application of machine learning for compiler optimizations, from Meta optimization in 2003 to OpenTuner extendable autotuner today. With professor Anant Agarwal, he co-led the Raw architecture project, which did pioneering work on scalable multicores. Prof. Amarasinghe’s entrepreneurship activities include founding Determina, Inc. (acquired by VMWare) based on computer security research pioneered in his research group at MIT and co-founding Lanka Internet Services, Ltd., the first Internet Service Provider in Sri Lanka. Prof. Amarasinghe is also the faculty director of MIT Global Startup Labs, whose summer programs in 17 countries have helped to create more than 20 thriving startups. Prof. Amarasinghe developed the popular Performance Engineering of Software Systems (6.172) class with Professor Charles Leiserson. He also created individualized software project classes such as the Open Source Software Project Lab, the Open Source Entrepreneurship Lab, and the Bring Your Own Software Project Lab.</bio>
          <homepage_url>http://people.csail.mit.edu/saman</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/samanamarasinghe/9e4ed1ad-ff3e-468e-b1a8-36ffb2c882ef/small.jpg</picture_url>
          <person_id>samanamarasinghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d097f74e-7aee-4590-99d6-530f4574ab5d</slot_id>
      <event_id>fc13e2b3-604c-4954-9997-35f41f87ef1f</event_id>
      <title>Towards A Unified Proof Framework for Automated Fixpoint Reasoning Using Matching Logic</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>10:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>10:20</end_time>
      <description>Automation of fixpoint reasoning has been extensively studied for various mathematical structures, logical formalisms, and computational domains, resulting in specialized fixpoint provers for heaps, for streams, for term algebras, for temporal properties, for program correctness, and for many other formal systems and inductive and coinductive properties. However, in spite of great theoretical and practical interest, there is no unified framework for automated fixpoint reasoning. Although several attempts have been made, there is no evidence that such a unified framework is possible, or practical. In this paper, we propose a candidate based on matching logic, a formalism that is recently shown to theoretically unify the above mentioned formal systems. Unfortunately, the Knaster-Tarski proof rule of matching logic, which enables inductive reasoning, is not syntax-driven. Worse, it can be applied at any step during a proof, making automation seem hopeless. Inspired by recent advances in automation of inductive proofs in separation logic, we propose an alternative proof system for matching logic, which is amenable for automation. We then discuss our implementation of it, which although not superior to specialized state-of-the-art automated provers for specific domains, we believe brings some evidence and hope that a unified framework for automated reasoning is not out of reach.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiaohong</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsl.cs.illinois.edu/~xchen</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/xiaohongchen1/e982c014-9fda-495c-93d6-b5fdc8158320/small.jpg</picture_url>
          <person_id>xiaohongchen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thai</first_name>
          <last_name>Trinh</last_name>
          <affiliation>Advanced Digital Sciences Center, Illinois at Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>thaitrinh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nishant</first_name>
          <last_name>Rodrigues</last_name>
          <affiliation>University of Illinois Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>nishantrodrigues</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lucas</first_name>
          <last_name>Peña</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>lucaspena</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Grigore</first_name>
          <last_name>Rosu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsl.cs.illinois.edu/index.php/Grigore_Rosu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/grigorerosu/5d2acd04-bb45-46a0-a743-4826f3d8086c/small.jpg</picture_url>
          <person_id>grigorerosu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d3fc75e8-b072-4a94-ae3a-42a81a54e4b3</slot_id>
      <event_id>7907d076-ba43-4ab2-87fb-41a41db9c572</event_id>
      <title>Resolution as Intersection Subtyping via Modus Ponens</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>09:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>09:40</end_time>
      <description>Resolution and subtyping are two common mechanisms in programming languages. Resolution is used by features such as type classes or Scala-style implicits to synthesize values automatically from contextual type information. Subtyping is commonly used to automatically convert the type of a value into another compatible type. So far the two mechanisms have been considered independently of each other. This paper shows that, with a small extension, subtyping with intersection types can subsume resolution. This has three main consequences. Firstly, resolution does not need to be implemented as a separate mechanism. Secondly, the interaction between resolution and subtyping becomes apparent. Finally, the integration of resolution into subtyping enables first-class (implicit) environments. The extension that recovers the power of resolution via subtyping is the modus ponens rule of propositional logic. While it is easily added to declarative subtyping, significant care needs to be taken to retain desirable properties, such as transitivity and decidability of algorithmic subtyping, and coherence. To materialize these ideas we develop λ_MP, a calculus that extends a previous calculus with disjoint intersection types, and develop its metatheory in the Coq theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Klara</first_name>
          <last_name>Mardirosian</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/klaramardirosian/15cf04a1-de90-4f6d-b88d-cd1a230da0e4/small.jpg</picture_url>
          <person_id>klaramardirosian</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>The University of Hong Kong, Hong Kong</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://i.cs.hku.hk/~bruno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/brunooliveira/f799cea5-abc3-443d-a265-ff5699cac240/small.jpg</picture_url>
          <person_id>brunooliveira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Georgios</first_name>
          <last_name>Karachalias</last_name>
          <affiliation>Tweag I/O</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://gkaracha.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/georgekarachalias/cb10a8f5-6b72-4883-aef0-c9978070378a/small.jpg</picture_url>
          <person_id>georgekarachalias</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>dee154f2-7c36-49dd-b3e0-c94fed7a80df</slot_id>
      <event_id>0cd262dc-3c5c-498c-814d-952a4abeecf6</event_id>
      <title>Guided Linking: Dynamic Linking Without the Costs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>09:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>10:00</end_time>
      <description>Dynamic linking is extremely common in modern software systems, thanks to the flexibility and space savings it offers. However, this flexibility comes at a cost: every library call has an extra layer of indirection, and it’s impossible to perform interprocedural optimizations that involve calls to a dynamic library. The basic problem is that the run-time behavior of the dynamic linker can’t be predicted at compile time, so the compiler can make no assumptions about how external calls will behave.
This paper introduces guided linking, a technique for optimizing dynamically linked software when some information about the dynamic linker’s behavior is known in advance. The developer provides an arbitrary set of programs, libraries, and plugins to our tool, along with constraints that limit the possible dynamic linking behavior of the software. Given a software set and a list of constraints, our tool takes advantage of the constraints to optimize the software for speed and size. For example, the “no dynamic redefinitions” constraint can be applied to a function when the developer knows the function will never be unexpectedly overridden with a different definition at run time; this constraint allows dynamic references between libraries in the set to be resolved to static references, which can then be optimized with standard link-time optimizations. As an additional optimization, we deduplicate identical functions that appear anywhere in the software set.
By applying guided linking to a dynamically linked distribution of Clang and LLVM, and using the constraint that no other software will use the LLVM libraries, we can increase speed by 6% and reduce file size by 11%. If we relax the constraint to allow other software to use the LLVM libraries, we can still increase speed by 5.5% and reduce file size by 3%. If we apply guided linking to the Python interpreter and a set of loadable Python modules, applying the constraint that no other programs or modules will be used, we can increase speed by an average of 6.6%. If we use guided linking to combine 11 different versions of the Boost library, applying minimal constraints, we can reduce the total library size by 57%.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sean</first_name>
          <last_name>Bartell</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>seanbartell</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Will</first_name>
          <last_name>Dietz</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wdtz.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/willdietz/f5b6948e-d200-44b1-ba05-8d21549414f8/small.jpg</picture_url>
          <person_id>willdietz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Vikram S.</first_name>
          <last_name>Adve</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>Vikram Adve is the Donald B. Gillies Professor of Computer Science at the University of Illinois at Urbana-Champaign and a Professor in Electrical and Computer Engineering. He is a Co-founder and Co-Director of the Center for Digital Agriculture and leads AIFARMS, a $20M National Artificial Intelligence Research Institute funded by NIFA and NSF. Adve’s research interests lie in developing and using compiler techniques to improve the performance, programmability and reliability of computer systems. Adve and his Ph.D. student, Chris Lattner, co-designed the LLVM Compiler Infrastructure, which enables a novel approach to “lifelong compilation” of programs in a wide range of general-purpose programming languages. For example, most mobile apps for the iPhone, iPad, Apple Watch and Apple TV are shipped by developers to Apple in the LLVM compiler representation called “LLVM bitcode” and then compiled and specialized for the various end-user devices. LLVM is widely used in industry today, ranging from mobile devices (e.g., iOS and Android) to supercomputers (e.g., at NVIDIA, Cray, IBM and Intel) to data centers (e.g., at Google). Adve, Lattner and Evan Cheng received the ACM Software System Award in 2012 for co-developing LLVM. Adve has won a ten-year-retrospective Most Influential Paper award at CGO 2004, and distinguished paper awards at several conferences including PLDI 2005, SOSP 2007 and ICSE 2011. He has served as the Associate Editor for the ACM Transactions on Programming Languages and Systems, and co-chaired the Program Committees for ASPLOS 2010, VEE 2008, and LCPC 2007. One of Adve’s Ph.D. students, Robert Bocchino, won the 2010 ACM SIGPLAN Outstanding Dissertation Award and another student, John Criswell, won Honorable Mentions for both the 2014 ACM SIGOPS Dissertation Award and the 2014 ACM Doctoral Dissertation Award. Adve is a Fellow of the ACM and was named a University Scholar at the University of Illinois in 2015. He served as Interim Head of the Computer Science Department from 2017 to 2019.</bio>
          <homepage_url>http://vikram.cs.illinois.edu</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vikramadve/a99a9248-20e3-4738-9200-173c353c5fcb/small.jpg</picture_url>
          <person_id>vikramadve</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b366d8a2-e804-4fd4-901b-12e27304c019</subevent_id>
    <title>SPLASH OOPSLA: R-5</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>8cf86a13-e6ce-4fb6-80a0-12ae579829d1</slot_id>
      <title>Session: SPLASH OOPSLA - R-5</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>03:00</start_time>
      <end_time>04:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6e86f488-671e-4ee5-a35b-b3c48294ce27</slot_id>
      <event_id>e19d9707-bf19-4fc6-a3cd-80b6c920be7f</event_id>
      <title>Exposing Cache Timing Side-channel Leaks through Out-of-order Symbolic Execution</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>04:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>04:20</end_time>
      <description>Out-of-order execution, as one of the fundamental microarchitectural optimizations in modern processors, boosts the pipeline throughput by executing independent instructions in parallel rather than in their program orders. However, due to the side effects from out-of-order execution to the CPU cache, secret-critical applications may suffer from cache timing side-channel leaks. This paper presents a symbolic execution-based technique, named SymO3, for exposing timing leaks under the context of out-of-order execution. SymO3 owns synergetic new components targeting the modeling, reduction, and reasoning challenges of accomodating program analysis methods to the out-of-order behaviors of software programs. We implemented SymO3 upon KLEE and conducted three groups of evaluations on it. Experimental results show that SymO3 successfully uncovers from 31 to 242 cache timing leaks in 3 real-world cipher programs. Also, SymO3 shows that program transformation from aggressive compiler optimizations increases the surface to timing leaks. Furthermore, augmented with speculative modeling, SymO3 identifies five more leaky programs based on a compound analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shengjian</first_name>
          <last_name>Guo</last_name>
          <affiliation>Baidu X-Lab</affiliation>
          <bio>undefined</bio>
          <person_id>shengjianguo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yueqi</first_name>
          <last_name>Chen</last_name>
          <affiliation>The Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <person_id>yueqichen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jiyong</first_name>
          <last_name>Yu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>jiyongyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Meng</first_name>
          <last_name>Wu</last_name>
          <affiliation>Ant Financial</affiliation>
          <bio>undefined</bio>
          <person_id>mengwu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Zhiqiang</first_name>
          <last_name>Zuo</last_name>
          <affiliation>Nanjing University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://zuozhiqiang.bitbucket.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhiqiangzuo/deb374c0-3456-4c74-b48d-8f855a64643c/small.jpg</picture_url>
          <person_id>zhiqiangzuo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Peng</first_name>
          <last_name>Li</last_name>
          <affiliation>Baidu X-Lab</affiliation>
          <bio>undefined</bio>
          <person_id>pengli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Yueqiang</first_name>
          <last_name>Cheng</last_name>
          <affiliation>Baidu Security</affiliation>
          <bio>Yueqiang Cheng is a Senior Staff Security Scientist at Baidu Research and Baidu Security. His research interests are in the areas of data security and privacy, hardware security, and system security. His works have been published on top academic conferences, e.g., IEEE TDSC, ASPLOS, Usenix Security, NDSS, and ICSE.</bio>
          <homepage_url>https://sites.google.com/site/strongerwillcheng/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yueqiangcheng1/62c07e08-2bfd-49de-84a3-43049547d1d7/small.jpg</picture_url>
          <person_id>yueqiangcheng1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8c9c5772-ed98-41ef-add5-286e69b26dfe</slot_id>
      <event_id>762acf95-3734-44cf-94f3-333cf54f7969</event_id>
      <title>Precise Static Modeling of Ethereum ``Memory''</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>03:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>03:20</end_time>
      <description>Static analysis of smart contracts as-deployed on the Ethereum blockchain has received much recent attention. However, high-precision analyses currently face significant challenges when dealing with the Ethereum VM (EVM) execution model. A major such challenge is the modeling of low-level, transient “memory” (as opposed to persistent, on-blockchain “storage”) that smart contracts employ. Statically understanding the usage patterns of memory is non-trivial, due to the dynamic allocation nature of in-memory buffers. We offer an analysis that models EVM memory, recovering high-level concepts (e.g., arrays, buffers, call arguments) via deep modeling of the flow of values. Our analysis opens the door to Ethereum static analyses with drastically increased precision. One such analysis detects the extraction of ERC20 tokens by unauthorized users. For another practical vulnerability (redundant calls, possibly used as an attack vector), our memory modeling yields analysis precision of 89%, compared to 16% for a state-of-the-art tool without precise memory modeling. Additionally, precise memory modeling enables the static computation of a contract’s gas cost. This gas-cost analysis has recently been instrumental in the evaluation of the impact of the EIP-1884 repricing (in terms of gas costs) of EVM operations, leading to a reward and significant publicity from the Ethereum Foundation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sifis</first_name>
          <last_name>Lagouvardos</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/sifislagouvardos/7bff730b-e719-4f0c-935c-245291f18d9d/small.jpg</picture_url>
          <person_id>sifislagouvardos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Neville</first_name>
          <last_name>Grech</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.nevillegrech.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nevillegrech/e0405613-3240-4ef2-a51f-cb7536870dc5/small.jpg</picture_url>
          <person_id>nevillegrech</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ilias</first_name>
          <last_name>Tsatiris</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/iliastsatiris/b33fd835-f771-4b76-b5e8-00452e460cf7/small.jpg</picture_url>
          <person_id>iliastsatiris</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>Research Interests: programming languages and software engineering

 Program analysis (static analysis, test generation, invariant inference, symbolic execution)
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming)
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality)
          </bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
          <person_id>yannissmaragdakis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d9d9cc88-1cc3-4885-96fc-6420c4e63d67</slot_id>
      <event_id>d6245b1d-c06a-4095-a451-8337b829c6c7</event_id>
      <title>Perfectly Parallel Fairness Certification of Neural Networks</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>03:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>03:40</end_time>
      <description>Recently, there is growing concern that machine-learning models, which currently assist or even automate decision making, reproduce, and in the worst case reinforce, bias of the training data. The development of tools and techniques for certifying fairness of these models or describing their biased behavior is, therefore, critical. In this paper, we propose a perfectly parallel static analysis for certifying causal fairness of feed-forward neural networks used for classification of tabular data. When certification succeeds, our approach provides definite guarantees, otherwise, it describes and quantifies the biased behavior. We design the analysis to be sound, in practice also exact, and configurable in terms of scalability and precision, thereby enabling pay-as-you-go certification. We implement our approach in an open-source tool and demonstrate its effectiveness on models trained with popular datasets.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Caterina</first_name>
          <last_name>Urban</last_name>
          <affiliation>INRIA &amp; École Normale Supérieure</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://caterinaurban.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/caterinaurban1/a945f9bd-bc13-4fe2-945a-59528d7d7e2a/small.jpg</picture_url>
          <person_id>caterinaurban1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Maria</first_name>
          <last_name>Christakis</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mariachris.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mariachristakis/b7bf39cc-368b-44aa-bbcb-c83734e1e8fa/small.jpg</picture_url>
          <person_id>mariachristakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Valentin</first_name>
          <last_name>Wüstholz</last_name>
          <affiliation>ConsenSys, Germany</affiliation>
          <bio>Valentin is a software security researcher at ConsenSys Diligence and has held positions both in academia (at ETH Zürich and UT Austin) and in industry (at Microsoft and Google). He is passionate about developing tools and techniques that allow us to produce more reliable and correct software.</bio>
          <homepage_url>http://www.wuestholz.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/valentinwustholz/c6ff5691-4f3e-472c-8454-168eaaebb7eb/small.jpg</picture_url>
          <person_id>valentinwustholz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Fuyuan</first_name>
          <last_name>Zhang</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
          <person_id>fuyuanzhang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>de5fb532-e1a9-4570-8070-5dacf3421347</slot_id>
      <event_id>8f64a7c7-6637-4768-a862-bef448adb89f</event_id>
      <title>Taming Callbacks for Smart Contract Modularity</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>03:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>04:00</end_time>
      <description>Callbacks are an effective programming discipline for implementing event-driven programming, especially in environments like Ethereum which forbid shared global state and concurrency. Callbacks allow a callee to delegate the execution back to the caller. Though effective, they can lead to subtle mistakes principally in open environments where callbacks can be added in a new code. Indeed, several high profile bugs in smart contracts exploit callbacks. We present the first static technique ensuring \emph{modularity} in the presence of callbacks and apply it to verify prominent smart contracts. Modularity ensures that external calls to other contracts cannot affect the behavior of the contract. Importantly, modularity is guaranteed without restricting programming.
In general, checking modularity is undecidable—even for programs without loops. This paper describes an effective technique for soundly ensuring modularity harnessing SMT solvers. The main idea is to define a constructive version of modularity using \emph{commutativity} and \emph{projection} operations on program segments. We believe that this approach is also accessible to programmers, since counterexamples to modularity can be generated automatically by the SMT solvers, allowing programmers to understand and fix the error.
We implemented our approach in order to demonstrate the precision of the modularity analysis and applied it to real smart contracts, including a subset of the 150 most active contracts in Ethereum. Our implementation decompiles bytecode programs into an intermediate representation and then implements the modularity checking using SMT queries. Overall, we argue that our experimental results indicate that the method can be applied to many realistic contracts, and that it is able to prove modularity where other methods fail.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Elvira</first_name>
          <last_name>Albert</last_name>
          <affiliation>Complutense University of Madrid</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/elviraalbert1/9c4fd401-4969-4cc6-ba12-d79d92acee62/small.jpg</picture_url>
          <person_id>elviraalbert1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shelly</first_name>
          <last_name>Grossman</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shellygrossman/c4b389a6-6165-44ef-a938-4b1acbecaaa8/small.jpg</picture_url>
          <person_id>shellygrossman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Noam</first_name>
          <last_name>Rinetzky</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~maon/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/noamrinetzky/1ea9bd0d-bd16-4b15-bb66-a8a576ffaa40/small.jpg</picture_url>
          <person_id>noamrinetzky</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Clara</first_name>
          <last_name>Rodríguez</last_name>
          <affiliation>Complutense University of Madrid</affiliation>
          <bio>undefined</bio>
          <person_id>clararodriguez</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Albert</first_name>
          <last_name>Rubio</last_name>
          <affiliation>Complutense University of Madrid</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://costa.fdi.ucm.es/~arubio/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/albertrubio1/effd4c9a-16fb-4d5d-83cb-a32d83d40c47/small.jpg</picture_url>
          <person_id>albertrubio1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Mooly</first_name>
          <last_name>Sagiv</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>My research focuses on easing the task of developing reliable and efficient software systems. I am particularly interested in static program analysis which combines two disciplines: automated theorem proving and abstract interpretation. In the next decade, I am hoping to develop useful techniques in order to change the ways modern software is built. I am particularly interested in proof automation, given a program and a requirement, automatically prove or disprove that all executions of the program satisfy the requirements. This problem is in general undecidable and untractable. I am interested in developing practical solutions to proof-automation by: (i) exploring modularity of the system and (ii) relying on semi-automatic and interactive process, where the user manually and interactively guides the proof automation, and (iii) simplifying the verification task by using domain-specific abstractions expressed in a decidable logic. I am applying these techniques to verify safety of liveness of distributed systems.</bio>
          <homepage_url>http://www.cs.tau.ac.il/~msagiv/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/moolysagiv/5ff34ce2-4812-410c-aa6d-e1457fc2f1ac/small.jpg</picture_url>
          <person_id>moolysagiv</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6804922c-72bd-4b96-9cf6-35c4b60c8780</subevent_id>
    <title>SPLASH OOPSLA: R-3</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>c7c4d502-f952-42fa-9d48-6e200c56ef8c</slot_id>
      <title>Session: SPLASH OOPSLA - R-3</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>23:00</start_time>
      <end_time>00:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>22d62595-943d-4552-90c2-db2071d0d645</slot_id>
      <event_id>fcea71f9-9bb0-4209-a01f-13ad1fb54e32</event_id>
      <title>The Anchor Verifier for Blocking and Non-Blocking Concurrent Software</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>00:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>00:20</end_time>
      <description>Verifying the correctness of performance critical concurrent software with subtle synchronization is notoriously challenging, and many existing verifiers are either inadequately expressive or excessively burdensome to use. We present the Anchor verifier, which is based on a new, expressive formalism for specifying synchronization disciplines that naturally matches how programmers should think about reduction-based correctness arguments. Anchor proves concurrent components are race-free; do not go wrong; respect their synchronization disciplines; and are preemptive/cooperative equivalent, meaning that thread interference only happens at explicit yield annotations. Experiments on textbook concurrent data structures and the FastTrack analysis demonstrate that Anchor significantly reduces the burden of concurrent verification.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Freund</last_name>
          <affiliation>Williams College</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/stephenfreund/0b468f46-1f87-41c4-bcff-4321da9869c2/small.jpg</picture_url>
          <person_id>stephenfreund</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Cormac</first_name>
          <last_name>Flanagan</last_name>
          <affiliation>University of California, Santa Cruz</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://users.soe.ucsc.edu/~cormac/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cormacflanagan/fd454a8e-4230-4fa5-a4da-1d16a1027de3/small.jpg</picture_url>
          <person_id>cormacflanagan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>49d98079-a4b8-4698-8bbe-a91e183da6b8</slot_id>
      <event_id>b9042a01-7709-4b12-9a6d-e627f04668a5</event_id>
      <title>Projection-based Runtime Assertions for Testing and Debugging Quantum Programs</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>23:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>23:40</end_time>
      <description>In this paper, we propose Proq, a runtime assertion scheme for testing and debugging quantum programs on a quantum computer. The predicates in Proq are represented by projections (or equivalently, closed subspaces of the state space), following Birkhoff-von Neumann quantum logic. The satisfaction of a projection by a quantum state can be directly checked upon a small number of projective measurements rather than a large number of repeated executions. On the theory side, we rigorously prove that checking projection-based assertions can help locate bugs or statistically assure that the semantic function of the tested program is close to what we expect, for both exact and approximate quantum programs. On the practice side, we consider hardware constraints and introduce several techniques to transform the assertions, making them directly executable on the measurement-restricted quantum computers. We also propose to achieve simplified assertion implementation using local projection technique with soundness guaranteed. We compare Proq with existing quantum program assertions and demonstrate the effectiveness and efficiency of Proq by its applications to assert two ingenious quantum algorithms, the Harrow-Hassidim-Lloyd algorithm and Shor’s algorithm.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gushu</first_name>
          <last_name>Li</last_name>
          <affiliation>University of California, Santa Barbara</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.google.com/view/gushuli</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/gushuli/5cdbca43-a9df-483d-aa77-d44bad9a5dc3/small.jpg</picture_url>
          <person_id>gushuli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Li</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Max Planck Institute for Security and Privacy/Tsinghua University</affiliation>
          <bio>undefined</bio>
          <person_id>lizhou1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nengkun</first_name>
          <last_name>Yu</last_name>
          <affiliation>University of Technology Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <person_id>nengkunyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yufei</first_name>
          <last_name>Ding</last_name>
          <affiliation>UCSB</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ucsb.edu/~yufeiding/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yufeiding/c37f32e5-103b-4441-891c-b82fc8e9640a/small.jpg</picture_url>
          <person_id>yufeiding</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Mingsheng</first_name>
          <last_name>Ying</last_name>
          <affiliation>University of Technology Sydney, Australia / Institute of Software at Chinese Academy of Sciences, China/ Department of Computer Science and Technology, Tsinghua University.</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://quantum-lab.org/mingsheng/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/mingshengying/955ed532-f014-4273-965a-4906017b4b8d/small.jpg</picture_url>
          <person_id>mingshengying</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Yuan</first_name>
          <last_name>Xie</last_name>
          <affiliation>University of California, Santa Barbara</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ece.ucsb.edu/~yuanxie/</homepage_url>
          <person_id>yuanxie</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d19ffc61-b7c5-4ddd-a8af-6b7742bacbcd</slot_id>
      <event_id>a3ab81c8-640a-4a08-9893-24582fac04f3</event_id>
      <title>Compiling Symbolic Execution with Staging and Algebraic Effects</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>23:00</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>23:20</end_time>
      <description>Building effective symbolic execution engines poses challenges in multiple dimensions: an engine must correctly model the program semantics, provide flexibility in symbolic execution strategies, and execute them efficiently.
This paper proposes a principled approach to building correct, flexible, and efficient symbolic execution engines, directly rooted in the semantics of the underlying language in terms of a high-level definitional interpreter. The definitional interpreter induces algebraic effects to abstract over semantic variants of symbolic execution, e.g., collecting path conditions as a state effect and path exploration as a nondeterminism effect. Different handlers of these effects give rise to different symbolic execution strategies, making execution strategies orthogonal to the symbolic execution semantics, thus improving flexibility. Furthermore, by annotating the symbolic definitional interpreter with binding-times and specializing it to the input program via the first Futamura projection, we obtain a “symbolic compiler”, generating efficient instrumented code having the symbolic execution semantics. Our work reconciles the interpretation- and instrumentation-based approaches to building symbolic execution engines in a uniform framework.
We illustrate our approach on a simple imperative language step-by-step and then scale up to a significant subset of LLVM IR. We also show effect handlers for common path selection strategies. Evaluating our prototype’s performance shows speedups of 10~30x over the unstaged counterpart, and ~2x over KLEE, a state-of-the-art symbolic interpreter for LLVM IR.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guannan</first_name>
          <last_name>Wei</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://continuation.passing.style</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guannanwei/e1971b4b-ebd3-429b-b28c-0c2cfb0f0289/small.jpg</picture_url>
          <person_id>guannanwei</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Oliver</first_name>
          <last_name>Bračevac</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://bracevac.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/oliverbracevac/17c0ac71-a156-4868-8df9-d4ae4cd669e7/small.jpg</picture_url>
          <person_id>oliverbracevac</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Shangyin</first_name>
          <last_name>Tan</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/shangyintan/05c3151d-071e-451a-9863-639fc66108ca/small.jpg</picture_url>
          <person_id>shangyintan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
          <person_id>tiarkrompf</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fe4b6647-548f-4ae4-8fad-b50ce113f83c</slot_id>
      <event_id>5b2281e0-6ffc-4b3a-976f-ae840b9db5fd</event_id>
      <title>SATUNE: Synthesizing Efficient SAT Encoders</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>23:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>00:00</end_time>
      <description>Modern SAT solvers are extremely efficient at solving boolean satisfiability problems, enabling a wide spectrum of techniques for checking, verifying, and validating real-world programs. What remains challenging, though, is how to encode a domain problem (e.g., model checking) into a SAT formula because the same problem can have multiple distinct encodings, which can yield performance results that are orders-of-magnitude apart, regardless of the underlying solvers used. We develop SATUNE, a tool that can automatically synthesize SAT encoders for different problem domains. SATUNE employs a DSL that allows developers to express domain problems at a high level and a search algorithm that can effectively find efficient solutions. The search process is guided by observations made over example encodings and their performance for the domain and hence SATUNE can quickly synthesize a high-performance encoder by incorporating patterns from examples that yield good performance. A thorough evaluation with JMCR, SyPet, Dirk, Hexiom, Sudoku, and KillerSudoku demonstrates that SATUNE can easily synthesize high-performance encoders for different domains including model checking, synthesis, and games. These encodings generate constraint problems that are often several orders of magnitude faster to solve than the original encodings used by the tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hamed</first_name>
          <last_name>Gorjiara</last_name>
          <affiliation>University of California at Irvine, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gorjiara.net</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hamedgorjiara/ac3c3dcb-0d83-409b-91a3-d369cd445f3b/small.jpg</picture_url>
          <person_id>hamedgorjiara</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guoqing Harry</first_name>
          <last_name>Xu</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>I am an Associate Professor of Computer Science at University of California, Los Angeles (UCLA). I am interested broadly in software and hardware systems — including programming languages, compilers, big data analytics, distributed systems, and computer architecture.</bio>
          <homepage_url>http://web.cs.ucla.edu/~harryxu/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/harryxu/5d680c47-2b02-4f5f-a2fb-55c72b5d63ed/small.jpg</picture_url>
          <person_id>harryxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brian</first_name>
          <last_name>Demsky</last_name>
          <affiliation>University of California at Irvine, USA</affiliation>
          <bio>undefined</bio>
          <person_id>briandemsky</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6aaaf58c-f57c-4f6a-95f6-f7dbbc839ae4</subevent_id>
    <title>SPLASH OOPSLA: W-5</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>29d66576-6927-441a-ac32-f9453dad6ea9</slot_id>
      <title>Session: SPLASH OOPSLA - W-5</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>09496b66-93ff-4d0c-ac05-810c55621cd7</slot_id>
      <event_id>fb1f6365-ed4d-47f7-b0d5-c96755f131af</event_id>
      <title>Persistent Owicki-Gries Reasoning</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>15:40</end_time>
      <description>The advent of non-volatile memory (NVM) technologies has fundamentally transformed how software systems are structured, making the task of \emph{correct} programming significantly harder. This is because ensuring that memory stores persist in the correct order is challenging, and requires low-level programming to flush the cache at appropriate points. This has in turn resulted in a noticeable \emph{verification} gap.
To address this, we study the verification of NVM programs, and present \emph{Persistent Owicki-Gries} (POG), the first program logic for reasoning about such programs. We prove the soundness of POG over the recent Intel-x86 model, which formalises the out-of-order persistence of memory stores and the semantics of the Intel cache line flush instructions. We then use POG to verify several examples of interacting with the NVM.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Azalea</first_name>
          <last_name>Raad</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.SoundAndComplete.org</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/azalearaad/180ee602-475f-483f-a01b-ea187c9e8ac1/small.jpg</picture_url>
          <person_id>azalearaad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~orilahav/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/orilahav/89b656f6-7634-49d1-9917-4b74da70a976/small.jpg</picture_url>
          <person_id>orilahav</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Vafeiadis</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>Viktor Vafeiadis is a tenured faculty at the Max Planck Institute for Software Systems (MPI-SWS) in Germany. He got his BA and PhD from the University of Cambridge, and held post-doctoral researcher positions at the University of Cambridge and at Microsoft Research Cambridge before joining MPI-SWS in October 2010.</bio>
          <homepage_url>http://www.mpi-sws.org/~viktor/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/viktorvafeiadis/6a063832-47ca-4c32-8047-4bf4f74ae764/small.jpg</picture_url>
          <person_id>viktorvafeiadis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>234056b0-9400-4fd4-8b03-18fb9a61a8f0</slot_id>
      <event_id>c5a30df7-cf14-473f-9641-714eedc28464</event_id>
      <title>Structure Interpretation of Text Formats</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>16:00</end_time>
      <description>Data repositories often consist of semi-structured files in a wide range of standard formats, ad-hoc formats, as well as mixtures of formats where data in one format is embedded into other data in a different format. It is therefore a significant challenge to parse these files into a structured tabular form, which is important to enable any downstream data processing.
We present UnRavel, an extensible framework for structure interpretation of ad-hoc formats. UnRavel can automatically, with no user input, extract tabular data from a diverse range of standard, ad-hoc and mixed format files. The framework is also easily extensible to add support for previously unseen formats, and also supports interactivity from the user in terms of examples to guide the system when specialized data extraction is desired. Our key insight is to allow arbitrary combination of extraction and parsing techniques through a concept called partial structures. Partial structures act as a common language through which the file structure can be shared and refined by different techniques. This makes UnRavel more powerful than applying the individual techniques in parallel or sequentially. Further, with this rule-based extensible approach, we introduce the novel notion of re-interpretation where the variety of techniques supported by our system can be exploited to improve accuracy while optimizing for particular quality measures or restricted environments. On our benchmark of 617 text files gathered from a variety of sources, UnRavel is able to extract the intended table in many more cases compared to state-of-the-art techniques.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vu</first_name>
          <last_name>Le</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>I am a Researcher at Microsoft, working on the Microsoft Program Synthesis using Examples (PROSE) framework. I obtained my PhD in 2015 at UC Davis, advised by Zhendong Su and Sumit Gulwani. My research is about developing novel and practical techniques to help improve the quality of critical software (e.g., compilers and database engines) and make programming accessible for end users. My work has led to the discovery of hundreds of bugs in GCC and LLVM, most of which have been fixed, and shipped in various Microsoft products.</bio>
          <homepage_url>http://vuminhle.com</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/vule/8674b9d0-747d-4a80-b8f0-3c7a435cd9b7/small.jpg</picture_url>
          <person_id>vule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Radhakrishna</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://arjunradhakrishna.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/arjunradhakrishna/5187c933-18de-4045-9119-d97023dd12b7/small.jpg</picture_url>
          <person_id>arjunradhakrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Radiček</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>ivanradicek2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Mohammad</first_name>
          <last_name>Raza</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>mohammadraza</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>503cbb2c-2040-49a9-9c0b-7ef6de329d73</slot_id>
      <event_id>b766280d-c659-44b7-ad70-289237a4edcc</event_id>
      <title>A Model for Detecting Faults in Build Specifications</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>15:20</end_time>
      <description>Incremental and parallel builds are crucial features of modern build systems. Parallelism enables fast builds by running independent tasks simultaneously, while incrementality saves time and computing resources by processing the build operations that were affected by a particular code change. Writing build scripts that lead to error-free incremental and parallel builds is a challenging task. This is mainly because developers are often unable to predict the effects of build operations on the file system and how different build operations interact with each other. Faulty build scripts may seriously degrade the reliability of automated builds, as they cause build failures, and non-deterministic and incorrect outputs.
To reason about arbitrary build executions, we present BuildFS, a generally-applicable model that takes into account the specification (as declared in build scripts) and the actual behavior (low-level file system operation) of build operations. We then formally define different types of faults related to incremental and parallel builds in terms of the conditions under which a file system operation violates the specification of a build operation. Our testing approach, which relies on the proposed model, analyzes the execution of single full build, translates it into BuildFS, and uncovers faults by checking for corresponding violations.
We evaluate the effectiveness, efficiency, and applicability of our approach by examining 612 Make and Gradle projects. Notably, thanks to our treatment of build executions, our method is the first to handle JVM-oriented build systems. The results indicate that our approach is (1) able to uncover several important issues (245 issues found in 45 open-source projects have been confirmed and fixed by the upstream developers), and (2) up to six orders of magnitude faster than a state-of-the-art tool for Make builds.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thodoris</first_name>
          <last_name>Sotiropoulos</last_name>
          <affiliation>Athens University of Economics and Business</affiliation>
          <bio>undefined</bio>
          <person_id>thodorissotiropoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stefanos</first_name>
          <last_name>Chaliasos</last_name>
          <affiliation>Athens University of Economics and Business</affiliation>
          <bio>undefined</bio>
          <person_id>stefanoschaliasos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dimitris</first_name>
          <last_name>Mitropoulos</last_name>
          <affiliation>Athens University of Economics and Business</affiliation>
          <bio>Dimitris Mitropoulos is the Head of the Reliability Engineering Directorate of the Greek National Infrastructures for Research and Technology (GRNET) and a Researcher at the Athens University of Economics and Business. Previously, he has been a Postdoctoral Researcher at the Network Security Laboratory (NSL) of Columbia University in the City of New York. Dimitris holds a PhD in Computer Security from the Athens University of Economics and Business and has been involved in several EU and US funded R&amp;amp;D projects. His research interests include computer security, software reliability, software engineering and applied cryptography. He is a member of ACM, IEEE, SysSec, and an official writer for the ACM Computing Reviews journal.</bio>
          <homepage_url>https://dimitro.gr/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/dimitrismitropoulos/a0d64ae8-d979-4ed9-a834-b808d3cc40d2/small.jpg</picture_url>
          <person_id>dimitrismitropoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Diomidis</first_name>
          <last_name>Spinellis</last_name>
          <affiliation>Athens University of Economics and Business</affiliation>
          <bio>Diomidis Spinellis is Professor of Software Engineering, Head of the Department of Management Science and Technology, and director of the Business Analytics Laboratory (BALab), at the Athens University of Economics and Business, Greece. His research interests include software engineering, IT security, and computing systems. He has written two award-winning, widely-translated books: Code Reading and Code Quality: The Open Source Perspective. In 2016 he published the book Effective Debugging: 66 Specific Ways to Debug Software and Systems. Dr. Spinellis has also published more than 300 technical papers in journals and refereed conference proceedings, which have received more than 8000 citations. He served for a decade as a member of the IEEE Software editorial board, authoring the regular “Tools of the Trade” column and for four years at the magazine’s Editor in Chief. He has contributed code that ships with Apple’s macOS and BSD Unix and is the developer of CScout, UMLGraph, dgsh, and other open-source software packages, libraries, and tools. He holds an MEng in Software Engineering and a PhD in Computer Science, both from Imperial College London. Dr. Spinellis has served as an elected member of the IEEE Computer Society Board of Governors (2013–2015), and is a senior member of the ACM and the IEEE.</bio>
          <homepage_url>https://www.dmst.aueb.gr/dds</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/diomidisspinellis/a7f21db5-04c0-4282-85ab-614b4394c90a/small.jpg</picture_url>
          <person_id>diomidisspinellis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7018de7c-999e-41da-96a0-20e10b69f389</slot_id>
      <event_id>3861b0b2-0efa-45db-a79a-416ae2de5a28</event_id>
      <title>Statically Verified Refinements for Multiparty Protocols</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>16:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>16:20</end_time>
      <description>With distributed computing becoming ubiquitous in the modern era, safe distributed programming is an open challenge. To address this, multiparty session types (MPST) provide a typing discipline for message-passing concurrency, guaranteeing communication safety properties such as deadlock freedom.
While originally MPST focus on the communication aspects, and employ a simple typing system for communication payloads, communication protocols in the real world usually contain \emph{constraints} on the payload. We introduce \emph{refined multiparty session types (RMPST)}, an extension of MPST, that express data dependent protocols via \emph{refinement types} on the data types.
We provide an implementation of RMPST, in a toolchain called Session*, using Scribble, a multiparty protocol description toolchain, and targeting F*, a verification-oriented functional programming language. Users can describe a protocol in Scribble and implement the endpoints in F* using \emph{refinement-typed} APIs generated from the protocol. The F* compiler can then statically verify the refinements. Moreover, we use a novel approach of callback-styled API generation, providing \emph{static} linearity guarantees with the inversion of control. We evaluate our approach with real world examples and show that it has little overhead compared to a naive implementation, while guaranteeing safety properties from the underlying theory.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fangyi</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/fangyizhou/c1ff2787-4ce8-45c7-a584-0cc8f627722c/small.jpg</picture_url>
          <person_id>fangyizhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Francisco</first_name>
          <last_name>Ferreira</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <person_id>franciscoferreira1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Raymond</first_name>
          <last_name>Hu</last_name>
          <affiliation>University of Hertfordshire</affiliation>
          <bio>undefined</bio>
          <person_id>raymondhu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rumyana</first_name>
          <last_name>Neykova</last_name>
          <affiliation>Brunel University London</affiliation>
          <bio>Rumyana Neykova is a lecturer at Brunel University London, previously completed a PhD degree under the supervision of Prof. Nobuko Yoshida at Imperial College London, where she was also research fellow. Her research interests are in the area of distributed systems and networks, as well as type systems and language design. Her PhD focuses on development and applications of a type theory (called session types) for runtime verification of concurrent and distributed systems.</bio>
          <homepage_url>https://www.brunel.ac.uk/people/rumyana-neykova</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rumyananeykova/66457b0a-8e8b-471e-b278-37d7f4242bcb/small.jpg</picture_url>
          <person_id>rumyananeykova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
          <person_id>nobukoyoshida</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>80a27d2f-91d7-4d27-a9a7-c853a7b13e72</subevent_id>
    <title>SPLASH OOPSLA: F-5B</title>
    <subevent_type type="regular"/>
    <room>Online | SPLASH</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>e54fd9a6-19eb-46b9-a735-d5926ee13a05</slot_id>
      <title>Session: SPLASH OOPSLA - F-5B</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>15:00</start_time>
      <end_time>16:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>055a9df6-645a-4f0b-9cb3-bd125d6ca831</slot_id>
      <event_id>67d39e09-ddf4-4c9d-8d1b-b8dffa795e2f</event_id>
      <title>Testing Consensus Implementations Using Communication Closure</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>15:40</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>16:00</end_time>
      <description>Large scale production distributed systems are difficult to design and test. Correctness must be ensured when processes run asynchronously, at arbitrary rates relative to each other, and in the presence of failures, e.g., process crashes or message losses. These conditions create a huge space of executions that is difficult to explore in a principled way. Current testing techniques focus on systematic or randomized exploration of all executions of an implementation while treating the implemented algorithms as black boxes. On the other hand, proofs of correctness of many of the underlying algorithms often exploit semantic properties that reduce reasoning about correctness to a subset of behaviors. For example, the \emph{communication-closure} property, used in many proofs of distributed consensus algorithms, shows that every asynchronous execution of the algorithm is equivalent to a \emph{lossy synchronous} execution, thus reducing the burden of proof to only that subset. In a lossy synchronous execution, processes execute in lock-step rounds, and messages are either received in the same round or lost forever—such executions form a small subset of all asynchronous ones.
We formulate the \emph{communication-closure hypothesis}, which states that bugs in distributed systems implementations will already manifest in lossy synchronous executions and present a testing algorithm based on this hypothesis. We prioritize the search space based on a bound on the number of failures in the execution and the rate at which these failures are recovered. We show that a random testing algorithm based on sampling lossy synchronous executions can empirically find a number of bugs—including previously unknown ones—in production distributed systems such as Zookeeper, Cassandra, and Ratis, and also produce more understandable bug traces.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cezara</first_name>
          <last_name>Drăgoi</last_name>
          <affiliation>INRIA, ENS, CNRS</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.di.ens.fr/~cezarad/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cezaradragoi/3403e4d3-23e5-41ac-8cf7-48cc033f3d48/small.jpg</picture_url>
          <person_id>cezaradragoi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Constantin</first_name>
          <last_name>Enea</last_name>
          <affiliation>IRIF, University Paris Diderot &amp; CNRS</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~cenea/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/constantinenea/2dfe8bfe-ddfe-4012-a2e2-01cc8b953734/small.jpg</picture_url>
          <person_id>constantinenea</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Burcu</first_name>
          <last_name>Kulahcioglu Ozkan</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/burcukulahciogluozkan/4a854b1d-126f-47f5-8935-25d6401437c4/small.jpg</picture_url>
          <person_id>burcukulahciogluozkan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rupak</first_name>
          <last_name>Majumdar</last_name>
          <affiliation>Max Planck Institute for Software Systems (MPI-SWS)</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~rupak</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/rupakmajumdar/3289b197-9f9a-4880-94c5-d9cf6d764bb1/small.jpg</picture_url>
          <person_id>rupakmajumdar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Filip</first_name>
          <last_name>Niksic</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://fniksic.github.io</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/filipniksic/404f7660-8944-48cb-b97d-7b25a191367c/small.jpg</picture_url>
          <person_id>filipniksic</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7c051174-a874-416e-ae69-c8a0537e589a</slot_id>
      <event_id>3f3bef96-f531-418a-9389-fe359db5c7a1</event_id>
      <title>Rethinking Safe Consistency in Distributed Object-Oriented Programming</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>15:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>15:40</end_time>
      <description>Large scale distributed systems require to embrace the trade off between consistency and availability, accepting lower levels of consistency to guarantee higher availability. Existing programming languages are, however, agnostic to this compromise, resulting in consistency guarantees that are the same for the whole application and are implicitly adopted from the middleware or hardcoded in configuration files.
In this paper, we propose to integrate availability in the design of an object-oriented language, allowing developers to specify different consistency and isolation constraints in the same application at the granularity of single objects. We investigate how availability levels interact with object structure and define a type system that preserves correct program behavior. Our evaluation shows that our solution performs efficiently and improves the design of distributed applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mirko</first_name>
          <last_name>Köhler</last_name>
          <affiliation>Technische Universität Darmstadt</affiliation>
          <bio>undefined</bio>
          <person_id>mirkokohler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nafise</first_name>
          <last_name>Eskandani Masoule</last_name>
          <affiliation>Technical University of Darmstadt</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.stg.tu-darmstadt.de/staff/nafise_eskandani</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/nafiseeskandanimasoule/6eac9bf0-bfcf-4440-ba06-24fa9145cb4e/small.jpg</picture_url>
          <person_id>nafiseeskandanimasoule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pascal</first_name>
          <last_name>Weisenburger</last_name>
          <affiliation>Technische Universität Darmstadt</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2020.splashcon.org/getProfileImage/pascalweisenburger/bf663f00-24ac-4d12-919b-ef1e2ff8e128/small.jpg</picture_url>
          <person_id>pascalweisenburger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Alessandro</first_name>
          <last_name>Margara</last_name>
          <affiliation>Politecnico di Milano</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://margara.faculty.polimi.it</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/alessandromargara/c43a91d0-b824-4046-ab28-23a6ad3c2c3b/small.jpg</picture_url>
          <person_id>alessandromargara</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Guido</first_name>
          <last_name>Salvaneschi</last_name>
          <affiliation>University of St. Gallen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.guidosalvaneschi.com/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/guidosalvaneschi/6f1373d5-57c6-4d68-b6c3-c0a679ee24ed/small.jpg</picture_url>
          <person_id>guidosalvaneschi</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>810b594e-6e75-4f9b-872e-50182c33ff11</slot_id>
      <event_id>193eb222-e5b0-4ec0-88fe-28f689c66880</event_id>
      <title>Programming at the Edge of Synchrony</title>
      <room>Online | SPLASH</room>
      <date>2020/11/20</date>
      <start_time>15:00</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>15:20</end_time>
      <description>Synchronization primitives for fault-tolerant distributed systems that ensure an effective and efficient cooperation among processes are an important challenge in the programming languages community. We present a new programming abstraction, ReSync, for implementing benign and Byzantine fault-tolerant protocols. ReSync has a new round structure that offers a simple abstraction for group communication, like it is customary in synchronous systems, but also allows messages to be received one by one, like in the asynchronous systems. This extension allows implementing network and algorithm-specific policies for the message reception, which is not possible in classic round models.
The execution of ReSync programs is based on a new generic round switch protocol that generalizes the famous theoretical result of Dwork, Lynch and Stockmeyer [1988]. We evaluate experimentally the performance of ReSync’s execution platform, by comparing consensus implementations in ReSync with LibPaxos3, etcd, and Bft-SMaRt, three consensus libraries tolerant to benign, resp. byzantine faults.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cezara</first_name>
          <last_name>Drăgoi</last_name>
          <affiliation>INRIA, ENS, CNRS</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.di.ens.fr/~cezarad/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/cezaradragoi/3403e4d3-23e5-41ac-8cf7-48cc033f3d48/small.jpg</picture_url>
          <person_id>cezaradragoi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Josef</first_name>
          <last_name>Widder</last_name>
          <affiliation>Informal Systems</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://forsyte.at/widder</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/josefwidder1/44228499-3e67-4144-be7a-4bcc366c4dd7/small.jpg</picture_url>
          <person_id>josefwidder1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Damien</first_name>
          <last_name>Zufferey</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://dzufferey.github.io/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/damienzufferey/5dc321db-5cef-4f4b-bd3c-a5bbb2f11dd1/small.jpg</picture_url>
          <person_id>damienzufferey</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>80612a65-fb84-48cc-a7ad-ee22a6be0819</subevent_id>
    <title>SPLASH OOPSLA: W-6</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>d26929c2-bbd2-4529-93f4-9bf3e5f17f58</slot_id>
      <title>Session: SPLASH OOPSLA - W-6</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1d66b77f-70fa-41bf-a850-7332c6c77a25</slot_id>
      <event_id>1ba9a54b-ae12-41da-8d16-8c37c6ab299d</event_id>
      <title>Programming with a Read-Eval-Synth Loop</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>17:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>17:20</end_time>
      <description>A frequent programming pattern for small tasks, especially expressions, is to repeatedly evaluate the program on an input as its editing progresses. The Read-Eval-Print Loop (REPL) interaction model has been a successful model for this programming pattern. We present the new notion of Read-Eval-Synth Loop (RESL) that extends REPL by providing in-place synthesis on parts of the expression marked by the user. RESL eases programming by synthesizing parts of a required solution. The underlying synthesizer relies on a partial solution from the programmer and a few examples.
RESL hinges on bottom-up synthesis with general predicates and sketching, generalizing programming by example. To make RESL practical, we present a formal framework that extends observational equivalence to non-example specifications.
We show the value of RESL by conducting a controlled within-subjects user-study on 19 programmers from 8 companies, where programmers are asked to solve a small but challenging set of competitive programming problems. We find that programmers using RESL solve these problems with far less need to edit the code themselves and by browsing documentation far less. In addition, they are less likely to leave a task unfinished and more likely to be correct.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~hpeleg/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roi</first_name>
          <last_name>Gabay</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <person_id>roigabay</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Shachar</first_name>
          <last_name>Itzhaky</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~shachari</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/shacharitzhaky/649d5921-4057-4ac3-8fc7-75471ee8527b/small.jpg</picture_url>
          <person_id>shacharitzhaky</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion</affiliation>
          <bio>Eran Yahav is an associate professor at the Computer Science Department, Technion, Israel. Prior to that, he was a research staff member at the IBM T.J. Watson Research Center (2004-2010). He received his Ph.D. from Tel Aviv University (2005) and his B.Sc. from the Technion in 1996. His research interests include program analysis, program synthesis and program verification. Eran is a recipient of the prestigious Alon Fellowship for Outstanding Young Researchers, the Andre Deloro Career Advancement Chair in Engineering, the ERC Consolidator Grant as well as multiple best paper awards at various conferences.</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
          <person_id>eranyahav</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>62a04932-24d5-4715-8aea-3f14c5b31a32</slot_id>
      <event_id>5ded2007-1aa2-4b18-800b-2c660a495cca</event_id>
      <title>CompCertELF: Verified Separate Compilation of C Programs into ELF Object Files</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>18:00</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>18:20</end_time>
      <description>We present CompCertELF, the first extension to CompCert that supports verified compilation from C programs all the way to a standard binary file format, i.e., the ELF object format. Previous work on Stack-Aware CompCert provides a verified compilation chain from C programs to assembly programs with a realistic machine memory model. We build CompCertELF by modifying and extending this compilation chain with a verified assembler which further transforms assembly programs into ELF object files.
CompCert supports large-scale verification via verified separate compilation: C modules can be written and compiled separately, and then linked together to get a target program that refines the semantics of the program linked from the source modules. However, verified separate compilation in CompCert only works for compilation to assembly programs, not to object files. For the latter, the main difficulty is to bridge the two different views of linking: one for CompCert’s programs that allows arbitrary shuffling of global definitions by linking and the other for ELF object files that treats blocks of encoded definitions as unanalyzable and indivisible units.
We propose a lightweight approach that solves the above problem without any modification to CompCert’s framework for verified separate compilation: by introducing a notion of syntactical equivalence between programs and proving the commutativity between syntactical equivalence and the two different kinds of linking, we are able to transit from the more abstract linking operation in CompCert to the more concrete one for ELF object files. By applying this approach to CompCertELF, we obtain the first compiler that supports verified separate compilation of C programs into ELF object files.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuting</first_name>
          <last_name>Wang</last_name>
          <affiliation>Shanghai Jiao Tong University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jhc.sjtu.edu.cn/~yutingwang/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/yutingwang/963979f5-1f61-418e-9435-0abbb408ef37/small.jpg</picture_url>
          <person_id>yutingwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xiangzhe</first_name>
          <last_name>Xu</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <person_id>xiangzhexu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pierre</first_name>
          <last_name>WILKE</last_name>
          <affiliation>CentraleSupelec Rennes</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pwilke.fr/pwilke-en.html</homepage_url>
          <person_id>pierrewilke1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhong</first_name>
          <last_name>Shao</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/shao/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/zhongshao/18a2973a-020f-46ed-9073-85bd70626116/small.jpg</picture_url>
          <person_id>zhongshao</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7b2229db-e070-4a04-9d3c-f809592e0644</slot_id>
      <event_id>7d597c02-ff5f-4db1-a3f8-2f251a9ca0a5</event_id>
      <title>Sound Garbage Collection for C Using Pointer Provenance</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>17:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>17:40</end_time>
      <description>Garbage collection (GC) support for unmanaged languages can reduce programming burden in reasoning about liveness of dynamic objects. It also avoids temporal memory safety violations and memory leaks. Sound GC for weakly-typed languages such as C/C++, however, remains an unsolved problem. Current value-based GC solutions examine values of memory locations to discover the pointers, and the objects they point-to. The approach is inherently unsound in the presence of arbitrary type casts and pointer manipulations, which are legal in C/C++. Such language features are regularly used, especially in low-level systems code.
In this paper, we propose Dynamic Pointer Provenance Tracking to realize sound GC. We observe that pointers cannot be created out-of-thin-air, and they must have provenance to at least one valid allocation. Therefore, by tracking pointer provenance from the source (e.g., malloc) through both explicit data-flow and implicit control-flow, our GC has sound and precise information to compute the set of all reachable objects at any program state. We discuss several static analysis optimizations to significantly reduce the overhead of dynamic provenance tracking from nearly 8x to 16%. Pointer provenance based sound GC invocation is also 13% faster and reclaims 6% more memory on average, compared to an unsound value-based GC.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Subarno</first_name>
          <last_name>Banerjee</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.eecs.umich.edu/~subarno/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/subarnobanerjee/56075c15-14b6-4177-b624-840d0b02cf22/small.jpg</picture_url>
          <person_id>subarnobanerjee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Devecsery</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>daviddevecsery</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter M.</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Michigan, USA</affiliation>
          <bio>undefined</bio>
          <person_id>petermchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Satish</first_name>
          <last_name>Narayanasamy</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.eecs.umich.edu/~nsatish/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/satishnarayanasamy/cedfbed8-4f1b-40b0-afdd-135766659f94/small.jpg</picture_url>
          <person_id>satishnarayanasamy</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ca5e0489-650e-4d31-a81b-54a150c0c318</slot_id>
      <event_id>4d0f5a86-a761-438e-b9c1-1c44f16d89f9</event_id>
      <title>Semiring Optimizations: Dynamic Elision of Expressions with Identity and Absorbing Elements</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>17:40</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>18:00</end_time>
      <description>This paper describes a compiler optimization to eliminates dynamic occurrences of expressions in the format $a = a \oplus b \otimes c$. The operation $\oplus$ must admit an identity element $z$, such that $a \oplus z = a$. Also, $z$ must be the absorbing element of $\otimes$, such that $b \otimes z = z \otimes c = z$. Semirings where $\oplus$ is the additive operator and $\otimes$ is the multiplicative operator meet this contract. This pattern is common in high-performance benchmarks—its canonical representative being the multiply-add operation $a = a + b \times c$. However, several other expressions involving arithmetic and logic operations satisfy the required algebra. We show that the runtime elimination of such assignments can be implemented in a performance-safe way via in-loco profiling. The elimination of dynamic redundancies involving identity and absorbing elements in the LLVM test suite brings an average speedup of 6% (geo-mean) and 19% (arith-mean) over clang -O3. When added onto clang, semiring optimizations approximates it to TACO, a specialized tensor compiler.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guilherme</first_name>
          <last_name>Leobas</last_name>
          <affiliation>Universidade Federal de Minas Gerais</affiliation>
          <bio>undefined</bio>
          <person_id>guilhermeleobas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fernando Magno Quintão</first_name>
          <last_name>Pereira</last_name>
          <affiliation>UFMG</affiliation>
          <bio>Fernando got his Ph.D at UCLA in 2008, under the supervision of Jens Palsberg. He is currently an assistant professor at the Universidade Federal de Minas Gerais, Brazil. His main research interest are in code generation, compiler optimizations and static program analyses.</bio>
          <homepage_url>http://homepages.dcc.ufmg.br/~fernando/</homepage_url>
          <picture_url>https://2020.splashcon.org/getProfileImage/fernandomagnoquintaopereira/8f86b14f-fbc3-49a4-9f4f-1a8216564d39/small.jpg</picture_url>
          <person_id>fernandomagnoquintaopereira</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>87e4b5ea-eed7-45b7-bbdf-b0dc87df67e2</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in Sydney</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>fc314b4b-fdeb-4529-8645-af352e5f8610</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in Sydney</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>02:20</start_time>
      <end_time>03:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4664f198-7455-4844-b3f8-982f3054091f</slot_id>
      <event_id>a2e0574b-823d-4e03-8d1e-cf786722b3da</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>02:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>03:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>06dc8b3d-08fa-4d37-a33f-96fcdd6ae79b</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>5207c506-c488-4c32-9863-6ed490999319</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in Paris</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>14:20</start_time>
      <end_time>15:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>abc1e095-7c22-49a5-a3e5-af5de34fd3c1</slot_id>
      <event_id>6fc744f4-fc7f-4b96-b70f-e25251614484</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>14:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>15:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2556bb91-6f47-4214-9176-ac03c58ef23d</subevent_id>
    <title>SPLASH Meet Someone New (MSN):  Breakfast in Wellington</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>52bb859a-5600-47bf-96fb-dba1e553b11b</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) -  Breakfast in Wellington</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>12:20</start_time>
      <end_time>13:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5800993a-0589-430b-be37-1b8bd4d9c9e5</slot_id>
      <event_id>8010406f-2804-40f1-8c0c-b519197640c0</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>13:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1116d7ac-0a5b-4130-b0fe-b0d43baa7ec6</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Lunch in Tokyo</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>9a1bd4e7-8bfd-4357-8133-d27d2b705fe5</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Lunch in Tokyo</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>22:20</start_time>
      <end_time>23:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8d5f9848-74e7-436a-9435-543a00449405</slot_id>
      <event_id>e45cad66-437c-4dad-b3d5-e726922b664b</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>23:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a312dc73-0928-4aef-a9f1-367f35ec0582</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Wellington</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>46860f9d-95be-41cd-be6f-adb1313e2406</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Wellington</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>12:20</start_time>
      <end_time>13:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4a316931-1993-4ff3-a89a-2d61489b3ba1</slot_id>
      <event_id>1eafc361-05aa-48dd-80e5-a8708d7ac2c8</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>13:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>110887f5-3971-48cc-b32e-09a8fc65c79a</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>18b9c24d-87d8-49e6-8a83-85828e998fc3</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in Paris</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>14:20</start_time>
      <end_time>15:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1effe11a-a3e6-490d-81ca-368fd8097004</slot_id>
      <event_id>7ec665e0-18d7-40be-9c73-3fb71ad0d3a5</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>14:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>15:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>183ae9da-3ef3-4369-821b-2d04247e6dc2</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Dinner in Delhi</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>39d98bdb-509d-4c1e-9679-2b3a8460f536</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Dinner in Delhi</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>06:20</start_time>
      <end_time>07:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>de69b4ff-f9cc-4d98-8962-8478ec631050</slot_id>
      <event_id>a2314e5c-fecf-4e32-bc37-5c8af0e8395d</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>06:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>07:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>946113d2-7dca-4cf4-bf18-65828238a8e6</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Lunch in Tokyo</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>72306046-424a-45de-833c-3ee4361502ba</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Lunch in Tokyo</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>22:20</start_time>
      <end_time>23:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>40b0c6a8-8dfc-49c6-b8e0-4f6aaa04fcd8</slot_id>
      <event_id>b3d90584-8297-4112-b66a-f612567a4efe</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>23:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>41eed975-ea43-475b-87cb-172380f11881</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Dinner in Delhi</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>469d74ae-d370-4f6e-88e8-419d58ad21e8</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Dinner in Delhi</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>06:20</start_time>
      <end_time>07:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ccf31134-d942-4fcf-95d3-d3804e8340b1</slot_id>
      <event_id>41344328-debe-4b54-a95f-00473bea98e4</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>06:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>07:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>38fafd68-6ecc-4e5a-8e24-40dc24a9be1e</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Lunch in Tokyo</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>7a6cdc9c-cf5c-4f2d-8d73-dd1590006579</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Lunch in Tokyo</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>22:20</start_time>
      <end_time>23:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2ca89ffc-93c5-4434-9f3b-72c5ad10e5ac</slot_id>
      <event_id>ff5144df-c9fe-48d0-886c-d050a8ed6101</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>23:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f1d76aa3-7097-415b-9336-e9bf90f8c509</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Dinner in Delhi</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>888dbd5f-80fa-476b-8965-6e8c20a5bd2e</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Dinner in Delhi</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>06:20</start_time>
      <end_time>07:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9c0a2c44-a879-4250-851a-7ece2a89a755</slot_id>
      <event_id>af0a9139-5efc-4433-848e-f879847a8593</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>06:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>07:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>59d8b311-a3f1-42fb-8278-0676015a2971</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>e443e75b-a225-40e3-b882-8f2c0c49141b</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Paris</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>00:20</start_time>
      <end_time>01:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5f03c7fe-c998-4045-ae24-1ad7ad98e5be</slot_id>
      <event_id>20fd4662-e02e-4f90-9009-d4e240b955c1</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>01:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9efd3000-546e-4e07-b16f-491e96093660</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in Sydney</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>afa9e49f-8715-44a1-b6ed-43fbc01e7fad</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in Sydney</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>02:20</start_time>
      <end_time>03:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f8449caa-0f13-4db5-a61a-bf1f0476f999</slot_id>
      <event_id>f20253ce-958e-48d0-b23f-bd511a5cab7b</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>02:20</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>03:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>38700b30-3854-4560-92d3-8470fc26a5b9</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Dinner in Bejing</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>6797bc5c-2307-4e8a-84df-ea46385b82ac</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Dinner in Bejing</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>04:20</start_time>
      <end_time>05:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>28b438c8-2bb8-4c84-9d21-6e2026f92db5</slot_id>
      <event_id>5a1b823c-58b7-45a2-a372-1295a926866d</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>04:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>05:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4a687b5e-d441-4544-bdd4-35e6390cc82d</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>fc078588-7024-455d-994c-add4b46e8b29</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in Paris</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>14:20</start_time>
      <end_time>15:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3b288bef-d6f5-4b53-81a3-3bba2c8ac8d8</slot_id>
      <event_id>a2e0574b-823d-4e03-8d1e-cf786722b3da</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>14:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>15:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8883ccc9-409e-418c-aab3-f2960a4c6145</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Wellington</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>6a878f38-c3bd-4065-a934-b4a0c0bd9d65</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Wellington</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>12:20</start_time>
      <end_time>13:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>89ec667a-fbc0-4a09-8494-97a3f6f99a33</slot_id>
      <event_id>20fd4662-e02e-4f90-9009-d4e240b955c1</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>13:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>31270720-18f3-48bf-a63d-96e0caa0f99a</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Seattle</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>4e1fc14b-cd15-4205-a38c-691c22c3b0bb</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Seattle</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>10:20</start_time>
      <end_time>11:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5dcaaf21-711c-4f4a-8fd5-9fa521a51447</slot_id>
      <event_id>b3d90584-8297-4112-b66a-f612567a4efe</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>11:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2835ba52-2fcf-46c2-9819-1b41dc5788ed</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Wellington</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>de8a3daa-4a5f-436f-acf7-8827b5bb0156</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Wellington</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>12:20</start_time>
      <end_time>13:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>79d319e1-aae0-4d5b-a989-c5f07e8f2a47</slot_id>
      <event_id>ef0da7f6-6951-418c-81ac-a80a2cc82709</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>13:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a74bf172-bc9d-41d8-baea-2271a84d93eb</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>c6023619-3c91-46b8-b882-634f640cf65c</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Paris</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>00:20</start_time>
      <end_time>01:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c5a7dede-31a7-40d3-a94d-a92a8c9c88b3</slot_id>
      <event_id>1eafc361-05aa-48dd-80e5-a8708d7ac2c8</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>01:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>090f1831-79bf-451d-89eb-6216171828d7</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in Rio</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>7fcd6326-d0fe-444f-9bef-e01ba210a18c</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in Rio</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>18:20</start_time>
      <end_time>19:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0db1e0aa-166d-4e42-93a6-49fe07fe3b76</slot_id>
      <event_id>fd62e782-7287-4a4f-9fd1-4d11e89b96bb</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>18:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>63be007a-33fa-4eab-a13b-8f491c70c001</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Chicago</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>7ec23b2e-bba2-4487-84ce-c9b7fb2dd1ab</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Chicago</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>08:20</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c3ed0288-c732-4fac-b38a-3766f95a412f</slot_id>
      <event_id>0412756b-8f59-4c3c-ac47-94351e60bc25</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>09:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5de1e31e-1b7b-43cb-a75a-82ac2976712d</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Dinner in Delhi</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>8efd584e-4797-4534-aeec-59fe3f423cf7</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Dinner in Delhi</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>06:20</start_time>
      <end_time>07:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a561cd0e-b83c-4d22-9fa0-d71ebdeec5d2</slot_id>
      <event_id>74621f0c-91df-4fb7-857c-a74d1e6bede3</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>06:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>07:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9235bc39-57f1-4331-ae71-ff9f9a03425b</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Dinner in Beijing</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>50e4280c-0f7e-47f3-ab5f-5c6ae3248ecd</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Dinner in Beijing</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>04:20</start_time>
      <end_time>05:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4730d618-60da-42ff-ab71-c9ed92788011</slot_id>
      <event_id>69feb002-c268-4ad4-aa4b-b2c2ac601cfc</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>04:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>05:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>dcb7c099-6f68-44ca-9993-0ad9e4ce089c</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Dinner in Beijing</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>35660a14-ea2b-4c07-a870-fd368b154bb4</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Dinner in Beijing</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>04:20</start_time>
      <end_time>05:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bf8aa1bb-debe-4319-b674-d869eb3ac7e1</slot_id>
      <event_id>70d3b92e-67ed-4b25-9ef7-8685970e6aa1</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>04:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>05:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6ebf9556-6d55-4fff-82de-e3d73a079efb</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in Rio</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>d5efed96-a892-40d8-8fa1-1a50c22c1cd7</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in Rio</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>18:20</start_time>
      <end_time>19:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2e115366-93c3-4f21-a8e7-24e86007a95a</slot_id>
      <event_id>41344328-debe-4b54-a95f-00473bea98e4</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>18:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>100c923e-49fe-4578-9df6-99bff9fb354d</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Dinner in Beijing</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>e3648b24-f6f5-42f5-b118-a85a3c14692a</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Dinner in Beijing</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>04:20</start_time>
      <end_time>05:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ba08d855-3c45-46bc-b3de-7dbf3d486433</slot_id>
      <event_id>fb550191-b8f9-4f85-adbd-b8f8cb30a311</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>04:20</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>05:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b97335be-91a7-48bb-b480-7a16f563491a</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in New York</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>4bf94259-40c3-43da-be46-3a0c2cff5331</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in New York</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>20:20</start_time>
      <end_time>21:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>98fd09a5-985b-458c-8bb5-a3a8f78a24b3</slot_id>
      <event_id>0412756b-8f59-4c3c-ac47-94351e60bc25</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>21:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>96b04dc9-609d-4add-a4ca-d54905355fa2</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Seoul</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>f7e72578-1caa-4bc8-ba04-1966c0258c07</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Seoul</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>16:20</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e27ab703-0158-4b31-97a6-46bab42ff367</slot_id>
      <event_id>fb550191-b8f9-4f85-adbd-b8f8cb30a311</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>16:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c301703c-b9e9-49c9-a722-7d51a41c6a69</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Lunch in Tokyo</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>cf3e426f-e593-4ab9-ae8b-3e76fa95bbac</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Lunch in Tokyo</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>22:20</start_time>
      <end_time>23:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d15030ec-ac9a-426e-8e5e-6a259dae4c9b</slot_id>
      <event_id>0946af88-5fc0-40d0-827b-f00b431464d2</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>22:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>23:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>159e9c65-67d3-424f-8e04-1494b46c5ad5</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>0f92abb2-e2ee-45cf-a1bc-4643a45baa64</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in Paris</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>14:20</start_time>
      <end_time>15:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3bff6fff-e28b-409f-98fe-d4e1a71df530</slot_id>
      <event_id>8e014af6-7d2d-484b-bc92-75fe6dda785d</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>14:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>15:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fa2dae48-2be3-4095-967d-e3540344aa3c</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in Rio</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>f80a1b61-11d0-498d-bb3e-979685b90f6d</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in Rio</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>18:20</start_time>
      <end_time>19:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b13f8297-83c5-4b5a-b471-fe12eee8ec07</slot_id>
      <event_id>af0a9139-5efc-4433-848e-f879847a8593</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>18:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8a72ec77-51f9-4238-9aa4-23ca7c1fe551</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/21</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>8918cf84-baed-4db8-b4a3-6b79fe6e4932</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Paris</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>00:20</start_time>
      <end_time>01:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1b01cb71-50c5-4eae-87a7-1e1f869c8b67</slot_id>
      <event_id>ef0da7f6-6951-418c-81ac-a80a2cc82709</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/21</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/21</end_date>
      <end_time>01:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5da90891-02f7-4c04-b462-a4512aff7a7d</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Dinner in Beijing</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>4b1cbcfc-b7a2-41d5-acc0-e66efb40e429</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Dinner in Beijing</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>04:20</start_time>
      <end_time>05:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1ff7370a-b874-459e-ae4f-8f65c24f1e96</slot_id>
      <event_id>8e461460-7155-4f2e-8aeb-88ff712acfac</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>04:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>05:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6bd6e8e8-8929-4589-924c-9de6ed952d96</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Seattle</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>c0e085d4-3671-420d-9c32-2a116e89bb33</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Seattle</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>10:20</start_time>
      <end_time>11:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>44bdbff9-0f7a-48a5-9ced-41c280b4bf36</slot_id>
      <event_id>e45cad66-437c-4dad-b3d5-e726922b664b</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>11:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3cbc034c-d41d-498c-ad74-bb5a6c619435</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in New York</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>d526105c-526d-4c3d-98f7-c26566d47a3f</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in New York</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>20:20</start_time>
      <end_time>21:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3d5cc542-a518-49e2-bf11-f6005292cd63</slot_id>
      <event_id>badde84c-bc9d-4fef-bd68-58ecc99fd8a5</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>20:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>21:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ccda1cf9-d754-4113-9f65-c68358446fea</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in Sydney</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>c23db3cb-cd3e-4541-843f-9736f29c5c48</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in Sydney</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>02:20</start_time>
      <end_time>03:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>811c4765-b7f9-4651-a4fa-6302b865b1bf</slot_id>
      <event_id>8e014af6-7d2d-484b-bc92-75fe6dda785d</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>02:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>03:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>28c4e27e-2082-4eac-8f27-655b118396a4</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Dinner in Beijing</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>63c58641-3bdb-404f-a828-8f1cdc7ff603</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Dinner in Beijing</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>04:20</start_time>
      <end_time>05:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5af4d813-8303-4e72-9d4c-a91c25c2529f</slot_id>
      <event_id>8fea7ac6-5aca-4951-82b6-6af04e2e6e57</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>04:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>05:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9120fd32-a14b-40ba-9b86-de9aa36eb10c</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in Sydney</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>8f96b452-7f3b-4fef-8a97-5c314a8a88e5</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in Sydney</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>02:20</start_time>
      <end_time>03:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>88c33a85-936c-49e3-960c-5cf996f1cba4</slot_id>
      <event_id>6fc744f4-fc7f-4b96-b70f-e25251614484</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>02:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>03:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>900fc1a6-6c4e-4f8b-80ec-47014cfe7648</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Seoul</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>5d30929f-48bb-4cb2-8a78-755f096e88b6</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Seoul</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>16:20</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7b597fe4-019b-4808-93da-7167de334119</slot_id>
      <event_id>70d3b92e-67ed-4b25-9ef7-8685970e6aa1</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>16:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0d115f3c-78a1-4267-a93b-1d14942b6f1e</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>b1bb8cbb-d1b2-4e72-874a-a2a75d34bfc4</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Paris</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>00:20</start_time>
      <end_time>01:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>85b26bdb-dc95-4451-b54b-a5068fe507e1</slot_id>
      <event_id>5dda3903-b7f6-4d55-9d84-82a865e29e54</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>01:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5ca4cc26-ba9c-4da3-958f-bf8749b7e69d</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Dinner in Delhi</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>eb94dabc-de48-4ffb-9684-70be3666fd27</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Dinner in Delhi</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>06:20</start_time>
      <end_time>07:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d165938f-5a58-4bea-b8a5-9d5585503f09</slot_id>
      <event_id>fd62e782-7287-4a4f-9fd1-4d11e89b96bb</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>06:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>07:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9fa92caa-773d-43e7-ac1b-6c1c3991a711</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>05c3ed95-5b71-4ad0-bdd1-91a5f8b1ded2</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in Paris</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>14:20</start_time>
      <end_time>15:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8fb562d2-89db-4b84-b513-3fc5a2adb915</slot_id>
      <event_id>4c9081af-aa92-4d04-a815-22b427724873</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>14:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>15:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>29157bcf-d097-4226-b688-34189b84769d</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Seoul</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/15</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>154e7480-3b26-4dc8-8b61-7b96589e1bad</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Seoul</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>16:20</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bc62cc2c-0854-4d56-9ad9-01f05f3675d1</slot_id>
      <event_id>69feb002-c268-4ad4-aa4b-b2c2ac601cfc</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/15</date>
      <start_time>16:20</start_time>
      <end_date>2020/11/15</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8493e0d9-35dd-45f7-a2f3-ce3635d8ce5d</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in Sydney</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>3d9f2844-e2d9-43df-879f-cb712b19b6cf</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in Sydney</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>02:20</start_time>
      <end_time>03:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d058804c-dca1-403c-a7a1-fc4ae37a346b</slot_id>
      <event_id>4c9081af-aa92-4d04-a815-22b427724873</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>02:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>03:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8b87cdb8-4da6-468e-8ba4-0d75b309aecc</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Seattle</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>c8753a8b-4736-478b-b379-9cbff18ba569</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Seattle</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>10:20</start_time>
      <end_time>11:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8afe681c-2f1c-443b-8a09-a14538a27ab4</slot_id>
      <event_id>ff5144df-c9fe-48d0-886c-d050a8ed6101</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>11:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>22c7551a-91e1-4088-835c-687b4279608d</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>a9e58204-796c-4033-8b61-672eb5418ad7</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in Paris</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>14:20</start_time>
      <end_time>15:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>584b5226-0d4c-4608-977d-dff4be0a7d7c</slot_id>
      <event_id>f20253ce-958e-48d0-b23f-bd511a5cab7b</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>14:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>15:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>10ae67d5-ba3d-4fa2-9dec-6c84daafe01b</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Seoul</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/16</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>8e05bc92-a3d7-4fd8-a53b-2635f31e16e0</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Seoul</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>16:20</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>49ee09e2-15ca-4c92-b843-6201c955ff55</slot_id>
      <event_id>8fea7ac6-5aca-4951-82b6-6af04e2e6e57</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/16</date>
      <start_time>16:20</start_time>
      <end_date>2020/11/16</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>eab5fd2f-be93-4fe4-bfd2-d96ca4577c91</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in Rio</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/18</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>df6d9734-3c01-4713-b334-6c94ca0a780f</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in Rio</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>18:20</start_time>
      <end_time>19:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7f978100-6d5a-4d3f-939a-adc2e6ecae65</slot_id>
      <event_id>74621f0c-91df-4fb7-857c-a74d1e6bede3</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/18</date>
      <start_time>18:20</start_time>
      <end_date>2020/11/18</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d8c93115-4f66-40b3-979c-2b9484cffc0b</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in Rio</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>ecd3c6f9-7500-4ddd-a390-0223cac52cee</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in Rio</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>18:20</start_time>
      <end_time>19:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>57de7806-1e6b-4b9c-8a39-e852615f5e8d</slot_id>
      <event_id>a2314e5c-fecf-4e32-bc37-5c8af0e8395d</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>18:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2fb14507-a159-4e84-8673-160b2266ea26</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Seattle</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>c5650e01-bcbb-4625-b15c-e33301575bb4</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Seattle</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>10:20</start_time>
      <end_time>11:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c2eb141d-1841-40a2-9330-297b5777801b</slot_id>
      <event_id>0946af88-5fc0-40d0-827b-f00b431464d2</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>10:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>11:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>cfc5f1c7-ca5c-45bb-83f5-d056f851b1fc</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Seoul</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/19</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>6603b7b6-acfc-4a5b-be06-748b355a0bbd</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Seoul</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>16:20</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a7522d94-002d-410d-9465-602ddb9f8a41</slot_id>
      <event_id>8e461460-7155-4f2e-8aeb-88ff712acfac</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/19</date>
      <start_time>16:20</start_time>
      <end_date>2020/11/19</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>420ad0eb-9487-4639-a69e-11b24c4d4d15</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Chicago</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>50b0fccc-37ae-4bee-a50a-dae49feec5c5</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Chicago</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>08:20</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f011b6e1-c921-4aac-b12f-6358f3b6fd80</slot_id>
      <event_id>badde84c-bc9d-4fef-bd68-58ecc99fd8a5</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>08:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>09:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>95fa77a0-bc5b-47f8-b2e3-77f5ce68b2ae</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Seoul</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>568214cf-4aa7-4ccb-9161-b6d5a4a94246</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Seoul</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>16:20</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>234b049b-70e0-4bf0-beec-c531f765c6a0</slot_id>
      <event_id>5a1b823c-58b7-45a2-a372-1295a926866d</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>16:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2be5ebe4-181b-4172-a56e-b0926ffad517</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Paris</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/20</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>5b653b82-1e9d-4bac-b447-8bee0ba21a26</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Paris</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>00:20</start_time>
      <end_time>01:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1109966a-c357-4f60-913d-cdae9d732b45</slot_id>
      <event_id>8010406f-2804-40f1-8c0c-b519197640c0</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/20</date>
      <start_time>00:20</start_time>
      <end_date>2020/11/20</end_date>
      <end_time>01:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>52ba652d-ede3-4545-8785-4ecb2a449793</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Breakfast in Wellington</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>20312296-86c7-483e-96a2-1fbbd4598565</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Breakfast in Wellington</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>12:20</start_time>
      <end_time>13:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e6246129-f8d2-4d9f-9773-3b1273e36be8</slot_id>
      <event_id>5dda3903-b7f6-4d55-9d84-82a865e29e54</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>12:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>13:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>45fca3c6-94a2-4a73-9a2e-e845ca6fc2c9</subevent_id>
    <title>SPLASH Meet Someone New (MSN): Cocktails in Sydney</title>
    <subevent_type type="regular"/>
    <room>Online | OOPSLA/ECOOP</room>
    <date>2020/11/17</date>
    <url>https://2020.splashcon.org/track/splash-2020-meet-someone-new--msn-</url>
    <url_link_display>Meet Someone New (MSN)</url_link_display>
    <tracks>
      <track>Meet Someone New (MSN)</track>
    </tracks>
    <timeslot>
      <slot_id>15651b93-1a9b-4ae6-a9de-3c9344a65b1d</slot_id>
      <title>Session: SPLASH Meet Someone New (MSN) - Cocktails in Sydney</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>02:20</start_time>
      <end_time>03:00</end_time>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bf69ae78-670e-4210-9256-0136323113e6</slot_id>
      <event_id>7ec665e0-18d7-40be-9c73-3fb71ad0d3a5</event_id>
      <title>Meet Someone New</title>
      <room>Online | OOPSLA/ECOOP</room>
      <date>2020/11/17</date>
      <start_time>02:20</start_time>
      <end_date>2020/11/17</end_date>
      <end_time>03:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Meet Someone New (MSN)</track>
      </tracks>
    </timeslot>
  </subevent>
  <timezone_id>America/Chicago</timezone_id>
</event>
